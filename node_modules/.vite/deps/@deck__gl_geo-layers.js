import {
  arc_layer_default,
  bitmap_layer_default,
  column_layer_default,
  earcut,
  geojson_layer_default,
  getPolygonSignedArea,
  path_layer_default,
  point_cloud_layer_default,
  polygon_layer_default
} from "./chunk-OAPNVSVO.js";
import {
  COORDINATE_SYSTEM,
  Geometry,
  GroupNode,
  ImageLoader,
  ImageSource,
  LayersPass,
  Matrix3,
  Matrix4,
  Model,
  ModelNode,
  PickLayersPass,
  Quaternion,
  RequestScheduler,
  ScenegraphNode,
  Vector2,
  Vector3,
  assert as assert2,
  assert2 as assert3,
  clamp,
  composite_layer_default,
  concatenateTypedArrays,
  config,
  copyToArray,
  createIterable,
  deduceMeshField,
  deduceTableSchema,
  deepEqual,
  degrees,
  equals,
  fetchFile,
  flatten,
  fp64,
  fp64LowPart,
  getBinaryImageMetadata,
  getImageData,
  getJSModuleOrNull,
  getMeshBoundingBox,
  globe_viewport_default,
  isImageFormatSupported,
  layer_default,
  layer_extension_default,
  lerp,
  lngLatToWorld,
  load,
  loadLibrary,
  log,
  log_default,
  mat4_exports,
  math_utils_exports,
  memoize,
  mergeLoaderOptions,
  mergeShaders,
  orthographic_viewport_default,
  padToNBytes,
  parseFromContext,
  parseJSON,
  path_exports,
  pbrMaterial,
  phongMaterial,
  picking_default,
  project32_default,
  project_default,
  registerJSModules,
  sliceArrayBuffer,
  toDegrees,
  toRadians,
  vec3_exports,
  web_mercator_viewport_default,
  worldToLngLat
} from "./chunk-LLQE5WUS.js";
import {
  Stat,
  Stats,
  Texture,
  dist_default,
  log as log2
} from "./chunk-CEBDJKZS.js";
import {
  __commonJS,
  __export,
  __publicField,
  __require,
  __toESM
} from "./chunk-2TUXWMP5.js";

// node_modules/fast-xml-parser/src/util.js
var require_util = __commonJS({
  "node_modules/fast-xml-parser/src/util.js"(exports) {
    "use strict";
    var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
    var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
    var nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
    var regexName = new RegExp("^" + nameRegexp + "$");
    var getAllMatches = function(string, regex) {
      const matches = [];
      let match = regex.exec(string);
      while (match) {
        const allmatches = [];
        allmatches.startIndex = regex.lastIndex - match[0].length;
        const len4 = match.length;
        for (let index = 0; index < len4; index++) {
          allmatches.push(match[index]);
        }
        matches.push(allmatches);
        match = regex.exec(string);
      }
      return matches;
    };
    var isName = function(string) {
      const match = regexName.exec(string);
      return !(match === null || typeof match === "undefined");
    };
    exports.isExist = function(v2) {
      return typeof v2 !== "undefined";
    };
    exports.isEmptyObject = function(obj) {
      return Object.keys(obj).length === 0;
    };
    exports.merge = function(target, a3, arrayMode) {
      if (a3) {
        const keys = Object.keys(a3);
        const len4 = keys.length;
        for (let i = 0; i < len4; i++) {
          if (arrayMode === "strict") {
            target[keys[i]] = [a3[keys[i]]];
          } else {
            target[keys[i]] = a3[keys[i]];
          }
        }
      }
    };
    exports.getValue = function(v2) {
      if (exports.isExist(v2)) {
        return v2;
      } else {
        return "";
      }
    };
    exports.isName = isName;
    exports.getAllMatches = getAllMatches;
    exports.nameRegexp = nameRegexp;
  }
});

// node_modules/fast-xml-parser/src/validator.js
var require_validator = __commonJS({
  "node_modules/fast-xml-parser/src/validator.js"(exports) {
    "use strict";
    var util = require_util();
    var defaultOptions3 = {
      allowBooleanAttributes: false,
      //A tag can have attributes without any value
      unpairedTags: []
    };
    exports.validate = function(xmlData, options) {
      options = Object.assign({}, defaultOptions3, options);
      const tags = [];
      let tagFound = false;
      let reachedRoot = false;
      if (xmlData[0] === "\uFEFF") {
        xmlData = xmlData.substr(1);
      }
      for (let i = 0; i < xmlData.length; i++) {
        if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
          i += 2;
          i = readPI(xmlData, i);
          if (i.err) return i;
        } else if (xmlData[i] === "<") {
          let tagStartPos = i;
          i++;
          if (xmlData[i] === "!") {
            i = readCommentAndCDATA(xmlData, i);
            continue;
          } else {
            let closingTag = false;
            if (xmlData[i] === "/") {
              closingTag = true;
              i++;
            }
            let tagName = "";
            for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
              tagName += xmlData[i];
            }
            tagName = tagName.trim();
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substring(0, tagName.length - 1);
              i--;
            }
            if (!validateTagName(tagName)) {
              let msg;
              if (tagName.trim().length === 0) {
                msg = "Invalid space after '<'.";
              } else {
                msg = "Tag '" + tagName + "' is an invalid name.";
              }
              return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
            }
            const result = readAttributeStr(xmlData, i);
            if (result === false) {
              return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
            }
            let attrStr = result.value;
            i = result.index;
            if (attrStr[attrStr.length - 1] === "/") {
              const attrStrStart = i - attrStr.length;
              attrStr = attrStr.substring(0, attrStr.length - 1);
              const isValid = validateAttributeString(attrStr, options);
              if (isValid === true) {
                tagFound = true;
              } else {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
              }
            } else if (closingTag) {
              if (!result.tagClosed) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
              } else if (attrStr.trim().length > 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
              } else if (tags.length === 0) {
                return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
              } else {
                const otg = tags.pop();
                if (tagName !== otg.tagName) {
                  let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                  return getErrorObject(
                    "InvalidTag",
                    "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                    getLineNumberForPosition(xmlData, tagStartPos)
                  );
                }
                if (tags.length == 0) {
                  reachedRoot = true;
                }
              }
            } else {
              const isValid = validateAttributeString(attrStr, options);
              if (isValid !== true) {
                return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
              }
              if (reachedRoot === true) {
                return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
              } else if (options.unpairedTags.indexOf(tagName) !== -1) {
              } else {
                tags.push({ tagName, tagStartPos });
              }
              tagFound = true;
            }
            for (i++; i < xmlData.length; i++) {
              if (xmlData[i] === "<") {
                if (xmlData[i + 1] === "!") {
                  i++;
                  i = readCommentAndCDATA(xmlData, i);
                  continue;
                } else if (xmlData[i + 1] === "?") {
                  i = readPI(xmlData, ++i);
                  if (i.err) return i;
                } else {
                  break;
                }
              } else if (xmlData[i] === "&") {
                const afterAmp = validateAmpersand(xmlData, i);
                if (afterAmp == -1)
                  return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
                i = afterAmp;
              } else {
                if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
                  return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
                }
              }
            }
            if (xmlData[i] === "<") {
              i--;
            }
          }
        } else {
          if (isWhiteSpace(xmlData[i])) {
            continue;
          }
          return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
        }
      }
      if (!tagFound) {
        return getErrorObject("InvalidXml", "Start tag expected.", 1);
      } else if (tags.length == 1) {
        return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
      } else if (tags.length > 0) {
        return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
      }
      return true;
    };
    function isWhiteSpace(char) {
      return char === " " || char === "	" || char === "\n" || char === "\r";
    }
    function readPI(xmlData, i) {
      const start = i;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] == "?" || xmlData[i] == " ") {
          const tagname = xmlData.substr(start, i - start);
          if (i > 5 && tagname === "xml") {
            return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
          } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
            i++;
            break;
          } else {
            continue;
          }
        }
      }
      return i;
    }
    function readCommentAndCDATA(xmlData, i) {
      if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
        for (i += 3; i < xmlData.length; i++) {
          if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
        let angleBracketsCount = 1;
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            angleBracketsCount++;
          } else if (xmlData[i] === ">") {
            angleBracketsCount--;
            if (angleBracketsCount === 0) {
              break;
            }
          }
        }
      } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
        for (i += 8; i < xmlData.length; i++) {
          if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
            i += 2;
            break;
          }
        }
      }
      return i;
    }
    var doubleQuote = '"';
    var singleQuote = "'";
    function readAttributeStr(xmlData, i) {
      let attrStr = "";
      let startChar = "";
      let tagClosed = false;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
          if (startChar === "") {
            startChar = xmlData[i];
          } else if (startChar !== xmlData[i]) {
          } else {
            startChar = "";
          }
        } else if (xmlData[i] === ">") {
          if (startChar === "") {
            tagClosed = true;
            break;
          }
        }
        attrStr += xmlData[i];
      }
      if (startChar !== "") {
        return false;
      }
      return {
        value: attrStr,
        index: i,
        tagClosed
      };
    }
    var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
    function validateAttributeString(attrStr, options) {
      const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
      const attrNames = {};
      for (let i = 0; i < matches.length; i++) {
        if (matches[i][1].length === 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
        } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
          return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
        } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
          return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
        }
        const attrName = matches[i][2];
        if (!validateAttrName(attrName)) {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
        }
        if (!attrNames.hasOwnProperty(attrName)) {
          attrNames[attrName] = 1;
        } else {
          return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
        }
      }
      return true;
    }
    function validateNumberAmpersand(xmlData, i) {
      let re = /\d/;
      if (xmlData[i] === "x") {
        i++;
        re = /[\da-fA-F]/;
      }
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === ";")
          return i;
        if (!xmlData[i].match(re))
          break;
      }
      return -1;
    }
    function validateAmpersand(xmlData, i) {
      i++;
      if (xmlData[i] === ";")
        return -1;
      if (xmlData[i] === "#") {
        i++;
        return validateNumberAmpersand(xmlData, i);
      }
      let count = 0;
      for (; i < xmlData.length; i++, count++) {
        if (xmlData[i].match(/\w/) && count < 20)
          continue;
        if (xmlData[i] === ";")
          break;
        return -1;
      }
      return i;
    }
    function getErrorObject(code, message, lineNumber) {
      return {
        err: {
          code,
          msg: message,
          line: lineNumber.line || lineNumber,
          col: lineNumber.col
        }
      };
    }
    function validateAttrName(attrName) {
      return util.isName(attrName);
    }
    function validateTagName(tagname) {
      return util.isName(tagname);
    }
    function getLineNumberForPosition(xmlData, index) {
      const lines = xmlData.substring(0, index).split(/\r?\n/);
      return {
        line: lines.length,
        // column number is last line's length + 1, because column numbering starts at 1:
        col: lines[lines.length - 1].length + 1
      };
    }
    function getPositionFromMatch(match) {
      return match.startIndex + match[1].length;
    }
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js
var require_OptionsBuilder = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js"(exports) {
    var defaultOptions3 = {
      preserveOrder: false,
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      removeNSPrefix: false,
      // remove NS from tag name or attribute name if true
      allowBooleanAttributes: false,
      //a tag can have attributes without any value
      //ignoreRootElement : false,
      parseTagValue: true,
      parseAttributeValue: false,
      trimValues: true,
      //Trim string values of tag and attributes
      cdataPropName: false,
      numberParseOptions: {
        hex: true,
        leadingZeros: true,
        eNotation: true
      },
      tagValueProcessor: function(tagName, val) {
        return val;
      },
      attributeValueProcessor: function(attrName, val) {
        return val;
      },
      stopNodes: [],
      //nested tags will not be parsed even for errors
      alwaysCreateTextNode: false,
      isArray: () => false,
      commentPropName: false,
      unpairedTags: [],
      processEntities: true,
      htmlEntities: false,
      ignoreDeclaration: false,
      ignorePiTags: false,
      transformTagName: false,
      transformAttributeName: false,
      updateTag: function(tagName, jPath, attrs) {
        return tagName;
      }
      // skipEmptyListItem: false
    };
    var buildOptions = function(options) {
      return Object.assign({}, defaultOptions3, options);
    };
    exports.buildOptions = buildOptions;
    exports.defaultOptions = defaultOptions3;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/xmlNode.js
var require_xmlNode = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/xmlNode.js"(exports, module) {
    "use strict";
    var XmlNode = class {
      constructor(tagname) {
        this.tagname = tagname;
        this.child = [];
        this[":@"] = {};
      }
      add(key, val) {
        if (key === "__proto__") key = "#__proto__";
        this.child.push({ [key]: val });
      }
      addChild(node) {
        if (node.tagname === "__proto__") node.tagname = "#__proto__";
        if (node[":@"] && Object.keys(node[":@"]).length > 0) {
          this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
        } else {
          this.child.push({ [node.tagname]: node.child });
        }
      }
    };
    module.exports = XmlNode;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js
var require_DocTypeReader = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js"(exports, module) {
    var util = require_util();
    function readDocType(xmlData, i) {
      const entities = {};
      if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
        i = i + 9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp2 = "";
        for (; i < xmlData.length; i++) {
          if (xmlData[i] === "<" && !comment) {
            if (hasBody && isEntity(xmlData, i)) {
              i += 7;
              let entityName, val;
              [entityName, val, i] = readEntityExp(xmlData, i + 1);
              if (val.indexOf("&") === -1)
                entities[validateEntityName(entityName)] = {
                  regx: RegExp(`&${entityName};`, "g"),
                  val
                };
            } else if (hasBody && isElement(xmlData, i)) i += 8;
            else if (hasBody && isAttlist(xmlData, i)) i += 8;
            else if (hasBody && isNotation(xmlData, i)) i += 9;
            else if (isComment) comment = true;
            else throw new Error("Invalid DOCTYPE");
            angleBracketsCount++;
            exp2 = "";
          } else if (xmlData[i] === ">") {
            if (comment) {
              if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
                comment = false;
                angleBracketsCount--;
              }
            } else {
              angleBracketsCount--;
            }
            if (angleBracketsCount === 0) {
              break;
            }
          } else if (xmlData[i] === "[") {
            hasBody = true;
          } else {
            exp2 += xmlData[i];
          }
        }
        if (angleBracketsCount !== 0) {
          throw new Error(`Unclosed DOCTYPE`);
        }
      } else {
        throw new Error(`Invalid Tag instead of DOCTYPE`);
      }
      return { entities, i };
    }
    function readEntityExp(xmlData, i) {
      let entityName = "";
      for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
        entityName += xmlData[i];
      }
      entityName = entityName.trim();
      if (entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");
      const startChar = xmlData[i++];
      let val = "";
      for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
        val += xmlData[i];
      }
      return [entityName, val, i];
    }
    function isComment(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "-" && xmlData[i + 3] === "-") return true;
      return false;
    }
    function isEntity(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y") return true;
      return false;
    }
    function isElement(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T") return true;
      return false;
    }
    function isAttlist(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T") return true;
      return false;
    }
    function isNotation(xmlData, i) {
      if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N") return true;
      return false;
    }
    function validateEntityName(name12) {
      if (util.isName(name12))
        return name12;
      else
        throw new Error(`Invalid entity name ${name12}`);
    }
    module.exports = readDocType;
  }
});

// node_modules/strnum/strnum.js
var require_strnum = __commonJS({
  "node_modules/strnum/strnum.js"(exports, module) {
    var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
    var numRegex = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/;
    var consider = {
      hex: true,
      // oct: false,
      leadingZeros: true,
      decimalPoint: ".",
      eNotation: true
      //skipLike: /regex/
    };
    function toNumber2(str5, options = {}) {
      options = Object.assign({}, consider, options);
      if (!str5 || typeof str5 !== "string") return str5;
      let trimmedStr = str5.trim();
      if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr)) return str5;
      else if (str5 === "0") return 0;
      else if (options.hex && hexRegex.test(trimmedStr)) {
        return parse_int(trimmedStr, 16);
      } else if (trimmedStr.search(/[eE]/) !== -1) {
        const notation = trimmedStr.match(/^([-\+])?(0*)([0-9]*(\.[0-9]*)?[eE][-\+]?[0-9]+)$/);
        if (notation) {
          if (options.leadingZeros) {
            trimmedStr = (notation[1] || "") + notation[3];
          } else {
            if (notation[2] === "0" && notation[3][0] === ".") {
            } else {
              return str5;
            }
          }
          return options.eNotation ? Number(trimmedStr) : str5;
        } else {
          return str5;
        }
      } else {
        const match = numRegex.exec(trimmedStr);
        if (match) {
          const sign = match[1];
          const leadingZeros = match[2];
          let numTrimmedByZeros = trimZeros(match[3]);
          if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str5;
          else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str5;
          else if (options.leadingZeros && leadingZeros === str5) return 0;
          else {
            const num = Number(trimmedStr);
            const numStr = "" + num;
            if (numStr.search(/[eE]/) !== -1) {
              if (options.eNotation) return num;
              else return str5;
            } else if (trimmedStr.indexOf(".") !== -1) {
              if (numStr === "0" && numTrimmedByZeros === "") return num;
              else if (numStr === numTrimmedByZeros) return num;
              else if (sign && numStr === "-" + numTrimmedByZeros) return num;
              else return str5;
            }
            if (leadingZeros) {
              return numTrimmedByZeros === numStr || sign + numTrimmedByZeros === numStr ? num : str5;
            } else {
              return trimmedStr === numStr || trimmedStr === sign + numStr ? num : str5;
            }
          }
        } else {
          return str5;
        }
      }
    }
    function trimZeros(numStr) {
      if (numStr && numStr.indexOf(".") !== -1) {
        numStr = numStr.replace(/0+$/, "");
        if (numStr === ".") numStr = "0";
        else if (numStr[0] === ".") numStr = "0" + numStr;
        else if (numStr[numStr.length - 1] === ".") numStr = numStr.substr(0, numStr.length - 1);
        return numStr;
      }
      return numStr;
    }
    function parse_int(numStr, base) {
      if (parseInt) return parseInt(numStr, base);
      else if (Number.parseInt) return Number.parseInt(numStr, base);
      else if (window && window.parseInt) return window.parseInt(numStr, base);
      else throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
    }
    module.exports = toNumber2;
  }
});

// node_modules/fast-xml-parser/src/ignoreAttributes.js
var require_ignoreAttributes = __commonJS({
  "node_modules/fast-xml-parser/src/ignoreAttributes.js"(exports, module) {
    function getIgnoreAttributesFn(ignoreAttributes) {
      if (typeof ignoreAttributes === "function") {
        return ignoreAttributes;
      }
      if (Array.isArray(ignoreAttributes)) {
        return (attrName) => {
          for (const pattern of ignoreAttributes) {
            if (typeof pattern === "string" && attrName === pattern) {
              return true;
            }
            if (pattern instanceof RegExp && pattern.test(attrName)) {
              return true;
            }
          }
        };
      }
      return () => false;
    }
    module.exports = getIgnoreAttributesFn;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js
var require_OrderedObjParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js"(exports, module) {
    "use strict";
    var util = require_util();
    var xmlNode = require_xmlNode();
    var readDocType = require_DocTypeReader();
    var toNumber2 = require_strnum();
    var getIgnoreAttributesFn = require_ignoreAttributes();
    var OrderedObjParser = class {
      constructor(options) {
        this.options = options;
        this.currentNode = null;
        this.tagsNodeStack = [];
        this.docTypeEntities = {};
        this.lastEntities = {
          "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
          "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
          "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
          "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
        };
        this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
        this.htmlEntities = {
          "space": { regex: /&(nbsp|#160);/g, val: " " },
          // "lt" : { regex: /&(lt|#60);/g, val: "<" },
          // "gt" : { regex: /&(gt|#62);/g, val: ">" },
          // "amp" : { regex: /&(amp|#38);/g, val: "&" },
          // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
          // "apos" : { regex: /&(apos|#39);/g, val: "'" },
          "cent": { regex: /&(cent|#162);/g, val: "¢" },
          "pound": { regex: /&(pound|#163);/g, val: "£" },
          "yen": { regex: /&(yen|#165);/g, val: "¥" },
          "euro": { regex: /&(euro|#8364);/g, val: "€" },
          "copyright": { regex: /&(copy|#169);/g, val: "©" },
          "reg": { regex: /&(reg|#174);/g, val: "®" },
          "inr": { regex: /&(inr|#8377);/g, val: "₹" },
          "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str5) => String.fromCharCode(Number.parseInt(str5, 10)) },
          "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str5) => String.fromCharCode(Number.parseInt(str5, 16)) }
        };
        this.addExternalEntities = addExternalEntities;
        this.parseXml = parseXml;
        this.parseTextData = parseTextData;
        this.resolveNameSpace = resolveNameSpace;
        this.buildAttributesMap = buildAttributesMap;
        this.isItStopNode = isItStopNode;
        this.replaceEntitiesValue = replaceEntitiesValue;
        this.readStopNodeData = readStopNodeData;
        this.saveTextToParentTag = saveTextToParentTag;
        this.addChild = addChild;
        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
      }
    };
    function addExternalEntities(externalEntities) {
      const entKeys = Object.keys(externalEntities);
      for (let i = 0; i < entKeys.length; i++) {
        const ent = entKeys[i];
        this.lastEntities[ent] = {
          regex: new RegExp("&" + ent + ";", "g"),
          val: externalEntities[ent]
        };
      }
    }
    function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
      if (val !== void 0) {
        if (this.options.trimValues && !dontTrim) {
          val = val.trim();
        }
        if (val.length > 0) {
          if (!escapeEntities) val = this.replaceEntitiesValue(val);
          const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
          if (newval === null || newval === void 0) {
            return val;
          } else if (typeof newval !== typeof val || newval !== val) {
            return newval;
          } else if (this.options.trimValues) {
            return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
          } else {
            const trimmedVal = val.trim();
            if (trimmedVal === val) {
              return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
            } else {
              return val;
            }
          }
        }
      }
    }
    function resolveNameSpace(tagname) {
      if (this.options.removeNSPrefix) {
        const tags = tagname.split(":");
        const prefix = tagname.charAt(0) === "/" ? "/" : "";
        if (tags[0] === "xmlns") {
          return "";
        }
        if (tags.length === 2) {
          tagname = prefix + tags[1];
        }
      }
      return tagname;
    }
    var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function buildAttributesMap(attrStr, jPath, tagName) {
      if (this.options.ignoreAttributes !== true && typeof attrStr === "string") {
        const matches = util.getAllMatches(attrStr, attrsRegx);
        const len4 = matches.length;
        const attrs = {};
        for (let i = 0; i < len4; i++) {
          const attrName = this.resolveNameSpace(matches[i][1]);
          if (this.ignoreAttributesFn(attrName, jPath)) {
            continue;
          }
          let oldVal = matches[i][4];
          let aName = this.options.attributeNamePrefix + attrName;
          if (attrName.length) {
            if (this.options.transformAttributeName) {
              aName = this.options.transformAttributeName(aName);
            }
            if (aName === "__proto__") aName = "#__proto__";
            if (oldVal !== void 0) {
              if (this.options.trimValues) {
                oldVal = oldVal.trim();
              }
              oldVal = this.replaceEntitiesValue(oldVal);
              const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
              if (newVal === null || newVal === void 0) {
                attrs[aName] = oldVal;
              } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
                attrs[aName] = newVal;
              } else {
                attrs[aName] = parseValue(
                  oldVal,
                  this.options.parseAttributeValue,
                  this.options.numberParseOptions
                );
              }
            } else if (this.options.allowBooleanAttributes) {
              attrs[aName] = true;
            }
          }
        }
        if (!Object.keys(attrs).length) {
          return;
        }
        if (this.options.attributesGroupName) {
          const attrCollection = {};
          attrCollection[this.options.attributesGroupName] = attrs;
          return attrCollection;
        }
        return attrs;
      }
    }
    var parseXml = function(xmlData) {
      xmlData = xmlData.replace(/\r\n?/g, "\n");
      const xmlObj = new xmlNode("!xml");
      let currentNode = xmlObj;
      let textData = "";
      let jPath = "";
      for (let i = 0; i < xmlData.length; i++) {
        const ch = xmlData[i];
        if (ch === "<") {
          if (xmlData[i + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
            let tagName = xmlData.substring(i + 2, closeIndex).trim();
            if (this.options.removeNSPrefix) {
              const colonIndex = tagName.indexOf(":");
              if (colonIndex !== -1) {
                tagName = tagName.substr(colonIndex + 1);
              }
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode) {
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
            }
            const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
            if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
              throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
            }
            let propIndex = 0;
            if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
              propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
              this.tagsNodeStack.pop();
            } else {
              propIndex = jPath.lastIndexOf(".");
            }
            jPath = jPath.substring(0, propIndex);
            currentNode = this.tagsNodeStack.pop();
            textData = "";
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            let tagData = readTagExp(xmlData, i, false, "?>");
            if (!tagData) throw new Error("Pi Tag is not closed.");
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags) {
            } else {
              const childNode = new xmlNode(tagData.tagName);
              childNode.add(this.options.textNodeName, "");
              if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
              }
              this.addChild(currentNode, childNode, jPath);
            }
            i = tagData.closeIndex + 1;
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              const comment = xmlData.substring(i + 4, endIndex - 2);
              textData = this.saveTextToParentTag(textData, currentNode, jPath);
              currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
            }
            i = endIndex;
          } else if (xmlData.substr(i + 1, 2) === "!D") {
            const result = readDocType(xmlData, i);
            this.docTypeEntities = result.entities;
            i = result.i;
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
            const tagExp = xmlData.substring(i + 9, closeIndex);
            textData = this.saveTextToParentTag(textData, currentNode, jPath);
            let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
            if (val == void 0) val = "";
            if (this.options.cdataPropName) {
              currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
            } else {
              currentNode.add(this.options.textNodeName, val);
            }
            i = closeIndex + 2;
          } else {
            let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
            let tagName = result.tagName;
            const rawTagName = result.rawTagName;
            let tagExp = result.tagExp;
            let attrExpPresent = result.attrExpPresent;
            let closeIndex = result.closeIndex;
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            if (currentNode && textData) {
              if (currentNode.tagname !== "!xml") {
                textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
              }
            }
            const lastTag = currentNode;
            if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
              currentNode = this.tagsNodeStack.pop();
              jPath = jPath.substring(0, jPath.lastIndexOf("."));
            }
            if (tagName !== xmlObj.tagname) {
              jPath += jPath ? "." + tagName : tagName;
            }
            if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
              let tagContent = "";
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                i = result.closeIndex;
              } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
                i = result.closeIndex;
              } else {
                const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
                if (!result2) throw new Error(`Unexpected end of ${rawTagName}`);
                i = result2.i;
                tagContent = result2.tagContent;
              }
              const childNode = new xmlNode(tagName);
              if (tagName !== tagExp && attrExpPresent) {
                childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
              }
              if (tagContent) {
                tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
              }
              jPath = jPath.substr(0, jPath.lastIndexOf("."));
              childNode.add(this.options.textNodeName, tagContent);
              this.addChild(currentNode, childNode, jPath);
            } else {
              if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
                if (tagName[tagName.length - 1] === "/") {
                  tagName = tagName.substr(0, tagName.length - 1);
                  jPath = jPath.substr(0, jPath.length - 1);
                  tagExp = tagName;
                } else {
                  tagExp = tagExp.substr(0, tagExp.length - 1);
                }
                if (this.options.transformTagName) {
                  tagName = this.options.transformTagName(tagName);
                }
                const childNode = new xmlNode(tagName);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                jPath = jPath.substr(0, jPath.lastIndexOf("."));
              } else {
                const childNode = new xmlNode(tagName);
                this.tagsNodeStack.push(currentNode);
                if (tagName !== tagExp && attrExpPresent) {
                  childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
                }
                this.addChild(currentNode, childNode, jPath);
                currentNode = childNode;
              }
              textData = "";
              i = closeIndex;
            }
          }
        } else {
          textData += xmlData[i];
        }
      }
      return xmlObj.child;
    };
    function addChild(currentNode, childNode, jPath) {
      const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
      if (result === false) {
      } else if (typeof result === "string") {
        childNode.tagname = result;
        currentNode.addChild(childNode);
      } else {
        currentNode.addChild(childNode);
      }
    }
    var replaceEntitiesValue = function(val) {
      if (this.options.processEntities) {
        for (let entityName in this.docTypeEntities) {
          const entity = this.docTypeEntities[entityName];
          val = val.replace(entity.regx, entity.val);
        }
        for (let entityName in this.lastEntities) {
          const entity = this.lastEntities[entityName];
          val = val.replace(entity.regex, entity.val);
        }
        if (this.options.htmlEntities) {
          for (let entityName in this.htmlEntities) {
            const entity = this.htmlEntities[entityName];
            val = val.replace(entity.regex, entity.val);
          }
        }
        val = val.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return val;
    };
    function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
      if (textData) {
        if (isLeafNode === void 0) isLeafNode = currentNode.child.length === 0;
        textData = this.parseTextData(
          textData,
          currentNode.tagname,
          jPath,
          false,
          currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
          isLeafNode
        );
        if (textData !== void 0 && textData !== "")
          currentNode.add(this.options.textNodeName, textData);
        textData = "";
      }
      return textData;
    }
    function isItStopNode(stopNodes, jPath, currentTagName) {
      const allNodesExp = "*." + currentTagName;
      for (const stopNodePath in stopNodes) {
        const stopNodeExp = stopNodes[stopNodePath];
        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;
      }
      return false;
    }
    function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
      let attrBoundary;
      let tagExp = "";
      for (let index = i; index < xmlData.length; index++) {
        let ch = xmlData[index];
        if (attrBoundary) {
          if (ch === attrBoundary) attrBoundary = "";
        } else if (ch === '"' || ch === "'") {
          attrBoundary = ch;
        } else if (ch === closingChar[0]) {
          if (closingChar[1]) {
            if (xmlData[index + 1] === closingChar[1]) {
              return {
                data: tagExp,
                index
              };
            }
          } else {
            return {
              data: tagExp,
              index
            };
          }
        } else if (ch === "	") {
          ch = " ";
        }
        tagExp += ch;
      }
    }
    function findClosingIndex(xmlData, str5, i, errMsg) {
      const closingIndex = xmlData.indexOf(str5, i);
      if (closingIndex === -1) {
        throw new Error(errMsg);
      } else {
        return closingIndex + str5.length - 1;
      }
    }
    function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
      const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
      if (!result) return;
      let tagExp = result.data;
      const closeIndex = result.index;
      const separatorIndex = tagExp.search(/\s/);
      let tagName = tagExp;
      let attrExpPresent = true;
      if (separatorIndex !== -1) {
        tagName = tagExp.substring(0, separatorIndex);
        tagExp = tagExp.substring(separatorIndex + 1).trimStart();
      }
      const rawTagName = tagName;
      if (removeNSPrefix) {
        const colonIndex = tagName.indexOf(":");
        if (colonIndex !== -1) {
          tagName = tagName.substr(colonIndex + 1);
          attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
        }
      }
      return {
        tagName,
        tagExp,
        closeIndex,
        attrExpPresent,
        rawTagName
      };
    }
    function readStopNodeData(xmlData, tagName, i) {
      const startIndex = i;
      let openTagCount = 1;
      for (; i < xmlData.length; i++) {
        if (xmlData[i] === "<") {
          if (xmlData[i + 1] === "/") {
            const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
            let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
            if (closeTagName === tagName) {
              openTagCount--;
              if (openTagCount === 0) {
                return {
                  tagContent: xmlData.substring(startIndex, i),
                  i: closeIndex
                };
              }
            }
            i = closeIndex;
          } else if (xmlData[i + 1] === "?") {
            const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
            i = closeIndex;
          } else if (xmlData.substr(i + 1, 3) === "!--") {
            const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
            i = closeIndex;
          } else if (xmlData.substr(i + 1, 2) === "![") {
            const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
            i = closeIndex;
          } else {
            const tagData = readTagExp(xmlData, i, ">");
            if (tagData) {
              const openTagName = tagData && tagData.tagName;
              if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
                openTagCount++;
              }
              i = tagData.closeIndex;
            }
          }
        }
      }
    }
    function parseValue(val, shouldParse, options) {
      if (shouldParse && typeof val === "string") {
        const newval = val.trim();
        if (newval === "true") return true;
        else if (newval === "false") return false;
        else return toNumber2(val, options);
      } else {
        if (util.isExist(val)) {
          return val;
        } else {
          return "";
        }
      }
    }
    module.exports = OrderedObjParser;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/node2json.js
var require_node2json = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/node2json.js"(exports) {
    "use strict";
    function prettify(node, options) {
      return compress2(node, options);
    }
    function compress2(arr, options, jPath) {
      let text;
      const compressedObj = {};
      for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const property = propName(tagObj);
        let newJpath = "";
        if (jPath === void 0) newJpath = property;
        else newJpath = jPath + "." + property;
        if (property === options.textNodeName) {
          if (text === void 0) text = tagObj[property];
          else text += "" + tagObj[property];
        } else if (property === void 0) {
          continue;
        } else if (tagObj[property]) {
          let val = compress2(tagObj[property], options, newJpath);
          const isLeaf = isLeafTag(val, options);
          if (tagObj[":@"]) {
            assignAttributes(val, tagObj[":@"], newJpath, options);
          } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
            val = val[options.textNodeName];
          } else if (Object.keys(val).length === 0) {
            if (options.alwaysCreateTextNode) val[options.textNodeName] = "";
            else val = "";
          }
          if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
            if (!Array.isArray(compressedObj[property])) {
              compressedObj[property] = [compressedObj[property]];
            }
            compressedObj[property].push(val);
          } else {
            if (options.isArray(property, newJpath, isLeaf)) {
              compressedObj[property] = [val];
            } else {
              compressedObj[property] = val;
            }
          }
        }
      }
      if (typeof text === "string") {
        if (text.length > 0) compressedObj[options.textNodeName] = text;
      } else if (text !== void 0) compressedObj[options.textNodeName] = text;
      return compressedObj;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ":@") return key;
      }
    }
    function assignAttributes(obj, attrMap, jpath, options) {
      if (attrMap) {
        const keys = Object.keys(attrMap);
        const len4 = keys.length;
        for (let i = 0; i < len4; i++) {
          const atrrName = keys[i];
          if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
            obj[atrrName] = [attrMap[atrrName]];
          } else {
            obj[atrrName] = attrMap[atrrName];
          }
        }
      }
    }
    function isLeafTag(obj, options) {
      const { textNodeName } = options;
      const propCount = Object.keys(obj).length;
      if (propCount === 0) {
        return true;
      }
      if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
        return true;
      }
      return false;
    }
    exports.prettify = prettify;
  }
});

// node_modules/fast-xml-parser/src/xmlparser/XMLParser.js
var require_XMLParser = __commonJS({
  "node_modules/fast-xml-parser/src/xmlparser/XMLParser.js"(exports, module) {
    var { buildOptions } = require_OptionsBuilder();
    var OrderedObjParser = require_OrderedObjParser();
    var { prettify } = require_node2json();
    var validator = require_validator();
    var XMLParser = class {
      constructor(options) {
        this.externalEntities = {};
        this.options = buildOptions(options);
      }
      /**
       * Parse XML dats to JS object 
       * @param {string|Buffer} xmlData 
       * @param {boolean|Object} validationOption 
       */
      parse(xmlData, validationOption) {
        if (typeof xmlData === "string") {
        } else if (xmlData.toString) {
          xmlData = xmlData.toString();
        } else {
          throw new Error("XML data is accepted in String or Bytes[] form.");
        }
        if (validationOption) {
          if (validationOption === true) validationOption = {};
          const result = validator.validate(xmlData, validationOption);
          if (result !== true) {
            throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
          }
        }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if (this.options.preserveOrder || orderedResult === void 0) return orderedResult;
        else return prettify(orderedResult, this.options);
      }
      /**
       * Add Entity which is not by default supported by this library
       * @param {string} key 
       * @param {string} value 
       */
      addEntity(key, value) {
        if (value.indexOf("&") !== -1) {
          throw new Error("Entity value can't have '&'");
        } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
          throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
        } else if (value === "&") {
          throw new Error("An entity with value '&' is not permitted");
        } else {
          this.externalEntities[key] = value;
        }
      }
    };
    module.exports = XMLParser;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js
var require_orderedJs2Xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js"(exports, module) {
    var EOL = "\n";
    function toXml(jArray, options) {
      let indentation = "";
      if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
      }
      return arrToStr(jArray, options, "", indentation);
    }
    function arrToStr(arr, options, jPath, indentation) {
      let xmlStr = "";
      let isPreviousElementTag = false;
      for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        if (tagName === void 0) continue;
        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName;
        else newJPath = `${jPath}.${tagName}`;
        if (tagName === options.textNodeName) {
          let tagText = tagObj[tagName];
          if (!isStopNode(newJPath, options)) {
            tagText = options.tagValueProcessor(tagName, tagText);
            tagText = replaceEntitiesValue(tagText, options);
          }
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += tagText;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.cdataPropName) {
          if (isPreviousElementTag) {
            xmlStr += indentation;
          }
          xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
          isPreviousElementTag = false;
          continue;
        } else if (tagName === options.commentPropName) {
          xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
          isPreviousElementTag = true;
          continue;
        } else if (tagName[0] === "?") {
          const attStr2 = attr_to_str(tagObj[":@"], options);
          const tempInd = tagName === "?xml" ? "" : indentation;
          let piTextNodeName = tagObj[tagName][0][options.textNodeName];
          piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
          xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
          isPreviousElementTag = true;
          continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
          newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
          if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
          else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
          xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
          xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
          xmlStr += tagStart + ">";
          if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
            xmlStr += indentation + options.indentBy + tagValue + indentation;
          } else {
            xmlStr += tagValue;
          }
          xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
      }
      return xmlStr;
    }
    function propName(obj) {
      const keys = Object.keys(obj);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (!obj.hasOwnProperty(key)) continue;
        if (key !== ":@") return key;
      }
    }
    function attr_to_str(attrMap, options) {
      let attrStr = "";
      if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
          if (!attrMap.hasOwnProperty(attr)) continue;
          let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
          attrVal = replaceEntitiesValue(attrVal, options);
          if (attrVal === true && options.suppressBooleanAttributes) {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
          } else {
            attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
          }
        }
      }
      return attrStr;
    }
    function isStopNode(jPath, options) {
      jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
      let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
      for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
      }
      return false;
    }
    function replaceEntitiesValue(textValue, options) {
      if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
          const entity = options.entities[i];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    }
    module.exports = toXml;
  }
});

// node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js
var require_json2xml = __commonJS({
  "node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js"(exports, module) {
    "use strict";
    var buildFromOrderedJs = require_orderedJs2Xml();
    var getIgnoreAttributesFn = require_ignoreAttributes();
    var defaultOptions3 = {
      attributeNamePrefix: "@_",
      attributesGroupName: false,
      textNodeName: "#text",
      ignoreAttributes: true,
      cdataPropName: false,
      format: false,
      indentBy: "  ",
      suppressEmptyNode: false,
      suppressUnpairedNode: true,
      suppressBooleanAttributes: true,
      tagValueProcessor: function(key, a3) {
        return a3;
      },
      attributeValueProcessor: function(attrName, a3) {
        return a3;
      },
      preserveOrder: false,
      commentPropName: false,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        //it must be on top
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" }
      ],
      processEntities: true,
      stopNodes: [],
      // transformTagName: false,
      // transformAttributeName: false,
      oneListGroup: false
    };
    function Builder(options) {
      this.options = Object.assign({}, defaultOptions3, options);
      if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
        this.isAttribute = function() {
          return false;
        };
      } else {
        this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes);
        this.attrPrefixLen = this.options.attributeNamePrefix.length;
        this.isAttribute = isAttribute;
      }
      this.processTextOrObjNode = processTextOrObjNode;
      if (this.options.format) {
        this.indentate = indentate;
        this.tagEndChar = ">\n";
        this.newLine = "\n";
      } else {
        this.indentate = function() {
          return "";
        };
        this.tagEndChar = ">";
        this.newLine = "";
      }
    }
    Builder.prototype.build = function(jObj) {
      if (this.options.preserveOrder) {
        return buildFromOrderedJs(jObj, this.options);
      } else {
        if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
          jObj = {
            [this.options.arrayNodeName]: jObj
          };
        }
        return this.j2x(jObj, 0, []).val;
      }
    };
    Builder.prototype.j2x = function(jObj, level, ajPath) {
      let attrStr = "";
      let val = "";
      const jPath = ajPath.join(".");
      for (let key in jObj) {
        if (!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
        if (typeof jObj[key] === "undefined") {
          if (this.isAttribute(key)) {
            val += "";
          }
        } else if (jObj[key] === null) {
          if (this.isAttribute(key)) {
            val += "";
          } else if (key === this.options.cdataPropName) {
            val += "";
          } else if (key[0] === "?") {
            val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          } else {
            val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
          }
        } else if (jObj[key] instanceof Date) {
          val += this.buildTextValNode(jObj[key], key, "", level);
        } else if (typeof jObj[key] !== "object") {
          const attr = this.isAttribute(key);
          if (attr && !this.ignoreAttributesFn(attr, jPath)) {
            attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
          } else if (!attr) {
            if (key === this.options.textNodeName) {
              let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
              val += this.replaceEntitiesValue(newval);
            } else {
              val += this.buildTextValNode(jObj[key], key, "", level);
            }
          }
        } else if (Array.isArray(jObj[key])) {
          const arrLen = jObj[key].length;
          let listTagVal = "";
          let listTagAttr = "";
          for (let j = 0; j < arrLen; j++) {
            const item = jObj[key][j];
            if (typeof item === "undefined") {
            } else if (item === null) {
              if (key[0] === "?") val += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
              else val += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
            } else if (typeof item === "object") {
              if (this.options.oneListGroup) {
                const result = this.j2x(item, level + 1, ajPath.concat(key));
                listTagVal += result.val;
                if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
                  listTagAttr += result.attrStr;
                }
              } else {
                listTagVal += this.processTextOrObjNode(item, key, level, ajPath);
              }
            } else {
              if (this.options.oneListGroup) {
                let textValue = this.options.tagValueProcessor(key, item);
                textValue = this.replaceEntitiesValue(textValue);
                listTagVal += textValue;
              } else {
                listTagVal += this.buildTextValNode(item, key, "", level);
              }
            }
          }
          if (this.options.oneListGroup) {
            listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
          }
          val += listTagVal;
        } else {
          if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
            const Ks = Object.keys(jObj[key]);
            const L2 = Ks.length;
            for (let j = 0; j < L2; j++) {
              attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
            }
          } else {
            val += this.processTextOrObjNode(jObj[key], key, level, ajPath);
          }
        }
      }
      return { attrStr, val };
    };
    Builder.prototype.buildAttrPairStr = function(attrName, val) {
      val = this.options.attributeValueProcessor(attrName, "" + val);
      val = this.replaceEntitiesValue(val);
      if (this.options.suppressBooleanAttributes && val === "true") {
        return " " + attrName;
      } else return " " + attrName + '="' + val + '"';
    };
    function processTextOrObjNode(object, key, level, ajPath) {
      const result = this.j2x(object, level + 1, ajPath.concat(key));
      if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
        return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
      } else {
        return this.buildObjectNode(result.val, key, result.attrStr, level);
      }
    }
    Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
      if (val === "") {
        if (key[0] === "?") return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
        else {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        }
      } else {
        let tagEndExp = "</" + key + this.tagEndChar;
        let piClosingChar = "";
        if (key[0] === "?") {
          piClosingChar = "?";
          tagEndExp = "";
        }
        if ((attrStr || attrStr === "") && val.indexOf("<") === -1) {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val + tagEndExp;
        } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
          return this.indentate(level) + `<!--${val}-->` + this.newLine;
        } else {
          return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val + this.indentate(level) + tagEndExp;
        }
      }
    };
    Builder.prototype.closeTag = function(key) {
      let closeTag = "";
      if (this.options.unpairedTags.indexOf(key) !== -1) {
        if (!this.options.suppressUnpairedNode) closeTag = "/";
      } else if (this.options.suppressEmptyNode) {
        closeTag = "/";
      } else {
        closeTag = `></${key}`;
      }
      return closeTag;
    };
    Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
      if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
        return this.indentate(level) + `<![CDATA[${val}]]>` + this.newLine;
      } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
        return this.indentate(level) + `<!--${val}-->` + this.newLine;
      } else if (key[0] === "?") {
        return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
      } else {
        let textValue = this.options.tagValueProcessor(key, val);
        textValue = this.replaceEntitiesValue(textValue);
        if (textValue === "") {
          return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
        } else {
          return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
        }
      }
    };
    Builder.prototype.replaceEntitiesValue = function(textValue) {
      if (textValue && textValue.length > 0 && this.options.processEntities) {
        for (let i = 0; i < this.options.entities.length; i++) {
          const entity = this.options.entities[i];
          textValue = textValue.replace(entity.regex, entity.val);
        }
      }
      return textValue;
    };
    function indentate(level) {
      return this.options.indentBy.repeat(level);
    }
    function isAttribute(name12) {
      if (name12.startsWith(this.options.attributeNamePrefix) && name12 !== this.options.textNodeName) {
        return name12.substr(this.attrPrefixLen);
      } else {
        return false;
      }
    }
    module.exports = Builder;
  }
});

// node_modules/fast-xml-parser/src/fxp.js
var require_fxp = __commonJS({
  "node_modules/fast-xml-parser/src/fxp.js"(exports, module) {
    "use strict";
    var validator = require_validator();
    var XMLParser = require_XMLParser();
    var XMLBuilder = require_json2xml();
    module.exports = {
      XMLParser,
      XMLValidator: validator,
      XMLBuilder
    };
  }
});

// node_modules/long/dist/long.js
var require_long = __commonJS({
  "node_modules/long/dist/long.js"(exports, module) {
    (function(global2, factory) {
      if (typeof define === "function" && define["amd"])
        define([], factory);
      else if (typeof __require === "function" && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
      else
        (global2["dcodeIO"] = global2["dcodeIO"] || {})["Long"] = factory();
    })(exports, function() {
      "use strict";
      function Long4(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long4.prototype.__isLong__;
      Object.defineProperty(Long4.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
      });
      function isLong2(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      Long4.isLong = isLong2;
      var INT_CACHE2 = {};
      var UINT_CACHE2 = {};
      function fromInt2(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
          value >>>= 0;
          if (cache = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE2[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits2(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache)
            UINT_CACHE2[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache = -128 <= value && value < 128) {
            cachedObj = INT_CACHE2[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits2(value, value < 0 ? -1 : 0, false);
          if (cache)
            INT_CACHE2[value] = obj;
          return obj;
        }
      }
      Long4.fromInt = fromInt2;
      function fromNumber2(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
          return unsigned ? UZERO2 : ZERO3;
        if (unsigned) {
          if (value < 0)
            return UZERO2;
          if (value >= TWO_PWR_64_DBL2)
            return MAX_UNSIGNED_VALUE2;
        } else {
          if (value <= -TWO_PWR_63_DBL2)
            return MIN_VALUE2;
          if (value + 1 >= TWO_PWR_63_DBL2)
            return MAX_VALUE2;
        }
        if (value < 0)
          return fromNumber2(-value, unsigned).neg();
        return fromBits2(value % TWO_PWR_32_DBL2 | 0, value / TWO_PWR_32_DBL2 | 0, unsigned);
      }
      Long4.fromNumber = fromNumber2;
      function fromBits2(lowBits, highBits, unsigned) {
        return new Long4(lowBits, highBits, unsigned);
      }
      Long4.fromBits = fromBits2;
      var pow_dbl2 = Math.pow;
      function fromString2(str5, unsigned, radix) {
        if (str5.length === 0)
          throw Error("empty string");
        if (str5 === "NaN" || str5 === "Infinity" || str5 === "+Infinity" || str5 === "-Infinity")
          return ZERO3;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p;
        if ((p = str5.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p === 0) {
          return fromString2(str5.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber2(pow_dbl2(radix, 8));
        var result = ZERO3;
        for (var i = 0; i < str5.length; i += 8) {
          var size = Math.min(8, str5.length - i), value = parseInt(str5.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber2(pow_dbl2(radix, size));
            result = result.mul(power).add(fromNumber2(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber2(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long4.fromString = fromString2;
      function fromValue2(val) {
        if (val instanceof Long4)
          return val;
        if (typeof val === "number")
          return fromNumber2(val);
        if (typeof val === "string")
          return fromString2(val);
        return fromBits2(val.low, val.high, val.unsigned);
      }
      Long4.fromValue = fromValue2;
      var TWO_PWR_16_DBL2 = 1 << 16;
      var TWO_PWR_24_DBL2 = 1 << 24;
      var TWO_PWR_32_DBL2 = TWO_PWR_16_DBL2 * TWO_PWR_16_DBL2;
      var TWO_PWR_64_DBL2 = TWO_PWR_32_DBL2 * TWO_PWR_32_DBL2;
      var TWO_PWR_63_DBL2 = TWO_PWR_64_DBL2 / 2;
      var TWO_PWR_242 = fromInt2(TWO_PWR_24_DBL2);
      var ZERO3 = fromInt2(0);
      Long4.ZERO = ZERO3;
      var UZERO2 = fromInt2(0, true);
      Long4.UZERO = UZERO2;
      var ONE2 = fromInt2(1);
      Long4.ONE = ONE2;
      var UONE2 = fromInt2(1, true);
      Long4.UONE = UONE2;
      var NEG_ONE2 = fromInt2(-1);
      Long4.NEG_ONE = NEG_ONE2;
      var MAX_VALUE2 = fromBits2(4294967295 | 0, 2147483647 | 0, false);
      Long4.MAX_VALUE = MAX_VALUE2;
      var MAX_UNSIGNED_VALUE2 = fromBits2(4294967295 | 0, 4294967295 | 0, true);
      Long4.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE2;
      var MIN_VALUE2 = fromBits2(0, 2147483648 | 0, false);
      Long4.MIN_VALUE = MIN_VALUE2;
      var LongPrototype2 = Long4.prototype;
      LongPrototype2.toInt = function toInt2() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype2.toNumber = function toNumber2() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL2 + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL2 + (this.low >>> 0);
      };
      LongPrototype2.toString = function toString2(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE2)) {
            var radixLong = fromNumber2(radix), div3 = this.div(radixLong), rem1 = div3.mul(radixLong).sub(this);
            return div3.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber2(pow_dbl2(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype2.getHighBits = function getHighBits2() {
        return this.high;
      };
      LongPrototype2.getHighBitsUnsigned = function getHighBitsUnsigned2() {
        return this.high >>> 0;
      };
      LongPrototype2.getLowBits = function getLowBits2() {
        return this.low;
      };
      LongPrototype2.getLowBitsUnsigned = function getLowBitsUnsigned2() {
        return this.low >>> 0;
      };
      LongPrototype2.getNumBitsAbs = function getNumBitsAbs2() {
        if (this.isNegative())
          return this.eq(MIN_VALUE2) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype2.isZero = function isZero2() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype2.isNegative = function isNegative2() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype2.isPositive = function isPositive2() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype2.isOdd = function isOdd2() {
        return (this.low & 1) === 1;
      };
      LongPrototype2.isEven = function isEven2() {
        return (this.low & 1) === 0;
      };
      LongPrototype2.equals = function equals8(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype2.eq = LongPrototype2.equals;
      LongPrototype2.notEquals = function notEquals2(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype2.neq = LongPrototype2.notEquals;
      LongPrototype2.lessThan = function lessThan2(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype2.lt = LongPrototype2.lessThan;
      LongPrototype2.lessThanOrEqual = function lessThanOrEqual2(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype2.lte = LongPrototype2.lessThanOrEqual;
      LongPrototype2.greaterThan = function greaterThan2(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype2.gt = LongPrototype2.greaterThan;
      LongPrototype2.greaterThanOrEqual = function greaterThanOrEqual2(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype2.gte = LongPrototype2.greaterThanOrEqual;
      LongPrototype2.compare = function compare2(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype2.comp = LongPrototype2.compare;
      LongPrototype2.negate = function negate4() {
        if (!this.unsigned && this.eq(MIN_VALUE2))
          return MIN_VALUE2;
        return this.not().add(ONE2);
      };
      LongPrototype2.neg = LongPrototype2.negate;
      LongPrototype2.add = function add7(addend) {
        if (!isLong2(addend))
          addend = fromValue2(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype2.subtract = function subtract5(subtrahend) {
        if (!isLong2(subtrahend))
          subtrahend = fromValue2(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype2.sub = LongPrototype2.subtract;
      LongPrototype2.multiply = function multiply6(multiplier) {
        if (this.isZero())
          return ZERO3;
        if (!isLong2(multiplier))
          multiplier = fromValue2(multiplier);
        if (multiplier.isZero())
          return ZERO3;
        if (this.eq(MIN_VALUE2))
          return multiplier.isOdd() ? MIN_VALUE2 : ZERO3;
        if (multiplier.eq(MIN_VALUE2))
          return this.isOdd() ? MIN_VALUE2 : ZERO3;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_242) && multiplier.lt(TWO_PWR_242))
          return fromNumber2(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits2(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype2.mul = LongPrototype2.multiply;
      LongPrototype2.divide = function divide4(divisor) {
        if (!isLong2(divisor))
          divisor = fromValue2(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (this.isZero())
          return this.unsigned ? UZERO2 : ZERO3;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE2)) {
            if (divisor.eq(ONE2) || divisor.eq(NEG_ONE2))
              return MIN_VALUE2;
            else if (divisor.eq(MIN_VALUE2))
              return ONE2;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO3)) {
                return divisor.isNegative() ? ONE2 : NEG_ONE2;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE2))
            return this.unsigned ? UZERO2 : ZERO3;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO3;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO2;
          if (divisor.gt(this.shru(1)))
            return UONE2;
          res = UZERO2;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl2(2, log22 - 48), approxRes = fromNumber2(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber2(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE2;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype2.div = LongPrototype2.divide;
      LongPrototype2.modulo = function modulo2(divisor) {
        if (!isLong2(divisor))
          divisor = fromValue2(divisor);
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype2.mod = LongPrototype2.modulo;
      LongPrototype2.not = function not2() {
        return fromBits2(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype2.and = function and2(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        return fromBits2(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype2.or = function or2(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        return fromBits2(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype2.xor = function xor2(other) {
        if (!isLong2(other))
          other = fromValue2(other);
        return fromBits2(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype2.shiftLeft = function shiftLeft3(numBits) {
        if (isLong2(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits2(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits2(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype2.shl = LongPrototype2.shiftLeft;
      LongPrototype2.shiftRight = function shiftRight3(numBits) {
        if (isLong2(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits2(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits2(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype2.shr = LongPrototype2.shiftRight;
      LongPrototype2.shiftRightUnsigned = function shiftRightUnsigned2(numBits) {
        if (isLong2(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return fromBits2(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return fromBits2(high, 0, this.unsigned);
          else
            return fromBits2(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      LongPrototype2.shru = LongPrototype2.shiftRightUnsigned;
      LongPrototype2.toSigned = function toSigned2() {
        if (!this.unsigned)
          return this;
        return fromBits2(this.low, this.high, false);
      };
      LongPrototype2.toUnsigned = function toUnsigned2() {
        if (this.unsigned)
          return this;
        return fromBits2(this.low, this.high, true);
      };
      LongPrototype2.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype2.toBytesLE = function() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24 & 255,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24 & 255
        ];
      };
      LongPrototype2.toBytesBE = function() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24 & 255,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24 & 255,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      return Long4;
    });
  }
});

// node_modules/jszip/dist/jszip.min.js
var require_jszip_min = __commonJS({
  "node_modules/jszip/dist/jszip.min.js"(exports, module) {
    !function(e2) {
      if ("object" == typeof exports && "undefined" != typeof module) module.exports = e2();
      else if ("function" == typeof define && define.amd) define([], e2);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).JSZip = e2();
      }
    }(function() {
      return function s(a3, o, h) {
        function u2(r, e3) {
          if (!o[r]) {
            if (!a3[r]) {
              var t = "function" == typeof __require && __require;
              if (!e3 && t) return t(r, true);
              if (l) return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a3[r][0].call(i.exports, function(e4) {
              var t2 = a3[r][1][e4];
              return u2(t2 || e4);
            }, i, i.exports, s, a3, o, h);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof __require && __require, e2 = 0; e2 < h.length; e2++) u2(h[e2]);
        return u2;
      }({ 1: [function(e2, t, r) {
        "use strict";
        var d2 = e2("./utils"), c2 = e2("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e3) {
          for (var t2, r2, n, i, s, a3, o, h = [], u2 = 0, l = e3.length, f = l, c3 = "string" !== d2.getTypeOf(e3); u2 < e3.length; ) f = l - u2, n = c3 ? (t2 = e3[u2++], r2 = u2 < l ? e3[u2++] : 0, u2 < l ? e3[u2++] : 0) : (t2 = e3.charCodeAt(u2++), r2 = u2 < l ? e3.charCodeAt(u2++) : 0, u2 < l ? e3.charCodeAt(u2++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a3 = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a3) + p.charAt(o));
          return h.join("");
        }, r.decode = function(e3) {
          var t2, r2, n, i, s, a3, o = 0, h = 0, u2 = "data:";
          if (e3.substr(0, u2.length) === u2) throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e3 = e3.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e3.charAt(e3.length - 1) === p.charAt(64) && f--, e3.charAt(e3.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (l = c2.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e3.length; ) t2 = p.indexOf(e3.charAt(o++)) << 2 | (i = p.indexOf(e3.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e3.charAt(o++))) >> 2, n = (3 & s) << 6 | (a3 = p.indexOf(e3.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a3 && (l[h++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e2, t, r) {
        "use strict";
        var n = e2("./external"), i = e2("./stream/DataWorker"), s = e2("./stream/Crc32Probe"), a3 = e2("./stream/DataLengthProbe");
        function o(e3, t2, r2, n2, i2) {
          this.compressedSize = e3, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e3 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a3("data_length")), t2 = this;
          return e3.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), e3;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e3, t2, r2) {
          return e3.pipe(new s()).pipe(new a3("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a3("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e2, t, r) {
        "use strict";
        var n = e2("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e2("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e2, t, r) {
        "use strict";
        var n = e2("./utils");
        var o = function() {
          for (var e3, t2 = [], r2 = 0; r2 < 256; r2++) {
            e3 = r2;
            for (var n2 = 0; n2 < 8; n2++) e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t2[r2] = e3;
          }
          return t2;
        }();
        t.exports = function(e3, t2) {
          return void 0 !== e3 && e3.length ? "string" !== n.getTypeOf(e3) ? function(e4, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e4 ^= -1;
            for (var a3 = n2; a3 < s; a3++) e4 = e4 >>> 8 ^ i[255 & (e4 ^ t3[a3])];
            return -1 ^ e4;
          }(0 | t2, e3, e3.length, 0) : function(e4, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e4 ^= -1;
            for (var a3 = n2; a3 < s; a3++) e4 = e4 >>> 8 ^ i[255 & (e4 ^ t3.charCodeAt(a3))];
            return -1 ^ e4;
          }(0 | t2, e3, e3.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e2, t, r) {
        "use strict";
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e2, t, r) {
        "use strict";
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e2("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e2, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e2("pako"), s = e2("./utils"), a3 = e2("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h(e3, t2) {
          a3.call(this, "FlateWorker/" + e3), this._pako = null, this._pakoAction = e3, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h, a3), h.prototype.processChunk = function(e3) {
          this.meta = e3.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e3.data), false);
        }, h.prototype.flush = function() {
          a3.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h.prototype.cleanUp = function() {
          a3.prototype.cleanUp.call(this), this._pako = null;
        }, h.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e3) {
            t2.push({ data: e3, meta: t2.meta });
          };
        }, r.compressWorker = function(e3) {
          return new h("Deflate", e3);
        }, r.uncompressWorker = function() {
          return new h("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e2, t, r) {
        "use strict";
        function A2(e3, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++) n2 += String.fromCharCode(255 & e3), e3 >>>= 8;
          return n2;
        }
        function n(e3, t2, r2, n2, i2, s2) {
          var a3, o, h = e3.file, u2 = e3.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c2 = I.transformTo("string", O.utf8encode(h.name)), d2 = h.comment, p = I.transformTo("string", s2(d2)), m = I.transformTo("string", O.utf8encode(d2)), _ = c2.length !== h.name.length, g = m.length !== d2.length, b3 = "", v2 = "", y = "", w2 = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e3.crc32, x.compressedSize = e3.compressedSize, x.uncompressedSize = e3.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_ && !g || (S |= 2048);
          var z = 0, C2 = 0;
          w2 && (z |= 16), "UNIX" === i2 ? (C2 = 798, z |= function(e4, t3) {
            var r3 = e4;
            return e4 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          }(h.unixPermissions, w2)) : (C2 = 20, z |= function(e4) {
            return 63 & (e4 || 0);
          }(h.dosPermissions)), a3 = k.getUTCHours(), a3 <<= 6, a3 |= k.getUTCMinutes(), a3 <<= 5, a3 |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v2 = A2(1, 1) + A2(B2(f), 4) + c2, b3 += "up" + A2(v2.length, 2) + v2), g && (y = A2(1, 1) + A2(B2(p), 4) + m, b3 += "uc" + A2(y.length, 2) + y);
          var E2 = "";
          return E2 += "\n\0", E2 += A2(S, 2), E2 += u2.magic, E2 += A2(a3, 2), E2 += A2(o, 2), E2 += A2(x.crc32, 4), E2 += A2(x.compressedSize, 4), E2 += A2(x.uncompressedSize, 4), E2 += A2(f.length, 2), E2 += A2(b3.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E2 + f + b3, dirRecord: R.CENTRAL_FILE_HEADER + A2(C2, 2) + E2 + A2(p.length, 2) + "\0\0\0\0" + A2(z, 4) + A2(n2, 4) + f + b3 + p };
        }
        var I = e2("../utils"), i = e2("../stream/GenericWorker"), O = e2("../utf8"), B2 = e2("../crc32"), R = e2("../signature");
        function s(e3, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e3, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e3) {
          var t2 = e3.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e3) : (this.bytesWritten += e3.data.length, i.prototype.push.call(this, { data: e3.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e3) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e3.file.name;
          var t2 = this.streamFiles && !e3.file.dir;
          if (t2) {
            var r2 = n(e3, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = true;
        }, s.prototype.closedSource = function(e3) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e3.file.dir, r2 = n(e3, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2) this.push({ data: function(e4) {
            return R.DATA_DESCRIPTOR + A2(e4.crc32, 4) + A2(e4.compressedSize, 4) + A2(e4.uncompressedSize, 4);
          }(e3), meta: { percent: 100 } });
          else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e3 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++) this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e3, n2 = function(e4, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A2(e4, 2) + A2(e4, 2) + A2(t3, 4) + A2(r3, 4) + A2(s2.length, 2) + s2;
          }(this.dirRecords.length, r2, e3, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e3) {
          this._sources.push(e3);
          var t2 = this;
          return e3.on("data", function(e4) {
            t2.processChunk(e4);
          }), e3.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e3.on("error", function(e4) {
            t2.error(e4);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e3) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e3)) return false;
          for (var r2 = 0; r2 < t2.length; r2++) try {
            t2[r2].error(e3);
          } catch (e4) {
          }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e3 = this._sources, t2 = 0; t2 < e3.length; t2++) e3[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e2, t, r) {
        "use strict";
        var u2 = e2("../compressions"), n = e2("./ZipFileWorker");
        r.generateWorker = function(e3, a3, t2) {
          var o = new n(a3.streamFiles, t2, a3.platform, a3.encodeFileName), h = 0;
          try {
            e3.forEach(function(e4, t3) {
              h++;
              var r2 = function(e5, t4) {
                var r3 = e5 || t4, n3 = u2[r3];
                if (!n3) throw new Error(r3 + " is not a valid compression method !");
                return n3;
              }(t3.options.compression, a3.compression), n2 = t3.options.compressionOptions || a3.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e4, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h;
          } catch (e4) {
            o.error(e4);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e2, t, r) {
        "use strict";
        function n() {
          if (!(this instanceof n)) return new n();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e3 = new n();
            for (var t2 in this) "function" != typeof this[t2] && (e3[t2] = this[t2]);
            return e3;
          };
        }
        (n.prototype = e2("./object")).loadAsync = e2("./load"), n.support = e2("./support"), n.defaults = e2("./defaults"), n.version = "3.10.1", n.loadAsync = function(e3, t2) {
          return new n().loadAsync(e3, t2);
        }, n.external = e2("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e2, t, r) {
        "use strict";
        var u2 = e2("./utils"), i = e2("./external"), n = e2("./utf8"), s = e2("./zipEntries"), a3 = e2("./stream/Crc32Probe"), l = e2("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e3, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a3());
            r2.on("error", function(e4) {
              t2(e4);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e3();
            }).resume();
          });
        }
        t.exports = function(e3, o) {
          var h = this;
          return o = u2.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e3) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u2.prepareContent("the loaded zip file", e3, true, o.optimizedBinaryString, o.base64).then(function(e4) {
            var t2 = new s(o);
            return t2.load(e4), t2;
          }).then(function(e4) {
            var t2 = [i.Promise.resolve(e4)], r2 = e4.files;
            if (o.checkCRC32) for (var n2 = 0; n2 < r2.length; n2++) t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e4) {
            for (var t2 = e4.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a4 = u2.resolve(i2.fileNameStr);
              h.file(a4, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a4).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h.comment = t2.zipComment), h;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e2, t, r) {
        "use strict";
        var n = e2("../utils"), i = e2("../stream/GenericWorker");
        function s(e3, t2) {
          i.call(this, "Nodejs stream input adapter for " + e3), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e3) {
          var t2 = this;
          (this._stream = e3).pause(), e3.on("data", function(e4) {
            t2.push({ data: e4, meta: { percent: 0 } });
          }).on("error", function(e4) {
            t2.isPaused ? this.generatedError = e4 : t2.error(e4);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e2, t, r) {
        "use strict";
        var i = e2("readable-stream").Readable;
        function n(e3, t2, r2) {
          i.call(this, t2), this._helper = e3;
          var n2 = this;
          e3.on("data", function(e4, t3) {
            n2.push(e4) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e4) {
            n2.emit("error", e4);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e2("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e2, t, r) {
        "use strict";
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e3, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e3, t2);
          if ("number" == typeof e3) throw new Error('The "data" argument must not be a number');
          return new Buffer(e3, t2);
        }, allocBuffer: function(e3) {
          if (Buffer.alloc) return Buffer.alloc(e3);
          var t2 = new Buffer(e3);
          return t2.fill(0), t2;
        }, isBuffer: function(e3) {
          return Buffer.isBuffer(e3);
        }, isStream: function(e3) {
          return e3 && "function" == typeof e3.on && "function" == typeof e3.pause && "function" == typeof e3.resume;
        } };
      }, {}], 15: [function(e2, t, r) {
        "use strict";
        function s(e3, t2, r2) {
          var n2, i2 = u2.getTypeOf(t2), s2 = u2.extend(r2 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e3 = g(e3)), s2.createFolders && (n2 = _(e3)) && b3.call(this, n2, true);
          var a4 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a4), (t2 instanceof c2 && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c2 || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e3, t2) : u2.prepareContent(e3, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h2 = new d2(e3, o2, s2);
          this.files[e3] = h2;
        }
        var i = e2("./utf8"), u2 = e2("./utils"), l = e2("./stream/GenericWorker"), a3 = e2("./stream/StreamHelper"), f = e2("./defaults"), c2 = e2("./compressedObject"), d2 = e2("./zipObject"), o = e2("./generate"), p = e2("./nodejsUtils"), m = e2("./nodejs/NodejsStreamInputAdapter"), _ = function(e3) {
          "/" === e3.slice(-1) && (e3 = e3.substring(0, e3.length - 1));
          var t2 = e3.lastIndexOf("/");
          return 0 < t2 ? e3.substring(0, t2) : "";
        }, g = function(e3) {
          return "/" !== e3.slice(-1) && (e3 += "/"), e3;
        }, b3 = function(e3, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e3 = g(e3), this.files[e3] || s.call(this, e3, null, { dir: true, createFolders: t2 }), this.files[e3];
        };
        function h(e3) {
          return "[object RegExp]" === Object.prototype.toString.call(e3);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e3) {
          var t2, r2, n2;
          for (t2 in this.files) n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e3(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e3, t2) {
            r2(e3, t2) && n2.push(t2);
          }), n2;
        }, file: function(e3, t2, r2) {
          if (1 !== arguments.length) return e3 = this.root + e3, s.call(this, e3, t2, r2), this;
          if (h(e3)) {
            var n2 = e3;
            return this.filter(function(e4, t3) {
              return !t3.dir && n2.test(e4);
            });
          }
          var i2 = this.files[this.root + e3];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2) return this;
          if (h(r2)) return this.filter(function(e4, t3) {
            return t3.dir && r2.test(e4);
          });
          var e3 = this.root + r2, t2 = b3.call(this, e3), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e3 = this.files[r2];
          if (e3 || ("/" !== r2.slice(-1) && (r2 += "/"), e3 = this.files[r2]), e3 && !e3.dir) delete this.files[r2];
          else for (var t2 = this.filter(function(e4, t3) {
            return t3.name.slice(0, r2.length) === r2;
          }), n2 = 0; n2 < t2.length; n2++) delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e3) {
          var t2, r2 = {};
          try {
            if ((r2 = u2.extend(e3 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type) throw new Error("No output type specified.");
            u2.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e4) {
            (t2 = new l("error")).error(e4);
          }
          return new a3(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e3, t2) {
          return this.generateInternalStream(e3).accumulate(t2);
        }, generateNodeStream: function(e3, t2) {
          return (e3 = e3 || {}).type || (e3.type = "nodebuffer"), this.generateInternalStream(e3).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e2, t, r) {
        "use strict";
        t.exports = e2("stream");
      }, { stream: void 0 }], 17: [function(e2, t, r) {
        "use strict";
        var n = e2("./DataReader");
        function i(e3) {
          n.call(this, e3);
          for (var t2 = 0; t2 < this.data.length; t2++) e3[t2] = 255 & e3[t2];
        }
        e2("../utils").inherits(i, n), i.prototype.byteAt = function(e3) {
          return this.data[this.zero + e3];
        }, i.prototype.lastIndexOfSignature = function(e3) {
          for (var t2 = e3.charCodeAt(0), r2 = e3.charCodeAt(1), n2 = e3.charCodeAt(2), i2 = e3.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2) return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e3) {
          var t2 = e3.charCodeAt(0), r2 = e3.charCodeAt(1), n2 = e3.charCodeAt(2), i2 = e3.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3) return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e2, t, r) {
        "use strict";
        var n = e2("../utils");
        function i(e3) {
          this.data = e3, this.length = e3.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e3) {
          this.checkIndex(this.index + e3);
        }, checkIndex: function(e3) {
          if (this.length < this.zero + e3 || e3 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e3 + "). Corrupted zip ?");
        }, setIndex: function(e3) {
          this.checkIndex(e3), this.index = e3;
        }, skip: function(e3) {
          this.setIndex(this.index + e3);
        }, byteAt: function() {
        }, readInt: function(e3) {
          var t2, r2 = 0;
          for (this.checkOffset(e3), t2 = this.index + e3 - 1; t2 >= this.index; t2--) r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e3, r2;
        }, readString: function(e3) {
          return n.transformTo("string", this.readData(e3));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e3 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e3 >> 25 & 127), (e3 >> 21 & 15) - 1, e3 >> 16 & 31, e3 >> 11 & 31, e3 >> 5 & 63, (31 & e3) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e2, t, r) {
        "use strict";
        var n = e2("./Uint8ArrayReader");
        function i(e3) {
          n.call(this, e3);
        }
        e2("../utils").inherits(i, n), i.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e2, t, r) {
        "use strict";
        var n = e2("./DataReader");
        function i(e3) {
          n.call(this, e3);
        }
        e2("../utils").inherits(i, n), i.prototype.byteAt = function(e3) {
          return this.data.charCodeAt(this.zero + e3);
        }, i.prototype.lastIndexOfSignature = function(e3) {
          return this.data.lastIndexOf(e3) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e3) {
          return e3 === this.readData(4);
        }, i.prototype.readData = function(e3) {
          this.checkOffset(e3);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e2, t, r) {
        "use strict";
        var n = e2("./ArrayReader");
        function i(e3) {
          n.call(this, e3);
        }
        e2("../utils").inherits(i, n), i.prototype.readData = function(e3) {
          if (this.checkOffset(e3), 0 === e3) return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e3);
          return this.index += e3, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e2, t, r) {
        "use strict";
        var n = e2("../utils"), i = e2("../support"), s = e2("./ArrayReader"), a3 = e2("./StringReader"), o = e2("./NodeBufferReader"), h = e2("./Uint8ArrayReader");
        t.exports = function(e3) {
          var t2 = n.getTypeOf(e3);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e3) : i.uint8array ? new h(n.transformTo("uint8array", e3)) : new s(n.transformTo("array", e3)) : new a3(e3);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e2, t, r) {
        "use strict";
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e2, t, r) {
        "use strict";
        var n = e2("./GenericWorker"), i = e2("../utils");
        function s(e3) {
          n.call(this, "ConvertWorker to " + e3), this.destType = e3;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e3) {
          this.push({ data: i.transformTo(this.destType, e3.data), meta: e3.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e2, t, r) {
        "use strict";
        var n = e2("./GenericWorker"), i = e2("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e2("../utils").inherits(s, n), s.prototype.processChunk = function(e3) {
          this.streamInfo.crc32 = i(e3.data, this.streamInfo.crc32 || 0), this.push(e3);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e2, t, r) {
        "use strict";
        var n = e2("../utils"), i = e2("./GenericWorker");
        function s(e3) {
          i.call(this, "DataLengthProbe for " + e3), this.propName = e3, this.withStreamInfo(e3, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e3) {
          if (e3) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e3.data.length;
          }
          i.prototype.processChunk.call(this, e3);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e2, t, r) {
        "use strict";
        var n = e2("../utils"), i = e2("./GenericWorker");
        function s(e3) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e3.then(function(e4) {
            t2.dataIsReady = true, t2.data = e4, t2.max = e4 && e4.length || 0, t2.type = n.getTypeOf(e4), t2.isPaused || t2._tickAndRepeat();
          }, function(e4) {
            t2.error(e4);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return false;
          var e3 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              e3 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e3 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e3 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e3, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e2, t, r) {
        "use strict";
        function n(e3) {
          this.name = e3 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e3) {
          this.emit("data", e3);
        }, end: function() {
          if (this.isFinished) return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e3) {
            this.emit("error", e3);
          }
          return true;
        }, error: function(e3) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e3 : (this.isFinished = true, this.emit("error", e3), this.previous && this.previous.error(e3), this.cleanUp()), true);
        }, on: function(e3, t2) {
          return this._listeners[e3].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e3, t2) {
          if (this._listeners[e3]) for (var r2 = 0; r2 < this._listeners[e3].length; r2++) this._listeners[e3][r2].call(this, t2);
        }, pipe: function(e3) {
          return e3.registerPrevious(this);
        }, registerPrevious: function(e3) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e3.streamInfo, this.mergeStreamInfo(), this.previous = e3;
          var t2 = this;
          return e3.on("data", function(e4) {
            t2.processChunk(e4);
          }), e3.on("end", function() {
            t2.end();
          }), e3.on("error", function(e4) {
            t2.error(e4);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return false;
          var e3 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e3 = true), this.previous && this.previous.resume(), !e3;
        }, flush: function() {
        }, processChunk: function(e3) {
          this.push(e3);
        }, withStreamInfo: function(e3, t2) {
          return this.extraStreamInfo[e3] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e3 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e3) && (this.streamInfo[e3] = this.extraStreamInfo[e3]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e3 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e3 : e3;
        } }, t.exports = n;
      }, {}], 29: [function(e2, t, r) {
        "use strict";
        var h = e2("../utils"), i = e2("./ConvertWorker"), s = e2("./GenericWorker"), u2 = e2("../base64"), n = e2("../support"), a3 = e2("../external"), o = null;
        if (n.nodestream) try {
          o = e2("../nodejs/NodejsStreamOutputAdapter");
        } catch (e3) {
        }
        function l(e3, o2) {
          return new a3.Promise(function(t2, r2) {
            var n2 = [], i2 = e3._internalType, s2 = e3._outputType, a4 = e3._mimeType;
            e3.on("data", function(e4, t3) {
              n2.push(e4), o2 && o2(t3);
            }).on("error", function(e4) {
              n2 = [], r2(e4);
            }).on("end", function() {
              try {
                var e4 = function(e5, t3, r3) {
                  switch (e5) {
                    case "blob":
                      return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u2.encode(t3);
                    default:
                      return h.transformTo(e5, t3);
                  }
                }(s2, function(e5, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++) s3 += t3[r3].length;
                  switch (e5) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++) i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e5 + "'");
                  }
                }(i2, n2), a4);
                t2(e4);
              } catch (e5) {
                r2(e5);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e3, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e3.pipe(new i(n2)), e3.lock();
          } catch (e4) {
            this._worker = new s("error"), this._worker.error(e4);
          }
        }
        f.prototype = { accumulate: function(e3) {
          return l(this, e3);
        }, on: function(e3, t2) {
          var r2 = this;
          return "data" === e3 ? this._worker.on(e3, function(e4) {
            t2.call(r2, e4.data, e4.meta);
          }) : this._worker.on(e3, function() {
            h.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e3) {
          if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e3);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e2, t, r) {
        "use strict";
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e3) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e4) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e2("readable-stream").Readable;
        } catch (e3) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e2, t, s) {
        "use strict";
        for (var o = e2("./utils"), h = e2("./support"), r = e2("./nodejsUtils"), n = e2("./stream/GenericWorker"), u2 = new Array(256), i = 0; i < 256; i++) u2[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u2[254] = u2[254] = 1;
        function a3() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e3) {
          return h.nodebuffer ? r.newBufferFrom(e3, "utf-8") : function(e4) {
            var t2, r2, n2, i2, s2, a4 = e4.length, o2 = 0;
            for (i2 = 0; i2 < a4; i2++) 55296 == (64512 & (r2 = e4.charCodeAt(i2))) && i2 + 1 < a4 && 56320 == (64512 & (n2 = e4.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++) 55296 == (64512 & (r2 = e4.charCodeAt(i2))) && i2 + 1 < a4 && 56320 == (64512 & (n2 = e4.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          }(e3);
        }, s.utf8decode = function(e3) {
          return h.nodebuffer ? o.transformTo("nodebuffer", e3).toString("utf-8") : function(e4) {
            var t2, r2, n2, i2, s2 = e4.length, a4 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; ) if ((n2 = e4[t2++]) < 128) a4[r2++] = n2;
            else if (4 < (i2 = u2[n2])) a4[r2++] = 65533, t2 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; ) n2 = n2 << 6 | 63 & e4[t2++], i2--;
              1 < i2 ? a4[r2++] = 65533 : n2 < 65536 ? a4[r2++] = n2 : (n2 -= 65536, a4[r2++] = 55296 | n2 >> 10 & 1023, a4[r2++] = 56320 | 1023 & n2);
            }
            return a4.length !== r2 && (a4.subarray ? a4 = a4.subarray(0, r2) : a4.length = r2), o.applyFromCharCode(a4);
          }(e3 = o.transformTo(h.uint8array ? "uint8array" : "array", e3));
        }, o.inherits(a3, n), a3.prototype.processChunk = function(e3) {
          var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e3.data);
          if (this.leftOver && this.leftOver.length) {
            if (h.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = function(e4, t3) {
            var r3;
            for ((t3 = t3 || e4.length) > e4.length && (t3 = e4.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e4[r3]); ) r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u2[e4[r3]] > t3 ? r3 : t3;
          }(t2), i2 = t2;
          n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e3.meta });
        }, a3.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a3, o.inherits(l, n), l.prototype.processChunk = function(e3) {
          this.push({ data: s.utf8encode(e3.data), meta: e3.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e2, t, a3) {
        "use strict";
        var o = e2("./support"), h = e2("./base64"), r = e2("./nodejsUtils"), u2 = e2("./external");
        function n(e3) {
          return e3;
        }
        function l(e3, t2) {
          for (var r2 = 0; r2 < e3.length; ++r2) t2[r2] = 255 & e3.charCodeAt(r2);
          return t2;
        }
        e2("setimmediate"), a3.newBlob = function(t2, r2) {
          a3.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e3) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e4) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e3, t2, r2) {
          var n2 = [], i2 = 0, s2 = e3.length;
          if (s2 <= r2) return String.fromCharCode.apply(null, e3);
          for (; i2 < s2; ) "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e3.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e3.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e3) {
          for (var t2 = "", r2 = 0; r2 < e3.length; r2++) t2 += String.fromCharCode(e3[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e3) {
            return false;
          }
        }(), nodebuffer: function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e3) {
            return false;
          }
        }() } };
        function s(e3) {
          var t2 = 65536, r2 = a3.getTypeOf(e3), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2) for (; 1 < t2; ) try {
            return i.stringifyByChunk(e3, r2, t2);
          } catch (e4) {
            t2 = Math.floor(t2 / 2);
          }
          return i.stringifyByChar(e3);
        }
        function f(e3, t2) {
          for (var r2 = 0; r2 < e3.length; r2++) t2[r2] = e3[r2];
          return t2;
        }
        a3.applyFromCharCode = s;
        var c2 = {};
        c2.string = { string: n, array: function(e3) {
          return l(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c2.string.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return l(e3, new Uint8Array(e3.length));
        }, nodebuffer: function(e3) {
          return l(e3, r.allocBuffer(e3.length));
        } }, c2.array = { string: s, array: n, arraybuffer: function(e3) {
          return new Uint8Array(e3).buffer;
        }, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r.newBufferFrom(e3);
        } }, c2.arraybuffer = { string: function(e3) {
          return s(new Uint8Array(e3));
        }, array: function(e3) {
          return f(new Uint8Array(e3), new Array(e3.byteLength));
        }, arraybuffer: n, uint8array: function(e3) {
          return new Uint8Array(e3);
        }, nodebuffer: function(e3) {
          return r.newBufferFrom(new Uint8Array(e3));
        } }, c2.uint8array = { string: s, array: function(e3) {
          return f(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return e3.buffer;
        }, uint8array: n, nodebuffer: function(e3) {
          return r.newBufferFrom(e3);
        } }, c2.nodebuffer = { string: s, array: function(e3) {
          return f(e3, new Array(e3.length));
        }, arraybuffer: function(e3) {
          return c2.nodebuffer.uint8array(e3).buffer;
        }, uint8array: function(e3) {
          return f(e3, new Uint8Array(e3.length));
        }, nodebuffer: n }, a3.transformTo = function(e3, t2) {
          if (t2 = t2 || "", !e3) return t2;
          a3.checkSupport(e3);
          var r2 = a3.getTypeOf(t2);
          return c2[r2][e3](t2);
        }, a3.resolve = function(e3) {
          for (var t2 = e3.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a3.getTypeOf = function(e3) {
          return "string" == typeof e3 ? "string" : "[object Array]" === Object.prototype.toString.call(e3) ? "array" : o.nodebuffer && r.isBuffer(e3) ? "nodebuffer" : o.uint8array && e3 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e3 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a3.checkSupport = function(e3) {
          if (!o[e3.toLowerCase()]) throw new Error(e3 + " is not supported by this platform");
        }, a3.MAX_VALUE_16BITS = 65535, a3.MAX_VALUE_32BITS = -1, a3.pretty = function(e3) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e3 || "").length; r2++) n2 += "\\x" + ((t2 = e3.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a3.delay = function(e3, t2, r2) {
          setImmediate(function() {
            e3.apply(r2 || null, t2 || []);
          });
        }, a3.inherits = function(e3, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e3.prototype = new r2();
        }, a3.extend = function() {
          var e3, t2, r2 = {};
          for (e3 = 0; e3 < arguments.length; e3++) for (t2 in arguments[e3]) Object.prototype.hasOwnProperty.call(arguments[e3], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e3][t2]);
          return r2;
        }, a3.prepareContent = function(r2, e3, n2, i2, s2) {
          return u2.Promise.resolve(e3).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u2.Promise(function(t2, r3) {
              var e4 = new FileReader();
              e4.onload = function(e5) {
                t2(e5.target.result);
              }, e4.onerror = function(e5) {
                r3(e5.target.error);
              }, e4.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e4) {
            var t2 = a3.getTypeOf(e4);
            return t2 ? ("arraybuffer" === t2 ? e4 = a3.transformTo("uint8array", e4) : "string" === t2 && (s2 ? e4 = h.decode(e4) : n2 && true !== i2 && (e4 = function(e5) {
              return l(e5, o.uint8array ? new Uint8Array(e5.length) : new Array(e5.length));
            }(e4))), e4) : u2.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e2, t, r) {
        "use strict";
        var n = e2("./reader/readerFor"), i = e2("./utils"), s = e2("./signature"), a3 = e2("./zipEntry"), o = e2("./support");
        function h(e3) {
          this.files = [], this.loadOptions = e3;
        }
        h.prototype = { checkSignature: function(e3) {
          if (!this.reader.readAndCheckSignature(e3)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e3) + ")");
          }
        }, isSignature: function(e3, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e3);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e3 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e3);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e3, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e3 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e3] = { id: e3, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e3, t2;
          for (e3 = 0; e3 < this.files.length; e3++) t2 = this.files[e3], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e3;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (e3 = new a3({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e3);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e3 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e3 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e3);
          var t2 = e3;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e3 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e3), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2) this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e3) {
          this.reader = n(e3);
        }, load: function(e3) {
          this.prepareReader(e3), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e2, t, r) {
        "use strict";
        var n = e2("./reader/readerFor"), s = e2("./utils"), i = e2("./compressedObject"), a3 = e2("./crc32"), o = e2("./utf8"), h = e2("./compressions"), u2 = e2("./support");
        function l(e3, t2) {
          this.options = e3, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e3) {
          var t2, r2;
          if (e3.skip(22), this.fileNameLength = e3.readInt(2), r2 = e3.readInt(2), this.fileName = e3.readData(this.fileNameLength), e3.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = function(e4) {
            for (var t3 in h) if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e4) return h[t3];
            return null;
          }(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e3.readData(this.compressedSize));
        }, readCentralPart: function(e3) {
          this.versionMadeBy = e3.readInt(2), e3.skip(2), this.bitFlag = e3.readInt(2), this.compressionMethod = e3.readString(2), this.date = e3.readDate(), this.crc32 = e3.readInt(4), this.compressedSize = e3.readInt(4), this.uncompressedSize = e3.readInt(4);
          var t2 = e3.readInt(2);
          if (this.extraFieldsLength = e3.readInt(2), this.fileCommentLength = e3.readInt(2), this.diskNumberStart = e3.readInt(2), this.internalFileAttributes = e3.readInt(2), this.externalFileAttributes = e3.readInt(4), this.localHeaderOffset = e3.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          e3.skip(t2), this.readExtraFields(e3), this.parseZIP64ExtraField(e3), this.fileComment = e3.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e3 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e3 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e3 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e3.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e3.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e3.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e3.readInt(4));
          }
        }, readExtraFields: function(e3) {
          var t2, r2, n2, i2 = e3.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e3.index + 4 < i2; ) t2 = e3.readInt(2), r2 = e3.readInt(2), n2 = e3.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e3.setIndex(i2);
        }, handleUTF8: function() {
          var e3 = u2.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2) this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e3, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2) this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e3, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e3 = this.extraFields[28789];
          if (e3) {
            var t2 = n(e3.value);
            return 1 !== t2.readInt(1) ? null : a3(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e3.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e3 = this.extraFields[25461];
          if (e3) {
            var t2 = n(e3.value);
            return 1 !== t2.readInt(1) ? null : a3(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e3.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e2, t, r) {
        "use strict";
        function n(e3, t2, r2) {
          this.name = e3, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e2("./stream/StreamHelper"), i = e2("./stream/DataWorker"), a3 = e2("./utf8"), o = e2("./compressedObject"), h = e2("./stream/GenericWorker");
        n.prototype = { internalStream: function(e3) {
          var t2 = null, r2 = "string";
          try {
            if (!e3) throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e3.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a3.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a3.Utf8DecodeWorker()));
          } catch (e4) {
            (t2 = new h("error")).error(e4);
          }
          return new s(t2, r2, "");
        }, async: function(e3, t2) {
          return this.internalStream(e3).accumulate(t2);
        }, nodeStream: function(e3, t2) {
          return this.internalStream(e3 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e3, t2) {
          if (this._data instanceof o && this._data.compression.magic === e3.magic) return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a3.Utf8EncodeWorker())), o.createWorkerFrom(r2, e3, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
        } };
        for (var u2 = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u2.length; f++) n.prototype[u2[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e2, l, t) {
        (function(t2) {
          "use strict";
          var r, n, e3 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e3) {
            var i = 0, s = new e3(u2), a3 = t2.document.createTextNode("");
            s.observe(a3, { characterData: true }), r = function() {
              a3.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel) r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e4 = t2.document.createElement("script");
            e4.onreadystatechange = function() {
              u2(), e4.onreadystatechange = null, e4.parentNode.removeChild(e4), e4 = null;
            }, t2.document.documentElement.appendChild(e4);
          } : function() {
            setTimeout(u2, 0);
          };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u2, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h = [];
          function u2() {
            var e4, t3;
            n = true;
            for (var r2 = h.length; r2; ) {
              for (t3 = h, h = [], e4 = -1; ++e4 < r2; ) t3[e4]();
              r2 = h.length;
            }
            n = false;
          }
          l.exports = function(e4) {
            1 !== h.push(e4) || n || r();
          };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e2, t, r) {
        "use strict";
        var i = e2("immediate");
        function u2() {
        }
        var l = {}, s = ["REJECTED"], a3 = ["FULFILLED"], n = ["PENDING"];
        function o(e3) {
          if ("function" != typeof e3) throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e3 !== u2 && d2(this, e3);
        }
        function h(e3, t2, r2) {
          this.promise = e3, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e3;
            try {
              e3 = r2(n2);
            } catch (e4) {
              return l.reject(t2, e4);
            }
            e3 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e3);
          });
        }
        function c2(e3) {
          var t2 = e3 && e3.then;
          if (e3 && ("object" == typeof e3 || "function" == typeof e3) && "function" == typeof t2) return function() {
            t2.apply(e3, arguments);
          };
        }
        function d2(t2, e3) {
          var r2 = false;
          function n2(e4) {
            r2 || (r2 = true, l.reject(t2, e4));
          }
          function i2(e4) {
            r2 || (r2 = true, l.resolve(t2, e4));
          }
          var s2 = p(function() {
            e3(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e3, t2) {
          var r2 = {};
          try {
            r2.value = e3(t2), r2.status = "success";
          } catch (e4) {
            r2.status = "error", r2.value = e4;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2) return this;
          var r2 = this.constructor;
          return this.then(function(e3) {
            return r2.resolve(t2()).then(function() {
              return e3;
            });
          }, function(e3) {
            return r2.resolve(t2()).then(function() {
              throw e3;
            });
          });
        }, o.prototype.catch = function(e3) {
          return this.then(null, e3);
        }, o.prototype.then = function(e3, t2) {
          if ("function" != typeof e3 && this.state === a3 || "function" != typeof t2 && this.state === s) return this;
          var r2 = new this.constructor(u2);
          this.state !== n ? f(r2, this.state === a3 ? e3 : t2, this.outcome) : this.queue.push(new h(r2, e3, t2));
          return r2;
        }, h.prototype.callFulfilled = function(e3) {
          l.resolve(this.promise, e3);
        }, h.prototype.otherCallFulfilled = function(e3) {
          f(this.promise, this.onFulfilled, e3);
        }, h.prototype.callRejected = function(e3) {
          l.reject(this.promise, e3);
        }, h.prototype.otherCallRejected = function(e3) {
          f(this.promise, this.onRejected, e3);
        }, l.resolve = function(e3, t2) {
          var r2 = p(c2, t2);
          if ("error" === r2.status) return l.reject(e3, r2.value);
          var n2 = r2.value;
          if (n2) d2(e3, n2);
          else {
            e3.state = a3, e3.outcome = t2;
            for (var i2 = -1, s2 = e3.queue.length; ++i2 < s2; ) e3.queue[i2].callFulfilled(t2);
          }
          return e3;
        }, l.reject = function(e3, t2) {
          e3.state = s, e3.outcome = t2;
          for (var r2 = -1, n2 = e3.queue.length; ++r2 < n2; ) e3.queue[r2].callRejected(t2);
          return e3;
        }, o.resolve = function(e3) {
          if (e3 instanceof this) return e3;
          return l.resolve(new this(u2), e3);
        }, o.reject = function(e3) {
          var t2 = new this(u2);
          return l.reject(t2, e3);
        }, o.all = function(e3) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3)) return this.reject(new TypeError("must be an array"));
          var n2 = e3.length, i2 = false;
          if (!n2) return this.resolve([]);
          var s2 = new Array(n2), a4 = 0, t2 = -1, o2 = new this(u2);
          for (; ++t2 < n2; ) h2(e3[t2], t2);
          return o2;
          function h2(e4, t3) {
            r2.resolve(e4).then(function(e5) {
              s2[t3] = e5, ++a4 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e5) {
              i2 || (i2 = true, l.reject(o2, e5));
            });
          }
        }, o.race = function(e3) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e3)) return this.reject(new TypeError("must be an array"));
          var r2 = e3.length, n2 = false;
          if (!r2) return this.resolve([]);
          var i2 = -1, s2 = new this(u2);
          for (; ++i2 < r2; ) a4 = e3[i2], t2.resolve(a4).then(function(e4) {
            n2 || (n2 = true, l.resolve(s2, e4));
          }, function(e4) {
            n2 || (n2 = true, l.reject(s2, e4));
          });
          var a4;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e2, t, r) {
        "use strict";
        var n = {};
        (0, e2("./lib/utils/common").assign)(n, e2("./lib/deflate"), e2("./lib/inflate"), e2("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e2, t, r) {
        "use strict";
        var a3 = e2("./zlib/deflate"), o = e2("./utils/common"), h = e2("./utils/strings"), i = e2("./zlib/messages"), s = e2("./zlib/zstream"), u2 = Object.prototype.toString, l = 0, f = -1, c2 = 0, d2 = 8;
        function p(e3) {
          if (!(this instanceof p)) return new p(e3);
          this.options = o.assign({ level: f, method: d2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e3 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a3.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l) throw new Error(i[r2]);
          if (t2.header && a3.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u2.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a3.deflateSetDictionary(this.strm, n2)) !== l) throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e3, t2) {
          var r2 = new p(t2);
          if (r2.push(e3, true), r2.err) throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e3, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended) return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e3 ? i2.input = h.string2buf(e3) : "[object ArrayBuffer]" === u2.call(e3) ? i2.input = new Uint8Array(e3) : i2.input = e3, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a3.deflate(i2, n2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a3.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, p.prototype.onEnd = function(e3) {
          e3 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e3, t2) {
          return (t2 = t2 || {}).raw = true, n(e3, t2);
        }, r.gzip = function(e3, t2) {
          return (t2 = t2 || {}).gzip = true, n(e3, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e2, t, r) {
        "use strict";
        var c2 = e2("./zlib/inflate"), d2 = e2("./utils/common"), p = e2("./utils/strings"), m = e2("./zlib/constants"), n = e2("./zlib/messages"), i = e2("./zlib/zstream"), s = e2("./zlib/gzheader"), _ = Object.prototype.toString;
        function a3(e3) {
          if (!(this instanceof a3)) return new a3(e3);
          this.options = d2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e3 && e3.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c2.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK) throw new Error(n[r2]);
          this.header = new s(), c2.inflateGetHeader(this.strm, this.header);
        }
        function o(e3, t2) {
          var r2 = new a3(t2);
          if (r2.push(e3, true), r2.err) throw r2.msg || n[r2.err];
          return r2.result;
        }
        a3.prototype.push = function(e3, t2) {
          var r2, n2, i2, s2, a4, o2, h = this.strm, u2 = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended) return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e3 ? h.input = p.binstring2buf(e3) : "[object ArrayBuffer]" === _.call(e3) ? h.input = new Uint8Array(e3) : h.input = e3, h.next_in = 0, h.avail_in = h.input.length;
          do {
            if (0 === h.avail_out && (h.output = new d2.Buf8(u2), h.next_out = 0, h.avail_out = u2), (r2 = c2.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c2.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);
            h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a4 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u2 - s2, s2 && d2.arraySet(h.output, h.output, i2, s2, 0), this.onData(a4)) : this.onData(d2.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
          } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c2.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
        }, a3.prototype.onData = function(e3) {
          this.chunks.push(e3);
        }, a3.prototype.onEnd = function(e3) {
          e3 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d2.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
        }, r.Inflate = a3, r.inflate = o, r.inflateRaw = function(e3, t2) {
          return (t2 = t2 || {}).raw = true, o(e3, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e2, t, r) {
        "use strict";
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e3) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2) r2.hasOwnProperty(n2) && (e3[n2] = r2[n2]);
            }
          }
          return e3;
        }, r.shrinkBuf = function(e3, t2) {
          return e3.length === t2 ? e3 : e3.subarray ? e3.subarray(0, t2) : (e3.length = t2, e3);
        };
        var i = { arraySet: function(e3, t2, r2, n2, i2) {
          if (t2.subarray && e3.subarray) e3.set(t2.subarray(r2, r2 + n2), i2);
          else for (var s2 = 0; s2 < n2; s2++) e3[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e3) {
          var t2, r2, n2, i2, s2, a3;
          for (t2 = n2 = 0, r2 = e3.length; t2 < r2; t2++) n2 += e3[t2].length;
          for (a3 = new Uint8Array(n2), t2 = i2 = 0, r2 = e3.length; t2 < r2; t2++) s2 = e3[t2], a3.set(s2, i2), i2 += s2.length;
          return a3;
        } }, s = { arraySet: function(e3, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++) e3[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e3) {
          return [].concat.apply([], e3);
        } };
        r.setTyped = function(e3) {
          e3 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e2, t, r) {
        "use strict";
        var h = e2("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e3) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e3) {
          s = false;
        }
        for (var u2 = new h.Buf8(256), n = 0; n < 256; n++) u2[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e3, t2) {
          if (t2 < 65537 && (e3.subarray && s || !e3.subarray && i)) return String.fromCharCode.apply(null, h.shrinkBuf(e3, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++) r2 += String.fromCharCode(e3[n2]);
          return r2;
        }
        u2[254] = u2[254] = 1, r.string2buf = function(e3) {
          var t2, r2, n2, i2, s2, a3 = e3.length, o = 0;
          for (i2 = 0; i2 < a3; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a3 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a3 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e3) {
          return l(e3, e3.length);
        }, r.binstring2buf = function(e3) {
          for (var t2 = new h.Buf8(e3.length), r2 = 0, n2 = t2.length; r2 < n2; r2++) t2[r2] = e3.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e3, t2) {
          var r2, n2, i2, s2, a3 = t2 || e3.length, o = new Array(2 * a3);
          for (r2 = n2 = 0; r2 < a3; ) if ((i2 = e3[r2++]) < 128) o[n2++] = i2;
          else if (4 < (s2 = u2[i2])) o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a3; ) i2 = i2 << 6 | 63 & e3[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
          return l(o, n2);
        }, r.utf8border = function(e3, t2) {
          var r2;
          for ((t2 = t2 || e3.length) > e3.length && (t2 = e3.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e3[r2]); ) r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u2[e3[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e2, t, r) {
        "use strict";
        t.exports = function(e3, t2, r2, n) {
          for (var i = 65535 & e3 | 0, s = e3 >>> 16 & 65535 | 0, a3 = 0; 0 !== r2; ) {
            for (r2 -= a3 = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a3; ) ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e2, t, r) {
        "use strict";
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e2, t, r) {
        "use strict";
        var o = function() {
          for (var e3, t2 = [], r2 = 0; r2 < 256; r2++) {
            e3 = r2;
            for (var n = 0; n < 8; n++) e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
            t2[r2] = e3;
          }
          return t2;
        }();
        t.exports = function(e3, t2, r2, n) {
          var i = o, s = n + r2;
          e3 ^= -1;
          for (var a3 = n; a3 < s; a3++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t2[a3])];
          return -1 ^ e3;
        };
      }, {}], 46: [function(e2, t, r) {
        "use strict";
        var h, c2 = e2("../utils/common"), u2 = e2("./trees"), d2 = e2("./adler32"), p = e2("./crc32"), n = e2("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b3 = 4, i = 2, v2 = 8, y = 9, s = 286, a3 = 30, o = 19, w2 = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C2 = 42, E2 = 113, A2 = 1, I = 2, O = 3, B2 = 4;
        function R(e3, t2) {
          return e3.msg = n[t2], t2;
        }
        function T(e3) {
          return (e3 << 1) - (4 < e3 ? 9 : 0);
        }
        function D2(e3) {
          for (var t2 = e3.length; 0 <= --t2; ) e3[t2] = 0;
        }
        function F2(e3) {
          var t2 = e3.state, r2 = t2.pending;
          r2 > e3.avail_out && (r2 = e3.avail_out), 0 !== r2 && (c2.arraySet(e3.output, t2.pending_buf, t2.pending_out, r2, e3.next_out), e3.next_out += r2, t2.pending_out += r2, e3.total_out += r2, e3.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e3, t2) {
          u2._tr_flush_block(e3, 0 <= e3.block_start ? e3.block_start : -1, e3.strstart - e3.block_start, t2), e3.block_start = e3.strstart, F2(e3.strm);
        }
        function U(e3, t2) {
          e3.pending_buf[e3.pending++] = t2;
        }
        function P(e3, t2) {
          e3.pending_buf[e3.pending++] = t2 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t2;
        }
        function L2(e3, t2) {
          var r2, n2, i2 = e3.max_chain_length, s2 = e3.strstart, a4 = e3.prev_length, o2 = e3.nice_match, h2 = e3.strstart > e3.w_size - z ? e3.strstart - (e3.w_size - z) : 0, u3 = e3.window, l2 = e3.w_mask, f2 = e3.prev, c3 = e3.strstart + S, d3 = u3[s2 + a4 - 1], p2 = u3[s2 + a4];
          e3.prev_length >= e3.good_match && (i2 >>= 2), o2 > e3.lookahead && (o2 = e3.lookahead);
          do {
            if (u3[(r2 = t2) + a4] === p2 && u3[r2 + a4 - 1] === d3 && u3[r2] === u3[s2] && u3[++r2] === u3[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u3[++s2] === u3[++r2] && u3[++s2] === u3[++r2] && u3[++s2] === u3[++r2] && u3[++s2] === u3[++r2] && u3[++s2] === u3[++r2] && u3[++s2] === u3[++r2] && u3[++s2] === u3[++r2] && u3[++s2] === u3[++r2] && s2 < c3);
              if (n2 = S - (c3 - s2), s2 = c3 - S, a4 < n2) {
                if (e3.match_start = t2, o2 <= (a4 = n2)) break;
                d3 = u3[s2 + a4 - 1], p2 = u3[s2 + a4];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
          return a4 <= e3.lookahead ? a4 : e3.lookahead;
        }
        function j(e3) {
          var t2, r2, n2, i2, s2, a4, o2, h2, u3, l2, f2 = e3.w_size;
          do {
            if (i2 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= f2 + (f2 - z)) {
              for (c2.arraySet(e3.window, e3.window, f2, f2, 0), e3.match_start -= f2, e3.strstart -= f2, e3.block_start -= f2, t2 = r2 = e3.hash_size; n2 = e3.head[--t2], e3.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
              for (t2 = r2 = f2; n2 = e3.prev[--t2], e3.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
              i2 += f2;
            }
            if (0 === e3.strm.avail_in) break;
            if (a4 = e3.strm, o2 = e3.window, h2 = e3.strstart + e3.lookahead, u3 = i2, l2 = void 0, l2 = a4.avail_in, u3 < l2 && (l2 = u3), r2 = 0 === l2 ? 0 : (a4.avail_in -= l2, c2.arraySet(o2, a4.input, a4.next_in, l2, h2), 1 === a4.state.wrap ? a4.adler = d2(a4.adler, o2, l2, h2) : 2 === a4.state.wrap && (a4.adler = p(a4.adler, o2, l2, h2)), a4.next_in += l2, a4.total_in += l2, l2), e3.lookahead += r2, e3.lookahead + e3.insert >= x) for (s2 = e3.strstart - e3.insert, e3.ins_h = e3.window[s2], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s2 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s2 + x - 1]) & e3.hash_mask, e3.prev[s2 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = s2, s2++, e3.insert--, !(e3.lookahead + e3.insert < x)); ) ;
          } while (e3.lookahead < z && 0 !== e3.strm.avail_in);
        }
        function Z(e3, t2) {
          for (var r2, n2; ; ) {
            if (e3.lookahead < z) {
              if (j(e3), e3.lookahead < z && t2 === l) return A2;
              if (0 === e3.lookahead) break;
            }
            if (r2 = 0, e3.lookahead >= x && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x - 1]) & e3.hash_mask, r2 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r2 && e3.strstart - r2 <= e3.w_size - z && (e3.match_length = L2(e3, r2)), e3.match_length >= x) if (n2 = u2._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - x), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= x) {
              for (e3.match_length--; e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x - 1]) & e3.hash_mask, r2 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart, 0 != --e3.match_length; ) ;
              e3.strstart++;
            } else e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
            else n2 = u2._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
            if (n2 && (N(e3, false), 0 === e3.strm.avail_out)) return A2;
          }
          return e3.insert = e3.strstart < x - 1 ? e3.strstart : x - 1, t2 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B2) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A2 : I;
        }
        function W2(e3, t2) {
          for (var r2, n2, i2; ; ) {
            if (e3.lookahead < z) {
              if (j(e3), e3.lookahead < z && t2 === l) return A2;
              if (0 === e3.lookahead) break;
            }
            if (r2 = 0, e3.lookahead >= x && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x - 1]) & e3.hash_mask, r2 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = x - 1, 0 !== r2 && e3.prev_length < e3.max_lazy_match && e3.strstart - r2 <= e3.w_size - z && (e3.match_length = L2(e3, r2), e3.match_length <= 5 && (1 === e3.strategy || e3.match_length === x && 4096 < e3.strstart - e3.match_start) && (e3.match_length = x - 1)), e3.prev_length >= x && e3.match_length <= e3.prev_length) {
              for (i2 = e3.strstart + e3.lookahead - x, n2 = u2._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - x), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2; ++e3.strstart <= i2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + x - 1]) & e3.hash_mask, r2 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 != --e3.prev_length; ) ;
              if (e3.match_available = 0, e3.match_length = x - 1, e3.strstart++, n2 && (N(e3, false), 0 === e3.strm.avail_out)) return A2;
            } else if (e3.match_available) {
              if ((n2 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && N(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out) return A2;
            } else e3.match_available = 1, e3.strstart++, e3.lookahead--;
          }
          return e3.match_available && (n2 = u2._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < x - 1 ? e3.strstart : x - 1, t2 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B2) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A2 : I;
        }
        function M(e3, t2, r2, n2, i2) {
          this.good_length = e3, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w2), this.dyn_dtree = new c2.Buf16(2 * (2 * a3 + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k + 1), this.heap = new c2.Buf16(2 * s + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G2(e3) {
          var t2;
          return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = i, (t2 = e3.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C2 : E2, e3.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u2._tr_init(t2), m) : R(e3, _);
        }
        function K(e3) {
          var t2 = G2(e3);
          return t2 === m && function(e4) {
            e4.window_size = 2 * e4.w_size, D2(e4.head), e4.max_lazy_match = h[e4.level].max_lazy, e4.good_match = h[e4.level].good_length, e4.nice_match = h[e4.level].nice_length, e4.max_chain_length = h[e4.level].max_chain, e4.strstart = 0, e4.block_start = 0, e4.lookahead = 0, e4.insert = 0, e4.match_length = e4.prev_length = x - 1, e4.match_available = 0, e4.ins_h = 0;
          }(e3.state), t2;
        }
        function Y(e3, t2, r2, n2, i2, s2) {
          if (!e3) return _;
          var a4 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a4 = 0, n2 = -n2) : 15 < n2 && (a4 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v2 || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b3 < s2) return R(e3, _);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e3.state = o2).strm = e3, o2.wrap = a4, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c2.Buf8(2 * o2.w_size), o2.head = new c2.Buf16(o2.hash_size), o2.prev = new c2.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c2.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e3);
        }
        h = [new M(0, 0, 0, 0, function(e3, t2) {
          var r2 = 65535;
          for (r2 > e3.pending_buf_size - 5 && (r2 = e3.pending_buf_size - 5); ; ) {
            if (e3.lookahead <= 1) {
              if (j(e3), 0 === e3.lookahead && t2 === l) return A2;
              if (0 === e3.lookahead) break;
            }
            e3.strstart += e3.lookahead, e3.lookahead = 0;
            var n2 = e3.block_start + r2;
            if ((0 === e3.strstart || e3.strstart >= n2) && (e3.lookahead = e3.strstart - n2, e3.strstart = n2, N(e3, false), 0 === e3.strm.avail_out)) return A2;
            if (e3.strstart - e3.block_start >= e3.w_size - z && (N(e3, false), 0 === e3.strm.avail_out)) return A2;
          }
          return e3.insert = 0, t2 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B2) : (e3.strstart > e3.block_start && (N(e3, false), e3.strm.avail_out), A2);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W2), new M(8, 16, 32, 32, W2), new M(8, 16, 128, 128, W2), new M(8, 32, 128, 256, W2), new M(32, 128, 258, 1024, W2), new M(32, 258, 258, 4096, W2)], r.deflateInit = function(e3, t2) {
          return Y(e3, t2, v2, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G2, r.deflateSetHeader = function(e3, t2) {
          return e3 && e3.state ? 2 !== e3.state.wrap ? _ : (e3.state.gzhead = t2, m) : _;
        }, r.deflate = function(e3, t2) {
          var r2, n2, i2, s2;
          if (!e3 || !e3.state || 5 < t2 || t2 < 0) return e3 ? R(e3, _) : _;
          if (n2 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || 666 === n2.status && t2 !== f) return R(e3, 0 === e3.avail_out ? -5 : _);
          if (n2.strm = e3, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C2) if (2 === n2.wrap) e3.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e3.adler = p(e3.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E2);
          else {
            var a4 = v2 + (n2.w_bits - 8 << 4) << 8;
            a4 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a4 |= 32), a4 += 31 - a4 % 31, n2.status = E2, P(n2, a4), 0 !== n2.strstart && (P(n2, e3.adler >>> 16), P(n2, 65535 & e3.adler)), e3.adler = 1;
          }
          if (69 === n2.status) if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p(e3.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e3), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p(e3.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else n2.status = 73;
          if (73 === n2.status) if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p(e3.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e3), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p(e3.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else n2.status = 91;
          if (91 === n2.status) if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p(e3.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e3), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e3.adler = p(e3.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F2(e3), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e3.adler), U(n2, e3.adler >> 8 & 255), e3.adler = 0, n2.status = E2)) : n2.status = E2), 0 !== n2.pending) {
            if (F2(e3), 0 === e3.avail_out) return n2.last_flush = -1, m;
          } else if (0 === e3.avail_in && T(t2) <= T(r2) && t2 !== f) return R(e3, -5);
          if (666 === n2.status && 0 !== e3.avail_in) return R(e3, -5);
          if (0 !== e3.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? function(e4, t3) {
              for (var r3; ; ) {
                if (0 === e4.lookahead && (j(e4), 0 === e4.lookahead)) {
                  if (t3 === l) return A2;
                  break;
                }
                if (e4.match_length = 0, r3 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r3 && (N(e4, false), 0 === e4.strm.avail_out)) return A2;
              }
              return e4.insert = 0, t3 === f ? (N(e4, true), 0 === e4.strm.avail_out ? O : B2) : e4.last_lit && (N(e4, false), 0 === e4.strm.avail_out) ? A2 : I;
            }(n2, t2) : 3 === n2.strategy ? function(e4, t3) {
              for (var r3, n3, i3, s3, a5 = e4.window; ; ) {
                if (e4.lookahead <= S) {
                  if (j(e4), e4.lookahead <= S && t3 === l) return A2;
                  if (0 === e4.lookahead) break;
                }
                if (e4.match_length = 0, e4.lookahead >= x && 0 < e4.strstart && (n3 = a5[i3 = e4.strstart - 1]) === a5[++i3] && n3 === a5[++i3] && n3 === a5[++i3]) {
                  s3 = e4.strstart + S;
                  do {
                  } while (n3 === a5[++i3] && n3 === a5[++i3] && n3 === a5[++i3] && n3 === a5[++i3] && n3 === a5[++i3] && n3 === a5[++i3] && n3 === a5[++i3] && n3 === a5[++i3] && i3 < s3);
                  e4.match_length = S - (s3 - i3), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
                }
                if (e4.match_length >= x ? (r3 = u2._tr_tally(e4, 1, e4.match_length - x), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r3 = u2._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r3 && (N(e4, false), 0 === e4.strm.avail_out)) return A2;
              }
              return e4.insert = 0, t3 === f ? (N(e4, true), 0 === e4.strm.avail_out ? O : B2) : e4.last_lit && (N(e4, false), 0 === e4.strm.avail_out) ? A2 : I;
            }(n2, t2) : h[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B2 || (n2.status = 666), o2 === A2 || o2 === O) return 0 === e3.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u2._tr_align(n2) : 5 !== t2 && (u2._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D2(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F2(e3), 0 === e3.avail_out)) return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e3.adler), U(n2, e3.adler >> 8 & 255), U(n2, e3.adler >> 16 & 255), U(n2, e3.adler >> 24 & 255), U(n2, 255 & e3.total_in), U(n2, e3.total_in >> 8 & 255), U(n2, e3.total_in >> 16 & 255), U(n2, e3.total_in >> 24 & 255)) : (P(n2, e3.adler >>> 16), P(n2, 65535 & e3.adler)), F2(e3), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e3) {
          var t2;
          return e3 && e3.state ? (t2 = e3.state.status) !== C2 && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E2 && 666 !== t2 ? R(e3, _) : (e3.state = null, t2 === E2 ? R(e3, -3) : m) : _;
        }, r.deflateSetDictionary = function(e3, t2) {
          var r2, n2, i2, s2, a4, o2, h2, u3, l2 = t2.length;
          if (!e3 || !e3.state) return _;
          if (2 === (s2 = (r2 = e3.state).wrap) || 1 === s2 && r2.status !== C2 || r2.lookahead) return _;
          for (1 === s2 && (e3.adler = d2(e3.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D2(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u3 = new c2.Buf8(r2.w_size), c2.arraySet(u3, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u3, l2 = r2.w_size), a4 = e3.avail_in, o2 = e3.next_in, h2 = e3.input, e3.avail_in = l2, e3.next_in = 0, e3.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; ) ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e3.next_in = o2, e3.input = h2, e3.avail_in = a4, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e2, t, r) {
        "use strict";
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e2, t, r) {
        "use strict";
        t.exports = function(e3, t2) {
          var r2, n, i, s, a3, o, h, u2, l, f, c2, d2, p, m, _, g, b3, v2, y, w2, k, x, S, z, C2;
          r2 = e3.state, n = e3.next_in, z = e3.input, i = n + (e3.avail_in - 5), s = e3.next_out, C2 = e3.output, a3 = s - (t2 - e3.avail_out), o = s + (e3.avail_out - 257), h = r2.dmax, u2 = r2.wsize, l = r2.whave, f = r2.wnext, c2 = r2.window, d2 = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b3 = (1 << r2.distbits) - 1;
          e: do {
            p < 15 && (d2 += z[n++] << p, p += 8, d2 += z[n++] << p, p += 8), v2 = m[d2 & g];
            t: for (; ; ) {
              if (d2 >>>= y = v2 >>> 24, p -= y, 0 === (y = v2 >>> 16 & 255)) C2[s++] = 65535 & v2;
              else {
                if (!(16 & y)) {
                  if (0 == (64 & y)) {
                    v2 = m[(65535 & v2) + (d2 & (1 << y) - 1)];
                    continue t;
                  }
                  if (32 & y) {
                    r2.mode = 12;
                    break e;
                  }
                  e3.msg = "invalid literal/length code", r2.mode = 30;
                  break e;
                }
                w2 = 65535 & v2, (y &= 15) && (p < y && (d2 += z[n++] << p, p += 8), w2 += d2 & (1 << y) - 1, d2 >>>= y, p -= y), p < 15 && (d2 += z[n++] << p, p += 8, d2 += z[n++] << p, p += 8), v2 = _[d2 & b3];
                r: for (; ; ) {
                  if (d2 >>>= y = v2 >>> 24, p -= y, !(16 & (y = v2 >>> 16 & 255))) {
                    if (0 == (64 & y)) {
                      v2 = _[(65535 & v2) + (d2 & (1 << y) - 1)];
                      continue r;
                    }
                    e3.msg = "invalid distance code", r2.mode = 30;
                    break e;
                  }
                  if (k = 65535 & v2, p < (y &= 15) && (d2 += z[n++] << p, (p += 8) < y && (d2 += z[n++] << p, p += 8)), h < (k += d2 & (1 << y) - 1)) {
                    e3.msg = "invalid distance too far back", r2.mode = 30;
                    break e;
                  }
                  if (d2 >>>= y, p -= y, (y = s - a3) < k) {
                    if (l < (y = k - y) && r2.sane) {
                      e3.msg = "invalid distance too far back", r2.mode = 30;
                      break e;
                    }
                    if (S = c2, (x = 0) === f) {
                      if (x += u2 - y, y < w2) {
                        for (w2 -= y; C2[s++] = c2[x++], --y; ) ;
                        x = s - k, S = C2;
                      }
                    } else if (f < y) {
                      if (x += u2 + f - y, (y -= f) < w2) {
                        for (w2 -= y; C2[s++] = c2[x++], --y; ) ;
                        if (x = 0, f < w2) {
                          for (w2 -= y = f; C2[s++] = c2[x++], --y; ) ;
                          x = s - k, S = C2;
                        }
                      }
                    } else if (x += f - y, y < w2) {
                      for (w2 -= y; C2[s++] = c2[x++], --y; ) ;
                      x = s - k, S = C2;
                    }
                    for (; 2 < w2; ) C2[s++] = S[x++], C2[s++] = S[x++], C2[s++] = S[x++], w2 -= 3;
                    w2 && (C2[s++] = S[x++], 1 < w2 && (C2[s++] = S[x++]));
                  } else {
                    for (x = s - k; C2[s++] = C2[x++], C2[s++] = C2[x++], C2[s++] = C2[x++], 2 < (w2 -= 3); ) ;
                    w2 && (C2[s++] = C2[x++], 1 < w2 && (C2[s++] = C2[x++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (n < i && s < o);
          n -= w2 = p >> 3, d2 &= (1 << (p -= w2 << 3)) - 1, e3.next_in = n, e3.next_out = s, e3.avail_in = n < i ? i - n + 5 : 5 - (n - i), e3.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d2, r2.bits = p;
        };
      }, {}], 49: [function(e2, t, r) {
        "use strict";
        var I = e2("../utils/common"), O = e2("./adler32"), B2 = e2("./crc32"), R = e2("./inffast"), T = e2("./inftrees"), D2 = 1, F2 = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L2(e3) {
          return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a3(e3) {
          var t2;
          return e3 && e3.state ? (t2 = e3.state, e3.total_in = e3.total_out = t2.total = 0, e3.msg = "", t2.wrap && (e3.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e3) {
          var t2;
          return e3 && e3.state ? ((t2 = e3.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a3(e3)) : U;
        }
        function h(e3, t2) {
          var r2, n2;
          return e3 && e3.state ? (n2 = e3.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e3))) : U;
        }
        function u2(e3, t2) {
          var r2, n2;
          return e3 ? (n2 = new s(), (e3.state = n2).window = null, (r2 = h(e3, t2)) !== N && (e3.state = null), r2) : U;
        }
        var l, f, c2 = true;
        function j(e3) {
          if (c2) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; ) e3.lens[t2++] = 8;
            for (; t2 < 256; ) e3.lens[t2++] = 9;
            for (; t2 < 280; ) e3.lens[t2++] = 7;
            for (; t2 < 288; ) e3.lens[t2++] = 8;
            for (T(D2, e3.lens, 0, 288, l, 0, e3.work, { bits: 9 }), t2 = 0; t2 < 32; ) e3.lens[t2++] = 5;
            T(F2, e3.lens, 0, 32, f, 0, e3.work, { bits: 5 }), c2 = false;
          }
          e3.lencode = l, e3.lenbits = 9, e3.distcode = f, e3.distbits = 5;
        }
        function Z(e3, t2, r2, n2) {
          var i2, s2 = e3.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a3, r.inflateInit = function(e3) {
          return u2(e3, 15);
        }, r.inflateInit2 = u2, r.inflate = function(e3, t2) {
          var r2, n2, i2, s2, a4, o2, h2, u3, l2, f2, c3, d2, p, m, _, g, b3, v2, y, w2, k, x, S, z, C2 = 0, E2 = new I.Buf8(4), A2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in) return U;
          12 === (r2 = e3.state).mode && (r2.mode = 13), a4 = e3.next_out, i2 = e3.output, h2 = e3.avail_out, s2 = e3.next_in, n2 = e3.input, o2 = e3.avail_in, u3 = r2.hold, l2 = r2.bits, f2 = o2, c3 = h2, x = N;
          e: for (; ; ) switch (r2.mode) {
            case P:
              if (0 === r2.wrap) {
                r2.mode = 13;
                break;
              }
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              if (2 & r2.wrap && 35615 === u3) {
                E2[r2.check = 0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r2.check = B2(r2.check, E2, 2, 0), l2 = u3 = 0, r2.mode = 2;
                break;
              }
              if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u3) << 8) + (u3 >> 8)) % 31) {
                e3.msg = "incorrect header check", r2.mode = 30;
                break;
              }
              if (8 != (15 & u3)) {
                e3.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (l2 -= 4, k = 8 + (15 & (u3 >>>= 4)), 0 === r2.wbits) r2.wbits = k;
              else if (k > r2.wbits) {
                e3.msg = "invalid window size", r2.mode = 30;
                break;
              }
              r2.dmax = 1 << k, e3.adler = r2.check = 1, r2.mode = 512 & u3 ? 10 : 12, l2 = u3 = 0;
              break;
            case 2:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              if (r2.flags = u3, 8 != (255 & r2.flags)) {
                e3.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (57344 & r2.flags) {
                e3.msg = "unknown header flags set", r2.mode = 30;
                break;
              }
              r2.head && (r2.head.text = u3 >> 8 & 1), 512 & r2.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r2.check = B2(r2.check, E2, 2, 0)), l2 = u3 = 0, r2.mode = 3;
            case 3:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              r2.head && (r2.head.time = u3), 512 & r2.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, E2[2] = u3 >>> 16 & 255, E2[3] = u3 >>> 24 & 255, r2.check = B2(r2.check, E2, 4, 0)), l2 = u3 = 0, r2.mode = 4;
            case 4:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              r2.head && (r2.head.xflags = 255 & u3, r2.head.os = u3 >> 8), 512 & r2.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r2.check = B2(r2.check, E2, 2, 0)), l2 = u3 = 0, r2.mode = 5;
            case 5:
              if (1024 & r2.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u3 += n2[s2++] << l2, l2 += 8;
                }
                r2.length = u3, r2.head && (r2.head.extra_len = u3), 512 & r2.flags && (E2[0] = 255 & u3, E2[1] = u3 >>> 8 & 255, r2.check = B2(r2.check, E2, 2, 0)), l2 = u3 = 0;
              } else r2.head && (r2.head.extra = null);
              r2.mode = 6;
            case 6:
              if (1024 & r2.flags && (o2 < (d2 = r2.length) && (d2 = o2), d2 && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d2, k)), 512 & r2.flags && (r2.check = B2(r2.check, n2, d2, s2)), o2 -= d2, s2 += d2, r2.length -= d2), r2.length)) break e;
              r2.length = 0, r2.mode = 7;
            case 7:
              if (2048 & r2.flags) {
                if (0 === o2) break e;
                for (d2 = 0; k = n2[s2 + d2++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d2 < o2; ) ;
                if (512 & r2.flags && (r2.check = B2(r2.check, n2, d2, s2)), o2 -= d2, s2 += d2, k) break e;
              } else r2.head && (r2.head.name = null);
              r2.length = 0, r2.mode = 8;
            case 8:
              if (4096 & r2.flags) {
                if (0 === o2) break e;
                for (d2 = 0; k = n2[s2 + d2++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d2 < o2; ) ;
                if (512 & r2.flags && (r2.check = B2(r2.check, n2, d2, s2)), o2 -= d2, s2 += d2, k) break e;
              } else r2.head && (r2.head.comment = null);
              r2.mode = 9;
            case 9:
              if (512 & r2.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u3 += n2[s2++] << l2, l2 += 8;
                }
                if (u3 !== (65535 & r2.check)) {
                  e3.msg = "header crc mismatch", r2.mode = 30;
                  break;
                }
                l2 = u3 = 0;
              }
              r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e3.adler = r2.check = 0, r2.mode = 12;
              break;
            case 10:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              e3.adler = r2.check = L2(u3), l2 = u3 = 0, r2.mode = 11;
            case 11:
              if (0 === r2.havedict) return e3.next_out = a4, e3.avail_out = h2, e3.next_in = s2, e3.avail_in = o2, r2.hold = u3, r2.bits = l2, 2;
              e3.adler = r2.check = 1, r2.mode = 12;
            case 12:
              if (5 === t2 || 6 === t2) break e;
            case 13:
              if (r2.last) {
                u3 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                break;
              }
              for (; l2 < 3; ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              switch (r2.last = 1 & u3, l2 -= 1, 3 & (u3 >>>= 1)) {
                case 0:
                  r2.mode = 14;
                  break;
                case 1:
                  if (j(r2), r2.mode = 20, 6 !== t2) break;
                  u3 >>>= 2, l2 -= 2;
                  break e;
                case 2:
                  r2.mode = 17;
                  break;
                case 3:
                  e3.msg = "invalid block type", r2.mode = 30;
              }
              u3 >>>= 2, l2 -= 2;
              break;
            case 14:
              for (u3 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              if ((65535 & u3) != (u3 >>> 16 ^ 65535)) {
                e3.msg = "invalid stored block lengths", r2.mode = 30;
                break;
              }
              if (r2.length = 65535 & u3, l2 = u3 = 0, r2.mode = 15, 6 === t2) break e;
            case 15:
              r2.mode = 16;
            case 16:
              if (d2 = r2.length) {
                if (o2 < d2 && (d2 = o2), h2 < d2 && (d2 = h2), 0 === d2) break e;
                I.arraySet(i2, n2, s2, d2, a4), o2 -= d2, s2 += d2, h2 -= d2, a4 += d2, r2.length -= d2;
                break;
              }
              r2.mode = 12;
              break;
            case 17:
              for (; l2 < 14; ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              if (r2.nlen = 257 + (31 & u3), u3 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u3), u3 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u3), u3 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                e3.msg = "too many length or distance symbols", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 18;
            case 18:
              for (; r2.have < r2.ncode; ) {
                for (; l2 < 3; ) {
                  if (0 === o2) break e;
                  o2--, u3 += n2[s2++] << l2, l2 += 8;
                }
                r2.lens[A2[r2.have++]] = 7 & u3, u3 >>>= 3, l2 -= 3;
              }
              for (; r2.have < 19; ) r2.lens[A2[r2.have++]] = 0;
              if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                e3.msg = "invalid code lengths set", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 19;
            case 19:
              for (; r2.have < r2.nlen + r2.ndist; ) {
                for (; g = (C2 = r2.lencode[u3 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b3 = 65535 & C2, !((_ = C2 >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u3 += n2[s2++] << l2, l2 += 8;
                }
                if (b3 < 16) u3 >>>= _, l2 -= _, r2.lens[r2.have++] = b3;
                else {
                  if (16 === b3) {
                    for (z = _ + 2; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u3 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u3 >>>= _, l2 -= _, 0 === r2.have) {
                      e3.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    k = r2.lens[r2.have - 1], d2 = 3 + (3 & u3), u3 >>>= 2, l2 -= 2;
                  } else if (17 === b3) {
                    for (z = _ + 3; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u3 += n2[s2++] << l2, l2 += 8;
                    }
                    l2 -= _, k = 0, d2 = 3 + (7 & (u3 >>>= _)), u3 >>>= 3, l2 -= 3;
                  } else {
                    for (z = _ + 7; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u3 += n2[s2++] << l2, l2 += 8;
                    }
                    l2 -= _, k = 0, d2 = 11 + (127 & (u3 >>>= _)), u3 >>>= 7, l2 -= 7;
                  }
                  if (r2.have + d2 > r2.nlen + r2.ndist) {
                    e3.msg = "invalid bit length repeat", r2.mode = 30;
                    break;
                  }
                  for (; d2--; ) r2.lens[r2.have++] = k;
                }
              }
              if (30 === r2.mode) break;
              if (0 === r2.lens[256]) {
                e3.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                break;
              }
              if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D2, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                e3.msg = "invalid literal/lengths set", r2.mode = 30;
                break;
              }
              if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F2, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                e3.msg = "invalid distances set", r2.mode = 30;
                break;
              }
              if (r2.mode = 20, 6 === t2) break e;
            case 20:
              r2.mode = 21;
            case 21:
              if (6 <= o2 && 258 <= h2) {
                e3.next_out = a4, e3.avail_out = h2, e3.next_in = s2, e3.avail_in = o2, r2.hold = u3, r2.bits = l2, R(e3, c3), a4 = e3.next_out, i2 = e3.output, h2 = e3.avail_out, s2 = e3.next_in, n2 = e3.input, o2 = e3.avail_in, u3 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                break;
              }
              for (r2.back = 0; g = (C2 = r2.lencode[u3 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b3 = 65535 & C2, !((_ = C2 >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              if (g && 0 == (240 & g)) {
                for (v2 = _, y = g, w2 = b3; g = (C2 = r2.lencode[w2 + ((u3 & (1 << v2 + y) - 1) >> v2)]) >>> 16 & 255, b3 = 65535 & C2, !(v2 + (_ = C2 >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u3 += n2[s2++] << l2, l2 += 8;
                }
                u3 >>>= v2, l2 -= v2, r2.back += v2;
              }
              if (u3 >>>= _, l2 -= _, r2.back += _, r2.length = b3, 0 === g) {
                r2.mode = 26;
                break;
              }
              if (32 & g) {
                r2.back = -1, r2.mode = 12;
                break;
              }
              if (64 & g) {
                e3.msg = "invalid literal/length code", r2.mode = 30;
                break;
              }
              r2.extra = 15 & g, r2.mode = 22;
            case 22:
              if (r2.extra) {
                for (z = r2.extra; l2 < z; ) {
                  if (0 === o2) break e;
                  o2--, u3 += n2[s2++] << l2, l2 += 8;
                }
                r2.length += u3 & (1 << r2.extra) - 1, u3 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
              }
              r2.was = r2.length, r2.mode = 23;
            case 23:
              for (; g = (C2 = r2.distcode[u3 & (1 << r2.distbits) - 1]) >>> 16 & 255, b3 = 65535 & C2, !((_ = C2 >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u3 += n2[s2++] << l2, l2 += 8;
              }
              if (0 == (240 & g)) {
                for (v2 = _, y = g, w2 = b3; g = (C2 = r2.distcode[w2 + ((u3 & (1 << v2 + y) - 1) >> v2)]) >>> 16 & 255, b3 = 65535 & C2, !(v2 + (_ = C2 >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u3 += n2[s2++] << l2, l2 += 8;
                }
                u3 >>>= v2, l2 -= v2, r2.back += v2;
              }
              if (u3 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                e3.msg = "invalid distance code", r2.mode = 30;
                break;
              }
              r2.offset = b3, r2.extra = 15 & g, r2.mode = 24;
            case 24:
              if (r2.extra) {
                for (z = r2.extra; l2 < z; ) {
                  if (0 === o2) break e;
                  o2--, u3 += n2[s2++] << l2, l2 += 8;
                }
                r2.offset += u3 & (1 << r2.extra) - 1, u3 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
              }
              if (r2.offset > r2.dmax) {
                e3.msg = "invalid distance too far back", r2.mode = 30;
                break;
              }
              r2.mode = 25;
            case 25:
              if (0 === h2) break e;
              if (d2 = c3 - h2, r2.offset > d2) {
                if ((d2 = r2.offset - d2) > r2.whave && r2.sane) {
                  e3.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                p = d2 > r2.wnext ? (d2 -= r2.wnext, r2.wsize - d2) : r2.wnext - d2, d2 > r2.length && (d2 = r2.length), m = r2.window;
              } else m = i2, p = a4 - r2.offset, d2 = r2.length;
              for (h2 < d2 && (d2 = h2), h2 -= d2, r2.length -= d2; i2[a4++] = m[p++], --d2; ) ;
              0 === r2.length && (r2.mode = 21);
              break;
            case 26:
              if (0 === h2) break e;
              i2[a4++] = r2.length, h2--, r2.mode = 21;
              break;
            case 27:
              if (r2.wrap) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u3 |= n2[s2++] << l2, l2 += 8;
                }
                if (c3 -= h2, e3.total_out += c3, r2.total += c3, c3 && (e3.adler = r2.check = r2.flags ? B2(r2.check, i2, c3, a4 - c3) : O(r2.check, i2, c3, a4 - c3)), c3 = h2, (r2.flags ? u3 : L2(u3)) !== r2.check) {
                  e3.msg = "incorrect data check", r2.mode = 30;
                  break;
                }
                l2 = u3 = 0;
              }
              r2.mode = 28;
            case 28:
              if (r2.wrap && r2.flags) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u3 += n2[s2++] << l2, l2 += 8;
                }
                if (u3 !== (4294967295 & r2.total)) {
                  e3.msg = "incorrect length check", r2.mode = 30;
                  break;
                }
                l2 = u3 = 0;
              }
              r2.mode = 29;
            case 29:
              x = 1;
              break e;
            case 30:
              x = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return U;
          }
          return e3.next_out = a4, e3.avail_out = h2, e3.next_in = s2, e3.avail_in = o2, r2.hold = u3, r2.bits = l2, (r2.wsize || c3 !== e3.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e3, e3.output, e3.next_out, c3 - e3.avail_out) ? (r2.mode = 31, -4) : (f2 -= e3.avail_in, c3 -= e3.avail_out, e3.total_in += f2, e3.total_out += c3, r2.total += c3, r2.wrap && c3 && (e3.adler = r2.check = r2.flags ? B2(r2.check, i2, c3, e3.next_out - c3) : O(r2.check, i2, c3, e3.next_out - c3)), e3.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c3 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e3) {
          if (!e3 || !e3.state) return U;
          var t2 = e3.state;
          return t2.window && (t2.window = null), e3.state = null, N;
        }, r.inflateGetHeader = function(e3, t2) {
          var r2;
          return e3 && e3.state ? 0 == (2 & (r2 = e3.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e3, t2) {
          var r2, n2 = t2.length;
          return e3 && e3.state ? 0 !== (r2 = e3.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e3, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e2, t, r) {
        "use strict";
        var D2 = e2("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e3, t2, r2, n, i, s, a3, o) {
          var h, u2, l, f, c2, d2, p, m, _, g = o.bits, b3 = 0, v2 = 0, y = 0, w2 = 0, k = 0, x = 0, S = 0, z = 0, C2 = 0, E2 = 0, A2 = null, I = 0, O = new D2.Buf16(16), B2 = new D2.Buf16(16), R = null, T = 0;
          for (b3 = 0; b3 <= 15; b3++) O[b3] = 0;
          for (v2 = 0; v2 < n; v2++) O[t2[r2 + v2]]++;
          for (k = g, w2 = 15; 1 <= w2 && 0 === O[w2]; w2--) ;
          if (w2 < k && (k = w2), 0 === w2) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w2 && 0 === O[y]; y++) ;
          for (k < y && (k = y), b3 = z = 1; b3 <= 15; b3++) if (z <<= 1, (z -= O[b3]) < 0) return -1;
          if (0 < z && (0 === e3 || 1 !== w2)) return -1;
          for (B2[1] = 0, b3 = 1; b3 < 15; b3++) B2[b3 + 1] = B2[b3] + O[b3];
          for (v2 = 0; v2 < n; v2++) 0 !== t2[r2 + v2] && (a3[B2[t2[r2 + v2]]++] = v2);
          if (d2 = 0 === e3 ? (A2 = R = a3, 19) : 1 === e3 ? (A2 = F2, I -= 257, R = N, T -= 257, 256) : (A2 = U, R = P, -1), b3 = y, c2 = s, S = v2 = E2 = 0, l = -1, f = (C2 = 1 << (x = k)) - 1, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2) return 1;
          for (; ; ) {
            for (p = b3 - S, _ = a3[v2] < d2 ? (m = 0, a3[v2]) : a3[v2] > d2 ? (m = R[T + a3[v2]], A2[I + a3[v2]]) : (m = 96, 0), h = 1 << b3 - S, y = u2 = 1 << x; i[c2 + (E2 >> S) + (u2 -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u2; ) ;
            for (h = 1 << b3 - 1; E2 & h; ) h >>= 1;
            if (0 !== h ? (E2 &= h - 1, E2 += h) : E2 = 0, v2++, 0 == --O[b3]) {
              if (b3 === w2) break;
              b3 = t2[r2 + a3[v2]];
            }
            if (k < b3 && (E2 & f) !== l) {
              for (0 === S && (S = k), c2 += y, z = 1 << (x = b3 - S); x + S < w2 && !((z -= O[x + S]) <= 0); ) x++, z <<= 1;
              if (C2 += 1 << x, 1 === e3 && 852 < C2 || 2 === e3 && 592 < C2) return 1;
              i[l = E2 & f] = k << 24 | x << 16 | c2 - s | 0;
            }
          }
          return 0 !== E2 && (i[c2 + E2] = b3 - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e2, t, r) {
        "use strict";
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e2, t, r) {
        "use strict";
        var i = e2("../utils/common"), o = 0, h = 1;
        function n(e3) {
          for (var t2 = e3.length; 0 <= --t2; ) e3[t2] = 0;
        }
        var s = 0, a3 = 29, u2 = 256, l = u2 + 1 + a3, f = 30, c2 = 19, _ = 2 * l + 1, g = 15, d2 = 16, p = 7, m = 256, b3 = 16, v2 = 17, y = 18, w2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C2 = new Array(2 * f);
        n(C2);
        var E2 = new Array(512);
        n(E2);
        var A2 = new Array(256);
        n(A2);
        var I = new Array(a3);
        n(I);
        var O, B2, R, T = new Array(f);
        function D2(e3, t2, r2, n2, i2) {
          this.static_tree = e3, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e3 && e3.length;
        }
        function F2(e3, t2) {
          this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e3) {
          return e3 < 256 ? E2[e3] : E2[256 + (e3 >>> 7)];
        }
        function U(e3, t2) {
          e3.pending_buf[e3.pending++] = 255 & t2, e3.pending_buf[e3.pending++] = t2 >>> 8 & 255;
        }
        function P(e3, t2, r2) {
          e3.bi_valid > d2 - r2 ? (e3.bi_buf |= t2 << e3.bi_valid & 65535, U(e3, e3.bi_buf), e3.bi_buf = t2 >> d2 - e3.bi_valid, e3.bi_valid += r2 - d2) : (e3.bi_buf |= t2 << e3.bi_valid & 65535, e3.bi_valid += r2);
        }
        function L2(e3, t2, r2) {
          P(e3, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e3, t2) {
          for (var r2 = 0; r2 |= 1 & e3, e3 >>>= 1, r2 <<= 1, 0 < --t2; ) ;
          return r2 >>> 1;
        }
        function Z(e3, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a4 = 0;
          for (n2 = 1; n2 <= g; n2++) s2[n2] = a4 = a4 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e3[2 * i2 + 1];
            0 !== o2 && (e3[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W2(e3) {
          var t2;
          for (t2 = 0; t2 < l; t2++) e3.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++) e3.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c2; t2++) e3.bl_tree[2 * t2] = 0;
          e3.dyn_ltree[2 * m] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
        }
        function M(e3) {
          8 < e3.bi_valid ? U(e3, e3.bi_buf) : 0 < e3.bi_valid && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
        }
        function H(e3, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e3[i2] < e3[s2] || e3[i2] === e3[s2] && n2[t2] <= n2[r2];
        }
        function G2(e3, t2, r2) {
          for (var n2 = e3.heap[r2], i2 = r2 << 1; i2 <= e3.heap_len && (i2 < e3.heap_len && H(t2, e3.heap[i2 + 1], e3.heap[i2], e3.depth) && i2++, !H(t2, n2, e3.heap[i2], e3.depth)); ) e3.heap[r2] = e3.heap[i2], r2 = i2, i2 <<= 1;
          e3.heap[r2] = n2;
        }
        function K(e3, t2, r2) {
          var n2, i2, s2, a4, o2 = 0;
          if (0 !== e3.last_lit) for (; n2 = e3.pending_buf[e3.d_buf + 2 * o2] << 8 | e3.pending_buf[e3.d_buf + 2 * o2 + 1], i2 = e3.pending_buf[e3.l_buf + o2], o2++, 0 === n2 ? L2(e3, i2, t2) : (L2(e3, (s2 = A2[i2]) + u2 + 1, t2), 0 !== (a4 = w2[s2]) && P(e3, i2 -= I[s2], a4), L2(e3, s2 = N(--n2), r2), 0 !== (a4 = k[s2]) && P(e3, n2 -= T[s2], a4)), o2 < e3.last_lit; ) ;
          L2(e3, m, t2);
        }
        function Y(e3, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a4 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u3 = -1;
          for (e3.heap_len = 0, e3.heap_max = _, r2 = 0; r2 < h2; r2++) 0 !== s2[2 * r2] ? (e3.heap[++e3.heap_len] = u3 = r2, e3.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e3.heap_len < 2; ) s2[2 * (i2 = e3.heap[++e3.heap_len] = u3 < 2 ? ++u3 : 0)] = 1, e3.depth[i2] = 0, e3.opt_len--, o2 && (e3.static_len -= a4[2 * i2 + 1]);
          for (t2.max_code = u3, r2 = e3.heap_len >> 1; 1 <= r2; r2--) G2(e3, s2, r2);
          for (i2 = h2; r2 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], G2(e3, s2, 1), n2 = e3.heap[1], e3.heap[--e3.heap_max] = r2, e3.heap[--e3.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e3.depth[i2] = (e3.depth[r2] >= e3.depth[n2] ? e3.depth[r2] : e3.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e3.heap[1] = i2++, G2(e3, s2, 1), 2 <= e3.heap_len; ) ;
          e3.heap[--e3.heap_max] = e3.heap[1], function(e4, t3) {
            var r3, n3, i3, s3, a5, o3, h3 = t3.dyn_tree, u4 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c3 = t3.stat_desc.extra_bits, d3 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++) e4.bl_count[s3] = 0;
            for (h3[2 * e4.heap[e4.heap_max] + 1] = 0, r3 = e4.heap_max + 1; r3 < _; r3++) p2 < (s3 = h3[2 * h3[2 * (n3 = e4.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u4 < n3 || (e4.bl_count[s3]++, a5 = 0, d3 <= n3 && (a5 = c3[n3 - d3]), o3 = h3[2 * n3], e4.opt_len += o3 * (s3 + a5), f2 && (e4.static_len += o3 * (l2[2 * n3 + 1] + a5)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e4.bl_count[s3]; ) s3--;
                e4.bl_count[s3]--, e4.bl_count[s3 + 1] += 2, e4.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--) for (n3 = e4.bl_count[s3]; 0 !== n3; ) u4 < (i3 = e4.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e4.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          }(e3, t2), Z(s2, u3, e3.bl_count);
        }
        function X(e3, t2, r2) {
          var n2, i2, s2 = -1, a4 = t2[1], o2 = 0, h2 = 7, u3 = 4;
          for (0 === a4 && (h2 = 138, u3 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++) i2 = a4, a4 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a4 || (o2 < u3 ? e3.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e3.bl_tree[2 * i2]++, e3.bl_tree[2 * b3]++) : o2 <= 10 ? e3.bl_tree[2 * v2]++ : e3.bl_tree[2 * y]++, s2 = i2, u3 = (o2 = 0) === a4 ? (h2 = 138, 3) : i2 === a4 ? (h2 = 6, 3) : (h2 = 7, 4));
        }
        function V2(e3, t2, r2) {
          var n2, i2, s2 = -1, a4 = t2[1], o2 = 0, h2 = 7, u3 = 4;
          for (0 === a4 && (h2 = 138, u3 = 3), n2 = 0; n2 <= r2; n2++) if (i2 = a4, a4 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a4)) {
            if (o2 < u3) for (; L2(e3, i2, e3.bl_tree), 0 != --o2; ) ;
            else 0 !== i2 ? (i2 !== s2 && (L2(e3, i2, e3.bl_tree), o2--), L2(e3, b3, e3.bl_tree), P(e3, o2 - 3, 2)) : o2 <= 10 ? (L2(e3, v2, e3.bl_tree), P(e3, o2 - 3, 3)) : (L2(e3, y, e3.bl_tree), P(e3, o2 - 11, 7));
            s2 = i2, u3 = (o2 = 0) === a4 ? (h2 = 138, 3) : i2 === a4 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
        }
        n(T);
        var q = false;
        function J(e3, t2, r2, n2) {
          P(e3, (s << 1) + (n2 ? 1 : 0), 3), function(e4, t3, r3, n3) {
            M(e4), n3 && (U(e4, r3), U(e4, ~r3)), i.arraySet(e4.pending_buf, e4.window, t3, r3, e4.pending), e4.pending += r3;
          }(e3, t2, r2, true);
        }
        r._tr_init = function(e3) {
          q || (function() {
            var e4, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a3 - 1; n2++) for (I[n2] = r2, e4 = 0; e4 < 1 << w2[n2]; e4++) A2[r2++] = n2;
            for (A2[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++) for (T[n2] = i2, e4 = 0; e4 < 1 << k[n2]; e4++) E2[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++) for (T[n2] = i2 << 7, e4 = 0; e4 < 1 << k[n2] - 7; e4++) E2[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++) s2[t2] = 0;
            for (e4 = 0; e4 <= 143; ) z[2 * e4 + 1] = 8, e4++, s2[8]++;
            for (; e4 <= 255; ) z[2 * e4 + 1] = 9, e4++, s2[9]++;
            for (; e4 <= 279; ) z[2 * e4 + 1] = 7, e4++, s2[7]++;
            for (; e4 <= 287; ) z[2 * e4 + 1] = 8, e4++, s2[8]++;
            for (Z(z, l + 1, s2), e4 = 0; e4 < f; e4++) C2[2 * e4 + 1] = 5, C2[2 * e4] = j(e4, 5);
            O = new D2(z, w2, u2 + 1, l, g), B2 = new D2(C2, k, 0, f, g), R = new D2(new Array(0), x, 0, c2, p);
          }(), q = true), e3.l_desc = new F2(e3.dyn_ltree, O), e3.d_desc = new F2(e3.dyn_dtree, B2), e3.bl_desc = new F2(e3.bl_tree, R), e3.bi_buf = 0, e3.bi_valid = 0, W2(e3);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e3, t2, r2, n2) {
          var i2, s2, a4 = 0;
          0 < e3.level ? (2 === e3.strm.data_type && (e3.strm.data_type = function(e4) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e4.dyn_ltree[2 * t3]) return o;
            if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26]) return h;
            for (t3 = 32; t3 < u2; t3++) if (0 !== e4.dyn_ltree[2 * t3]) return h;
            return o;
          }(e3)), Y(e3, e3.l_desc), Y(e3, e3.d_desc), a4 = function(e4) {
            var t3;
            for (X(e4, e4.dyn_ltree, e4.l_desc.max_code), X(e4, e4.dyn_dtree, e4.d_desc.max_code), Y(e4, e4.bl_desc), t3 = c2 - 1; 3 <= t3 && 0 === e4.bl_tree[2 * S[t3] + 1]; t3--) ;
            return e4.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          }(e3), i2 = e3.opt_len + 3 + 7 >>> 3, (s2 = e3.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e3, t2, r2, n2) : 4 === e3.strategy || s2 === i2 ? (P(e3, 2 + (n2 ? 1 : 0), 3), K(e3, z, C2)) : (P(e3, 4 + (n2 ? 1 : 0), 3), function(e4, t3, r3, n3) {
            var i3;
            for (P(e4, t3 - 257, 5), P(e4, r3 - 1, 5), P(e4, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P(e4, e4.bl_tree[2 * S[i3] + 1], 3);
            V2(e4, e4.dyn_ltree, t3 - 1), V2(e4, e4.dyn_dtree, r3 - 1);
          }(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a4 + 1), K(e3, e3.dyn_ltree, e3.dyn_dtree)), W2(e3), n2 && M(e3);
        }, r._tr_tally = function(e3, t2, r2) {
          return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t2 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t2, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r2, e3.last_lit++, 0 === t2 ? e3.dyn_ltree[2 * r2]++ : (e3.matches++, t2--, e3.dyn_ltree[2 * (A2[r2] + u2 + 1)]++, e3.dyn_dtree[2 * N(t2)]++), e3.last_lit === e3.lit_bufsize - 1;
        }, r._tr_align = function(e3) {
          P(e3, 2, 3), L2(e3, m, z), function(e4) {
            16 === e4.bi_valid ? (U(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : 8 <= e4.bi_valid && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
          }(e3);
        };
      }, { "../utils/common": 41 }], 53: [function(e2, t, r) {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e2, t, r) {
        (function(e3) {
          !function(r2, n) {
            "use strict";
            if (!r2.setImmediate) {
              var i, s, t2, a3, o = 1, h = {}, u2 = false, l = r2.document, e4 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e4 = e4 && e4.setTimeout ? e4 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e5) {
                process.nextTick(function() {
                  c2(e5);
                });
              } : function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e5 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e5 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e5;
                }
              }() ? (a3 = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d2, false) : r2.attachEvent("onmessage", d2), function(e5) {
                r2.postMessage(a3 + e5, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e5) {
                c2(e5.data);
              }, function(e5) {
                t2.port2.postMessage(e5);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e5) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c2(e5), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e5) {
                setTimeout(c2, 0, e5);
              }, e4.setImmediate = function(e5) {
                "function" != typeof e5 && (e5 = new Function("" + e5));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++) t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e5, args: t3 };
                return h[o] = n2, i(o), o++;
              }, e4.clearImmediate = f;
            }
            function f(e5) {
              delete h[e5];
            }
            function c2(e5) {
              if (u2) setTimeout(c2, 0, e5);
              else {
                var t3 = h[e5];
                if (t3) {
                  u2 = true;
                  try {
                    !function(e6) {
                      var t4 = e6.callback, r3 = e6.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    }(t3);
                  } finally {
                    f(e5), u2 = false;
                  }
                }
              }
            }
            function d2(e5) {
              e5.source === r2 && "string" == typeof e5.data && 0 === e5.data.indexOf(a3) && c2(+e5.data.slice(a3.length));
            }
          }("undefined" == typeof self ? void 0 === e3 ? this : e3 : self);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len4, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len4), dest_offs);
          return;
        }
        for (var i = 0; i < len4; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len4, pos, chunk, result;
        len4 = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len4 += chunks[i].length;
        }
        result = new Uint8Array(len4);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len4, dest_offs) {
        for (var i = 0; i < len4; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero3(buf) {
      var len4 = buf.length;
      while (--len4 >= 0) {
        buf[len4] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero3(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero3(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero3(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero3(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero3(base_length);
    var base_dist = new Array(D_CODES);
    zero3(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist3) {
      return dist3 < 256 ? _dist_code[dist3] : _dist_code[256 + (dist3 >>> 7)];
    }
    function put_short(s, w2) {
      s.pending_buf[s.pending++] = w2 & 255;
      s.pending_buf[s.pending++] = w2 >>> 8 & 255;
    }
    function send_bits(s, value, length5) {
      if (s.bi_valid > Buf_size - length5) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length5 - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length5;
      }
    }
    function send_code(s, c2, tree) {
      send_bits(
        s,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len4) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len4 > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len4 = tree[n * 2 + 1];
        if (len4 === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len4]++, len4);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length5;
      var code;
      var dist3;
      var bl_count = new Array(MAX_BITS + 1);
      length5 = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length5;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length5++] = code;
        }
      }
      _length_code[length5 - 1] = code;
      dist3 = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist3;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist3++] = code;
        }
      }
      dist3 >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist3 << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist3++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len4, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len4);
        put_short(s, ~len4);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len4, s.pending);
      s.pending += len4;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v2 = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v2, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v2;
    }
    function compress_block(s, ltree, dtree) {
      var dist3;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist3 = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist3 === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist3--;
            code = d_code(dist3);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist3 -= base_dist[code];
              send_bits(s, dist3, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist3, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist3 >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist3 & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist3 === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist3--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist3) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    function adler32(adler, buf, len4, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len4 !== 0) {
        n = len4 > 2e3 ? 2e3 : len4;
        len4 -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    function makeTable() {
      var c2, table = [];
      for (var n = 0; n < 256; n++) {
        c2 = n;
        for (var k = 0; k < 8; k++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table[n] = c2;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len4, pos) {
      var t = crcTable, end = pos + len4;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero3(buf) {
      var len4 = buf.length;
      while (--len4 >= 0) {
        buf[len4] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len4 = s.pending;
      if (len4 > strm.avail_out) {
        len4 = strm.avail_out;
      }
      if (len4 === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len4, strm.next_out);
      strm.next_out += len4;
      s.pending_out += len4;
      strm.total_out += len4;
      strm.avail_out -= len4;
      s.pending -= len4;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b3) {
      s.pending_buf[s.pending++] = b3;
    }
    function putShortMSB(s, b3) {
      s.pending_buf[s.pending++] = b3 >>> 8 & 255;
      s.pending_buf[s.pending++] = b3 & 255;
    }
    function read_buf(strm, buf, start, size) {
      var len4 = strm.avail_in;
      if (len4 > size) {
        len4 = size;
      }
      if (len4 === 0) {
        return 0;
      }
      strm.avail_in -= len4;
      utils.arraySet(buf, strm.input, strm.next_in, len4, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len4, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len4, start);
      }
      strm.next_in += len4;
      strm.total_in += len4;
      return len4;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len4;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len4 = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len4 > best_len) {
          s.match_start = cur_match;
          best_len = len4;
          if (len4 >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str5;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str5 = s.strstart - s.insert;
          s.ins_h = s.window[str5];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str5 + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str5 + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str5 & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str5;
            str5++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero3(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero3(this.dyn_ltree);
      zero3(this.dyn_dtree);
      zero3(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero3(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero3(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero3(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str5, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero3(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str5 = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str5 + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str5 & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str5;
          str5++;
        } while (--n);
        s.strstart = str5;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit2 = deflateInit2;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports.string2buf = function(str5) {
      var buf, c2, c22, m_pos, i, str_len = str5.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c2 = str5.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str5.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c2 = str5.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str5.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c2 < 128) {
          buf[i++] = c2;
        } else if (c2 < 2048) {
          buf[i++] = 192 | c2 >>> 6;
          buf[i++] = 128 | c2 & 63;
        } else if (c2 < 65536) {
          buf[i++] = 224 | c2 >>> 12;
          buf[i++] = 128 | c2 >>> 6 & 63;
          buf[i++] = 128 | c2 & 63;
        } else {
          buf[i++] = 240 | c2 >>> 18;
          buf[i++] = 128 | c2 >>> 12 & 63;
          buf[i++] = 128 | c2 >>> 6 & 63;
          buf[i++] = 128 | c2 & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len4) {
      if (len4 < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len4));
        }
      }
      var result = "";
      for (var i = 0; i < len4; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports.binstring2buf = function(str5) {
      var buf = new utils.Buf8(str5.length);
      for (var i = 0, len4 = buf.length; i < len4; i++) {
        buf[i] = str5.charCodeAt(i);
      }
      return buf;
    };
    exports.buf2string = function(buf, max3) {
      var i, out, c2, c_len;
      var len4 = max3 || buf.length;
      var utf16buf = new Array(len4 * 2);
      for (out = 0, i = 0; i < len4; ) {
        c2 = buf[i++];
        if (c2 < 128) {
          utf16buf[out++] = c2;
          continue;
        }
        c_len = _utf8len[c2];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len4) {
          c2 = c2 << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c2 < 65536) {
          utf16buf[out++] = c2;
        } else {
          c2 -= 65536;
          utf16buf[out++] = 55296 | c2 >> 10 & 1023;
          utf16buf[out++] = 56320 | c2 & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports.utf8border = function(buf, max3) {
      var pos;
      max3 = max3 || buf.length;
      if (max3 > buf.length) {
        max3 = buf.length;
      }
      pos = max3 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max3;
      }
      if (pos === 0) {
        return max3;
      }
      return pos + _utf8len[buf[pos]] > max3 ? pos : max3;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString2 = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate)) return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len4;
      var dist3;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len4 = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len4 += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist3 = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist3 += hold & (1 << op) - 1;
                      if (dist3 > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist3 > op) {
                        op = dist3 - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len4) {
                            len4 -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist3;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len4) {
                            len4 -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len4) {
                              op = wnext;
                              len4 -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist3;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len4) {
                            len4 -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist3;
                            from_source = output;
                          }
                        }
                        while (len4 > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len4 -= 3;
                        }
                        if (len4) {
                          output[_out++] = from_source[from++];
                          if (len4 > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist3;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len4 -= 3;
                        } while (len4 > 2);
                        if (len4) {
                          output[_out++] = output[from++];
                          if (len4 > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len4 = bits >> 3;
      _in -= len4;
      bits -= len4 << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len4 = 0;
      var sym = 0;
      var min3 = 0, max3 = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len4 = 0; len4 <= MAXBITS; len4++) {
        count[len4] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max3 = MAXBITS; max3 >= 1; max3--) {
        if (count[max3] !== 0) {
          break;
        }
      }
      if (root > max3) {
        root = max3;
      }
      if (max3 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min3 = 1; min3 < max3; min3++) {
        if (count[min3] !== 0) {
          break;
        }
      }
      if (root < min3) {
        root = min3;
      }
      left = 1;
      for (len4 = 1; len4 <= MAXBITS; len4++) {
        left <<= 1;
        left -= count[len4];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max3 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len4 = 1; len4 < MAXBITS; len4++) {
        offs[len4 + 1] = offs[len4] + count[len4];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len4 = min3;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len4 - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len4 - drop;
        fill = 1 << curr;
        min3 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len4 - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len4] === 0) {
          if (len4 === max3) {
            break;
          }
          len4 = lens[lens_index + work[sym]];
        }
        if (len4 > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min3;
          curr = len4 - drop;
          left = 1 << curr;
          while (curr + drop < max3) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len4 - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy6) {
      var dist3;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy6 >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist3 = state.wsize - state.wnext;
        if (dist3 > copy6) {
          dist3 = copy6;
        }
        utils.arraySet(state.window, src, end - copy6, dist3, state.wnext);
        copy6 -= dist3;
        if (copy6) {
          utils.arraySet(state.window, src, end - copy6, copy6, 0);
          state.wnext = copy6;
          state.whave = state.wsize;
        } else {
          state.wnext += dist3;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist3;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy6;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len4;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len4 = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len4;
              } else if (len4 > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len4;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy6 = state.length;
                if (copy6 > have) {
                  copy6 = have;
                }
                if (copy6) {
                  if (state.head) {
                    len4 = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy6,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len4
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy6, next);
                  }
                  have -= copy6;
                  next += copy6;
                  state.length -= copy6;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy6 = 0;
                do {
                  len4 = input[next + copy6++];
                  if (state.head && len4 && state.length < 65536) {
                    state.head.name += String.fromCharCode(len4);
                  }
                } while (len4 && copy6 < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy6, next);
                }
                have -= copy6;
                next += copy6;
                if (len4) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy6 = 0;
                do {
                  len4 = input[next + copy6++];
                  if (state.head && len4 && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len4);
                  }
                } while (len4 && copy6 < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy6, next);
                }
                have -= copy6;
                next += copy6;
                if (len4) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy6 = state.length;
              if (copy6) {
                if (copy6 > have) {
                  copy6 = have;
                }
                if (copy6 > left) {
                  copy6 = left;
                }
                if (copy6 === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy6, put);
                have -= copy6;
                next += copy6;
                left -= copy6;
                put += copy6;
                state.length -= copy6;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len4 = state.lens[state.have - 1];
                    copy6 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len4 = 0;
                    copy6 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len4 = 0;
                    copy6 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy6 > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy6--) {
                    state.lens[state.have++] = len4;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy6 = _out - left;
              if (state.offset > copy6) {
                copy6 = state.offset - copy6;
                if (copy6 > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy6 > state.wnext) {
                  copy6 -= state.wnext;
                  from = state.wsize - copy6;
                } else {
                  from = state.wnext - copy6;
                }
                if (copy6 > state.length) {
                  copy6 = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy6 = state.length;
              }
              if (copy6 > left) {
                copy6 = left;
              }
              left -= copy6;
              state.length -= copy6;
              do {
                output[put++] = from_source[from++];
              } while (--copy6);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset2 = inflateReset2;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit2 = inflateInit2;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c2 = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString2 = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c2.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c2.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c2.Z_FINISH : c2.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c2.Z_NO_FLUSH);
        if (status === c2.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c2.Z_BUF_ERROR && allowBufError === true) {
          status = c2.Z_OK;
          allowBufError = false;
        }
        if (status !== c2.Z_STREAM_END && status !== c2.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c2.Z_STREAM_END || strm.avail_in === 0 && (_mode === c2.Z_FINISH || _mode === c2.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c2.Z_STREAM_END);
      if (status === c2.Z_STREAM_END) {
        _mode = c2.Z_FINISH;
      }
      if (_mode === c2.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c2.Z_OK;
      }
      if (_mode === c2.Z_SYNC_FLUSH) {
        this.onEnd(c2.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c2.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako2 = {};
    assign(pako2, deflate, inflate, constants);
    module.exports = pako2;
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/snappyjs/snappy_decompressor.js
var require_snappy_decompressor = __commonJS({
  "node_modules/snappyjs/snappy_decompressor.js"(exports) {
    "use strict";
    var WORD_MASK = [0, 255, 65535, 16777215, 4294967295];
    function copyBytes(fromArray, fromPos, toArray, toPos, length5) {
      var i;
      for (i = 0; i < length5; i++) {
        toArray[toPos + i] = fromArray[fromPos + i];
      }
    }
    function selfCopyBytes(array, pos, offset, length5) {
      var i;
      for (i = 0; i < length5; i++) {
        array[pos + i] = array[pos - offset + i];
      }
    }
    function SnappyDecompressor(compressed) {
      this.array = compressed;
      this.pos = 0;
    }
    SnappyDecompressor.prototype.readUncompressedLength = function() {
      var result = 0;
      var shift = 0;
      var c2, val;
      while (shift < 32 && this.pos < this.array.length) {
        c2 = this.array[this.pos];
        this.pos += 1;
        val = c2 & 127;
        if (val << shift >>> shift !== val) {
          return -1;
        }
        result |= val << shift;
        if (c2 < 128) {
          return result;
        }
        shift += 7;
      }
      return -1;
    };
    SnappyDecompressor.prototype.uncompressToBuffer = function(outBuffer) {
      var array = this.array;
      var arrayLength = array.length;
      var pos = this.pos;
      var outPos = 0;
      var c2, len4, smallLen;
      var offset;
      while (pos < array.length) {
        c2 = array[pos];
        pos += 1;
        if ((c2 & 3) === 0) {
          len4 = (c2 >>> 2) + 1;
          if (len4 > 60) {
            if (pos + 3 >= arrayLength) {
              return false;
            }
            smallLen = len4 - 60;
            len4 = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
            len4 = (len4 & WORD_MASK[smallLen]) + 1;
            pos += smallLen;
          }
          if (pos + len4 > arrayLength) {
            return false;
          }
          copyBytes(array, pos, outBuffer, outPos, len4);
          pos += len4;
          outPos += len4;
        } else {
          switch (c2 & 3) {
            case 1:
              len4 = (c2 >>> 2 & 7) + 4;
              offset = array[pos] + (c2 >>> 5 << 8);
              pos += 1;
              break;
            case 2:
              if (pos + 1 >= arrayLength) {
                return false;
              }
              len4 = (c2 >>> 2) + 1;
              offset = array[pos] + (array[pos + 1] << 8);
              pos += 2;
              break;
            case 3:
              if (pos + 3 >= arrayLength) {
                return false;
              }
              len4 = (c2 >>> 2) + 1;
              offset = array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
              pos += 4;
              break;
            default:
              break;
          }
          if (offset === 0 || offset > outPos) {
            return false;
          }
          selfCopyBytes(outBuffer, outPos, offset, len4);
          outPos += len4;
        }
      }
      return true;
    };
    exports.SnappyDecompressor = SnappyDecompressor;
  }
});

// node_modules/snappyjs/snappy_compressor.js
var require_snappy_compressor = __commonJS({
  "node_modules/snappyjs/snappy_compressor.js"(exports) {
    "use strict";
    var BLOCK_LOG = 16;
    var BLOCK_SIZE = 1 << BLOCK_LOG;
    var MAX_HASH_TABLE_BITS = 14;
    var globalHashTables = new Array(MAX_HASH_TABLE_BITS + 1);
    function hashFunc(key, hashFuncShift) {
      return key * 506832829 >>> hashFuncShift;
    }
    function load32(array, pos) {
      return array[pos] + (array[pos + 1] << 8) + (array[pos + 2] << 16) + (array[pos + 3] << 24);
    }
    function equals32(array, pos1, pos2) {
      return array[pos1] === array[pos2] && array[pos1 + 1] === array[pos2 + 1] && array[pos1 + 2] === array[pos2 + 2] && array[pos1 + 3] === array[pos2 + 3];
    }
    function copyBytes(fromArray, fromPos, toArray, toPos, length5) {
      var i;
      for (i = 0; i < length5; i++) {
        toArray[toPos + i] = fromArray[fromPos + i];
      }
    }
    function emitLiteral(input, ip, len4, output, op) {
      if (len4 <= 60) {
        output[op] = len4 - 1 << 2;
        op += 1;
      } else if (len4 < 256) {
        output[op] = 60 << 2;
        output[op + 1] = len4 - 1;
        op += 2;
      } else {
        output[op] = 61 << 2;
        output[op + 1] = len4 - 1 & 255;
        output[op + 2] = len4 - 1 >>> 8;
        op += 3;
      }
      copyBytes(input, ip, output, op, len4);
      return op + len4;
    }
    function emitCopyLessThan64(output, op, offset, len4) {
      if (len4 < 12 && offset < 2048) {
        output[op] = 1 + (len4 - 4 << 2) + (offset >>> 8 << 5);
        output[op + 1] = offset & 255;
        return op + 2;
      } else {
        output[op] = 2 + (len4 - 1 << 2);
        output[op + 1] = offset & 255;
        output[op + 2] = offset >>> 8;
        return op + 3;
      }
    }
    function emitCopy(output, op, offset, len4) {
      while (len4 >= 68) {
        op = emitCopyLessThan64(output, op, offset, 64);
        len4 -= 64;
      }
      if (len4 > 64) {
        op = emitCopyLessThan64(output, op, offset, 60);
        len4 -= 60;
      }
      return emitCopyLessThan64(output, op, offset, len4);
    }
    function compressFragment(input, ip, inputSize, output, op) {
      var hashTableBits = 1;
      while (1 << hashTableBits <= inputSize && hashTableBits <= MAX_HASH_TABLE_BITS) {
        hashTableBits += 1;
      }
      hashTableBits -= 1;
      var hashFuncShift = 32 - hashTableBits;
      if (typeof globalHashTables[hashTableBits] === "undefined") {
        globalHashTables[hashTableBits] = new Uint16Array(1 << hashTableBits);
      }
      var hashTable = globalHashTables[hashTableBits];
      var i;
      for (i = 0; i < hashTable.length; i++) {
        hashTable[i] = 0;
      }
      var ipEnd = ip + inputSize;
      var ipLimit;
      var baseIp = ip;
      var nextEmit = ip;
      var hash, nextHash;
      var nextIp, candidate, skip;
      var bytesBetweenHashLookups;
      var base, matched, offset;
      var prevHash, curHash;
      var flag = true;
      var INPUT_MARGIN = 15;
      if (inputSize >= INPUT_MARGIN) {
        ipLimit = ipEnd - INPUT_MARGIN;
        ip += 1;
        nextHash = hashFunc(load32(input, ip), hashFuncShift);
        while (flag) {
          skip = 32;
          nextIp = ip;
          do {
            ip = nextIp;
            hash = nextHash;
            bytesBetweenHashLookups = skip >>> 5;
            skip += 1;
            nextIp = ip + bytesBetweenHashLookups;
            if (ip > ipLimit) {
              flag = false;
              break;
            }
            nextHash = hashFunc(load32(input, nextIp), hashFuncShift);
            candidate = baseIp + hashTable[hash];
            hashTable[hash] = ip - baseIp;
          } while (!equals32(input, ip, candidate));
          if (!flag) {
            break;
          }
          op = emitLiteral(input, nextEmit, ip - nextEmit, output, op);
          do {
            base = ip;
            matched = 4;
            while (ip + matched < ipEnd && input[ip + matched] === input[candidate + matched]) {
              matched += 1;
            }
            ip += matched;
            offset = base - candidate;
            op = emitCopy(output, op, offset, matched);
            nextEmit = ip;
            if (ip >= ipLimit) {
              flag = false;
              break;
            }
            prevHash = hashFunc(load32(input, ip - 1), hashFuncShift);
            hashTable[prevHash] = ip - 1 - baseIp;
            curHash = hashFunc(load32(input, ip), hashFuncShift);
            candidate = baseIp + hashTable[curHash];
            hashTable[curHash] = ip - baseIp;
          } while (equals32(input, ip, candidate));
          if (!flag) {
            break;
          }
          ip += 1;
          nextHash = hashFunc(load32(input, ip), hashFuncShift);
        }
      }
      if (nextEmit < ipEnd) {
        op = emitLiteral(input, nextEmit, ipEnd - nextEmit, output, op);
      }
      return op;
    }
    function putVarint(value, output, op) {
      do {
        output[op] = value & 127;
        value = value >>> 7;
        if (value > 0) {
          output[op] += 128;
        }
        op += 1;
      } while (value > 0);
      return op;
    }
    function SnappyCompressor(uncompressed) {
      this.array = uncompressed;
    }
    SnappyCompressor.prototype.maxCompressedLength = function() {
      var sourceLen = this.array.length;
      return 32 + sourceLen + Math.floor(sourceLen / 6);
    };
    SnappyCompressor.prototype.compressToBuffer = function(outBuffer) {
      var array = this.array;
      var length5 = array.length;
      var pos = 0;
      var outPos = 0;
      var fragmentSize;
      outPos = putVarint(length5, outBuffer, outPos);
      while (pos < length5) {
        fragmentSize = Math.min(length5 - pos, BLOCK_SIZE);
        outPos = compressFragment(array, pos, fragmentSize, outBuffer, outPos);
        pos += fragmentSize;
      }
      return outPos;
    };
    exports.SnappyCompressor = SnappyCompressor;
  }
});

// node_modules/snappyjs/index.js
var require_snappyjs = __commonJS({
  "node_modules/snappyjs/index.js"(exports) {
    "use strict";
    function isNode() {
      if (typeof process === "object") {
        if (typeof process.versions === "object") {
          if (typeof process.versions.node !== "undefined") {
            return true;
          }
        }
      }
      return false;
    }
    function isUint8Array(object) {
      return object instanceof Uint8Array && (!isNode() || !Buffer.isBuffer(object));
    }
    function isArrayBuffer(object) {
      return object instanceof ArrayBuffer;
    }
    function isBuffer(object) {
      if (!isNode()) {
        return false;
      }
      return Buffer.isBuffer(object);
    }
    var SnappyDecompressor = require_snappy_decompressor().SnappyDecompressor;
    var SnappyCompressor = require_snappy_compressor().SnappyCompressor;
    var TYPE_ERROR_MSG = "Argument compressed must be type of ArrayBuffer, Buffer, or Uint8Array";
    function uncompress2(compressed) {
      if (!isUint8Array(compressed) && !isArrayBuffer(compressed) && !isBuffer(compressed)) {
        throw new TypeError(TYPE_ERROR_MSG);
      }
      var uint8Mode = false;
      var arrayBufferMode = false;
      if (isUint8Array(compressed)) {
        uint8Mode = true;
      } else if (isArrayBuffer(compressed)) {
        arrayBufferMode = true;
        compressed = new Uint8Array(compressed);
      }
      var decompressor = new SnappyDecompressor(compressed);
      var length5 = decompressor.readUncompressedLength();
      if (length5 === -1) {
        throw new Error("Invalid Snappy bitstream");
      }
      var uncompressed, uncompressedView;
      if (uint8Mode) {
        uncompressed = new Uint8Array(length5);
        if (!decompressor.uncompressToBuffer(uncompressed)) {
          throw new Error("Invalid Snappy bitstream");
        }
      } else if (arrayBufferMode) {
        uncompressed = new ArrayBuffer(length5);
        uncompressedView = new Uint8Array(uncompressed);
        if (!decompressor.uncompressToBuffer(uncompressedView)) {
          throw new Error("Invalid Snappy bitstream");
        }
      } else {
        uncompressed = Buffer.alloc(length5);
        if (!decompressor.uncompressToBuffer(uncompressed)) {
          throw new Error("Invalid Snappy bitstream");
        }
      }
      return uncompressed;
    }
    function compress2(uncompressed) {
      if (!isUint8Array(uncompressed) && !isArrayBuffer(uncompressed) && !isBuffer(uncompressed)) {
        throw new TypeError(TYPE_ERROR_MSG);
      }
      var uint8Mode = false;
      var arrayBufferMode = false;
      if (isUint8Array(uncompressed)) {
        uint8Mode = true;
      } else if (isArrayBuffer(uncompressed)) {
        arrayBufferMode = true;
        uncompressed = new Uint8Array(uncompressed);
      }
      var compressor = new SnappyCompressor(uncompressed);
      var maxLength = compressor.maxCompressedLength();
      var compressed, compressedView;
      var length5;
      if (uint8Mode) {
        compressed = new Uint8Array(maxLength);
        length5 = compressor.compressToBuffer(compressed);
      } else if (arrayBufferMode) {
        compressed = new ArrayBuffer(maxLength);
        compressedView = new Uint8Array(compressed);
        length5 = compressor.compressToBuffer(compressedView);
      } else {
        compressed = Buffer.alloc(maxLength);
        length5 = compressor.compressToBuffer(compressed);
      }
      if (!compressed.slice) {
        var compressedArray = new Uint8Array(Array.prototype.slice.call(compressed, 0, length5));
        if (uint8Mode) {
          return compressedArray;
        } else if (arrayBufferMode) {
          return compressedArray.buffer;
        } else {
          throw new Error("Not implemented");
        }
      }
      return compressed.slice(0, length5);
    }
    exports.uncompress = uncompress2;
    exports.compress = compress2;
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d2;
      e2 = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i], i += d2, nBits -= 8) {
      }
      m = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d2, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d2, m /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i - d2] |= s * 128;
    };
  }
});

// node_modules/pbf/index.js
var require_pbf = __commonJS({
  "node_modules/pbf/index.js"(exports, module) {
    "use strict";
    module.exports = Pbf;
    var ieee754 = require_ieee754();
    function Pbf(buf) {
      this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
      this.pos = 0;
      this.type = 0;
      this.length = this.buf.length;
    }
    Pbf.Varint = 0;
    Pbf.Fixed64 = 1;
    Pbf.Bytes = 2;
    Pbf.Fixed32 = 5;
    var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
    var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
    var TEXT_DECODER_MIN_LENGTH = 12;
    var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
    Pbf.prototype = {
      destroy: function() {
        this.buf = null;
      },
      // === READING =================================================================
      readFields: function(readField, result, end) {
        end = end || this.length;
        while (this.pos < end) {
          var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
          this.type = val & 7;
          readField(tag, result, this);
          if (this.pos === startPos) this.skip(val);
        }
        return result;
      },
      readMessage: function(readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
      },
      readFixed32: function() {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      readSFixed32: function() {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
      },
      // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
      readFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readSFixed64: function() {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
      },
      readFloat: function() {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
      },
      readDouble: function() {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
      },
      readVarint: function(isSigned) {
        var buf = this.buf, val, b3;
        b3 = buf[this.pos++];
        val = b3 & 127;
        if (b3 < 128) return val;
        b3 = buf[this.pos++];
        val |= (b3 & 127) << 7;
        if (b3 < 128) return val;
        b3 = buf[this.pos++];
        val |= (b3 & 127) << 14;
        if (b3 < 128) return val;
        b3 = buf[this.pos++];
        val |= (b3 & 127) << 21;
        if (b3 < 128) return val;
        b3 = buf[this.pos];
        val |= (b3 & 15) << 28;
        return readVarintRemainder(val, isSigned, this);
      },
      readVarint64: function() {
        return this.readVarint(true);
      },
      readSVarint: function() {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2;
      },
      readBoolean: function() {
        return Boolean(this.readVarint());
      },
      readString: function() {
        var end = this.readVarint() + this.pos;
        var pos = this.pos;
        this.pos = end;
        if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
          return readUtf8TextDecoder(this.buf, pos, end);
        }
        return readUtf8(this.buf, pos, end);
      },
      readBytes: function() {
        var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
      },
      // verbose for performance reasons; doesn't affect gzipped size
      readPackedVarint: function(arr, isSigned) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readVarint(isSigned));
        return arr;
      },
      readPackedSVarint: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSVarint());
        return arr;
      },
      readPackedBoolean: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readBoolean());
        return arr;
      },
      readPackedFloat: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFloat());
        return arr;
      },
      readPackedDouble: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readDouble());
        return arr;
      },
      readPackedFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed32());
        return arr;
      },
      readPackedSFixed32: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed32());
        return arr;
      },
      readPackedFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readFixed64());
        return arr;
      },
      readPackedSFixed64: function(arr) {
        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());
        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) arr.push(this.readSFixed64());
        return arr;
      },
      skip: function(val) {
        var type = val & 7;
        if (type === Pbf.Varint) while (this.buf[this.pos++] > 127) {
        }
        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;
        else if (type === Pbf.Fixed32) this.pos += 4;
        else if (type === Pbf.Fixed64) this.pos += 8;
        else throw new Error("Unimplemented type: " + type);
      },
      // === WRITING =================================================================
      writeTag: function(tag, type) {
        this.writeVarint(tag << 3 | type);
      },
      realloc: function(min3) {
        var length5 = this.length || 16;
        while (length5 < this.pos + min3) length5 *= 2;
        if (length5 !== this.length) {
          var buf = new Uint8Array(length5);
          buf.set(this.buf);
          this.buf = buf;
          this.length = length5;
        }
      },
      finish: function() {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
      },
      writeFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeSFixed32: function(val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
      },
      writeFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeSFixed64: function(val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
      },
      writeVarint: function(val) {
        val = +val || 0;
        if (val > 268435455 || val < 0) {
          writeBigVarint(val, this);
          return;
        }
        this.realloc(4);
        this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
        if (val <= 127) return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127) return;
        this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
        if (val <= 127) return;
        this.buf[this.pos++] = val >>> 7 & 127;
      },
      writeSVarint: function(val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
      },
      writeBoolean: function(val) {
        this.writeVarint(Boolean(val));
      },
      writeString: function(str5) {
        str5 = String(str5);
        this.realloc(str5.length * 4);
        this.pos++;
        var startPos = this.pos;
        this.pos = writeUtf8(this.buf, str5, this.pos);
        var len4 = this.pos - startPos;
        if (len4 >= 128) makeRoomForExtraLength(startPos, len4, this);
        this.pos = startPos - 1;
        this.writeVarint(len4);
        this.pos += len4;
      },
      writeFloat: function(val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
      },
      writeDouble: function(val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
      },
      writeBytes: function(buffer) {
        var len4 = buffer.length;
        this.writeVarint(len4);
        this.realloc(len4);
        for (var i = 0; i < len4; i++) this.buf[this.pos++] = buffer[i];
      },
      writeRawMessage: function(fn, obj) {
        this.pos++;
        var startPos = this.pos;
        fn(obj, this);
        var len4 = this.pos - startPos;
        if (len4 >= 128) makeRoomForExtraLength(startPos, len4, this);
        this.pos = startPos - 1;
        this.writeVarint(len4);
        this.pos += len4;
      },
      writeMessage: function(tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
      },
      writePackedVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedVarint, arr);
      },
      writePackedSVarint: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);
      },
      writePackedBoolean: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);
      },
      writePackedFloat: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFloat, arr);
      },
      writePackedDouble: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedDouble, arr);
      },
      writePackedFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);
      },
      writePackedSFixed32: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr);
      },
      writePackedFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);
      },
      writePackedSFixed64: function(tag, arr) {
        if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr);
      },
      writeBytesField: function(tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
      },
      writeFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
      },
      writeSFixed32Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
      },
      writeFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
      },
      writeSFixed64Field: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
      },
      writeVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
      },
      writeSVarintField: function(tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
      },
      writeStringField: function(tag, str5) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str5);
      },
      writeFloatField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
      },
      writeDoubleField: function(tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
      },
      writeBooleanField: function(tag, val) {
        this.writeVarintField(tag, Boolean(val));
      }
    };
    function readVarintRemainder(l, s, p) {
      var buf = p.buf, h, b3;
      b3 = buf[p.pos++];
      h = (b3 & 112) >> 4;
      if (b3 < 128) return toNum(l, h, s);
      b3 = buf[p.pos++];
      h |= (b3 & 127) << 3;
      if (b3 < 128) return toNum(l, h, s);
      b3 = buf[p.pos++];
      h |= (b3 & 127) << 10;
      if (b3 < 128) return toNum(l, h, s);
      b3 = buf[p.pos++];
      h |= (b3 & 127) << 17;
      if (b3 < 128) return toNum(l, h, s);
      b3 = buf[p.pos++];
      h |= (b3 & 127) << 24;
      if (b3 < 128) return toNum(l, h, s);
      b3 = buf[p.pos++];
      h |= (b3 & 1) << 31;
      if (b3 < 128) return toNum(l, h, s);
      throw new Error("Expected varint not more than 10 bytes");
    }
    function readPackedEnd(pbf) {
      return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    }
    function toNum(low, high, isSigned) {
      if (isSigned) {
        return high * 4294967296 + (low >>> 0);
      }
      return (high >>> 0) * 4294967296 + (low >>> 0);
    }
    function writeBigVarint(val, pbf) {
      var low, high;
      if (val >= 0) {
        low = val % 4294967296 | 0;
        high = val / 4294967296 | 0;
      } else {
        low = ~(-val % 4294967296);
        high = ~(-val / 4294967296);
        if (low ^ 4294967295) {
          low = low + 1 | 0;
        } else {
          low = 0;
          high = high + 1 | 0;
        }
      }
      if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
        throw new Error("Given varint doesn't fit into 10 bytes");
      }
      pbf.realloc(10);
      writeBigVarintLow(low, high, pbf);
      writeBigVarintHigh(high, pbf);
    }
    function writeBigVarintLow(low, high, pbf) {
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos++] = low & 127 | 128;
      low >>>= 7;
      pbf.buf[pbf.pos] = low & 127;
    }
    function writeBigVarintHigh(high, pbf) {
      var lsb2 = (high & 7) << 4;
      pbf.buf[pbf.pos++] |= lsb2 | ((high >>>= 3) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
      if (!high) return;
      pbf.buf[pbf.pos++] = high & 127;
    }
    function makeRoomForExtraLength(startPos, len4, pbf) {
      var extraLen = len4 <= 16383 ? 1 : len4 <= 2097151 ? 2 : len4 <= 268435455 ? 3 : Math.floor(Math.log(len4) / (Math.LN2 * 7));
      pbf.realloc(extraLen);
      for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];
    }
    function writePackedVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);
    }
    function writePackedSVarint(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);
    }
    function writePackedFloat(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);
    }
    function writePackedDouble(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);
    }
    function writePackedBoolean(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);
    }
    function writePackedFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);
    }
    function writePackedSFixed32(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]);
    }
    function writePackedFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);
    }
    function writePackedSFixed64(arr, pbf) {
      for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]);
    }
    function readUInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
    }
    function writeInt32(buf, val, pos) {
      buf[pos] = val;
      buf[pos + 1] = val >>> 8;
      buf[pos + 2] = val >>> 16;
      buf[pos + 3] = val >>> 24;
    }
    function readInt32(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
    }
    function readUtf8(buf, pos, end) {
      var str5 = "";
      var i = pos;
      while (i < end) {
        var b0 = buf[i];
        var c2 = null;
        var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
        if (i + bytesPerSequence > end) break;
        var b1, b22, b3;
        if (bytesPerSequence === 1) {
          if (b0 < 128) {
            c2 = b0;
          }
        } else if (bytesPerSequence === 2) {
          b1 = buf[i + 1];
          if ((b1 & 192) === 128) {
            c2 = (b0 & 31) << 6 | b1 & 63;
            if (c2 <= 127) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 3) {
          b1 = buf[i + 1];
          b22 = buf[i + 2];
          if ((b1 & 192) === 128 && (b22 & 192) === 128) {
            c2 = (b0 & 15) << 12 | (b1 & 63) << 6 | b22 & 63;
            if (c2 <= 2047 || c2 >= 55296 && c2 <= 57343) {
              c2 = null;
            }
          }
        } else if (bytesPerSequence === 4) {
          b1 = buf[i + 1];
          b22 = buf[i + 2];
          b3 = buf[i + 3];
          if ((b1 & 192) === 128 && (b22 & 192) === 128 && (b3 & 192) === 128) {
            c2 = (b0 & 15) << 18 | (b1 & 63) << 12 | (b22 & 63) << 6 | b3 & 63;
            if (c2 <= 65535 || c2 >= 1114112) {
              c2 = null;
            }
          }
        }
        if (c2 === null) {
          c2 = 65533;
          bytesPerSequence = 1;
        } else if (c2 > 65535) {
          c2 -= 65536;
          str5 += String.fromCharCode(c2 >>> 10 & 1023 | 55296);
          c2 = 56320 | c2 & 1023;
        }
        str5 += String.fromCharCode(c2);
        i += bytesPerSequence;
      }
      return str5;
    }
    function readUtf8TextDecoder(buf, pos, end) {
      return utf8TextDecoder.decode(buf.subarray(pos, end));
    }
    function writeUtf8(buf, str5, pos) {
      for (var i = 0, c2, lead; i < str5.length; i++) {
        c2 = str5.charCodeAt(i);
        if (c2 > 55295 && c2 < 57344) {
          if (lead) {
            if (c2 < 56320) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
              lead = c2;
              continue;
            } else {
              c2 = lead - 55296 << 10 | c2 - 56320 | 65536;
              lead = null;
            }
          } else {
            if (c2 > 56319 || i + 1 === str5.length) {
              buf[pos++] = 239;
              buf[pos++] = 191;
              buf[pos++] = 189;
            } else {
              lead = c2;
            }
            continue;
          }
        } else if (lead) {
          buf[pos++] = 239;
          buf[pos++] = 191;
          buf[pos++] = 189;
          lead = null;
        }
        if (c2 < 128) {
          buf[pos++] = c2;
        } else {
          if (c2 < 2048) {
            buf[pos++] = c2 >> 6 | 192;
          } else {
            if (c2 < 65536) {
              buf[pos++] = c2 >> 12 | 224;
            } else {
              buf[pos++] = c2 >> 18 | 240;
              buf[pos++] = c2 >> 12 & 63 | 128;
            }
            buf[pos++] = c2 >> 6 & 63 | 128;
          }
          buf[pos++] = c2 & 63 | 128;
        }
      }
      return pos;
    }
  }
});

// node_modules/@deck.gl/geo-layers/dist/geo-cell-layer/GeoCellLayer.js
var defaultProps = {
  ...polygon_layer_default.defaultProps
};
var GeoCellLayer = class extends composite_layer_default {
  /** Implement to generate props to create geometry. */
  indexToBounds() {
    return null;
  }
  renderLayers() {
    const { elevationScale, extruded, wireframe, filled, stroked, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, lineJointRounded, lineMiterLimit, lineDashJustified, getElevation, getFillColor, getLineColor, getLineWidth } = this.props;
    const { updateTriggers, material, transitions } = this.props;
    const CellLayer = this.getSubLayerClass("cell", polygon_layer_default);
    const { updateTriggers: boundsUpdateTriggers, ...boundsProps } = this.indexToBounds() || {};
    return new CellLayer({
      filled,
      wireframe,
      extruded,
      elevationScale,
      stroked,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      lineDashJustified,
      material,
      transitions,
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth
    }, this.getSubLayerProps({
      id: "cell",
      updateTriggers: updateTriggers && {
        ...boundsUpdateTriggers,
        getElevation: updateTriggers.getElevation,
        getFillColor: updateTriggers.getFillColor,
        getLineColor: updateTriggers.getLineColor,
        getLineWidth: updateTriggers.getLineWidth
      }
    }), boundsProps);
  }
};
GeoCellLayer.layerName = "GeoCellLayer";
GeoCellLayer.defaultProps = defaultProps;
var GeoCellLayer_default = GeoCellLayer;

// node_modules/a5-js/dist/a5.js
var __defProp = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name12 in all)
    __defProp(target, name12, { get: all[name12], enumerable: true });
};
var common_exports = {};
__export2(common_exports, {
  ARRAY_TYPE: () => ARRAY_TYPE,
  EPSILON: () => EPSILON,
  RANDOM: () => RANDOM,
  equals: () => equals2,
  setMatrixArrayType: () => setMatrixArrayType,
  toRadian: () => toRadian
});
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a22) {
  return a22 * degree;
}
function equals2(a22, b22) {
  return Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
}
if (!Math.hypot) Math.hypot = function() {
  var y = 0, i = arguments.length;
  while (i--) {
    y += arguments[i] * arguments[i];
  }
  return Math.sqrt(y);
};
var mat2_exports = {};
__export2(mat2_exports, {
  LDU: () => LDU,
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals22,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}
function clone(a22) {
  var out = new ARRAY_TYPE(4);
  out[0] = a22[0];
  out[1] = a22[1];
  out[2] = a22[2];
  out[3] = a22[3];
  return out;
}
function copy(out, a22) {
  out[0] = a22[0];
  out[1] = a22[1];
  out[2] = a22[2];
  out[3] = a22[3];
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function fromValues(m00, m01, m10, m11) {
  var out = new ARRAY_TYPE(4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
function transpose(out, a22) {
  if (out === a22) {
    var a1 = a22[1];
    out[1] = a22[2];
    out[2] = a1;
  } else {
    out[0] = a22[0];
    out[1] = a22[2];
    out[2] = a22[1];
    out[3] = a22[3];
  }
  return out;
}
function invert(out, a22) {
  var a0 = a22[0], a1 = a22[1], a222 = a22[2], a3 = a22[3];
  var det = a0 * a3 - a222 * a1;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a222 * det;
  out[3] = a0 * det;
  return out;
}
function adjoint(out, a22) {
  var a0 = a22[0];
  out[0] = a22[3];
  out[1] = -a22[1];
  out[2] = -a22[2];
  out[3] = a0;
  return out;
}
function determinant(a22) {
  return a22[0] * a22[3] - a22[2] * a22[1];
}
function multiply(out, a22, b22) {
  var a0 = a22[0], a1 = a22[1], a222 = a22[2], a3 = a22[3];
  var b0 = b22[0], b1 = b22[1], b222 = b22[2], b3 = b22[3];
  out[0] = a0 * b0 + a222 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b222 + a222 * b3;
  out[3] = a1 * b222 + a3 * b3;
  return out;
}
function rotate(out, a22, rad) {
  var a0 = a22[0], a1 = a22[1], a222 = a22[2], a3 = a22[3];
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = a0 * c2 + a222 * s;
  out[1] = a1 * c2 + a3 * s;
  out[2] = a0 * -s + a222 * c2;
  out[3] = a1 * -s + a3 * c2;
  return out;
}
function scale(out, a22, v2) {
  var a0 = a22[0], a1 = a22[1], a222 = a22[2], a3 = a22[3];
  var v0 = v2[0], v1 = v2[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a222 * v1;
  out[3] = a3 * v1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s;
  out[2] = -s;
  out[3] = c2;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v2[1];
  return out;
}
function str(a22) {
  return "mat2(" + a22[0] + ", " + a22[1] + ", " + a22[2] + ", " + a22[3] + ")";
}
function frob(a22) {
  return Math.hypot(a22[0], a22[1], a22[2], a22[3]);
}
function LDU(L2, D2, U, a22) {
  L2[2] = a22[2] / a22[0];
  U[0] = a22[0];
  U[1] = a22[1];
  U[3] = a22[3] - L2[2] * U[1];
  return [L2, D2, U];
}
function add(out, a22, b22) {
  out[0] = a22[0] + b22[0];
  out[1] = a22[1] + b22[1];
  out[2] = a22[2] + b22[2];
  out[3] = a22[3] + b22[3];
  return out;
}
function subtract(out, a22, b22) {
  out[0] = a22[0] - b22[0];
  out[1] = a22[1] - b22[1];
  out[2] = a22[2] - b22[2];
  out[3] = a22[3] - b22[3];
  return out;
}
function exactEquals(a22, b22) {
  return a22[0] === b22[0] && a22[1] === b22[1] && a22[2] === b22[2] && a22[3] === b22[3];
}
function equals22(a22, b22) {
  var a0 = a22[0], a1 = a22[1], a222 = a22[2], a3 = a22[3];
  var b0 = b22[0], b1 = b22[1], b222 = b22[2], b3 = b22[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a222 - b222) <= EPSILON * Math.max(1, Math.abs(a222), Math.abs(b222)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
function multiplyScalar(out, a22, b22) {
  out[0] = a22[0] * b22;
  out[1] = a22[1] * b22;
  out[2] = a22[2] * b22;
  out[3] = a22[3] * b22;
  return out;
}
function multiplyScalarAndAdd(out, a22, b22, scale7) {
  out[0] = a22[0] + b22[0] * scale7;
  out[1] = a22[1] + b22[1] * scale7;
  out[2] = a22[2] + b22[2] * scale7;
  out[3] = a22[3] + b22[3] * scale7;
  return out;
}
var mul = multiply;
var sub = subtract;
function create2() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
var quat_exports = {};
__export2(quat_exports, {
  add: () => add4,
  calculateW: () => calculateW,
  clone: () => clone4,
  conjugate: () => conjugate,
  copy: () => copy4,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues4,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity2,
  invert: () => invert2,
  len: () => len2,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul3,
  multiply: () => multiply3,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random2,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  rotationTo: () => rotationTo,
  scale: () => scale4,
  set: () => set4,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen2,
  squaredLength: () => squaredLength3,
  str: () => str3
});
var vec3_exports2 = {};
__export2(vec3_exports2, {
  add: () => add2,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals2,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues2,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp2,
  max: () => max,
  min: () => min,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set2,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone2(a22) {
  var out = new ARRAY_TYPE(3);
  out[0] = a22[0];
  out[1] = a22[1];
  out[2] = a22[2];
  return out;
}
function length(a22) {
  var x = a22[0];
  var y = a22[1];
  var z = a22[2];
  return Math.hypot(x, y, z);
}
function fromValues2(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy2(out, a22) {
  out[0] = a22[0];
  out[1] = a22[1];
  out[2] = a22[2];
  return out;
}
function set2(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add2(out, a22, b22) {
  out[0] = a22[0] + b22[0];
  out[1] = a22[1] + b22[1];
  out[2] = a22[2] + b22[2];
  return out;
}
function subtract2(out, a22, b22) {
  out[0] = a22[0] - b22[0];
  out[1] = a22[1] - b22[1];
  out[2] = a22[2] - b22[2];
  return out;
}
function multiply2(out, a22, b22) {
  out[0] = a22[0] * b22[0];
  out[1] = a22[1] * b22[1];
  out[2] = a22[2] * b22[2];
  return out;
}
function divide(out, a22, b22) {
  out[0] = a22[0] / b22[0];
  out[1] = a22[1] / b22[1];
  out[2] = a22[2] / b22[2];
  return out;
}
function ceil(out, a22) {
  out[0] = Math.ceil(a22[0]);
  out[1] = Math.ceil(a22[1]);
  out[2] = Math.ceil(a22[2]);
  return out;
}
function floor(out, a22) {
  out[0] = Math.floor(a22[0]);
  out[1] = Math.floor(a22[1]);
  out[2] = Math.floor(a22[2]);
  return out;
}
function min(out, a22, b22) {
  out[0] = Math.min(a22[0], b22[0]);
  out[1] = Math.min(a22[1], b22[1]);
  out[2] = Math.min(a22[2], b22[2]);
  return out;
}
function max(out, a22, b22) {
  out[0] = Math.max(a22[0], b22[0]);
  out[1] = Math.max(a22[1], b22[1]);
  out[2] = Math.max(a22[2], b22[2]);
  return out;
}
function round(out, a22) {
  out[0] = Math.round(a22[0]);
  out[1] = Math.round(a22[1]);
  out[2] = Math.round(a22[2]);
  return out;
}
function scale2(out, a22, b22) {
  out[0] = a22[0] * b22;
  out[1] = a22[1] * b22;
  out[2] = a22[2] * b22;
  return out;
}
function scaleAndAdd(out, a22, b22, scale7) {
  out[0] = a22[0] + b22[0] * scale7;
  out[1] = a22[1] + b22[1] * scale7;
  out[2] = a22[2] + b22[2] * scale7;
  return out;
}
function distance(a22, b22) {
  var x = b22[0] - a22[0];
  var y = b22[1] - a22[1];
  var z = b22[2] - a22[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a22, b22) {
  var x = b22[0] - a22[0];
  var y = b22[1] - a22[1];
  var z = b22[2] - a22[2];
  return x * x + y * y + z * z;
}
function squaredLength(a22) {
  var x = a22[0];
  var y = a22[1];
  var z = a22[2];
  return x * x + y * y + z * z;
}
function negate(out, a22) {
  out[0] = -a22[0];
  out[1] = -a22[1];
  out[2] = -a22[2];
  return out;
}
function inverse(out, a22) {
  out[0] = 1 / a22[0];
  out[1] = 1 / a22[1];
  out[2] = 1 / a22[2];
  return out;
}
function normalize(out, a22) {
  var x = a22[0];
  var y = a22[1];
  var z = a22[2];
  var len4 = x * x + y * y + z * z;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a22[0] * len4;
  out[1] = a22[1] * len4;
  out[2] = a22[2] * len4;
  return out;
}
function dot(a22, b22) {
  return a22[0] * b22[0] + a22[1] * b22[1] + a22[2] * b22[2];
}
function cross(out, a22, b22) {
  var ax = a22[0], ay = a22[1], az = a22[2];
  var bx = b22[0], by = b22[1], bz = b22[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp2(out, a22, b22, t) {
  var ax = a22[0];
  var ay = a22[1];
  var az = a22[2];
  out[0] = ax + t * (b22[0] - ax);
  out[1] = ay + t * (b22[1] - ay);
  out[2] = az + t * (b22[2] - az);
  return out;
}
function hermite(out, a22, b22, c2, d2, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a22[0] * factor1 + b22[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a22[1] * factor1 + b22[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a22[2] * factor1 + b22[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function bezier(out, a22, b22, c2, d2, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a22[0] * factor1 + b22[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a22[1] * factor1 + b22[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a22[2] * factor1 + b22[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function random(out, scale7) {
  scale7 = scale7 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale7;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale7;
  return out;
}
function transformMat4(out, a22, m) {
  var x = a22[0], y = a22[1], z = a22[2];
  var w2 = m[3] * x + m[7] * y + m[11] * z + m[15];
  w2 = w2 || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w2;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w2;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w2;
  return out;
}
function transformMat3(out, a22, m) {
  var x = a22[0], y = a22[1], z = a22[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a22, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a22[0], y = a22[1], z = a22[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a22, b22, rad) {
  var p = [], r = [];
  p[0] = a22[0] - b22[0];
  p[1] = a22[1] - b22[1];
  p[2] = a22[2] - b22[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b22[0];
  out[1] = r[1] + b22[1];
  out[2] = r[2] + b22[2];
  return out;
}
function rotateY(out, a22, b22, rad) {
  var p = [], r = [];
  p[0] = a22[0] - b22[0];
  p[1] = a22[1] - b22[1];
  p[2] = a22[2] - b22[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b22[0];
  out[1] = r[1] + b22[1];
  out[2] = r[2] + b22[2];
  return out;
}
function rotateZ(out, a22, b22, rad) {
  var p = [], r = [];
  p[0] = a22[0] - b22[0];
  p[1] = a22[1] - b22[1];
  p[2] = a22[2] - b22[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b22[0];
  out[1] = r[1] + b22[1];
  out[2] = r[2] + b22[2];
  return out;
}
function angle(a22, b22) {
  var ax = a22[0], ay = a22[1], az = a22[2], bx = b22[0], by = b22[1], bz = b22[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a22, b22) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str2(a22) {
  return "vec3(" + a22[0] + ", " + a22[1] + ", " + a22[2] + ")";
}
function exactEquals2(a22, b22) {
  return a22[0] === b22[0] && a22[1] === b22[1] && a22[2] === b22[2];
}
function equals3(a22, b22) {
  var a0 = a22[0], a1 = a22[1], a222 = a22[2];
  var b0 = b22[0], b1 = b22[1], b222 = b22[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a222 - b222) <= EPSILON * Math.max(1, Math.abs(a222), Math.abs(b222));
}
var sub2 = subtract2;
var mul2 = multiply2;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a22, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a22.length);
    } else {
      l = a22.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a22[i];
      vec[1] = a22[i + 1];
      vec[2] = a22[i + 2];
      fn(vec, vec, arg);
      a22[i] = vec[0];
      a22[i + 1] = vec[1];
      a22[i + 2] = vec[2];
    }
    return a22;
  };
}();
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone3(a22) {
  var out = new ARRAY_TYPE(4);
  out[0] = a22[0];
  out[1] = a22[1];
  out[2] = a22[2];
  out[3] = a22[3];
  return out;
}
function fromValues3(x, y, z, w2) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w2;
  return out;
}
function copy3(out, a22) {
  out[0] = a22[0];
  out[1] = a22[1];
  out[2] = a22[2];
  out[3] = a22[3];
  return out;
}
function set3(out, x, y, z, w2) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w2;
  return out;
}
function add3(out, a22, b22) {
  out[0] = a22[0] + b22[0];
  out[1] = a22[1] + b22[1];
  out[2] = a22[2] + b22[2];
  out[3] = a22[3] + b22[3];
  return out;
}
function scale3(out, a22, b22) {
  out[0] = a22[0] * b22;
  out[1] = a22[1] * b22;
  out[2] = a22[2] * b22;
  out[3] = a22[3] * b22;
  return out;
}
function length2(a22) {
  var x = a22[0];
  var y = a22[1];
  var z = a22[2];
  var w2 = a22[3];
  return Math.hypot(x, y, z, w2);
}
function squaredLength2(a22) {
  var x = a22[0];
  var y = a22[1];
  var z = a22[2];
  var w2 = a22[3];
  return x * x + y * y + z * z + w2 * w2;
}
function normalize2(out, a22) {
  var x = a22[0];
  var y = a22[1];
  var z = a22[2];
  var w2 = a22[3];
  var len4 = x * x + y * y + z * z + w2 * w2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = x * len4;
  out[1] = y * len4;
  out[2] = z * len4;
  out[3] = w2 * len4;
  return out;
}
function dot2(a22, b22) {
  return a22[0] * b22[0] + a22[1] * b22[1] + a22[2] * b22[2] + a22[3] * b22[3];
}
function lerp22(out, a22, b22, t) {
  var ax = a22[0];
  var ay = a22[1];
  var az = a22[2];
  var aw = a22[3];
  out[0] = ax + t * (b22[0] - ax);
  out[1] = ay + t * (b22[1] - ay);
  out[2] = az + t * (b22[2] - az);
  out[3] = aw + t * (b22[3] - aw);
  return out;
}
function exactEquals3(a22, b22) {
  return a22[0] === b22[0] && a22[1] === b22[1] && a22[2] === b22[2] && a22[3] === b22[3];
}
function equals4(a22, b22) {
  var a0 = a22[0], a1 = a22[1], a222 = a22[2], a3 = a22[3];
  var b0 = b22[0], b1 = b22[1], b222 = b22[2], b3 = b22[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a222 - b222) <= EPSILON * Math.max(1, Math.abs(a222), Math.abs(b222)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var forEach2 = function() {
  var vec = create4();
  return function(a22, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a22.length);
    } else {
      l = a22.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a22[i];
      vec[1] = a22[i + 1];
      vec[2] = a22[i + 2];
      vec[3] = a22[i + 3];
      fn(vec, vec, arg);
      a22[i] = vec[0];
      a22[i + 1] = vec[1];
      a22[i + 2] = vec[2];
      a22[i + 3] = vec[3];
    }
    return a22;
  };
}();
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a22, b22) {
  var dotproduct = dot3(a22, b22);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply3(out, a22, b22) {
  var ax = a22[0], ay = a22[1], az = a22[2], aw = a22[3];
  var bx = b22[0], by = b22[1], bz = b22[2], bw = b22[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX2(out, a22, rad) {
  rad *= 0.5;
  var ax = a22[0], ay = a22[1], az = a22[2], aw = a22[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY2(out, a22, rad) {
  rad *= 0.5;
  var ax = a22[0], ay = a22[1], az = a22[2], aw = a22[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ2(out, a22, rad) {
  rad *= 0.5;
  var ax = a22[0], ay = a22[1], az = a22[2], aw = a22[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a22) {
  var x = a22[0], y = a22[1], z = a22[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a22) {
  var x = a22[0], y = a22[1], z = a22[2], w2 = a22[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w2);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a22) {
  var x = a22[0], y = a22[1], z = a22[2], w2 = a22[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w2) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w2 * w2);
  return out;
}
function pow(out, a22, b22) {
  ln(out, a22);
  scale4(out, out, b22);
  exp(out, out);
  return out;
}
function slerp(out, a22, b22, t) {
  var ax = a22[0], ay = a22[1], az = a22[2], aw = a22[3];
  var bx = b22[0], by = b22[1], bz = b22[2], bw = b22[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random2(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert2(out, a22) {
  var a0 = a22[0], a1 = a22[1], a222 = a22[2], a3 = a22[3];
  var dot5 = a0 * a0 + a1 * a1 + a222 * a222 + a3 * a3;
  var invDot = dot5 ? 1 / dot5 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a222 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a22) {
  out[0] = -a22[0];
  out[1] = -a22[1];
  out[2] = -a22[2];
  out[3] = a22[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str3(a22) {
  return "quat(" + a22[0] + ", " + a22[1] + ", " + a22[2] + ", " + a22[3] + ")";
}
var clone4 = clone3;
var fromValues4 = fromValues3;
var copy4 = copy3;
var set4 = set3;
var add4 = add3;
var mul3 = multiply3;
var scale4 = scale3;
var dot3 = dot2;
var lerp3 = lerp22;
var length3 = length2;
var len2 = length3;
var squaredLength3 = squaredLength2;
var sqrLen2 = squaredLength3;
var normalize3 = normalize2;
var exactEquals4 = exactEquals3;
var equals5 = equals4;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues2(1, 0, 0);
  var yUnitVec3 = fromValues2(0, 1, 0);
  return function(out, a22, b22) {
    var dot5 = dot(a22, b22);
    if (dot5 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a22);
      if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a22);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a22, b22);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot5;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a22, b22, c2, d2, t) {
    slerp(temp1, a22, d2, t);
    slerp(temp2, b22, c2, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create2();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();
var vec2_exports = {};
__export2(vec2_exports, {
  add: () => add5,
  angle: () => angle2,
  ceil: () => ceil2,
  clone: () => clone5,
  copy: () => copy5,
  create: () => create6,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals5,
  floor: () => floor2,
  forEach: () => forEach3,
  fromValues: () => fromValues5,
  inverse: () => inverse2,
  len: () => len3,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize4,
  random: () => random3,
  rotate: () => rotate2,
  round: () => round2,
  scale: () => scale5,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set5,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen3,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength4,
  str: () => str4,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  zero: () => zero2
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone5(a22) {
  var out = new ARRAY_TYPE(2);
  out[0] = a22[0];
  out[1] = a22[1];
  return out;
}
function fromValues5(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy5(out, a22) {
  out[0] = a22[0];
  out[1] = a22[1];
  return out;
}
function set5(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add5(out, a22, b22) {
  out[0] = a22[0] + b22[0];
  out[1] = a22[1] + b22[1];
  return out;
}
function subtract3(out, a22, b22) {
  out[0] = a22[0] - b22[0];
  out[1] = a22[1] - b22[1];
  return out;
}
function multiply4(out, a22, b22) {
  out[0] = a22[0] * b22[0];
  out[1] = a22[1] * b22[1];
  return out;
}
function divide2(out, a22, b22) {
  out[0] = a22[0] / b22[0];
  out[1] = a22[1] / b22[1];
  return out;
}
function ceil2(out, a22) {
  out[0] = Math.ceil(a22[0]);
  out[1] = Math.ceil(a22[1]);
  return out;
}
function floor2(out, a22) {
  out[0] = Math.floor(a22[0]);
  out[1] = Math.floor(a22[1]);
  return out;
}
function min2(out, a22, b22) {
  out[0] = Math.min(a22[0], b22[0]);
  out[1] = Math.min(a22[1], b22[1]);
  return out;
}
function max2(out, a22, b22) {
  out[0] = Math.max(a22[0], b22[0]);
  out[1] = Math.max(a22[1], b22[1]);
  return out;
}
function round2(out, a22) {
  out[0] = Math.round(a22[0]);
  out[1] = Math.round(a22[1]);
  return out;
}
function scale5(out, a22, b22) {
  out[0] = a22[0] * b22;
  out[1] = a22[1] * b22;
  return out;
}
function scaleAndAdd2(out, a22, b22, scale7) {
  out[0] = a22[0] + b22[0] * scale7;
  out[1] = a22[1] + b22[1] * scale7;
  return out;
}
function distance2(a22, b22) {
  var x = b22[0] - a22[0], y = b22[1] - a22[1];
  return Math.hypot(x, y);
}
function squaredDistance2(a22, b22) {
  var x = b22[0] - a22[0], y = b22[1] - a22[1];
  return x * x + y * y;
}
function length4(a22) {
  var x = a22[0], y = a22[1];
  return Math.hypot(x, y);
}
function squaredLength4(a22) {
  var x = a22[0], y = a22[1];
  return x * x + y * y;
}
function negate2(out, a22) {
  out[0] = -a22[0];
  out[1] = -a22[1];
  return out;
}
function inverse2(out, a22) {
  out[0] = 1 / a22[0];
  out[1] = 1 / a22[1];
  return out;
}
function normalize4(out, a22) {
  var x = a22[0], y = a22[1];
  var len4 = x * x + y * y;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a22[0] * len4;
  out[1] = a22[1] * len4;
  return out;
}
function dot4(a22, b22) {
  return a22[0] * b22[0] + a22[1] * b22[1];
}
function cross2(out, a22, b22) {
  var z = a22[0] * b22[1] - a22[1] * b22[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a22, b22, t) {
  var ax = a22[0], ay = a22[1];
  out[0] = ax + t * (b22[0] - ax);
  out[1] = ay + t * (b22[1] - ay);
  return out;
}
function random3(out, scale7) {
  scale7 = scale7 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale7;
  out[1] = Math.sin(r) * scale7;
  return out;
}
function transformMat2(out, a22, m) {
  var x = a22[0], y = a22[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a22, m) {
  var x = a22[0], y = a22[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a22, m) {
  var x = a22[0], y = a22[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat42(out, a22, m) {
  var x = a22[0];
  var y = a22[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate2(out, a22, b22, rad) {
  var p0 = a22[0] - b22[0], p1 = a22[1] - b22[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b22[0];
  out[1] = p0 * sinC + p1 * cosC + b22[1];
  return out;
}
function angle2(a22, b22) {
  var x1 = a22[0], y1 = a22[1], x2 = b22[0], y2 = b22[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str4(a22) {
  return "vec2(" + a22[0] + ", " + a22[1] + ")";
}
function exactEquals5(a22, b22) {
  return a22[0] === b22[0] && a22[1] === b22[1];
}
function equals6(a22, b22) {
  var a0 = a22[0], a1 = a22[1];
  var b0 = b22[0], b1 = b22[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len3 = length4;
var sub3 = subtract3;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var sqrLen3 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a22, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a22.length);
    } else {
      l = a22.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a22[i];
      vec[1] = a22[i + 1];
      fn(vec, vec, arg);
      a22[i] = vec[0];
      a22[i + 1] = vec[1];
    }
    return a22;
  };
}();
var φ = (1 + Math.sqrt(5)) / 2;
var TWO_PI = 2 * Math.PI;
var TWO_PI_OVER_5 = 2 * Math.PI / 5;
var PI_OVER_5 = Math.PI / 5;
var PI_OVER_10 = Math.PI / 10;
var dihedralAngle = 2 * Math.atan(φ);
var interhedralAngle = Math.PI - dihedralAngle;
var faceEdgeAngle = -0.5 * Math.PI + Math.acos(-1 / Math.sqrt(3 - φ));
var distanceToEdge = (Math.sqrt(5) - 1) / 2;
var distanceToVertex = 3 - Math.sqrt(5);
var Rmidedge = Math.sqrt(3 - φ);
var Rcircumscribed = Math.sqrt(3) * Rmidedge / φ;
common_exports.setMatrixArrayType(Float64Array);
var PentagonShape = class _PentagonShape {
  constructor(vertices) {
    this.vertices = vertices;
    if (!this.isWindingCorrect()) {
      this.vertices.reverse();
    }
  }
  getArea() {
    let signedArea2 = 0;
    const N = this.vertices.length;
    for (let i = 0; i < N; i++) {
      const j = (i + 1) % N;
      signedArea2 += (this.vertices[j][0] - this.vertices[i][0]) * (this.vertices[j][1] + this.vertices[i][1]);
    }
    return signedArea2;
  }
  isWindingCorrect() {
    return this.getArea() >= 0;
  }
  getVertices() {
    return this.vertices;
  }
  scale(scale7) {
    for (const vertex4 of this.vertices) {
      vec2_exports.scale(vertex4, vertex4, scale7);
    }
    return this;
  }
  /**
   * Rotates the pentagon 180 degrees (equivalent to negating x & y)
   * @returns The rotated pentagon
   */
  rotate180() {
    for (const vertex4 of this.vertices) {
      vec2_exports.negate(vertex4, vertex4);
    }
    return this;
  }
  /**
   * Reflects the pentagon over the x-axis (equivalent to negating y)
   * and reverses the winding order to maintain consistent orientation
   * @returns The reflected pentagon
   */
  reflectY() {
    for (const vertex4 of this.vertices) {
      vertex4[1] = -vertex4[1];
    }
    this.vertices.reverse();
    return this;
  }
  translate(translation2) {
    for (const vertex4 of this.vertices) {
      vec2_exports.add(vertex4, vertex4, translation2);
    }
    return this;
  }
  transform(transform2) {
    for (const vertex4 of this.vertices) {
      vec2_exports.transformMat2(vertex4, vertex4, transform2);
    }
    return this;
  }
  transform2d(transform2) {
    for (const vertex4 of this.vertices) {
      vec2_exports.transformMat2d(vertex4, vertex4, transform2);
    }
    return this;
  }
  clone() {
    const newPentagon = new _PentagonShape(this.vertices.map((v2) => vec2_exports.clone(v2)));
    return newPentagon;
  }
  getCenter() {
    const n = this.vertices.length;
    const sum = this.vertices.reduce((sum2, v2) => [sum2[0] + v2[0] / n, sum2[1] + v2[1] / n], [0, 0]);
    return sum;
  }
  /**
   * Tests if a point is inside the pentagon by checking if it's on the correct side of all edges.
   * Assumes consistent winding order (counter-clockwise).
   * @param point The point to test
   * @returns 1 if point is inside, otherwise a negative value proportional to the distance from the point to the edge
   */
  containsPoint(point2) {
    if (!this.isWindingCorrect()) {
      throw new Error("Pentagon is not counter-clockwise");
    }
    const N = this.vertices.length;
    let dMax = 1;
    for (let i = 0; i < N; i++) {
      const v1 = this.vertices[i];
      const v2 = this.vertices[(i + 1) % N];
      const dx = v1[0] - v2[0];
      const dy = v1[1] - v2[1];
      const px = point2[0] - v1[0];
      const py = point2[1] - v1[1];
      const crossProduct = dx * py - dy * px;
      if (crossProduct < 0) {
        const pLength = Math.sqrt(px * px + py * py);
        dMax = Math.min(dMax, crossProduct / pLength);
      }
    }
    return dMax;
  }
  /**
   * Splits each edge of the pentagon into the specified number of segments
   * @param segments Number of segments to split each edge into
   * @returns A new PentagonShape with more vertices, or the original PentagonShape if segments <= 1
   */
  splitEdges(segments) {
    if (segments <= 1) {
      return this;
    }
    const newVertices = [];
    const N = this.vertices.length;
    for (let i = 0; i < N; i++) {
      const v1 = this.vertices[i];
      const v2 = this.vertices[(i + 1) % N];
      newVertices.push(vec2_exports.clone(v1));
      for (let j = 1; j < segments; j++) {
        const t = j / segments;
        const interpolated = vec2_exports.create();
        vec2_exports.lerp(interpolated, v1, v2, t);
        newVertices.push(interpolated);
      }
    }
    return new _PentagonShape(newVertices);
  }
};
common_exports.setMatrixArrayType(Float64Array);
var a = [0, 0];
var b = [0, 1];
var c = [0.7885966681787006, 1.6149108024237764];
var d = [1.6171013659387945, 1.054928690397459];
var e = [Math.cos(PI_OVER_10), Math.sin(PI_OVER_10)];
var edgeMidpointD = 2 * vec2_exports.length(c) * Math.cos(PI_OVER_5);
var BASIS_ROTATION = PI_OVER_5 - Math.atan2(c[1], c[0]);
var scale6 = 2 * distanceToEdge / edgeMidpointD;
[a, b, c, d, e].forEach((v2) => {
  vec2_exports.scale(v2, v2, scale6);
  vec2_exports.rotate(v2, v2, [0, 0], BASIS_ROTATION);
});
var PENTAGON = new PentagonShape([a, b, c, d, e]);
var bisectorAngle = Math.atan2(c[1], c[0]) - PI_OVER_5;
var u = [0, 0];
var L = distanceToEdge / Math.cos(PI_OVER_5);
var V = bisectorAngle + PI_OVER_5;
var v = [L * Math.cos(V), L * Math.sin(V)];
var W = bisectorAngle - PI_OVER_5;
var w = [L * Math.cos(W), L * Math.sin(W)];
var TRIANGLE = new PentagonShape([u, v, w]);
var BASIS = mat2_exports.fromValues(v[0], v[1], w[0], w[1]);
var BASIS_INVERSE = mat2_exports.invert(mat2_exports.create(), BASIS);
var GEODETIC_TO_AUTHALIC = new Float64Array([
  -0.0022392098386786394,
  21308606513250217e-22,
  -2559257686421274e-24,
  33701965267802837e-28,
  -4667545312611249e-30,
  667492870384816e-32
]);
var AUTHALIC_TO_GEODETIC = new Float64Array([
  0.0022392089963541657,
  28831978048607556e-22,
  508622073997266e-23,
  102018123778161e-25,
  21912872306767718e-30,
  49284235482523806e-33
]);
var AuthalicProjection = class {
  /**
   * Applies coefficients using Clenshaw summation algorithm (order 6)
   * @param phi Angle in radians
   * @param C Array of coefficients
   * @returns Transformed angle in radians
   */
  applyCoefficients(phi, C2) {
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    const X = 2 * (cosPhi - sinPhi) * (cosPhi + sinPhi);
    let u0, u1;
    u0 = X * C2[5] + C2[4];
    u1 = X * u0 + C2[3];
    u0 = X * u1 - u0 + C2[2];
    u1 = X * u0 - u1 + C2[1];
    u0 = X * u1 - u0 + C2[0];
    return phi + 2 * sinPhi * cosPhi * u0;
  }
  /**
   * Converts geodetic latitude to authalic latitude
   * @param phi Geodetic latitude in radians
   * @returns Authalic latitude in radians
   */
  forward(phi) {
    return this.applyCoefficients(phi, GEODETIC_TO_AUTHALIC);
  }
  /**
   * Converts authalic latitude to geodetic latitude
   * @param phi Authalic latitude in radians
   * @returns Geodetic latitude in radians
   */
  inverse(phi) {
    return this.applyCoefficients(phi, AUTHALIC_TO_GEODETIC);
  }
};
common_exports.setMatrixArrayType(Float64Array);
var authalic = new AuthalicProjection();
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
function radToDeg(rad) {
  return rad * (180 / Math.PI);
}
function toPolar(xy) {
  const rho = vec2_exports.length(xy);
  const gamma = Math.atan2(xy[1], xy[0]);
  return [rho, gamma];
}
function toFace([rho, gamma]) {
  const x = rho * Math.cos(gamma);
  const y = rho * Math.sin(gamma);
  return [x, y];
}
function faceToBarycentric(p, [p1, p2, p3]) {
  const d31 = [p1[0] - p3[0], p1[1] - p3[1]];
  const d23 = [p3[0] - p2[0], p3[1] - p2[1]];
  const d3p = [p[0] - p3[0], p[1] - p3[1]];
  const det = d23[0] * d31[1] - d23[1] * d31[0];
  const b0 = (d23[0] * d3p[1] - d23[1] * d3p[0]) / det;
  const b1 = (d31[0] * d3p[1] - d31[1] * d3p[0]) / det;
  const b22 = 1 - (b0 + b1);
  return [b0, b1, b22];
}
function barycentricToFace(b22, [p1, p2, p3]) {
  return [
    b22[0] * p1[0] + b22[1] * p2[0] + b22[2] * p3[0],
    b22[0] * p1[1] + b22[1] * p2[1] + b22[2] * p3[1]
  ];
}
function toSpherical(xyz) {
  const theta = Math.atan2(xyz[1], xyz[0]);
  const r = Math.sqrt(xyz[0] * xyz[0] + xyz[1] * xyz[1] + xyz[2] * xyz[2]);
  const phi = Math.acos(xyz[2] / r);
  return [theta, phi];
}
function toCartesian([theta, phi]) {
  const sinPhi = Math.sin(phi);
  const x = sinPhi * Math.cos(theta);
  const y = sinPhi * Math.sin(theta);
  const z = Math.cos(phi);
  return [x, y, z];
}
var LONGITUDE_OFFSET = 93;
function fromLonLat([longitude, latitude]) {
  const theta = degToRad(longitude + LONGITUDE_OFFSET);
  const geodeticLat = degToRad(latitude);
  const authalicLat = authalic.forward(geodeticLat);
  const phi = Math.PI / 2 - authalicLat;
  return [theta, phi];
}
function toLonLat([theta, phi]) {
  const longitude = radToDeg(theta) - LONGITUDE_OFFSET;
  const authalicLat = Math.PI / 2 - phi;
  const geodeticLat = authalic.inverse(authalicLat);
  const latitude = radToDeg(geodeticLat);
  return [longitude, latitude];
}
function normalizeLongitudes(contour) {
  const points = contour.map((lonLat) => toCartesian(fromLonLat(lonLat)));
  const center2 = vec3_exports2.create();
  for (const point2 of points) {
    vec3_exports2.add(center2, center2, point2);
  }
  vec3_exports2.normalize(center2, center2);
  let [centerLon, centerLat] = toLonLat(toSpherical(center2));
  if (centerLat > 89.99 || centerLat < -89.99) {
    centerLon = contour[0][0];
  }
  centerLon = ((centerLon + 180) % 360 + 360) % 360 - 180;
  return contour.map((point2) => {
    let [longitude, latitude] = point2;
    while (longitude - centerLon > 180) longitude = longitude - 360;
    while (longitude - centerLon < -180) longitude = longitude + 360;
    return [longitude, latitude];
  });
}
common_exports.setMatrixArrayType(Float64Array);
var SQRT5 = Math.sqrt(5);
var INV_SQRT5 = Math.sqrt(0.2);
var sinAlpha = Math.sqrt((1 - INV_SQRT5) / 2);
var cosAlpha = Math.sqrt((1 + INV_SQRT5) / 2);
var A = 0.5;
var B = Math.sqrt((2.5 - SQRT5) / 10);
var C = Math.sqrt((2.5 + SQRT5) / 10);
var D = Math.sqrt((1 + INV_SQRT5) / 8);
var E = Math.sqrt((1 - INV_SQRT5) / 8);
var F = Math.sqrt((3 - SQRT5) / 8);
var G = Math.sqrt((3 + SQRT5) / 8);
var faceCenters = [
  [0, 0],
  // Doesn't actually matter as rotation is 0
  // First ring: five vertices, CCW, multiplied by sinAlpha
  [sinAlpha, 0],
  // [cos0, sin0]
  [B, A],
  // [cos72, sin72]
  [-D, F],
  // [-cos36, sin36]
  [-D, -F],
  // [-cos36, -sin36]
  [B, -A],
  // [cos72, -sin72]
  // Second ring: the same five vertices but negated (180deg rotation), multiplied by cosAlpha
  [-cosAlpha, 0],
  // [-cos0, -sin0]
  [-E, -G],
  // [-cos72, -sin72]
  [C, -A],
  // [cos36, -sin36]
  [C, A],
  // [cos36, sin36]
  [-E, G],
  // [-cos72, sin72]
  [0, 0]
];
var axes = faceCenters.map(([x, y]) => [-y, x]);
var quaternions = axes.map((axis, i) => {
  if (i === 0) return [0, 0, 0, 1];
  if (i === 11) return [0, -1, 0, 0];
  return [...axis, 0, i < 6 ? cosAlpha : sinAlpha];
});
common_exports.setMatrixArrayType(Float64Array);
var clockwiseFan = ["vu", "uw", "vw", "vw", "vw"];
var clockwiseStep = ["wu", "uw", "vw", "vu", "uw"];
var counterStep = ["wu", "uv", "wv", "wu", "uw"];
var counterJump = ["vu", "uv", "wv", "wu", "uw"];
var QUINTANT_ORIENTATIONS = [
  clockwiseFan,
  // 0 Arctic
  counterJump,
  // 1 North America
  counterStep,
  // 2 South America
  clockwiseStep,
  // 3 North Atlantic & Western Europe & Africa
  counterStep,
  // 4 South Atlantic & Africa
  counterJump,
  // 5 Europe, Middle East & CentralAfrica
  counterStep,
  // 6 Indian Ocean
  clockwiseStep,
  // 7 Asia
  clockwiseStep,
  // 8 Australia
  clockwiseStep,
  // 9 North Pacific
  counterJump,
  // 10 South Pacific
  counterJump
  // 11 Antarctic
];
var QUINTANT_FIRST = [4, 2, 3, 2, 0, 4, 3, 2, 2, 0, 3, 0];
var ORIGIN_ORDER = [0, 1, 2, 4, 3, 5, 7, 8, 6, 11, 10, 9];
var origins = [];
function generateOrigins() {
  addOrigin([0, 0], 0, quaternions[0]);
  for (let i = 0; i < 5; i++) {
    const alpha = i * TWO_PI_OVER_5;
    const alpha2 = alpha + PI_OVER_5;
    addOrigin([alpha, interhedralAngle], PI_OVER_5, quaternions[i + 1]);
    addOrigin([alpha2, Math.PI - interhedralAngle], PI_OVER_5, quaternions[(i + 3) % 5 + 6]);
  }
  addOrigin([0, Math.PI], 0, quaternions[11]);
}
var originId = 0;
function addOrigin(axis, angle3, quaternion) {
  if (originId > 11) {
    throw new Error(`Too many origins: ${originId}`);
  }
  const inverseQuat = quat_exports.create();
  quat_exports.conjugate(inverseQuat, quaternion);
  const origin = {
    id: originId,
    axis,
    quat: quaternion,
    inverseQuat,
    angle: angle3,
    orientation: QUINTANT_ORIENTATIONS[originId],
    firstQuintant: QUINTANT_FIRST[originId]
  };
  origins.push(origin);
  originId++;
}
generateOrigins();
origins.sort((a22, b22) => ORIGIN_ORDER.indexOf(a22.id) - ORIGIN_ORDER.indexOf(b22.id));
origins.forEach((origin, i) => origin.id = i);
function segmentToQuintant(segment, origin) {
  const layout = origin.orientation;
  const step = layout === clockwiseFan || layout === clockwiseStep ? -1 : 1;
  const faceRelativeQuintant = (segment - origin.firstQuintant + 5) % 5;
  const orientation = layout[faceRelativeQuintant];
  const quintant = (origin.firstQuintant + step * faceRelativeQuintant + 5) % 5;
  return { quintant, orientation };
}
var GnomonicProjection = class {
  /**
   * Projects spherical coordinates to polar coordinates using gnomonic projection
   * @param spherical Spherical coordinates [theta, phi]
   * @returns Polar coordinates [rho, gamma]
   */
  forward([theta, phi]) {
    return [Math.tan(phi), theta];
  }
  /**
   * Unprojects polar coordinates to spherical coordinates using gnomonic projection
   * @param polar Polar coordinates [rho, gamma]
   * @returns Spherical coordinates [theta, phi]
   */
  inverse([rho, gamma]) {
    return [gamma, Math.atan(rho)];
  }
};
var midpointAB = vec3_exports2.create();
var crossCD = vec3_exports2.create();
var scaledA = vec3_exports2.create();
var scaledB = vec3_exports2.create();
function vectorDifference(A2, B2) {
  vec3_exports2.lerp(midpointAB, A2, B2, 0.5);
  vec3_exports2.normalize(midpointAB, midpointAB);
  vec3_exports2.cross(midpointAB, A2, midpointAB);
  const D2 = vec3_exports2.length(midpointAB);
  if (D2 < 1e-8) {
    const AB = vec3_exports2.subtract(vec3_exports2.create(), A2, B2);
    const halfDistance = 0.5 * vec3_exports2.length(AB);
    return halfDistance;
  }
  return D2;
}
function tripleProduct(A2, B2, C2) {
  vec3_exports2.cross(crossCD, B2, C2);
  return vec3_exports2.dot(A2, crossCD);
}
function quadrupleProduct(out, A2, B2, C2, D2) {
  vec3_exports2.cross(crossCD, C2, D2);
  const tripleProductACD = vec3_exports2.dot(A2, crossCD);
  const tripleProductBCD = vec3_exports2.dot(B2, crossCD);
  vec3_exports2.scale(scaledA, A2, tripleProductBCD);
  vec3_exports2.scale(scaledB, B2, tripleProductACD);
  return vec3_exports2.sub(out, scaledB, scaledA);
}
function slerp2(out, A2, B2, t) {
  const gamma = vec3_exports2.angle(A2, B2);
  if (gamma < 1e-12) {
    return vec3_exports2.lerp(out, A2, B2, t);
  }
  const weightA = Math.sin((1 - t) * gamma) / Math.sin(gamma);
  const weightB = Math.sin(t * gamma) / Math.sin(gamma);
  const scaledA2 = vec3_exports2.scale(vec3_exports2.create(), A2, weightA);
  const scaledB2 = vec3_exports2.scale(vec3_exports2.create(), B2, weightB);
  return vec3_exports2.add(out, scaledA2, scaledB2);
}
common_exports.setMatrixArrayType(Float64Array);
var midA = vec3_exports2.create();
var midB = vec3_exports2.create();
var midC = vec3_exports2.create();
var center = vec3_exports2.create();
var SphericalPolygonShape = class {
  constructor(vertices) {
    this._area = null;
    this.vertices = vertices;
    Object.freeze(this.vertices);
  }
  /**
   * 
   * @param nSegments Returns a closed boundary of the polygon, with nSegments points per edge
   * @returns SphericalPolygon
   */
  getBoundary(nSegments = 1, closedRing = true) {
    const points = [];
    const N = this.vertices.length;
    for (let s = 0; s < N * nSegments; s++) {
      const t = s / nSegments;
      points.push(this.slerp(t));
    }
    if (closedRing) {
      points.push(points[0]);
    }
    return points;
  }
  /**
   * Interpolates along boundary of polygon. Pass t = 1.5 to get the midpoint between 2nd and 3rd vertices
   * @param t 
   * @returns Cartesian coordinate
   */
  slerp(t) {
    const N = this.vertices.length;
    const f = t % 1;
    const i = Math.floor(t % N);
    const j = (i + 1) % N;
    return slerp2(vec3_exports2.create(), this.vertices[i], this.vertices[j], f);
  }
  /**
   * Returns the vertex given by index t, along with the vectors:
   * - VA: Vector from vertex to point A
   * - VB: Vector from vertex to point B
   * @param t 
   * @returns 
   */
  getTransformedVertices(t) {
    const N = this.vertices.length;
    const i = Math.floor(t % N);
    const j = (i + 1) % N;
    const k = (i + N - 1) % N;
    const V2 = vec3_exports2.clone(this.vertices[i]);
    const VA = vec3_exports2.clone(this.vertices[j]);
    const VB = vec3_exports2.clone(this.vertices[k]);
    vec3_exports2.sub(VA, VA, V2);
    vec3_exports2.sub(VB, VB, V2);
    return [V2, VA, VB];
  }
  containsPoint(point2) {
    const N = this.vertices.length;
    let thetaDeltaMin = Infinity;
    for (let i = 0; i < N; i++) {
      const [V2, VA, VB] = this.getTransformedVertices(i);
      const VP = vec3_exports2.sub(vec3_exports2.create(), point2, V2);
      vec3_exports2.normalize(VP, VP);
      vec3_exports2.normalize(VA, VA);
      vec3_exports2.normalize(VB, VB);
      const crossAP = vec3_exports2.cross(vec3_exports2.create(), VA, VP);
      const crossPB = vec3_exports2.cross(vec3_exports2.create(), VP, VB);
      const sinAP = vec3_exports2.dot(V2, crossAP);
      const sinPB = vec3_exports2.dot(V2, crossPB);
      thetaDeltaMin = Math.min(thetaDeltaMin, sinAP, sinPB);
    }
    return thetaDeltaMin;
  }
  /**
   * Calculate the area of a spherical triangle given three vertices
   * @param v1 First vertex
   * @param v2 Second vertex  
   * @param v3 Third vertex
   * @returns Area of the spherical triangle in radians
   */
  getTriangleArea(v1, v2, v3) {
    vec3_exports2.lerp(midA, v2, v3, 0.5);
    vec3_exports2.lerp(midB, v3, v1, 0.5);
    vec3_exports2.lerp(midC, v1, v2, 0.5);
    vec3_exports2.normalize(midA, midA);
    vec3_exports2.normalize(midB, midB);
    vec3_exports2.normalize(midC, midC);
    const S = tripleProduct(midA, midB, midC);
    const clamped = Math.max(-1, Math.min(1, S));
    if (Math.abs(clamped) < 1e-8) {
      return 2 * clamped;
    } else {
      return Math.asin(clamped) * 2;
    }
  }
  /**
   * Calculate the area of the spherical polygon by decomposing it into a fan of triangles
   * @returns The area of the spherical polygon in radians
   */
  getArea() {
    if (this._area === null) {
      this._area = this._getArea();
    }
    return this._area;
  }
  _getArea() {
    if (this.vertices.length < 3) {
      return 0;
    }
    if (this.vertices.length === 3) {
      this._area = this.getTriangleArea(this.vertices[0], this.vertices[1], this.vertices[2]);
      return this._area;
    }
    vec3_exports2.set(center, 0, 0, 0);
    for (const vertex4 of this.vertices) {
      vec3_exports2.add(center, center, vertex4);
    }
    vec3_exports2.normalize(center, center);
    let area = 0;
    for (let i = 0; i < this.vertices.length; i++) {
      const v1 = this.vertices[i];
      const v2 = this.vertices[(i + 1) % this.vertices.length];
      const triArea = this.getTriangleArea(center, v1, v2);
      if (!isNaN(triArea)) {
        area += triArea;
      }
    }
    this._area = area;
    return this._area;
  }
  /**
   * For debugging purposes, check if the winding order is correct
   * In production, should always be correct
   */
  isWindingCorrect() {
    const area = this.getArea();
    const isCorrect = area > 0;
    if (!isCorrect) {
      debugger;
    }
  }
};
common_exports.setMatrixArrayType(Float64Array);
var SphericalTriangleShape = class extends SphericalPolygonShape {
  constructor(vertices) {
    if (vertices.length !== 3) {
      throw new Error("SphericalTriangleShape requires exactly 3 vertices");
    }
    super(vertices);
  }
};
common_exports.setMatrixArrayType(Float64Array);
var PolyhedralProjection = class {
  /**
   * Forward projection: converts a spherical point to face coordinates
   * @param v - The spherical point to project
   * @param sphericalTriangle - The spherical triangle vertices
   * @param faceTriangle - The face triangle vertices
   * @returns The face coordinates
   */
  forward(v2, sphericalTriangle, faceTriangle) {
    const [A2, B2, C2] = sphericalTriangle;
    const triangleShape = new SphericalTriangleShape([A2, B2, C2]);
    const Z = vec3_exports2.subtract(vec3_exports2.create(), v2, A2);
    vec3_exports2.normalize(Z, Z);
    const p = quadrupleProduct(vec3_exports2.create(), A2, Z, B2, C2);
    vec3_exports2.normalize(p, p);
    const h = vectorDifference(A2, v2) / vectorDifference(A2, p);
    const Area_ABC = triangleShape.getArea();
    const scaledArea = h / Area_ABC;
    const b22 = [
      1 - h,
      scaledArea * new SphericalTriangleShape([A2, p, C2]).getArea(),
      scaledArea * new SphericalTriangleShape([A2, B2, p]).getArea()
    ];
    return barycentricToFace(b22, faceTriangle);
  }
  /**
   * Inverse projection: converts face coordinates back to spherical coordinates
   * @param facePoint - The face coordinates
   * @param faceTriangle - The face triangle vertices
   * @param sphericalTriangle - The spherical triangle vertices
   * @returns The spherical coordinates
   */
  inverse(facePoint, faceTriangle, sphericalTriangle) {
    const [A2, B2, C2] = sphericalTriangle;
    const triangleShape = new SphericalTriangleShape([A2, B2, C2]);
    const b22 = faceToBarycentric(facePoint, faceTriangle);
    const threshold = 1 - 1e-14;
    if (b22[0] > threshold) return A2;
    if (b22[1] > threshold) return B2;
    if (b22[2] > threshold) return C2;
    const c1 = vec3_exports2.create();
    vec3_exports2.cross(c1, B2, C2);
    const Area_ABC = triangleShape.getArea();
    const h = 1 - b22[0];
    const R = b22[2] / h;
    const alpha = R * Area_ABC;
    const S = Math.sin(alpha);
    const halfC = Math.sin(alpha / 2);
    const CC = 2 * halfC * halfC;
    const c01 = vec3_exports2.dot(A2, B2);
    const c12 = vec3_exports2.dot(B2, C2);
    const c20 = vec3_exports2.dot(C2, A2);
    const s12 = vec3_exports2.length(c1);
    const V2 = vec3_exports2.dot(A2, c1);
    const f = S * V2 + CC * (c01 * c12 - c20);
    const g = CC * s12 * (1 + c01);
    const q = 2 / Math.acos(c12) * Math.atan2(g, f);
    const P = slerp2(vec3_exports2.create(), B2, C2, q);
    const K = vectorDifference(A2, P);
    const t = this.safeAcos(h * K) / this.safeAcos(K);
    const out = slerp2([0, 0, 0], A2, P, t);
    return out;
  }
  /**
   * Computes acos(1 - 2 * x * x) without loss of precision for small x
   * @param x 
   * @returns acos(1 - x)
   */
  safeAcos(x) {
    if (x < 1e-3) {
      return 2 * x + x * x * x / 3;
    } else {
      return Math.acos(1 - 2 * x * x);
    }
  }
};
common_exports.setMatrixArrayType(Float64Array);
var YES = -1;
var NO = 1;
var KJToIJ = ([k, j]) => {
  return vec2_exports.fromValues(k - j, j);
};
var kPos = vec2_exports.fromValues(1, 0);
var jPos = vec2_exports.fromValues(0, 1);
var kNeg = vec2_exports.negate(vec2_exports.create(), kPos);
var jNeg = vec2_exports.negate(vec2_exports.create(), jPos);
var ZERO = vec2_exports.fromValues(0, 0);
var quaternaryToKJ = (n, [flipX, flipY]) => {
  let p = ZERO;
  let q = ZERO;
  if (flipX === NO && flipY === NO) {
    p = kPos;
    q = jPos;
  } else if (flipX === YES && flipY === NO) {
    p = jNeg;
    q = kNeg;
  } else if (flipX === NO && flipY === YES) {
    p = jPos;
    q = kPos;
  } else if (flipX === YES && flipY === YES) {
    p = kNeg;
    q = jNeg;
  }
  switch (n) {
    case 0:
      return ZERO;
    case 1:
      return p;
    case 2:
      return vec2_exports.add(vec2_exports.create(), q, p);
    case 3:
      return vec2_exports.scaleAndAdd(vec2_exports.create(), q, p, 2);
    default:
      throw new Error(`Invalid Quaternary value: ${n}`);
  }
};
var quaternaryToFlips = (n) => {
  return [[NO, NO], [NO, YES], [NO, NO], [YES, NO]][n];
};
var FLIP_SHIFT = vec2_exports.fromValues(-1, 1);
function reversePattern(pattern) {
  return Array.from({ length: pattern.length }, (_, i) => pattern.indexOf(i));
}
var PATTERN = [0, 1, 3, 4, 5, 6, 7, 2];
var PATTERN_FLIPPED = [0, 1, 2, 7, 3, 4, 5, 6];
var PATTERN_REVERSED = reversePattern(PATTERN);
var PATTERN_FLIPPED_REVERSED = reversePattern(PATTERN_FLIPPED);
var _shiftDigits = (digits, i, flips, invertJ, pattern) => {
  if (i <= 0) return;
  const parentK = digits[i] || 0;
  const childK = digits[i - 1];
  const F2 = flips[0] + flips[1];
  let needsShift = true;
  let first = true;
  if (invertJ !== (F2 === 0)) {
    needsShift = parentK === 1 || parentK === 2;
    first = parentK === 1;
  } else {
    needsShift = parentK < 2;
    first = parentK === 0;
  }
  if (!needsShift) return;
  const src = first ? childK : childK + 4;
  const dst = pattern[src];
  digits[i - 1] = dst % 4;
  digits[i] = (parentK + 4 + Math.floor(dst / 4) - Math.floor(src / 4)) % 4;
};
var sToAnchor = (s, resolution, orientation) => {
  let input = BigInt(s);
  const reverse = orientation === "vu" || orientation === "wu" || orientation === "vw";
  const invertJ = orientation === "wv" || orientation === "vw";
  const flipIJ = orientation === "wu" || orientation === "uw";
  if (reverse) {
    input = (1n << BigInt(2 * resolution)) - input - 1n;
  }
  const anchor = _sToAnchor(input, resolution, invertJ, flipIJ);
  if (flipIJ) {
    const { offset: [_i, _j], flips: [flipX, flipY] } = anchor;
    anchor.offset = [_j, _i];
    if (flipX === YES) vec2_exports.add(anchor.offset, anchor.offset, FLIP_SHIFT);
    if (flipY === YES) vec2_exports.subtract(anchor.offset, anchor.offset, FLIP_SHIFT);
  }
  if (invertJ) {
    const { offset: [i, _j], flips } = anchor;
    const j = (1 << resolution) - (i + _j);
    flips[0] = -flips[0];
    anchor.offset[1] = j;
    anchor.flips = flips;
  }
  return anchor;
};
var _sToAnchor = (s, resolution, invertJ, flipIJ) => {
  const offset = vec2_exports.create();
  const flips = [NO, NO];
  let input = BigInt(s);
  const digits = [];
  while (input > 0n || digits.length < resolution) {
    digits.push(Number(input % 4n));
    input = input >> 2n;
  }
  const pattern = flipIJ ? PATTERN_FLIPPED : PATTERN;
  for (let i = digits.length - 1; i >= 0; i--) {
    _shiftDigits(digits, i, flips, invertJ, pattern);
    vec2_exports.multiply(flips, flips, quaternaryToFlips(digits[i]));
  }
  flips[0] = NO;
  flips[1] = NO;
  for (let i = digits.length - 1; i >= 0; i--) {
    vec2_exports.scale(offset, offset, 2);
    const childOffset = quaternaryToKJ(digits[i], flips);
    vec2_exports.add(offset, offset, childOffset);
    vec2_exports.multiply(flips, flips, quaternaryToFlips(digits[i]));
  }
  const k = digits[0] || 0;
  return { flips, k, offset: KJToIJ(offset) };
};
common_exports.setMatrixArrayType(Float64Array);
var TRIANGLE_MODE = false;
var shiftRight = vec2_exports.clone(w);
var shiftLeft = vec2_exports.negate(vec2_exports.create(), w);
var QUINTANT_ROTATIONS = [0, 1, 2, 3, 4].map((quintant) => {
  const rotation2 = mat2_exports.create();
  mat2_exports.fromRotation(rotation2, TWO_PI_OVER_5 * quintant);
  return rotation2;
});
var translation = vec2_exports.create();
function getPentagonVertices(resolution, quintant, anchor) {
  const pentagon = (TRIANGLE_MODE ? TRIANGLE : PENTAGON).clone();
  vec2_exports.transformMat2(translation, anchor.offset, BASIS);
  if (anchor.flips[0] === NO && anchor.flips[1] === YES) {
    pentagon.rotate180();
  }
  const { k } = anchor;
  const F2 = anchor.flips[0] + anchor.flips[1];
  if (
    // Orient last two pentagons when both or neither flips are YES
    (F2 === -2 || F2 === 2) && k > 1 || // Orient first & last pentagons when only one of flips is YES
    F2 === 0 && (k === 0 || k === 3)
  ) {
    pentagon.reflectY();
  }
  if (anchor.flips[0] === YES && anchor.flips[1] === YES) {
    pentagon.rotate180();
  } else if (anchor.flips[0] === YES) {
    pentagon.translate(shiftLeft);
  } else if (anchor.flips[1] === YES) {
    pentagon.translate(shiftRight);
  }
  pentagon.translate(translation);
  pentagon.scale(1 / 2 ** resolution);
  pentagon.transform(QUINTANT_ROTATIONS[quintant]);
  return pentagon;
}
function getQuintantVertices(quintant) {
  const triangle = TRIANGLE.clone();
  triangle.transform(QUINTANT_ROTATIONS[quintant]);
  return triangle;
}
function getFaceVertices() {
  const vertices = [];
  for (const rotation2 of QUINTANT_ROTATIONS) {
    vertices.push(vec2_exports.transformMat2(vec2_exports.create(), v, rotation2));
  }
  vertices.reverse();
  return new PentagonShape(vertices);
}
common_exports.setMatrixArrayType(Float64Array);
var CRS = class {
  constructor() {
    this.vertices = [];
    this.invocations = 0;
    this.addFaceCenters();
    this.addVertices();
    this.addMidpoints();
    if (this.vertices.length !== 62) {
      throw new Error("Failed to construct CRS: vertices length is not 62");
    }
    Object.freeze(this.vertices);
  }
  getVertex(point2) {
    this.invocations++;
    if (this.invocations === 1e4) {
      console.warn("Too many CRS invocations, results should be cached");
    }
    for (const vertex4 of this.vertices) {
      if (vec3_exports2.distance(point2, vertex4) < 1e-5) {
        return vertex4;
      }
    }
    throw new Error("Failed to find vertex in CRS");
  }
  addFaceCenters() {
    origins.forEach((origin) => this.add(toCartesian(origin.axis)));
  }
  addVertices() {
    const phiVertex = Math.atan(distanceToVertex);
    for (const origin of origins) {
      for (let i = 0; i < 5; i++) {
        const thetaVertex = (2 * i + 1) * Math.PI / 5;
        const vertex4 = toCartesian([thetaVertex + origin.angle, phiVertex]);
        vec3_exports2.transformQuat(vertex4, vertex4, origin.quat);
        this.add(vertex4);
      }
    }
  }
  addMidpoints() {
    const phiMidpoint = Math.atan(distanceToEdge);
    for (const origin of origins) {
      for (let i = 0; i < 5; i++) {
        const thetaMidpoint = 2 * i * Math.PI / 5;
        const midpoint = toCartesian([thetaMidpoint + origin.angle, phiMidpoint]);
        vec3_exports2.transformQuat(midpoint, midpoint, origin.quat);
        this.add(midpoint);
      }
    }
  }
  add(newVertex) {
    const normalized = vec3_exports2.normalize(vec3_exports2.create(), newVertex);
    const existingVertex = this.vertices.find((existingVertex2) => vec3_exports2.distance(normalized, existingVertex2) < 1e-5);
    if (existingVertex) {
      return false;
    }
    this.vertices.push(normalized);
    return true;
  }
};
common_exports.setMatrixArrayType(Float64Array);
var crs = new CRS();
var DodecahedronProjection = class {
  constructor() {
    this.faceTriangles = [];
    this.sphericalTriangles = [];
    this.polyhedral = new PolyhedralProjection();
    this.gnomonic = new GnomonicProjection();
  }
  /**
   * Projects spherical coordinates to face coordinates using dodecahedron projection
   * @param spherical Spherical coordinates [theta, phi]
   * @param originId Origin ID
   * @returns Face coordinates [x, y]
   */
  forward(spherical, originId2) {
    const origin = origins[originId2];
    const unprojected = toCartesian(spherical);
    const out = vec3_exports2.create();
    vec3_exports2.transformQuat(out, unprojected, origin.inverseQuat);
    const projectedSpherical = toSpherical(out);
    const polar = this.gnomonic.forward(projectedSpherical);
    polar[1] = polar[1] - origin.angle;
    const faceTriangleIndex = this.getFaceTriangleIndex(polar);
    const reflect = this.shouldReflect(polar);
    let faceTriangle = this.getFaceTriangle(faceTriangleIndex, reflect, false);
    let sphericalTriangle = this.getSphericalTriangle(faceTriangleIndex, originId2, reflect);
    return this.polyhedral.forward(unprojected, sphericalTriangle, faceTriangle);
  }
  /**
   * Unprojects face coordinates to spherical coordinates using dodecahedron projection
   * @param face Face coordinates [x, y]
   * @param originId Origin ID
   * @returns Spherical coordinates [theta, phi]
   */
  inverse(face, originId2) {
    const polar = toPolar(face);
    const faceTriangleIndex = this.getFaceTriangleIndex(polar);
    const reflect = this.shouldReflect(polar);
    const faceTriangle = this.getFaceTriangle(faceTriangleIndex, reflect, false);
    const sphericalTriangle = this.getSphericalTriangle(faceTriangleIndex, originId2, reflect);
    const unprojected = this.polyhedral.inverse(face, faceTriangle, sphericalTriangle);
    return toSpherical(unprojected);
  }
  /**
   * Detects when point is beyond the edge of the dodecahedron face
   * In the standard case (reflect = false), the face and spherical triangle can be
   * used directly.
   * In the reflected case (reflect = true), the point is beyond the edge of the dodecahedron face,
   * and so the face triangle is squashed to unproject correctly onto the neighboring dodecahedron face.
   * @param polar Polar coordinates
   * @returns True if point is beyond the edge of the dodecahedron face
   */
  shouldReflect(polar) {
    const [rho, gamma] = polar;
    const D2 = toFace([rho, this.normalizeGamma(gamma)])[0];
    return D2 > distanceToEdge;
  }
  /**
   * Given a polar coordinate, returns the index of the face triangle it belongs to
   * @param polar Polar coordinates
   * @returns Face triangle index, value from 0 to 9
   */
  getFaceTriangleIndex([_, gamma]) {
    return (Math.floor(gamma / PI_OVER_5) + 10) % 10;
  }
  /**
   * Gets the face triangle for a given polar coordinate
   * @param faceTriangleIndex Face triangle index, value from 0 to 9
   * @returns FaceTriangle: 3 vertices in counter-clockwise order
   */
  getFaceTriangle(faceTriangleIndex, reflected = false, squashed = false) {
    let index = faceTriangleIndex;
    if (reflected) {
      index += squashed ? 20 : 10;
    }
    if (this.faceTriangles[index]) {
      return this.faceTriangles[index];
    }
    this.faceTriangles[index] = reflected ? this._getReflectedFaceTriangle(faceTriangleIndex, squashed) : this._getFaceTriangle(faceTriangleIndex);
    Object.freeze(this.faceTriangles[index]);
    return this.faceTriangles[index];
  }
  _getFaceTriangle(faceTriangleIndex) {
    const quintant = Math.floor((faceTriangleIndex + 1) / 2) % 5;
    const [vCenter, vCorner1, vCorner2] = getQuintantVertices(quintant).getVertices();
    const vEdgeMidpoint = vec2_exports.create();
    vec2_exports.lerp(vEdgeMidpoint, vCorner1, vCorner2, 0.5);
    const even = faceTriangleIndex % 2 === 0;
    return even ? [vCenter, vEdgeMidpoint, vCorner1] : [vCenter, vCorner2, vEdgeMidpoint];
  }
  _getReflectedFaceTriangle(faceTriangleIndex, squashed = false) {
    let [A2, B2, C2] = this._getFaceTriangle(faceTriangleIndex).map((face) => vec2_exports.clone(face));
    const even = faceTriangleIndex % 2 === 0;
    vec2_exports.negate(A2, A2);
    const midpoint = even ? B2 : C2;
    vec2_exports.scaleAndAdd(A2, A2, midpoint, squashed ? 1 + 1 / Math.cos(interhedralAngle) : 2);
    return [A2, C2, B2];
  }
  /**
   * Gets the spherical triangle for a given face triangle index and origin
   * @param faceTriangleIndex Face triangle index
   * @param originId Origin ID
   * @returns Spherical triangle
   */
  getSphericalTriangle(faceTriangleIndex, originId2, reflected = false) {
    let index = 10 * originId2 + faceTriangleIndex;
    if (reflected) {
      index += 120;
    }
    if (this.sphericalTriangles[index]) {
      return this.sphericalTriangles[index];
    }
    this.sphericalTriangles[index] = this._getSphericalTriangle(faceTriangleIndex, originId2, reflected);
    Object.freeze(this.sphericalTriangles[index]);
    return this.sphericalTriangles[index];
  }
  _getSphericalTriangle(faceTriangleIndex, originId2, reflected = false) {
    const origin = origins[originId2];
    const faceTriangle = this.getFaceTriangle(faceTriangleIndex, reflected, true);
    const sphericalTriangle = faceTriangle.map((face) => {
      const [rho, gamma] = toPolar(face);
      const rotatedPolar = [rho, gamma + origin.angle];
      const rotated = toCartesian(this.gnomonic.inverse(rotatedPolar));
      vec3_exports2.transformQuat(rotated, rotated, origin.quat);
      return crs.getVertex(rotated);
    });
    return sphericalTriangle;
  }
  /**
   * Normalizes gamma to the range [-PI_OVER_5, PI_OVER_5]
   * @param gamma The gamma value to normalize
   * @returns Normalized gamma value
   */
  normalizeGamma(gamma) {
    const segment = gamma / TWO_PI_OVER_5;
    const sCenter = Math.round(segment);
    const sOffset = segment - sCenter;
    const beta = sOffset * TWO_PI_OVER_5;
    return beta;
  }
};
var FIRST_HILBERT_RESOLUTION = 2;
var MAX_RESOLUTION = 30;
var HILBERT_START_BIT = 58n;
var REMOVAL_MASK = 0x3ffffffffffffffn;
function getResolution(index) {
  let resolution = MAX_RESOLUTION - 1;
  let shifted = index >> 1n;
  while (resolution > -1 && (shifted & 0b1n) === 0n) {
    resolution -= 1;
    shifted = shifted >> (resolution < FIRST_HILBERT_RESOLUTION ? 1n : 2n);
  }
  return resolution;
}
function deserialize(index) {
  const resolution = getResolution(index);
  if (resolution === -1) {
    return { origin: origins[0], segment: 0, S: 0n, resolution };
  }
  const top6Bits = Number(index >> 58n);
  let origin, segment;
  if (resolution === 0) {
    const originId2 = top6Bits;
    origin = origins[originId2];
    segment = 0;
  } else {
    const originId2 = Math.floor(top6Bits / 5);
    origin = origins[originId2];
    segment = (top6Bits + origin.firstQuintant) % 5;
  }
  if (!origin) {
    throw new Error(`Could not parse origin: ${top6Bits}`);
  }
  if (resolution < FIRST_HILBERT_RESOLUTION) {
    return { origin, segment, S: 0n, resolution };
  }
  const hilbertLevels = resolution - FIRST_HILBERT_RESOLUTION + 1;
  const hilbertBits = BigInt(2 * hilbertLevels);
  const shift = HILBERT_START_BIT - hilbertBits;
  const S = (index & REMOVAL_MASK) >> shift;
  return { origin, segment, S, resolution };
}
common_exports.setMatrixArrayType(Float64Array);
var rotation = mat2_exports.create();
var dodecahedron = new DodecahedronProjection();
function _getPentagon({ S, segment, origin, resolution }) {
  const { quintant, orientation } = segmentToQuintant(segment, origin);
  if (resolution === FIRST_HILBERT_RESOLUTION - 1) {
    const out = getQuintantVertices(quintant);
    return out;
  } else if (resolution === FIRST_HILBERT_RESOLUTION - 2) {
    return getFaceVertices();
  }
  const hilbertResolution = resolution - FIRST_HILBERT_RESOLUTION + 1;
  const anchor = sToAnchor(S, hilbertResolution, orientation);
  return getPentagonVertices(hilbertResolution, quintant, anchor);
}
function cellToBoundary(cellId, { closedRing = true, segments = "auto" } = { closedRing: true, segments: "auto" }) {
  const { S, segment, origin, resolution } = deserialize(cellId);
  if (segments === "auto") {
    segments = Math.max(1, Math.pow(2, 6 - resolution));
  }
  const pentagon = _getPentagon({ S, segment, origin, resolution });
  const splitPentagon = pentagon.splitEdges(segments);
  const vertices = splitPentagon.getVertices();
  const unprojectedVertices = vertices.map((vertex4) => dodecahedron.inverse(vertex4, origin.id));
  const boundary = unprojectedVertices.map((vertex4) => toLonLat(vertex4));
  const normalizedBoundary = normalizeLongitudes(boundary);
  if (closedRing) {
    normalizedBoundary.push(normalizedBoundary[0]);
  }
  normalizedBoundary.reverse();
  return normalizedBoundary;
}
function hexToU64(hex) {
  return BigInt(`0x${hex}`);
}
var AUTHALIC_RADIUS = 63710072e-1;
var AUTHALIC_AREA = 4 * Math.PI * AUTHALIC_RADIUS * AUTHALIC_RADIUS;
common_exports.setMatrixArrayType(Float64Array);

// node_modules/h3-js/dist/browser/h3-js.es.js
var libh3 = function(libh32) {
  libh32 = libh32 || {};
  var Module = typeof libh32 !== "undefined" ? libh32 : {};
  var moduleOverrides = {};
  var key;
  for (key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key];
    }
  }
  var arguments_ = [];
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var readAsync;
  {
    if (typeof document !== "undefined" && document.currentScript) {
      scriptDirectory = document.currentScript.src;
    }
    if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
    } else {
      scriptDirectory = "";
    }
    readAsync = function readAsync2(url, onload, onerror) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function xhr_onload() {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          onload(xhr.response);
          return;
        }
        var data = tryParseAsDataURI(url);
        if (data) {
          onload(data.buffer);
          return;
        }
        onerror();
      };
      xhr.onerror = onerror;
      xhr.send(null);
    };
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.warn.bind(console);
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key];
    }
  }
  moduleOverrides = null;
  if (Module["arguments"]) {
    arguments_ = Module["arguments"];
  }
  var tempRet0 = 0;
  var setTempRet0 = function(value) {
    tempRet0 = value;
  };
  var getTempRet0 = function() {
    return tempRet0;
  };
  var GLOBAL_BASE = 8;
  function setValue(ptr, value, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        HEAP8[ptr >> 0] = value;
        break;
      case "i8":
        HEAP8[ptr >> 0] = value;
        break;
      case "i16":
        HEAP16[ptr >> 1] = value;
        break;
      case "i32":
        HEAP32[ptr >> 2] = value;
        break;
      case "i64":
        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
        break;
      case "float":
        HEAPF32[ptr >> 2] = value;
        break;
      case "double":
        HEAPF64[ptr >> 3] = value;
        break;
      default:
        abort("invalid type for setValue: " + type);
    }
  }
  function getValue(ptr, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        return HEAP8[ptr >> 0];
      case "i8":
        return HEAP8[ptr >> 0];
      case "i16":
        return HEAP16[ptr >> 1];
      case "i32":
        return HEAP32[ptr >> 2];
      case "i64":
        return HEAP32[ptr >> 2];
      case "float":
        return HEAPF32[ptr >> 2];
      case "double":
        return HEAPF64[ptr >> 3];
      default:
        abort("invalid type for getValue: " + type);
    }
    return null;
  }
  var ABORT = false;
  function assert6(condition, text) {
    if (!condition) {
      abort("Assertion failed: " + text);
    }
  }
  function getCFunc(ident) {
    var func = Module["_" + ident];
    assert6(func, "Cannot call unknown function " + ident + ", make sure it is exported");
    return func;
  }
  function ccall(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": function(str5) {
        var ret2 = 0;
        if (str5 !== null && str5 !== void 0 && str5 !== 0) {
          var len4 = (str5.length << 2) + 1;
          ret2 = stackAlloc(len4);
          stringToUTF8(str5, ret2, len4);
        }
        return ret2;
      },
      "array": function(arr) {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean") {
        return Boolean(ret2);
      }
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack2 = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack2 === 0) {
            stack2 = stackSave();
          }
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    ret = convertReturnValue(ret);
    if (stack2 !== 0) {
      stackRestore(stack2);
    }
    return ret;
  }
  function cwrap(ident, returnType, argTypes, opts) {
    argTypes = argTypes || [];
    var numericArgs = argTypes.every(function(type) {
      return type === "number";
    });
    var numericRet = returnType !== "string";
    if (numericRet && numericArgs && !opts) {
      return getCFunc(ident);
    }
    return function() {
      return ccall(ident, returnType, argTypes, arguments, opts);
    };
  }
  var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (u8Array[endPtr] && !(endPtr >= endIdx)) {
      ++endPtr;
    }
    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
    } else {
      var str5 = "";
      while (idx < endPtr) {
        var u0 = u8Array[idx++];
        if (!(u0 & 128)) {
          str5 += String.fromCharCode(u0);
          continue;
        }
        var u1 = u8Array[idx++] & 63;
        if ((u0 & 224) == 192) {
          str5 += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = u8Array[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u8Array[idx++] & 63;
        }
        if (u0 < 65536) {
          str5 += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str5 += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
    }
    return str5;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  }
  function stringToUTF8Array(str5, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) {
      return 0;
    }
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str5.length; ++i) {
      var u2 = str5.charCodeAt(i);
      if (u2 >= 55296 && u2 <= 57343) {
        var u1 = str5.charCodeAt(++i);
        u2 = 65536 + ((u2 & 1023) << 10) | u1 & 1023;
      }
      if (u2 <= 127) {
        if (outIdx >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = u2;
      } else if (u2 <= 2047) {
        if (outIdx + 1 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 192 | u2 >> 6;
        outU8Array[outIdx++] = 128 | u2 & 63;
      } else if (u2 <= 65535) {
        if (outIdx + 2 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 224 | u2 >> 12;
        outU8Array[outIdx++] = 128 | u2 >> 6 & 63;
        outU8Array[outIdx++] = 128 | u2 & 63;
      } else {
        if (outIdx + 3 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 240 | u2 >> 18;
        outU8Array[outIdx++] = 128 | u2 >> 12 & 63;
        outU8Array[outIdx++] = 128 | u2 >> 6 & 63;
        outU8Array[outIdx++] = 128 | u2 & 63;
      }
    }
    outU8Array[outIdx] = 0;
    return outIdx - startIdx;
  }
  function stringToUTF8(str5, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str5, HEAPU8, outPtr, maxBytesToWrite);
  }
  var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
  function writeArrayToMemory(array, buffer2) {
    HEAP8.set(array, buffer2);
  }
  function alignUp(x, multiple) {
    if (x % multiple > 0) {
      x += multiple - x % multiple;
    }
    return x;
  }
  var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateGlobalBufferAndViews(buf) {
    buffer = buf;
    Module["HEAP8"] = HEAP8 = new Int8Array(buf);
    Module["HEAP16"] = HEAP16 = new Int16Array(buf);
    Module["HEAP32"] = HEAP32 = new Int32Array(buf);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
  }
  var DYNAMIC_BASE = 5271536, DYNAMICTOP_PTR = 28624;
  var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 33554432;
  if (Module["buffer"]) {
    buffer = Module["buffer"];
  } else {
    buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
  }
  INITIAL_TOTAL_MEMORY = buffer.byteLength;
  updateGlobalBufferAndViews(buffer);
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == "function") {
        callback();
        continue;
      }
      var func = callback.func;
      if (typeof func === "number") {
        if (callback.arg === void 0) {
          Module["dynCall_v"](func);
        } else {
          Module["dynCall_vi"](func, callback.arg);
        }
      } else {
        func(callback.arg === void 0 ? null : callback.arg);
      }
    }
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATMAIN__ = [];
  var __ATPOSTRUN__ = [];
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function") {
        Module["preRun"] = [Module["preRun"]];
      }
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    callRuntimeCallbacks(__ATINIT__);
  }
  function preMain() {
    callRuntimeCallbacks(__ATMAIN__);
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function") {
        Module["postRun"] = [Module["postRun"]];
      }
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var Math_abs = Math.abs;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_min = Math.min;
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  Module["preloadedImages"] = {};
  Module["preloadedAudios"] = {};
  var memoryInitializer = null;
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
  }
  var tempDouble;
  var tempI64;
  memoryInitializer = "data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAAAQAAAAQAAAADAAAABgAAAAUAAAACAAAAAAAAAAIAAAADAAAAAQAAAAQAAAAGAAAAAAAAAAUAAAADAAAABgAAAAQAAAAFAAAAAAAAAAEAAAACAAAABAAAAAUAAAAGAAAAAAAAAAIAAAADAAAAAQAAAAUAAAACAAAAAAAAAAEAAAADAAAABgAAAAQAAAAGAAAAAAAAAAUAAAACAAAAAQAAAAQAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAAAAAAEAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAYAAAAAAAAABQAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAYAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAYAAAAAAAAAAwAAAAIAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAFAAAABAAAAAAAAAABAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAYAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAgAAAAQAAAADAAAACAAAAAEAAAAHAAAABgAAAAkAAAAAAAAAAwAAAAIAAAACAAAABgAAAAoAAAALAAAAAAAAAAEAAAAFAAAAAwAAAA0AAAABAAAABwAAAAQAAAAMAAAAAAAAAAQAAAB/AAAADwAAAAgAAAADAAAAAAAAAAwAAAAFAAAAAgAAABIAAAAKAAAACAAAAAAAAAAQAAAABgAAAA4AAAALAAAAEQAAAAEAAAAJAAAAAgAAAAcAAAAVAAAACQAAABMAAAADAAAADQAAAAEAAAAIAAAABQAAABYAAAAQAAAABAAAAAAAAAAPAAAACQAAABMAAAAOAAAAFAAAAAEAAAAHAAAABgAAAAoAAAALAAAAGAAAABcAAAAFAAAAAgAAABIAAAALAAAAEQAAABcAAAAZAAAAAgAAAAYAAAAKAAAADAAAABwAAAANAAAAGgAAAAQAAAAPAAAAAwAAAA0AAAAaAAAAFQAAAB0AAAADAAAADAAAAAcAAAAOAAAAfwAAABEAAAAbAAAACQAAABQAAAAGAAAADwAAABYAAAAcAAAAHwAAAAQAAAAIAAAADAAAABAAAAASAAAAIQAAAB4AAAAIAAAABQAAABYAAAARAAAACwAAAA4AAAAGAAAAIwAAABkAAAAbAAAAEgAAABgAAAAeAAAAIAAAAAUAAAAKAAAAEAAAABMAAAAiAAAAFAAAACQAAAAHAAAAFQAAAAkAAAAUAAAADgAAABMAAAAJAAAAKAAAABsAAAAkAAAAFQAAACYAAAATAAAAIgAAAA0AAAAdAAAABwAAABYAAAAQAAAAKQAAACEAAAAPAAAACAAAAB8AAAAXAAAAGAAAAAsAAAAKAAAAJwAAACUAAAAZAAAAGAAAAH8AAAAgAAAAJQAAAAoAAAAXAAAAEgAAABkAAAAXAAAAEQAAAAsAAAAtAAAAJwAAACMAAAAaAAAAKgAAAB0AAAArAAAADAAAABwAAAANAAAAGwAAACgAAAAjAAAALgAAAA4AAAAUAAAAEQAAABwAAAAfAAAAKgAAACwAAAAMAAAADwAAABoAAAAdAAAAKwAAACYAAAAvAAAADQAAABoAAAAVAAAAHgAAACAAAAAwAAAAMgAAABAAAAASAAAAIQAAAB8AAAApAAAALAAAADUAAAAPAAAAFgAAABwAAAAgAAAAHgAAABgAAAASAAAANAAAADIAAAAlAAAAIQAAAB4AAAAxAAAAMAAAABYAAAAQAAAAKQAAACIAAAATAAAAJgAAABUAAAA2AAAAJAAAADMAAAAjAAAALgAAAC0AAAA4AAAAEQAAABsAAAAZAAAAJAAAABQAAAAiAAAAEwAAADcAAAAoAAAANgAAACUAAAAnAAAANAAAADkAAAAYAAAAFwAAACAAAAAmAAAAfwAAACIAAAAzAAAAHQAAAC8AAAAVAAAAJwAAACUAAAAZAAAAFwAAADsAAAA5AAAALQAAACgAAAAbAAAAJAAAABQAAAA8AAAALgAAADcAAAApAAAAMQAAADUAAAA9AAAAFgAAACEAAAAfAAAAKgAAADoAAAArAAAAPgAAABwAAAAsAAAAGgAAACsAAAA+AAAALwAAAEAAAAAaAAAAKgAAAB0AAAAsAAAANQAAADoAAABBAAAAHAAAAB8AAAAqAAAALQAAACcAAAAjAAAAGQAAAD8AAAA7AAAAOAAAAC4AAAA8AAAAOAAAAEQAAAAbAAAAKAAAACMAAAAvAAAAJgAAACsAAAAdAAAARQAAADMAAABAAAAAMAAAADEAAAAeAAAAIQAAAEMAAABCAAAAMgAAADEAAAB/AAAAPQAAAEIAAAAhAAAAMAAAACkAAAAyAAAAMAAAACAAAAAeAAAARgAAAEMAAAA0AAAAMwAAAEUAAAA2AAAARwAAACYAAAAvAAAAIgAAADQAAAA5AAAARgAAAEoAAAAgAAAAJQAAADIAAAA1AAAAPQAAAEEAAABLAAAAHwAAACkAAAAsAAAANgAAAEcAAAA3AAAASQAAACIAAAAzAAAAJAAAADcAAAAoAAAANgAAACQAAABIAAAAPAAAAEkAAAA4AAAARAAAAD8AAABNAAAAIwAAAC4AAAAtAAAAOQAAADsAAABKAAAATgAAACUAAAAnAAAANAAAADoAAAB/AAAAPgAAAEwAAAAsAAAAQQAAACoAAAA7AAAAPwAAAE4AAABPAAAAJwAAAC0AAAA5AAAAPAAAAEgAAABEAAAAUAAAACgAAAA3AAAALgAAAD0AAAA1AAAAMQAAACkAAABRAAAASwAAAEIAAAA+AAAAKwAAADoAAAAqAAAAUgAAAEAAAABMAAAAPwAAAH8AAAA4AAAALQAAAE8AAAA7AAAATQAAAEAAAAAvAAAAPgAAACsAAABUAAAARQAAAFIAAABBAAAAOgAAADUAAAAsAAAAVgAAAEwAAABLAAAAQgAAAEMAAABRAAAAVQAAADEAAAAwAAAAPQAAAEMAAABCAAAAMgAAADAAAABXAAAAVQAAAEYAAABEAAAAOAAAADwAAAAuAAAAWgAAAE0AAABQAAAARQAAADMAAABAAAAALwAAAFkAAABHAAAAVAAAAEYAAABDAAAANAAAADIAAABTAAAAVwAAAEoAAABHAAAAWQAAAEkAAABbAAAAMwAAAEUAAAA2AAAASAAAAH8AAABJAAAANwAAAFAAAAA8AAAAWAAAAEkAAABbAAAASAAAAFgAAAA2AAAARwAAADcAAABKAAAATgAAAFMAAABcAAAANAAAADkAAABGAAAASwAAAEEAAAA9AAAANQAAAF4AAABWAAAAUQAAAEwAAABWAAAAUgAAAGAAAAA6AAAAQQAAAD4AAABNAAAAPwAAAEQAAAA4AAAAXQAAAE8AAABaAAAATgAAAEoAAAA7AAAAOQAAAF8AAABcAAAATwAAAE8AAABOAAAAPwAAADsAAABdAAAAXwAAAE0AAABQAAAARAAAAEgAAAA8AAAAYwAAAFoAAABYAAAAUQAAAFUAAABeAAAAZQAAAD0AAABCAAAASwAAAFIAAABgAAAAVAAAAGIAAAA+AAAATAAAAEAAAABTAAAAfwAAAEoAAABGAAAAZAAAAFcAAABcAAAAVAAAAEUAAABSAAAAQAAAAGEAAABZAAAAYgAAAFUAAABXAAAAZQAAAGYAAABCAAAAQwAAAFEAAABWAAAATAAAAEsAAABBAAAAaAAAAGAAAABeAAAAVwAAAFMAAABmAAAAZAAAAEMAAABGAAAAVQAAAFgAAABIAAAAWwAAAEkAAABjAAAAUAAAAGkAAABZAAAAYQAAAFsAAABnAAAARQAAAFQAAABHAAAAWgAAAE0AAABQAAAARAAAAGoAAABdAAAAYwAAAFsAAABJAAAAWQAAAEcAAABpAAAAWAAAAGcAAABcAAAAUwAAAE4AAABKAAAAbAAAAGQAAABfAAAAXQAAAE8AAABaAAAATQAAAG0AAABfAAAAagAAAF4AAABWAAAAUQAAAEsAAABrAAAAaAAAAGUAAABfAAAAXAAAAE8AAABOAAAAbQAAAGwAAABdAAAAYAAAAGgAAABiAAAAbgAAAEwAAABWAAAAUgAAAGEAAAB/AAAAYgAAAFQAAABnAAAAWQAAAG8AAABiAAAAbgAAAGEAAABvAAAAUgAAAGAAAABUAAAAYwAAAFAAAABpAAAAWAAAAGoAAABaAAAAcQAAAGQAAABmAAAAUwAAAFcAAABsAAAAcgAAAFwAAABlAAAAZgAAAGsAAABwAAAAUQAAAFUAAABeAAAAZgAAAGUAAABXAAAAVQAAAHIAAABwAAAAZAAAAGcAAABbAAAAYQAAAFkAAAB0AAAAaQAAAG8AAABoAAAAawAAAG4AAABzAAAAVgAAAF4AAABgAAAAaQAAAFgAAABnAAAAWwAAAHEAAABjAAAAdAAAAGoAAABdAAAAYwAAAFoAAAB1AAAAbQAAAHEAAABrAAAAfwAAAGUAAABeAAAAcwAAAGgAAABwAAAAbAAAAGQAAABfAAAAXAAAAHYAAAByAAAAbQAAAG0AAABsAAAAXQAAAF8AAAB1AAAAdgAAAGoAAABuAAAAYgAAAGgAAABgAAAAdwAAAG8AAABzAAAAbwAAAGEAAABuAAAAYgAAAHQAAABnAAAAdwAAAHAAAABrAAAAZgAAAGUAAAB4AAAAcwAAAHIAAABxAAAAYwAAAHQAAABpAAAAdQAAAGoAAAB5AAAAcgAAAHAAAABkAAAAZgAAAHYAAAB4AAAAbAAAAHMAAABuAAAAawAAAGgAAAB4AAAAdwAAAHAAAAB0AAAAZwAAAHcAAABvAAAAcQAAAGkAAAB5AAAAdQAAAH8AAABtAAAAdgAAAHEAAAB5AAAAagAAAHYAAAB4AAAAbAAAAHIAAAB1AAAAeQAAAG0AAAB3AAAAbwAAAHMAAABuAAAAeQAAAHQAAAB4AAAAeAAAAHMAAAByAAAAcAAAAHkAAAB3AAAAdgAAAHkAAAB0AAAAeAAAAHcAAAB1AAAAcQAAAHYAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAACAAAABQAAAAEAAAAAAAAA/////wEAAAAAAAAAAwAAAAQAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAUAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABAAAAAUAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAUAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAD//////////wEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAAAAAAAAAAABAAAAAgAAAAYAAAAEAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAAAAAAAAAAAAQAAAAEAAAAFAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAAAAAAAAAAABAAAAAwAAAAcAAAAGAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADgAAAAIAAAAAAAAAAAAAAAEAAAAAAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAAAAAAAAAAAAAEAAAAEAAAACAAAAAoAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAAAAAAAAAAAAQAAAAsAAAAPAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAIAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAAAAAAAAAAAAQAAAAwAAAAQAAAADAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAABAAAACgAAABMAAAAIAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAAAAAAAAAAAAAEAAAANAAAAEQAAAA0AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAACAAAAAAAAAAAAAAABAAAADgAAABIAAAAPAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAADwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABIAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAAAAAAAAQAAAP//////////EwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAASAAAAAAAAABgAAAAAAAAAIQAAAAAAAAAeAAAAAAAAACAAAAADAAAAMQAAAAEAAAAwAAAAAwAAADIAAAADAAAACAAAAAAAAAAFAAAABQAAAAoAAAAFAAAAFgAAAAAAAAAQAAAAAAAAABIAAAAAAAAAKQAAAAEAAAAhAAAAAAAAAB4AAAAAAAAABAAAAAAAAAAAAAAABQAAAAIAAAAFAAAADwAAAAEAAAAIAAAAAAAAAAUAAAAFAAAAHwAAAAEAAAAWAAAAAAAAABAAAAAAAAAAAgAAAAAAAAAGAAAAAAAAAA4AAAAAAAAACgAAAAAAAAALAAAAAAAAABEAAAADAAAAGAAAAAEAAAAXAAAAAwAAABkAAAADAAAAAAAAAAAAAAABAAAABQAAAAkAAAAFAAAABQAAAAAAAAACAAAAAAAAAAYAAAAAAAAAEgAAAAEAAAAKAAAAAAAAAAsAAAAAAAAABAAAAAEAAAADAAAABQAAAAcAAAAFAAAACAAAAAEAAAAAAAAAAAAAAAEAAAAFAAAAEAAAAAEAAAAFAAAAAAAAAAIAAAAAAAAABwAAAAAAAAAVAAAAAAAAACYAAAAAAAAACQAAAAAAAAATAAAAAAAAACIAAAADAAAADgAAAAEAAAAUAAAAAwAAACQAAAADAAAAAwAAAAAAAAANAAAABQAAAB0AAAAFAAAAAQAAAAAAAAAHAAAAAAAAABUAAAAAAAAABgAAAAEAAAAJAAAAAAAAABMAAAAAAAAABAAAAAIAAAAMAAAABQAAABoAAAAFAAAAAAAAAAEAAAADAAAAAAAAAA0AAAAFAAAAAgAAAAEAAAABAAAAAAAAAAcAAAAAAAAAGgAAAAAAAAAqAAAAAAAAADoAAAAAAAAAHQAAAAAAAAArAAAAAAAAAD4AAAADAAAAJgAAAAEAAAAvAAAAAwAAAEAAAAADAAAADAAAAAAAAAAcAAAABQAAACwAAAAFAAAADQAAAAAAAAAaAAAAAAAAACoAAAAAAAAAFQAAAAEAAAAdAAAAAAAAACsAAAAAAAAABAAAAAMAAAAPAAAABQAAAB8AAAAFAAAAAwAAAAEAAAAMAAAAAAAAABwAAAAFAAAABwAAAAEAAAANAAAAAAAAABoAAAAAAAAAHwAAAAAAAAApAAAAAAAAADEAAAAAAAAALAAAAAAAAAA1AAAAAAAAAD0AAAADAAAAOgAAAAEAAABBAAAAAwAAAEsAAAADAAAADwAAAAAAAAAWAAAABQAAACEAAAAFAAAAHAAAAAAAAAAfAAAAAAAAACkAAAAAAAAAKgAAAAEAAAAsAAAAAAAAADUAAAAAAAAABAAAAAQAAAAIAAAABQAAABAAAAAFAAAADAAAAAEAAAAPAAAAAAAAABYAAAAFAAAAGgAAAAEAAAAcAAAAAAAAAB8AAAAAAAAAMgAAAAAAAAAwAAAAAAAAADEAAAADAAAAIAAAAAAAAAAeAAAAAwAAACEAAAADAAAAGAAAAAMAAAASAAAAAwAAABAAAAADAAAARgAAAAAAAABDAAAAAAAAAEIAAAADAAAANAAAAAMAAAAyAAAAAAAAADAAAAAAAAAAJQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAUwAAAAAAAABXAAAAAwAAAFUAAAADAAAASgAAAAMAAABGAAAAAAAAAEMAAAAAAAAAOQAAAAEAAAA0AAAAAwAAADIAAAAAAAAAGQAAAAAAAAAXAAAAAAAAABgAAAADAAAAEQAAAAAAAAALAAAAAwAAAAoAAAADAAAADgAAAAMAAAAGAAAAAwAAAAIAAAADAAAALQAAAAAAAAAnAAAAAAAAACUAAAADAAAAIwAAAAMAAAAZAAAAAAAAABcAAAAAAAAAGwAAAAMAAAARAAAAAAAAAAsAAAADAAAAPwAAAAAAAAA7AAAAAwAAADkAAAADAAAAOAAAAAMAAAAtAAAAAAAAACcAAAAAAAAALgAAAAMAAAAjAAAAAwAAABkAAAAAAAAAJAAAAAAAAAAUAAAAAAAAAA4AAAADAAAAIgAAAAAAAAATAAAAAwAAAAkAAAADAAAAJgAAAAMAAAAVAAAAAwAAAAcAAAADAAAANwAAAAAAAAAoAAAAAAAAABsAAAADAAAANgAAAAMAAAAkAAAAAAAAABQAAAAAAAAAMwAAAAMAAAAiAAAAAAAAABMAAAADAAAASAAAAAAAAAA8AAAAAwAAAC4AAAADAAAASQAAAAMAAAA3AAAAAAAAACgAAAAAAAAARwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAQAAAAAAAAAAvAAAAAAAAACYAAAADAAAAPgAAAAAAAAArAAAAAwAAAB0AAAADAAAAOgAAAAMAAAAqAAAAAwAAABoAAAADAAAAVAAAAAAAAABFAAAAAAAAADMAAAADAAAAUgAAAAMAAABAAAAAAAAAAC8AAAAAAAAATAAAAAMAAAA+AAAAAAAAACsAAAADAAAAYQAAAAAAAABZAAAAAwAAAEcAAAADAAAAYgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAYAAAAAMAAABSAAAAAwAAAEAAAAAAAAAASwAAAAAAAABBAAAAAAAAADoAAAADAAAAPQAAAAAAAAA1AAAAAwAAACwAAAADAAAAMQAAAAMAAAApAAAAAwAAAB8AAAADAAAAXgAAAAAAAABWAAAAAAAAAEwAAAADAAAAUQAAAAMAAABLAAAAAAAAAEEAAAAAAAAAQgAAAAMAAAA9AAAAAAAAADUAAAADAAAAawAAAAAAAABoAAAAAwAAAGAAAAADAAAAZQAAAAMAAABeAAAAAAAAAFYAAAAAAAAAVQAAAAMAAABRAAAAAwAAAEsAAAAAAAAAOQAAAAAAAAA7AAAAAAAAAD8AAAADAAAASgAAAAAAAABOAAAAAwAAAE8AAAADAAAAUwAAAAMAAABcAAAAAwAAAF8AAAADAAAAJQAAAAAAAAAnAAAAAwAAAC0AAAADAAAANAAAAAAAAAA5AAAAAAAAADsAAAAAAAAARgAAAAMAAABKAAAAAAAAAE4AAAADAAAAGAAAAAAAAAAXAAAAAwAAABkAAAADAAAAIAAAAAMAAAAlAAAAAAAAACcAAAADAAAAMgAAAAMAAAA0AAAAAAAAADkAAAAAAAAALgAAAAAAAAA8AAAAAAAAAEgAAAADAAAAOAAAAAAAAABEAAAAAwAAAFAAAAADAAAAPwAAAAMAAABNAAAAAwAAAFoAAAADAAAAGwAAAAAAAAAoAAAAAwAAADcAAAADAAAAIwAAAAAAAAAuAAAAAAAAADwAAAAAAAAALQAAAAMAAAA4AAAAAAAAAEQAAAADAAAADgAAAAAAAAAUAAAAAwAAACQAAAADAAAAEQAAAAMAAAAbAAAAAAAAACgAAAADAAAAGQAAAAMAAAAjAAAAAAAAAC4AAAAAAAAARwAAAAAAAABZAAAAAAAAAGEAAAADAAAASQAAAAAAAABbAAAAAwAAAGcAAAADAAAASAAAAAMAAABYAAAAAwAAAGkAAAADAAAAMwAAAAAAAABFAAAAAwAAAFQAAAADAAAANgAAAAAAAABHAAAAAAAAAFkAAAAAAAAANwAAAAMAAABJAAAAAAAAAFsAAAADAAAAJgAAAAAAAAAvAAAAAwAAAEAAAAADAAAAIgAAAAMAAAAzAAAAAAAAAEUAAAADAAAAJAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAYAAAAAAAAABoAAAAAAAAAGsAAAADAAAAYgAAAAAAAABuAAAAAwAAAHMAAAADAAAAYQAAAAMAAABvAAAAAwAAAHcAAAADAAAATAAAAAAAAABWAAAAAwAAAF4AAAADAAAAUgAAAAAAAABgAAAAAAAAAGgAAAAAAAAAVAAAAAMAAABiAAAAAAAAAG4AAAADAAAAOgAAAAAAAABBAAAAAwAAAEsAAAADAAAAPgAAAAMAAABMAAAAAAAAAFYAAAADAAAAQAAAAAMAAABSAAAAAAAAAGAAAAAAAAAAVQAAAAAAAABXAAAAAAAAAFMAAAADAAAAZQAAAAAAAABmAAAAAwAAAGQAAAADAAAAawAAAAMAAABwAAAAAwAAAHIAAAADAAAAQgAAAAAAAABDAAAAAwAAAEYAAAADAAAAUQAAAAAAAABVAAAAAAAAAFcAAAAAAAAAXgAAAAMAAABlAAAAAAAAAGYAAAADAAAAMQAAAAAAAAAwAAAAAwAAADIAAAADAAAAPQAAAAMAAABCAAAAAAAAAEMAAAADAAAASwAAAAMAAABRAAAAAAAAAFUAAAAAAAAAXwAAAAAAAABcAAAAAAAAAFMAAAAAAAAATwAAAAAAAABOAAAAAAAAAEoAAAADAAAAPwAAAAEAAAA7AAAAAwAAADkAAAADAAAAbQAAAAAAAABsAAAAAAAAAGQAAAAFAAAAXQAAAAEAAABfAAAAAAAAAFwAAAAAAAAATQAAAAEAAABPAAAAAAAAAE4AAAAAAAAAdQAAAAQAAAB2AAAABQAAAHIAAAAFAAAAagAAAAEAAABtAAAAAAAAAGwAAAAAAAAAWgAAAAEAAABdAAAAAQAAAF8AAAAAAAAAWgAAAAAAAABNAAAAAAAAAD8AAAAAAAAAUAAAAAAAAABEAAAAAAAAADgAAAADAAAASAAAAAEAAAA8AAAAAwAAAC4AAAADAAAAagAAAAAAAABdAAAAAAAAAE8AAAAFAAAAYwAAAAEAAABaAAAAAAAAAE0AAAAAAAAAWAAAAAEAAABQAAAAAAAAAEQAAAAAAAAAdQAAAAMAAABtAAAABQAAAF8AAAAFAAAAcQAAAAEAAABqAAAAAAAAAF0AAAAAAAAAaQAAAAEAAABjAAAAAQAAAFoAAAAAAAAAaQAAAAAAAABYAAAAAAAAAEgAAAAAAAAAZwAAAAAAAABbAAAAAAAAAEkAAAADAAAAYQAAAAEAAABZAAAAAwAAAEcAAAADAAAAcQAAAAAAAABjAAAAAAAAAFAAAAAFAAAAdAAAAAEAAABpAAAAAAAAAFgAAAAAAAAAbwAAAAEAAABnAAAAAAAAAFsAAAAAAAAAdQAAAAIAAABqAAAABQAAAFoAAAAFAAAAeQAAAAEAAABxAAAAAAAAAGMAAAAAAAAAdwAAAAEAAAB0AAAAAQAAAGkAAAAAAAAAdwAAAAAAAABvAAAAAAAAAGEAAAAAAAAAcwAAAAAAAABuAAAAAAAAAGIAAAADAAAAawAAAAEAAABoAAAAAwAAAGAAAAADAAAAeQAAAAAAAAB0AAAAAAAAAGcAAAAFAAAAeAAAAAEAAAB3AAAAAAAAAG8AAAAAAAAAcAAAAAEAAABzAAAAAAAAAG4AAAAAAAAAdQAAAAEAAABxAAAABQAAAGkAAAAFAAAAdgAAAAEAAAB5AAAAAAAAAHQAAAAAAAAAcgAAAAEAAAB4AAAAAQAAAHcAAAAAAAAAcgAAAAAAAABwAAAAAAAAAGsAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGUAAAADAAAAUwAAAAEAAABXAAAAAwAAAFUAAAADAAAAdgAAAAAAAAB4AAAAAAAAAHMAAAAFAAAAbAAAAAEAAAByAAAAAAAAAHAAAAAAAAAAXAAAAAEAAABkAAAAAAAAAGYAAAAAAAAAdQAAAAAAAAB5AAAABQAAAHcAAAAFAAAAbQAAAAEAAAB2AAAAAAAAAHgAAAAAAAAAXwAAAAEAAABsAAAAAQAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAGAAAAAgAAAAUAAAABAAAABAAAAAAAAAAAAAAABQAAAAMAAAABAAAABgAAAAQAAAACAAAAAAAAAH6iBfbytuk/Gq6akm/58z/Xrm0Liez0P5doSdOpSwRAWs602ULg8D/dT7Rcbo/1v1N1RQHFNOM/g9Snx7HW3L8HWsP8Q3jfP6VwOLosutk/9rjk1YQcxj+gnmKMsNn6P/HDeuPFY+M/YHwDjqKhB0Ci19/fCVrbP4UxKkDWOP6/pvljWa09tL9wi7wrQXjnv/Z6yLImkM2/3yTlOzY14D+m+WNZrT20PzwKVQnrQwNA9nrIsiaQzT/g40rFrRQFwPa45NWEHMa/kbslHEZq97/xw3rjxWPjv4cLC2SMBci/otff3wla27+rKF5oIAv0P1N1RQHFNOO/iDJPGyWHBUAHWsP8Q3jfvwQf/by16gXAfqIF9vK26b8XrO0Vh0r+v9eubQuJ7PS/BxLrA0ZZ479azrTZQuDwv1MK1EuItPw/yscgV9Z6FkAwHBR2WjQMQJNRzXsQ5vY/GlUHVJYKF0DONuFv2lMNQNCGZ28QJfk/0WUwoIL36D8ggDOMQuATQNqMOeAy/wZAWFYOYM+M2z/LWC4uH3oSQDE+LyTsMgRAkJzhRGWFGEDd4soovCQQQKqk0DJMEP8/rGmNdwOLBUAW2X/9xCbjP4hu3dcqJhNAzuYItRvdB0CgzW3zJW/sPxotm/Y2TxRAQAk9XmdDDEC1Kx9MKgT3P1M+NctcghZAFVqcLlb0C0Bgzd3sB2b2P77mZDPUWhZAFROHJpUGCEDAfma5CxXtPz1DWq/zYxRAmhYY5824F0DOuQKWSbAOQNCMqrvu3fs/L6DR22K2wT9nAAxPBU8RQGiN6mW43AFAZhu25b633D8c1YgmzowSQNM25BRKWARArGS08/lNxD+LFssHwmMRQLC5aNcxBgJABL9HT0WRF0CjCmJmOGEOQHsuaVzMP/s/TWJCaGGwBUCeu1PAPLzjP9nqN9DZOBNAKE4JcydbCkCGtbd1qjPzP8dgm9U8jhVAtPeKTkVwDkCeCLss5l37P401XMPLmBdAFd29VMVQDUBg0yA55h75Pz6odcYLCRdApBM4rBrkAkDyAVWgQxbRP4XDMnK20hFAymLlF7EmzD8GUgo9XBHlP3lbK7T9COc/k+OhPthhy7+YGEpnrOvCPzBFhLs15u4/epbqB6H4uz9IuuLF5svev6lzLKY31es/CaQ0envF5z8ZY0xlUADXv7zaz7HYEuI/CfbK1sn16T8uAQfWwxLWPzKn/YuFN94/5KdbC1AFu793fyCSnlfvPzK2y4doAMY/NRg5t1/X6b/shq4QJaHDP5yNIAKPOeI/vpn7BSE30r/X4YQrO6nrv78Ziv/Thto/DqJ1Y6+y5z9l51NaxFrlv8QlA65HOLS/86dxiEc96z+Hj0+LFjneP6LzBZ8LTc2/DaJ1Y6+y579l51NaxFrlP8QlA65HOLQ/8qdxiEc967+Jj0+LFjnev6LzBZ8LTc0/1qdbC1AFuz93fyCSnlfvvzK2y4doAMa/NRg5t1/X6T/vhq4QJaHDv5yNIAKPOeK/wJn7BSE30j/W4YQrO6nrP78Ziv/Thtq/CaQ0envF578XY0xlUADXP7zaz7HYEuK/CvbK1sn16b8rAQfWwxLWvzKn/YuFN96/zWLlF7EmzL8GUgo9XBHlv3lbK7T9COe/kOOhPthhyz+cGEpnrOvCvzBFhLs15u6/c5bqB6H4u79IuuLF5sveP6lzLKY31eu/AQAAAP////8HAAAA/////zEAAAD/////VwEAAP////9hCQAA/////6dBAAD/////kcsBAP/////3kAwA/////8H2VwAAAAAAAAAAAAAAAAACAAAA/////w4AAAD/////YgAAAP////+uAgAA/////8ISAAD/////ToMAAP////8ilwMA/////+4hGQD/////gu2vAAAAAAAAAAAAAAAAAAAAAAACAAAA//////////8BAAAAAwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////AgAAAP//////////AQAAAAAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD/////////////////////AQAAAP///////////////wIAAAD///////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP///////////////////////////////wIAAAD///////////////8BAAAA/////////////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAABAAAA//////////8CAAAA//////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAAAQAAAP//////////AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAACAAAAAAAAAAIAAAABAAAAAQAAAAIAAAACAAAAAAAAAAUAAAAFAAAAAAAAAAIAAAACAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAEAAAACAAAAAgAAAAIAAAAAAAAABQAAAAYAAAAAAAAAAgAAAAIAAAADAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAQAAAAMAAAACAAAAAgAAAAAAAAAFAAAABwAAAAAAAAACAAAAAgAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAIAAAABAAAABAAAAAIAAAACAAAAAAAAAAUAAAAIAAAAAAAAAAIAAAACAAAAAwAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAgAAAAIAAAAAAAAABQAAAAkAAAAAAAAAAgAAAAIAAAADAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAIAAAAAAAAAAwAAAA4AAAACAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAgAAAAMAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAgAAAAAAAAADAAAACgAAAAIAAAAAAAAAAgAAAAMAAAABAAAAAAAAAAIAAAACAAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAACAAAAAAAAAAMAAAALAAAAAgAAAAAAAAACAAAAAwAAAAIAAAAAAAAAAgAAAAIAAAADAAAACAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAIAAAAAAAAAAwAAAAwAAAACAAAAAAAAAAIAAAADAAAAAwAAAAAAAAACAAAAAgAAAAMAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAACAAAAAgAAAAAAAAADAAAADQAAAAIAAAAAAAAAAgAAAAMAAAAEAAAAAAAAAAIAAAACAAAAAwAAAAoAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAACAAAAAAAAAAMAAAAGAAAAAgAAAAAAAAACAAAAAwAAAA8AAAAAAAAAAgAAAAIAAAADAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAIAAAAAAAAAAwAAAAcAAAACAAAAAAAAAAIAAAADAAAAEAAAAAAAAAACAAAAAgAAAAMAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAgAAAAAAAAADAAAACAAAAAIAAAAAAAAAAgAAAAMAAAARAAAAAAAAAAIAAAACAAAAAwAAAA0AAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAACAAAAAAAAAAMAAAAJAAAAAgAAAAAAAAACAAAAAwAAABIAAAAAAAAAAgAAAAIAAAADAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAgAAAAIAAAAAAAAAAwAAAAUAAAACAAAAAAAAAAIAAAADAAAAEwAAAAAAAAACAAAAAgAAAAMAAAAPAAAAAAAAAAAAAAAAAAAAAAAAABAAAAACAAAAAAAAAAIAAAABAAAAEwAAAAIAAAACAAAAAAAAAAUAAAAKAAAAAAAAAAIAAAACAAAAAwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAIAAAAAAAAAAgAAAAEAAAAPAAAAAgAAAAIAAAAAAAAABQAAAAsAAAAAAAAAAgAAAAIAAAADAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAgAAAAAAAAACAAAAAQAAABAAAAACAAAAAgAAAAAAAAAFAAAADAAAAAAAAAACAAAAAgAAAAMAAAASAAAAAAAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAIAAAABAAAAEQAAAAIAAAACAAAAAAAAAAUAAAANAAAAAAAAAAIAAAACAAAAAwAAABMAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAIAAAAAAAAAAgAAAAEAAAASAAAAAgAAAAIAAAAAAAAABQAAAA4AAAAAAAAAAgAAAAIAAAADAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAEAAAAAAAAAAAEAAAAAAQAAAAAAAAAAAQAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAA6B6FaUp9QQTPXMuL4myJBraiDfBwx9UBYJseitzTIQOL5if9jqZtAnXX+Z+ycb0C3pucbhRBCQG8wJBYqpRRAlWbDCzCY5z/eFWBUEve6P/+qo4Q50Y4/D9YM3iCcYT8fcA2QJSA0P4ADxu0qAAc/BNcGolVJ2j5d9FACqwquPh9z7MthtI9CSUSYJke/YUJQ/64OyjU0Qpi0+HCmFQdCm3GfIVdh2kHsJ11kAyauQYC3UDFJOoFBSJsFV1OwU0FK5fcxX4AmQWhy/zZIt/lACqaCPsBjzUDbdUNIScugQMYQlVJ4MXNANiuq8GTvRUDxTXnulxEZQFZ8QX5kpuw/qmG/JwYFlEAluh3Q6DB+QKn4vyNq0GZAKOXekas+UUB8xabXXhI6QG63C2pLtSNAdDBtyNfLDUDyOcu67ID2P0rCMvRXAeE/Ki2TSVyzyT9Dk+8Sz2uzP5J+w5ARWp0/NQAoOiMuhj9YnP+RyMJwPxgW7TvQVFk/KgsLYF0kQz9g5dAC6IwzQcgHPVvDex1B1XjppodHBkHJq3OMM9fwQNvcmJ7wddlAInGPpQs/w0BRobq5EBmtQJZ2ai7n+ZVAtv2G5E+bgECG+gIfKBlpQK5f8jdI91JAL39sL/WpPEB8rGxhDqklQK6yUf43XhBAxL9y/tK8+D86XyZpgrHiPwAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAP////8AAAAAAAAAAAAAAAABAAAAAAAAAAAAAAD/////AAAAAAAAAAABAAAAAQAAAAAAAAAAAAAA/////wAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAP////8FAAAABQAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAEAAAAAAAAABQAAAAEAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAQABAAABAQAAAAAAAQAAAAEAAAABAAEAAAAAAAAAAAAAAAAAAAAAquJYWJZl+D9jaeZNtj/zPwwdI9KqaeO/qGefXwdHdz+q4lhYlmX4P+OrlPMN3PI/DB0j0qpp47+7SQLV4VIEQKriWFiWZfg/r2kma3tz8T82eQmLqNIGwMRIWXMqSvo/fcCszPux9j+jara6ozTwP6hnn18HR3c/MSoKLequ8r+SabgA2nj0P7jBLbDOHO8/1Ym/ICfH4T+6lxjvlFXHv73m373LRPU/0vXyDVxo7T+ToKRHJXMAQF/33578aPE/pAyy64tD9T8+U/hCvyruPwxv8Y7YYwLAuXYr8NAiCEB4+LDK0Sn0P1Qeuy4j+eo/OMx50n7K7L+TrGB/nyf8v5ehC2fbYPM/aXMKexiT6z8mFRIMjg/zP7yUVwGGBNw/E6opHERf8z/z0wR2g9DqPw4pBpcOhvu/NbA29uWAA8DMaTExyXzyP02biiQ+Ruk/S8jz2/FKBEB1pzZnpbb9P7pQU4wLfPI//7ZcQXeG6D9CqEQvAYoIwDB2VB6sSgRAVyv8H5We8T+EHWF8XNPmPzB2wT8Nrrg/SEi+cX+w4L8of+GtdSDxP1sjk5AdouU/6ZjOVru13r8K0obqI6bxvwVbdNXyhfA/w5GG024n5z+rwmtMzP8BwLw9pSX49QXABe/2uQxP8D+b6wCzCvXkP7uGT87fK+Q/pz/JWw4coj+qoBf2J0nwP/yE3PUo0+I/vFJeHcaC+D96luSIqvntP/bf8sHUYu8/gZNN41mL4z9bhOqVOF4FwO6lmAh1hQhAbCVxbdhk7z+1C8NdDcfiPwG36x/0OQBAx0WJ76c2+D9nlSHXANfuP2HlfZ3gqOE/EwnVlVPg9r96+oHzEH//v5bXzdT1Auw/DM3GwLsA4D9p/8uoKcr+v+U9x5DQVAPAehjSdghb7D9sc1IetODgP8MVwwB1pu6/azPk6OGe978W8t/TUc3rP+0QMvYfP+A/RsG/QpSE8D+l3uwScxzgPwQaifgujuw/k1Vti1I43z8MAwLnSh0GQH5nYnwwZgJAiGUzWC5s6j8WyyI/BbLgPw4iUapGeQJAB3W+imnp/j9BLWR4ssrpP2t+gG5Pstk/cpBsfm6DCMCOpU9dOZsFQEv8nFypHeo/ehJ6i+6S2D9jqlGEmarLv7STC5TRiOa/bC+x8WZD6D9H3yUkWpDZP8gZvmCMuQLAreY19/eRBsCoPOc8UzzpP6KI/QV+y9g/t/MoboyWzT+Hv5q3Zu3Mvy2xROCT4uY/9gQitMMg1T9abAqhWMDkv1oLTavoUfG/PMUJP9CD5j+fHRX3t6fSPz7W2gk6bvs/WRnuHwqN9D8YFturGCTmP1EZczv0b9I/5t4exabB5D/1ESLh5fTEP9X2z6SYweQ/6lv3I2zT0D9zkRGNUNMAQKoSvc4EIfs/Xggt8wQI5T+mJHHg/w/SP4lhT/9t8vQ/DrZ/DbwH7D+XlhbYZrjkP34LIpFt6c4/lwfp8fLX9L+j96CTTf76v3WdNhEv9uM/d8c3o4lV0D/vFdCHVcsFwAHeDq0F1QhApbYqcZiN5D9KoilqByXLPwX0/diA0vq/0fo0GxnxAMBbaTkvlCzjP/RrFrWXrMs/UYTrky7jA0DB9f4FiZYAQEGAk/3QzeE/r/TeqE8t0D/OqjlsnPbvvz8RKU8JOfW/smSEbK/O4T8MzuyPm3DDP/rFtctq9gZAfb1EVEaSA0Dts5dVInnhP18SFMc79MM/7y34cw6LAMDFrRJsZO0DwC2KLvLSYuA/hx5wcUHewz+49SnK/4ruPyeS0PX9a+E/ZxaaLvvZ3z8WPu5T2QS8Pygo4RIvMqa/BJ0Kqsd0279cKW4ay8jdP3b05bmZ364/10/qtdxk2r+Bcz6CDMvpv54qOw+Amdw/qLV71pW7sT/YKc80nIPUP8OfIaBJ77G/LyTuD1un2z+diYu8efWzP1wU7ACkfwjAZroyPL1yBkAmv3lKJJbbPysKSE4W+p0/dIgqY79TA8ATLTOQ3tsGwJ2zweD/Xdg/XO/jXeFUaL8VW2qLFKfov1cA9Aa6XfK/tIa7YGgI2T+f3hu/sxqPv2nXdPpf3Pc/jkw8Jbda8j+tT/z8tGPVP1yBHpJd35k/KYvYOy1s8j/yz+kCQjPrP9+agH7x59g/PZfJ9aBhpr/rDKzvYBb+PwtkiaGCt/c/vb1mVr+f1T/JIHwHc8Govw7aeF6+9vG/Xv7kD6fp979isYioQYHVP7AIQZuSFrG/3z1AdUTnAUDN3XY9O7f9P0AdQ9ljYNQ/dJANJPTOrb8kLECUiiPlP4yF7UgmStA/9xGmXxCG1T9qZzix4W2zv2SGJRJVrPe/Fh9a2M/B/b8IexzFCoPSP9y1QFD2bLe/Q86cWLJe/b+mOOfYm78BwOTjkPAGE9E/8aPCUKu/ub9pPZyLCiUGwBA7Mev/BQlALOmrlRi+0j+AMJ/dKULBv7iLtL6a6QRAEMDV/yajAUDa62dE3crJP1P70RgBUbq/38hVnR6esT/s1tG10Z/Ov/zLwalHPss/dTS9NKTXx78nMcRzCIEHQAabxDsAmQRA0tyLK3gSyT+Aui7nOhDGv5Gs58z3WgHATN3forJuBMCAui7nOhDGP9Lciyt4Esm/WAJyHQ4c7z8UP5HFIs3iP3U0vTSk18c//MvBqUc+y7+cvv8HLg/Kvy1I/mHsI+K/U/vRGAFRuj/a62dE3crJv8p+WV8KlQjAuQ/nOP43B0CAMJ/dKULBPyzpq5UYvtK/ZoU+VoLh4L9etLlRUfvtv/GjwlCrv7k/5OOQ8AYT0b9DfT9FhufXPwUX8hJp+4u/3LVAUPZstz8IexzFCoPSv9+L609E5fQ/q9Fz7X2J7T9qZzix4W2zP/cRpl8QhtW/vtNilqGX+j8MOy7QJoL0P3SQDST0zq0/QB1D2WNg1L8IIjSvGNkDwGB8Jou2GAfAsAhBm5IWsT9isYioQYHVvyS9D3zb6uy/gnwRa7uM9L/JIHwHc8GoP729Zla/n9W/CsAHJZwmAEDEW6OYT1r6Pz2XyfWgYaY/35qAfvHn2L83Tdy4lS30vxf2/gZ0jPq/XIEekl3fmb+tT/z8tGPVvybPr2zJ1/+/K7mJ0ypVAsCf3hu/sxqPPwCGu2BoCNm/5oITrpZn+r+UDUyDP+n/v1zv413hVGg/nbPB4P9d2L9MlmkxNvgCQMtZlKE85v8/KwpIThb6nb8mv3lKJJbbv8+SZsTvOOc/pQCIIOYw0j+diYu8efWzvy8k7g9bp9u/kxYDa+pKtD9XlYvA8HnVv6i1e9aVu7G/nio7D4CZ3L/WR6rNh5EGwCkgQweBkghAdvTluZnfrr9cKW4ay8jdvxbjhr1f1QVAR5C0MzivAkAWPu5T2QS8v2cWmi772d+/cKj4lzLJCEBx2QJfYrMFQIcecHFB3sO/LYou8tJi4L+jr7lhO38BwIcI0Nb7xgTAXxIUxzv0w7/ts5dVInnhv0T+l8DZLfE/MP3FoFvS5D8MzuyPm3DDv7JkhGyvzuG/tzhzRIRc0b9Ovv3/0z7mv6/03qhPLdC/m4CT/dDN4b9dwjU5VCQBQBBJX1ntCv0/9GsWtZesy79baTkvlCzjv1mjYgEz++S/oW6KnOQW8b9KoilqByXLv6W2KnGYjeS/SmaKz3Vx9z+BZB5yxGHwP3fHN6OJVdC/dZ02ES/2478PuaBjLrXaP4/JU81pPaO/fgsikW3pzr+XlhbYZrjkv4tSn7YDbP0/f2LnFKlF9z+mJHHg/w/Sv14ILfMECOW/mfg4qYhR/b+OP+RQDCACwOpb9yNs09C/1fbPpJjB5L9pN2WOVZ3wv3hHy9nxIve/URlzO/Rv0r8YFturGCTmv1d1/KKR8QPA8gsy9qzSB8CfHRX3t6fSvzzFCT/Qg+a/EYStnrzV9r/2QJqI7Lb9v/YEIrTDINW/LbFE4JPi5r/7kQEs5fEDQHunnf4GeQBAooj9BX7L2L+oPOc8Uzzpv+ydYY2SSAfAL4HK6CRTB0BH3yUkWpDZv2wvsfFmQ+i/Ik0Yzruh6T8fM3LoGoDUP3oSeovukti/S/ycXKkd6r9rEv+7UWcHQCRIQe/GfwNAa36Abk+y2b9BLWR4ssrpv9KT87qa0bM/FTyktw823L8WyyI/BbLgv4hlM1gubOq/DizMp9Ki6r8b5ckdjVrzv5NVbYtSON+/BBqJ+C6O7L/dUBFqgyXYv00Wh18r7+q/7RAy9h8/4L8W8t/TUc3rv4RM5DKx3wDAfvWIj94aBcBsc1IetODgv3oY0nYIW+y/oGcTFF54AUDkJqS/FKX6PwzNxsC7AOC/ltfN1PUC7L+5Wrz/zHnzP6688w2rNOc/YeV9neCo4b9nlSHXANfuvw9RsxKjY/s/1V8GteXE8j+1C8NdDcfiv2wlcW3YZO+/IOywaA7Q8b9bFP+4Tg36v4GTTeNZi+O/9t/ywdRi77+tRc3yFR7eP2bkcHXJkLO//ITc9SjT4r+qoBf2J0nwv2YHKoswwfm/iQcLspCjAcCb6wCzCvXkvwXv9rkMT/C/YkuwYAMXBMApCNUai9kIwMORhtNuJ+e/BVt01fKF8L+ZqWEfvIjsP6h693QZYNk/WyOTkB2i5b8of+GtdSDxvwpaaulDSwVADMQAX+lOAECEHWF8XNPmv1cr/B+VnvG/XyFG6opcCMD/mtR32/UEQP+2XEF3hui/ulBTjAt88r/imfCfRP+yP9zbvtc8XeO/TZuKJD5G6b/MaTExyXzyvxiTQeElXOO/rbJRQVGN9L/z0wR2g9DqvxOqKRxEX/O/FDGCEei99j9x8zV4VYTmP2lzCnsYk+u/l6ELZ9tg878pRXacaDT/v3k6GZRqoQXAVB67LiP56r94+LDK0Sn0vwO6pZ9b7wFAvK0nKVcc9j8+U/hCvyruv6QMsuuLQ/W/FPhKFYv46j8MyxaDTOW/v9L18g1caO2/vebfvctE9b/7GD8ZrF3xv3gx1AR9bQDAuMEtsM4c77+SabgA2nj0v5xKFIwxsATArKNSBaKsB0Cjara6ozTwv33ArMz7sfa/dF2U0FcWCcDxL357DJX/P69pJmt7c/G/quJYWJZl+L/YntVJlnrSP4sRLzXM+fe/46uU8w3c8r+q4lhYlmX4v85lu5+QRwRAsI0H/WU8479jaeZNtj/zv6riWFiWZfi/sI0H/WU847/OZbufkEcEQHAoPUBrnss/9exKzDtFtT88wM8kax+gP9OqeKeAYog/MW0ItiZvcj+ph+smvt5bP2lCaV5dEUU/StaUmQDaLz+kK9y22BMYP0O3whZuMwI/IIbgZGWE6z7UkjYaEM3UPuezxwa9cr8+LybxRMnFpz6E1N8DbPiRPsYjySMvK3s+//////8fAAj//////zMQCP////9/MiAI/////28yMAj/////YzJACP///z9iMlAI////N2IyYAj///8zYjJwCP//vzNiMoAI//+rM2IykAj/f6szYjKgCP8PqzNiMrAI/wOrM2IywAi/A6szYjLQCJ8DqzNiMuAImQOrM2Iy8Aj//////z8PCP//////Kx8I/////38pLwj/////Pyk/CP////85KU8I////PzgpXwj///8POClvCP///w44KX8I//8fDjgpjwj//w8OOCmfCP9/DQ44Ka8I/w8NDjgpvwj/DQ0OOCnPCP8MDQ44Kd8IxwwNDjgp7wjEDA0OOCn/CAcAAAAHAAAAAQAAAAIAAAAEAAAAAwAAAAAAAAAAAAAABwAAAAMAAAABAAAAAgAAAAUAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAGAAAAAgAAAAMAAAAFAAAABAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAwAAAAEAAAAFAAAABAAAAAAAAAAAAAAABwAAAAUAAAADAAAABAAAAAEAAAAAAAAAAgAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAABgtRFT7Ifk/GC1EVPsh+b8YLURU+yEJQBgtRFT7IQnAYWxnb3MuYwBoM05laWdoYm9yUm90YXRpb25zAGNvb3JkaWprLmMAX3VwQXA3Q2hlY2tlZABfdXBBcDdyQ2hlY2tlZABkaXJlY3RlZEVkZ2UuYwBkaXJlY3RlZEVkZ2VUb0JvdW5kYXJ5AGFkamFjZW50RmFjZURpclt0bXBGaWprLmZhY2VdW2ZpamsuZmFjZV0gPT0gS0kAZmFjZWlqay5jAF9mYWNlSWprUGVudFRvQ2VsbEJvdW5kYXJ5AGFkamFjZW50RmFjZURpcltjZW50ZXJJSksuZmFjZV1bZmFjZTJdID09IEtJAF9mYWNlSWprVG9DZWxsQm91bmRhcnkAaDNJbmRleC5jAGNvbXBhY3RDZWxscwBsYXRMbmdUb0NlbGwAY2VsbFRvQ2hpbGRQb3MAdmFsaWRhdGVDaGlsZFBvcwBsYXRMbmcuYwBjZWxsQXJlYVJhZHMyAHBvbHlnb24tPm5leHQgPT0gTlVMTABsaW5rZWRHZW8uYwBhZGROZXdMaW5rZWRQb2x5Z29uAG5leHQgIT0gTlVMTABsb29wICE9IE5VTEwAYWRkTmV3TGlua2VkTG9vcABwb2x5Z29uLT5maXJzdCA9PSBOVUxMAGFkZExpbmtlZExvb3AAY29vcmQgIT0gTlVMTABhZGRMaW5rZWRDb29yZABsb29wLT5maXJzdCA9PSBOVUxMAGlubmVyTG9vcHMgIT0gTlVMTABub3JtYWxpemVNdWx0aVBvbHlnb24AYmJveGVzICE9IE5VTEwAY2FuZGlkYXRlcyAhPSBOVUxMAGZpbmRQb2x5Z29uRm9ySG9sZQBjYW5kaWRhdGVCQm94ZXMgIT0gTlVMTAByZXZEaXIgIT0gSU5WQUxJRF9ESUdJVABsb2NhbGlqLmMAY2VsbFRvTG9jYWxJamsAYmFzZUNlbGwgIT0gb3JpZ2luQmFzZUNlbGwAIShvcmlnaW5PblBlbnQgJiYgaW5kZXhPblBlbnQpAGJhc2VDZWxsID09IG9yaWdpbkJhc2VDZWxsAGJhc2VDZWxsICE9IElOVkFMSURfQkFTRV9DRUxMAGxvY2FsSWprVG9DZWxsACFfaXNCYXNlQ2VsbFBlbnRhZ29uKGJhc2VDZWxsKQBiYXNlQ2VsbFJvdGF0aW9ucyA+PSAwAGdyaWRQYXRoQ2VsbHMAcG9seWZpbGwuYwBpdGVyU3RlcFBvbHlnb25Db21wYWN0ADAAdmVydGV4LmMAdmVydGV4Um90YXRpb25zAGNlbGxUb1ZlcnRleABncmFwaC0+YnVja2V0cyAhPSBOVUxMAHZlcnRleEdyYXBoLmMAaW5pdFZlcnRleEdyYXBoAG5vZGUgIT0gTlVMTABhZGRWZXJ0ZXhOb2Rl";
  var tempDoublePtr = 28640;
  function demangle(func) {
    return func;
  }
  function demangleAll(text) {
    var regex = /\b__Z[\w\d_]+/g;
    return text.replace(regex, function(x) {
      var y = demangle(x);
      return x === y ? x : y + " [" + x + "]";
    });
  }
  function jsStackTrace() {
    var err2 = new Error();
    if (!err2.stack) {
      try {
        throw new Error(0);
      } catch (e2) {
        err2 = e2;
      }
      if (!err2.stack) {
        return "(no stack trace available)";
      }
    }
    return err2.stack.toString();
  }
  function stackTrace() {
    var js = jsStackTrace();
    if (Module["extraStackTrace"]) {
      js += "\n" + Module["extraStackTrace"]();
    }
    return demangleAll(js);
  }
  function ___assert_fail(condition, filename, line, func) {
    abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  }
  function _emscripten_get_heap_size() {
    return HEAP8.length;
  }
  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
  }
  function ___setErrNo(value) {
    if (Module["___errno_location"]) {
      HEAP32[Module["___errno_location"]() >> 2] = value;
    }
    return value;
  }
  function abortOnCannotGrowMemory(requestedSize) {
    abort("OOM");
  }
  function emscripten_realloc_buffer(size) {
    try {
      var newBuffer = new ArrayBuffer(size);
      if (newBuffer.byteLength != size) {
        return;
      }
      new Int8Array(newBuffer).set(HEAP8);
      _emscripten_replace_memory(newBuffer);
      updateGlobalBufferAndViews(newBuffer);
      return 1;
    } catch (e2) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    var oldSize = _emscripten_get_heap_size();
    var PAGE_MULTIPLE = 16777216;
    var LIMIT = 2147483648 - PAGE_MULTIPLE;
    if (requestedSize > LIMIT) {
      return false;
    }
    var MIN_TOTAL_MEMORY = 16777216;
    var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
    while (newSize < requestedSize) {
      if (newSize <= 536870912) {
        newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
      } else {
        newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
      }
    }
    var replacement = emscripten_realloc_buffer(newSize);
    if (!replacement) {
      return false;
    }
    return true;
  }
  var decodeBase64 = typeof atob === "function" ? atob : function(input) {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var output = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    do {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output = output + String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output = output + String.fromCharCode(chr3);
      }
    } while (i < input.length);
    return output;
  };
  function intArrayFromBase64(s) {
    try {
      var decoded = decodeBase64(s);
      var bytes = new Uint8Array(decoded.length);
      for (var i = 0; i < decoded.length; ++i) {
        bytes[i] = decoded.charCodeAt(i);
      }
      return bytes;
    } catch (_) {
      throw new Error("Converting base64 string to bytes failed.");
    }
  }
  function tryParseAsDataURI(filename) {
    if (!isDataURI(filename)) {
      return;
    }
    return intArrayFromBase64(filename.slice(dataURIPrefix.length));
  }
  var asmGlobalArg = {
    "Math": Math,
    "Int8Array": Int8Array,
    "Int32Array": Int32Array,
    "Uint8Array": Uint8Array,
    "Float32Array": Float32Array,
    "Float64Array": Float64Array
  };
  var asmLibraryArg = {
    "a": abort,
    "b": setTempRet0,
    "c": getTempRet0,
    "d": ___assert_fail,
    "e": ___setErrNo,
    "f": _emscripten_get_heap_size,
    "g": _emscripten_memcpy_big,
    "h": _emscripten_resize_heap,
    "i": abortOnCannotGrowMemory,
    "j": demangle,
    "k": demangleAll,
    "l": emscripten_realloc_buffer,
    "m": jsStackTrace,
    "n": stackTrace,
    "o": tempDoublePtr,
    "p": DYNAMICTOP_PTR
  };
  var asm = (
    /** @suppress {uselessCode} */
    function(global2, env, buffer2) {
      "almost asm";
      var a3 = new global2.Int8Array(buffer2), b3 = new global2.Int32Array(buffer2), c2 = new global2.Uint8Array(buffer2), d2 = new global2.Float32Array(buffer2), e2 = new global2.Float64Array(buffer2), f = env.o | 0, g = env.p | 0, p = global2.Math.floor, q = global2.Math.abs, r = global2.Math.sqrt, s = global2.Math.pow, t = global2.Math.cos, u2 = global2.Math.sin, v2 = global2.Math.tan, w2 = global2.Math.acos, x = global2.Math.asin, y = global2.Math.atan, z = global2.Math.atan2, A2 = global2.Math.ceil, B2 = global2.Math.imul, C2 = global2.Math.min, D2 = global2.Math.max, E2 = global2.Math.clz32, G2 = env.b, H = env.c, I = env.d, J = env.e, K = env.f, L2 = env.g, M = env.h, N = env.i, T = 28656;
      function W2(newBuffer) {
        a3 = new Int8Array(newBuffer);
        c2 = new Uint8Array(newBuffer);
        b3 = new Int32Array(newBuffer);
        d2 = new Float32Array(newBuffer);
        e2 = new Float64Array(newBuffer);
        buffer2 = newBuffer;
        return true;
      }
      function X(a4) {
        a4 = a4 | 0;
        var b4 = 0;
        b4 = T;
        T = T + a4 | 0;
        T = T + 15 & -16;
        return b4 | 0;
      }
      function Y() {
        return T | 0;
      }
      function Z(a4) {
        a4 = a4 | 0;
        T = a4;
      }
      function _(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        T = a4;
      }
      function $(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0;
        if ((a4 | 0) < 0) {
          c3 = 2;
          return c3 | 0;
        }
        if ((a4 | 0) > 13780509) {
          c3 = xc(15, c3) | 0;
          return c3 | 0;
        } else {
          d3 = ((a4 | 0) < 0) << 31 >> 31;
          f2 = Pd(a4 | 0, d3 | 0, 3, 0) | 0;
          e3 = H() | 0;
          d3 = Jd(a4 | 0, d3 | 0, 1, 0) | 0;
          d3 = Pd(f2 | 0, e3 | 0, d3 | 0, H() | 0) | 0;
          d3 = Jd(d3 | 0, H() | 0, 1, 0) | 0;
          a4 = H() | 0;
          b3[c3 >> 2] = d3;
          b3[c3 + 4 >> 2] = a4;
          c3 = 0;
          return c3 | 0;
        }
        return 0;
      }
      function aa(a4, b4, c3, d3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        return ba(a4, b4, c3, d3, 0) | 0;
      }
      function ba(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0;
        j = T;
        T = T + 16 | 0;
        h = j;
        if (!(ca(a4, c3, d3, e3, f2) | 0)) {
          e3 = 0;
          T = j;
          return e3 | 0;
        }
        do {
          if ((d3 | 0) >= 0) {
            if ((d3 | 0) > 13780509) {
              g2 = xc(15, h) | 0;
              if (g2 | 0) {
                break;
              }
              i = h;
              h = b3[i >> 2] | 0;
              i = b3[i + 4 >> 2] | 0;
            } else {
              g2 = ((d3 | 0) < 0) << 31 >> 31;
              k = Pd(d3 | 0, g2 | 0, 3, 0) | 0;
              i = H() | 0;
              g2 = Jd(d3 | 0, g2 | 0, 1, 0) | 0;
              g2 = Pd(k | 0, i | 0, g2 | 0, H() | 0) | 0;
              g2 = Jd(g2 | 0, H() | 0, 1, 0) | 0;
              i = H() | 0;
              b3[h >> 2] = g2;
              b3[h + 4 >> 2] = i;
              h = g2;
            }
            _d(e3 | 0, 0, h << 3 | 0) | 0;
            if (f2 | 0) {
              _d(f2 | 0, 0, h << 2 | 0) | 0;
              g2 = da(a4, c3, d3, e3, f2, h, i, 0) | 0;
              break;
            }
            g2 = Id(h, 4) | 0;
            if (!g2) {
              g2 = 13;
            } else {
              k = da(a4, c3, d3, e3, g2, h, i, 0) | 0;
              Hd(g2);
              g2 = k;
            }
          } else {
            g2 = 2;
          }
        } while (0);
        k = g2;
        T = j;
        return k | 0;
      }
      function ca(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0;
        q2 = T;
        T = T + 16 | 0;
        o = q2;
        p2 = q2 + 8 | 0;
        n = o;
        b3[n >> 2] = a4;
        b3[n + 4 >> 2] = c3;
        if ((d3 | 0) < 0) {
          p2 = 2;
          T = q2;
          return p2 | 0;
        }
        g2 = e3;
        b3[g2 >> 2] = a4;
        b3[g2 + 4 >> 2] = c3;
        g2 = (f2 | 0) != 0;
        if (g2) {
          b3[f2 >> 2] = 0;
        }
        if (Kb(a4, c3) | 0) {
          p2 = 9;
          T = q2;
          return p2 | 0;
        }
        b3[p2 >> 2] = 0;
        a: do {
          if ((d3 | 0) >= 1) {
            if (g2) {
              l = 1;
              k = 0;
              m = 0;
              n = 1;
              g2 = a4;
              while (1) {
                if (!(k | m)) {
                  g2 = ea(g2, c3, 4, p2, o) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  c3 = o;
                  g2 = b3[c3 >> 2] | 0;
                  c3 = b3[c3 + 4 >> 2] | 0;
                  if (Kb(g2, c3) | 0) {
                    g2 = 9;
                    break a;
                  }
                }
                g2 = ea(g2, c3, b3[26800 + (m << 2) >> 2] | 0, p2, o) | 0;
                if (g2 | 0) {
                  break a;
                }
                c3 = o;
                g2 = b3[c3 >> 2] | 0;
                c3 = b3[c3 + 4 >> 2] | 0;
                a4 = e3 + (l << 3) | 0;
                b3[a4 >> 2] = g2;
                b3[a4 + 4 >> 2] = c3;
                b3[f2 + (l << 2) >> 2] = n;
                a4 = k + 1 | 0;
                h = (a4 | 0) == (n | 0);
                i = m + 1 | 0;
                j = (i | 0) == 6;
                if (Kb(g2, c3) | 0) {
                  g2 = 9;
                  break a;
                }
                n = n + (j & h & 1) | 0;
                if ((n | 0) > (d3 | 0)) {
                  g2 = 0;
                  break;
                } else {
                  l = l + 1 | 0;
                  k = h ? 0 : a4;
                  m = h ? j ? 0 : i : m;
                }
              }
            } else {
              l = 1;
              k = 0;
              m = 0;
              n = 1;
              g2 = a4;
              while (1) {
                if (!(k | m)) {
                  g2 = ea(g2, c3, 4, p2, o) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  c3 = o;
                  g2 = b3[c3 >> 2] | 0;
                  c3 = b3[c3 + 4 >> 2] | 0;
                  if (Kb(g2, c3) | 0) {
                    g2 = 9;
                    break a;
                  }
                }
                g2 = ea(g2, c3, b3[26800 + (m << 2) >> 2] | 0, p2, o) | 0;
                if (g2 | 0) {
                  break a;
                }
                c3 = o;
                g2 = b3[c3 >> 2] | 0;
                c3 = b3[c3 + 4 >> 2] | 0;
                a4 = e3 + (l << 3) | 0;
                b3[a4 >> 2] = g2;
                b3[a4 + 4 >> 2] = c3;
                a4 = k + 1 | 0;
                h = (a4 | 0) == (n | 0);
                i = m + 1 | 0;
                j = (i | 0) == 6;
                if (Kb(g2, c3) | 0) {
                  g2 = 9;
                  break a;
                }
                n = n + (j & h & 1) | 0;
                if ((n | 0) > (d3 | 0)) {
                  g2 = 0;
                  break;
                } else {
                  l = l + 1 | 0;
                  k = h ? 0 : a4;
                  m = h ? j ? 0 : i : m;
                }
              }
            }
          } else {
            g2 = 0;
          }
        } while (0);
        p2 = g2;
        T = q2;
        return p2 | 0;
      }
      function da(a4, c3, d3, e3, f2, g2, h, i) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h = h | 0;
        i = i | 0;
        var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0;
        q2 = T;
        T = T + 16 | 0;
        o = q2 + 8 | 0;
        p2 = q2;
        j = Rd(a4 | 0, c3 | 0, g2 | 0, h | 0) | 0;
        l = H() | 0;
        m = e3 + (j << 3) | 0;
        r2 = m;
        s2 = b3[r2 >> 2] | 0;
        r2 = b3[r2 + 4 >> 2] | 0;
        k = (s2 | 0) == (a4 | 0) & (r2 | 0) == (c3 | 0);
        if (!((s2 | 0) == 0 & (r2 | 0) == 0 | k)) {
          do {
            j = Jd(j | 0, l | 0, 1, 0) | 0;
            j = Qd(j | 0, H() | 0, g2 | 0, h | 0) | 0;
            l = H() | 0;
            m = e3 + (j << 3) | 0;
            s2 = m;
            r2 = b3[s2 >> 2] | 0;
            s2 = b3[s2 + 4 >> 2] | 0;
            k = (r2 | 0) == (a4 | 0) & (s2 | 0) == (c3 | 0);
          } while (!((r2 | 0) == 0 & (s2 | 0) == 0 | k));
        }
        j = f2 + (j << 2) | 0;
        if (k ? (b3[j >> 2] | 0) <= (i | 0) : 0) {
          s2 = 0;
          T = q2;
          return s2 | 0;
        }
        s2 = m;
        b3[s2 >> 2] = a4;
        b3[s2 + 4 >> 2] = c3;
        b3[j >> 2] = i;
        if ((i | 0) >= (d3 | 0)) {
          s2 = 0;
          T = q2;
          return s2 | 0;
        }
        k = i + 1 | 0;
        b3[o >> 2] = 0;
        j = ea(a4, c3, 2, o, p2) | 0;
        switch (j | 0) {
          case 9: {
            n = 9;
            break;
          }
          case 0: {
            j = p2;
            j = da(b3[j >> 2] | 0, b3[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
            if (!j) {
              n = 9;
            }
            break;
          }
          default:
        }
        a: do {
          if ((n | 0) == 9) {
            b3[o >> 2] = 0;
            j = ea(a4, c3, 3, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b3[j >> 2] | 0, b3[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b3[o >> 2] = 0;
            j = ea(a4, c3, 1, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b3[j >> 2] | 0, b3[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b3[o >> 2] = 0;
            j = ea(a4, c3, 5, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b3[j >> 2] | 0, b3[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b3[o >> 2] = 0;
            j = ea(a4, c3, 4, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b3[j >> 2] | 0, b3[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b3[o >> 2] = 0;
            j = ea(a4, c3, 6, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da(b3[j >> 2] | 0, b3[j + 4 >> 2] | 0, d3, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            s2 = 0;
            T = q2;
            return s2 | 0;
          }
        } while (0);
        s2 = j;
        T = q2;
        return s2 | 0;
      }
      function ea(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        if (d3 >>> 0 > 6) {
          f2 = 1;
          return f2 | 0;
        }
        m = (b3[e3 >> 2] | 0) % 6 | 0;
        b3[e3 >> 2] = m;
        if ((m | 0) > 0) {
          g2 = 0;
          do {
            d3 = $a(d3) | 0;
            g2 = g2 + 1 | 0;
          } while ((g2 | 0) < (b3[e3 >> 2] | 0));
        }
        m = Td(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        l = m & 127;
        if (l >>> 0 > 121) {
          f2 = 5;
          return f2 | 0;
        }
        j = Sb(a4, c3) | 0;
        g2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        a: do {
          if (!g2) {
            k = 8;
          } else {
            while (1) {
              h = (15 - g2 | 0) * 3 | 0;
              i = Td(a4 | 0, c3 | 0, h | 0) | 0;
              H() | 0;
              i = i & 7;
              if ((i | 0) == 7) {
                c3 = 5;
                break;
              }
              p2 = (Yb(g2) | 0) == 0;
              g2 = g2 + -1 | 0;
              n = Ud(7, 0, h | 0) | 0;
              c3 = c3 & ~(H() | 0);
              o = Ud(b3[(p2 ? 432 : 16) + (i * 28 | 0) + (d3 << 2) >> 2] | 0, 0, h | 0) | 0;
              h = H() | 0;
              d3 = b3[(p2 ? 640 : 224) + (i * 28 | 0) + (d3 << 2) >> 2] | 0;
              a4 = o | a4 & ~n;
              c3 = h | c3;
              if (!d3) {
                d3 = 0;
                break a;
              }
              if (!g2) {
                k = 8;
                break a;
              }
            }
            return c3 | 0;
          }
        } while (0);
        if ((k | 0) == 8) {
          p2 = b3[848 + (l * 28 | 0) + (d3 << 2) >> 2] | 0;
          o = Ud(p2 | 0, 0, 45) | 0;
          a4 = o | a4;
          c3 = H() | 0 | c3 & -1040385;
          d3 = b3[4272 + (l * 28 | 0) + (d3 << 2) >> 2] | 0;
          if ((p2 & 127 | 0) == 127) {
            p2 = Ud(b3[848 + (l * 28 | 0) + 20 >> 2] | 0, 0, 45) | 0;
            c3 = H() | 0 | c3 & -1040385;
            d3 = b3[4272 + (l * 28 | 0) + 20 >> 2] | 0;
            a4 = Ub(p2 | a4, c3) | 0;
            c3 = H() | 0;
            b3[e3 >> 2] = (b3[e3 >> 2] | 0) + 1;
          }
        }
        i = Td(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        i = i & 127;
        b: do {
          if (!(oa(i) | 0)) {
            if ((d3 | 0) > 0) {
              g2 = 0;
              do {
                a4 = Ub(a4, c3) | 0;
                c3 = H() | 0;
                g2 = g2 + 1 | 0;
              } while ((g2 | 0) != (d3 | 0));
            }
          } else {
            c: do {
              if ((Sb(a4, c3) | 0) == 1) {
                if ((l | 0) != (i | 0)) {
                  if (ua(i, b3[7696 + (l * 28 | 0) >> 2] | 0) | 0) {
                    a4 = Wb(a4, c3) | 0;
                    h = 1;
                    c3 = H() | 0;
                    break;
                  } else {
                    I(27795, 26864, 533, 26872);
                  }
                }
                switch (j | 0) {
                  case 3: {
                    a4 = Ub(a4, c3) | 0;
                    c3 = H() | 0;
                    b3[e3 >> 2] = (b3[e3 >> 2] | 0) + 1;
                    h = 0;
                    break c;
                  }
                  case 5: {
                    a4 = Wb(a4, c3) | 0;
                    c3 = H() | 0;
                    b3[e3 >> 2] = (b3[e3 >> 2] | 0) + 5;
                    h = 0;
                    break c;
                  }
                  case 0: {
                    p2 = 9;
                    return p2 | 0;
                  }
                  default: {
                    p2 = 1;
                    return p2 | 0;
                  }
                }
              } else {
                h = 0;
              }
            } while (0);
            if ((d3 | 0) > 0) {
              g2 = 0;
              do {
                a4 = Tb(a4, c3) | 0;
                c3 = H() | 0;
                g2 = g2 + 1 | 0;
              } while ((g2 | 0) != (d3 | 0));
            }
            if ((l | 0) != (i | 0)) {
              if (!(pa(i) | 0)) {
                if ((h | 0) != 0 | (Sb(a4, c3) | 0) != 5) {
                  break;
                }
                b3[e3 >> 2] = (b3[e3 >> 2] | 0) + 1;
                break;
              }
              switch (m & 127) {
                case 8:
                case 118:
                  break b;
                default:
              }
              if ((Sb(a4, c3) | 0) != 3) {
                b3[e3 >> 2] = (b3[e3 >> 2] | 0) + 1;
              }
            }
          }
        } while (0);
        b3[e3 >> 2] = ((b3[e3 >> 2] | 0) + d3 | 0) % 6 | 0;
        p2 = f2;
        b3[p2 >> 2] = a4;
        b3[p2 + 4 >> 2] = c3;
        p2 = 0;
        return p2 | 0;
      }
      function fa(a4, b4, c3, d3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        if (!(ga(a4, b4, c3, d3) | 0)) {
          d3 = 0;
          return d3 | 0;
        }
        _d(d3 | 0, 0, c3 * 48 | 0) | 0;
        d3 = ha(a4, b4, c3, d3) | 0;
        return d3 | 0;
      }
      function ga(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        p2 = T;
        T = T + 16 | 0;
        n = p2;
        o = p2 + 8 | 0;
        m = n;
        b3[m >> 2] = a4;
        b3[m + 4 >> 2] = c3;
        if ((d3 | 0) < 0) {
          o = 2;
          T = p2;
          return o | 0;
        }
        if (!d3) {
          o = e3;
          b3[o >> 2] = a4;
          b3[o + 4 >> 2] = c3;
          o = 0;
          T = p2;
          return o | 0;
        }
        b3[o >> 2] = 0;
        a: do {
          if (!(Kb(a4, c3) | 0)) {
            f2 = 0;
            m = a4;
            do {
              a4 = ea(m, c3, 4, o, n) | 0;
              if (a4 | 0) {
                break a;
              }
              c3 = n;
              m = b3[c3 >> 2] | 0;
              c3 = b3[c3 + 4 >> 2] | 0;
              f2 = f2 + 1 | 0;
              if (Kb(m, c3) | 0) {
                a4 = 9;
                break a;
              }
            } while ((f2 | 0) < (d3 | 0));
            l = e3;
            b3[l >> 2] = m;
            b3[l + 4 >> 2] = c3;
            l = d3 + -1 | 0;
            k = 0;
            a4 = 1;
            do {
              f2 = 26800 + (k << 2) | 0;
              if ((k | 0) == 5) {
                h = b3[f2 >> 2] | 0;
                g2 = 0;
                f2 = a4;
                while (1) {
                  a4 = n;
                  a4 = ea(b3[a4 >> 2] | 0, b3[a4 + 4 >> 2] | 0, h, o, n) | 0;
                  if (a4 | 0) {
                    break a;
                  }
                  if ((g2 | 0) != (l | 0)) {
                    j = n;
                    i = b3[j >> 2] | 0;
                    j = b3[j + 4 >> 2] | 0;
                    a4 = e3 + (f2 << 3) | 0;
                    b3[a4 >> 2] = i;
                    b3[a4 + 4 >> 2] = j;
                    if (!(Kb(i, j) | 0)) {
                      a4 = f2 + 1 | 0;
                    } else {
                      a4 = 9;
                      break a;
                    }
                  } else {
                    a4 = f2;
                  }
                  g2 = g2 + 1 | 0;
                  if ((g2 | 0) >= (d3 | 0)) {
                    break;
                  } else {
                    f2 = a4;
                  }
                }
              } else {
                h = n;
                j = b3[f2 >> 2] | 0;
                i = 0;
                f2 = a4;
                g2 = b3[h >> 2] | 0;
                h = b3[h + 4 >> 2] | 0;
                while (1) {
                  a4 = ea(g2, h, j, o, n) | 0;
                  if (a4 | 0) {
                    break a;
                  }
                  h = n;
                  g2 = b3[h >> 2] | 0;
                  h = b3[h + 4 >> 2] | 0;
                  a4 = e3 + (f2 << 3) | 0;
                  b3[a4 >> 2] = g2;
                  b3[a4 + 4 >> 2] = h;
                  a4 = f2 + 1 | 0;
                  if (Kb(g2, h) | 0) {
                    a4 = 9;
                    break a;
                  }
                  i = i + 1 | 0;
                  if ((i | 0) >= (d3 | 0)) {
                    break;
                  } else {
                    f2 = a4;
                  }
                }
              }
              k = k + 1 | 0;
            } while (k >>> 0 < 6);
            a4 = n;
            a4 = ((m | 0) == (b3[a4 >> 2] | 0) ? (c3 | 0) == (b3[a4 + 4 >> 2] | 0) : 0) ? 0 : 9;
          } else {
            a4 = 9;
          }
        } while (0);
        o = a4;
        T = p2;
        return o | 0;
      }
      function ha(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        m = T;
        T = T + 16 | 0;
        h = m;
        if (!d3) {
          b3[e3 >> 2] = a4;
          b3[e3 + 4 >> 2] = c3;
          e3 = 0;
          T = m;
          return e3 | 0;
        }
        do {
          if ((d3 | 0) >= 0) {
            if ((d3 | 0) > 13780509) {
              f2 = xc(15, h) | 0;
              if (f2 | 0) {
                break;
              }
              g2 = h;
              f2 = b3[g2 >> 2] | 0;
              g2 = b3[g2 + 4 >> 2] | 0;
            } else {
              f2 = ((d3 | 0) < 0) << 31 >> 31;
              l = Pd(d3 | 0, f2 | 0, 3, 0) | 0;
              g2 = H() | 0;
              f2 = Jd(d3 | 0, f2 | 0, 1, 0) | 0;
              f2 = Pd(l | 0, g2 | 0, f2 | 0, H() | 0) | 0;
              f2 = Jd(f2 | 0, H() | 0, 1, 0) | 0;
              g2 = H() | 0;
              l = h;
              b3[l >> 2] = f2;
              b3[l + 4 >> 2] = g2;
            }
            k = Id(f2, 8) | 0;
            if (!k) {
              f2 = 13;
            } else {
              l = Id(f2, 4) | 0;
              if (!l) {
                Hd(k);
                f2 = 13;
                break;
              }
              f2 = da(a4, c3, d3, k, l, f2, g2, 0) | 0;
              if (f2 | 0) {
                Hd(k);
                Hd(l);
                break;
              }
              c3 = b3[h >> 2] | 0;
              h = b3[h + 4 >> 2] | 0;
              if ((h | 0) > 0 | (h | 0) == 0 & c3 >>> 0 > 0) {
                f2 = 0;
                i = 0;
                j = 0;
                do {
                  a4 = k + (i << 3) | 0;
                  g2 = b3[a4 >> 2] | 0;
                  a4 = b3[a4 + 4 >> 2] | 0;
                  if (!((g2 | 0) == 0 & (a4 | 0) == 0) ? (b3[l + (i << 2) >> 2] | 0) == (d3 | 0) : 0) {
                    n = e3 + (f2 << 3) | 0;
                    b3[n >> 2] = g2;
                    b3[n + 4 >> 2] = a4;
                    f2 = f2 + 1 | 0;
                  }
                  i = Jd(i | 0, j | 0, 1, 0) | 0;
                  j = H() | 0;
                } while ((j | 0) < (h | 0) | (j | 0) == (h | 0) & i >>> 0 < c3 >>> 0);
              }
              Hd(k);
              Hd(l);
              f2 = 0;
            }
          } else {
            f2 = 2;
          }
        } while (0);
        n = f2;
        T = m;
        return n | 0;
      }
      function ia(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        i = T;
        T = T + 16 | 0;
        g2 = i;
        h = i + 8 | 0;
        f2 = (Kb(a4, c3) | 0) == 0;
        f2 = f2 ? 1 : 2;
        while (1) {
          b3[h >> 2] = 0;
          k = (ea(a4, c3, f2, h, g2) | 0) == 0;
          j = g2;
          if (k & ((b3[j >> 2] | 0) == (d3 | 0) ? (b3[j + 4 >> 2] | 0) == (e3 | 0) : 0)) {
            a4 = 4;
            break;
          }
          f2 = f2 + 1 | 0;
          if (f2 >>> 0 >= 7) {
            f2 = 7;
            a4 = 4;
            break;
          }
        }
        if ((a4 | 0) == 4) {
          T = i;
          return f2 | 0;
        }
        return 0;
      }
      function ja(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        i = T;
        T = T + 48 | 0;
        f2 = i + 16 | 0;
        g2 = i + 8 | 0;
        h = i;
        d3 = _c(d3) | 0;
        if (d3 | 0) {
          h = d3;
          T = i;
          return h | 0;
        }
        k = a4;
        j = b3[k + 4 >> 2] | 0;
        d3 = g2;
        b3[d3 >> 2] = b3[k >> 2];
        b3[d3 + 4 >> 2] = j;
        Zc(g2, f2);
        d3 = Ha(f2, c3, h) | 0;
        if (!d3) {
          c3 = b3[g2 >> 2] | 0;
          g2 = b3[a4 + 8 >> 2] | 0;
          if ((g2 | 0) > 0) {
            f2 = b3[a4 + 12 >> 2] | 0;
            d3 = 0;
            do {
              c3 = (b3[f2 + (d3 << 3) >> 2] | 0) + c3 | 0;
              d3 = d3 + 1 | 0;
            } while ((d3 | 0) < (g2 | 0));
          }
          d3 = h;
          f2 = b3[d3 >> 2] | 0;
          d3 = b3[d3 + 4 >> 2] | 0;
          g2 = ((c3 | 0) < 0) << 31 >> 31;
          if ((d3 | 0) < (g2 | 0) | (d3 | 0) == (g2 | 0) & f2 >>> 0 < c3 >>> 0) {
            d3 = h;
            b3[d3 >> 2] = c3;
            b3[d3 + 4 >> 2] = g2;
            d3 = g2;
          } else {
            c3 = f2;
          }
          j = Jd(c3 | 0, d3 | 0, 12, 0) | 0;
          k = H() | 0;
          d3 = h;
          b3[d3 >> 2] = j;
          b3[d3 + 4 >> 2] = k;
          d3 = e3;
          b3[d3 >> 2] = j;
          b3[d3 + 4 >> 2] = k;
          d3 = 0;
        }
        k = d3;
        T = i;
        return k | 0;
      }
      function ka(a4, c3, d3, f2, g2, h, i) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h = h | 0;
        i = i | 0;
        var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F2 = 0, G3 = 0, I2 = 0, J2 = 0, K2 = 0, L3 = 0, M2 = 0;
        I2 = T;
        T = T + 64 | 0;
        D3 = I2 + 48 | 0;
        E3 = I2 + 32 | 0;
        F2 = I2 + 24 | 0;
        x2 = I2 + 8 | 0;
        y2 = I2;
        k = b3[a4 >> 2] | 0;
        if ((k | 0) <= 0) {
          G3 = 0;
          T = I2;
          return G3 | 0;
        }
        z2 = a4 + 4 | 0;
        A3 = D3 + 8 | 0;
        B3 = E3 + 8 | 0;
        C3 = x2 + 8 | 0;
        j = 0;
        v3 = 0;
        while (1) {
          l = b3[z2 >> 2] | 0;
          u3 = l + (v3 << 4) | 0;
          b3[D3 >> 2] = b3[u3 >> 2];
          b3[D3 + 4 >> 2] = b3[u3 + 4 >> 2];
          b3[D3 + 8 >> 2] = b3[u3 + 8 >> 2];
          b3[D3 + 12 >> 2] = b3[u3 + 12 >> 2];
          if ((v3 | 0) == (k + -1 | 0)) {
            b3[E3 >> 2] = b3[l >> 2];
            b3[E3 + 4 >> 2] = b3[l + 4 >> 2];
            b3[E3 + 8 >> 2] = b3[l + 8 >> 2];
            b3[E3 + 12 >> 2] = b3[l + 12 >> 2];
          } else {
            u3 = l + (v3 + 1 << 4) | 0;
            b3[E3 >> 2] = b3[u3 >> 2];
            b3[E3 + 4 >> 2] = b3[u3 + 4 >> 2];
            b3[E3 + 8 >> 2] = b3[u3 + 8 >> 2];
            b3[E3 + 12 >> 2] = b3[u3 + 12 >> 2];
          }
          k = Ia(D3, E3, f2, F2) | 0;
          a: do {
            if (!k) {
              k = F2;
              l = b3[k >> 2] | 0;
              k = b3[k + 4 >> 2] | 0;
              if ((k | 0) > 0 | (k | 0) == 0 & l >>> 0 > 0) {
                t2 = 0;
                u3 = 0;
                b: while (1) {
                  K2 = 1 / (+(l >>> 0) + 4294967296 * +(k | 0));
                  M2 = +e2[D3 >> 3];
                  k = Kd(l | 0, k | 0, t2 | 0, u3 | 0) | 0;
                  L3 = +(k >>> 0) + 4294967296 * +(H() | 0);
                  J2 = +(t2 >>> 0) + 4294967296 * +(u3 | 0);
                  e2[x2 >> 3] = K2 * (M2 * L3) + K2 * (+e2[E3 >> 3] * J2);
                  e2[C3 >> 3] = K2 * (+e2[A3 >> 3] * L3) + K2 * (+e2[B3 >> 3] * J2);
                  k = Zb(x2, f2, y2) | 0;
                  if (k | 0) {
                    j = k;
                    break;
                  }
                  s2 = y2;
                  r2 = b3[s2 >> 2] | 0;
                  s2 = b3[s2 + 4 >> 2] | 0;
                  o = Rd(r2 | 0, s2 | 0, c3 | 0, d3 | 0) | 0;
                  m = H() | 0;
                  k = i + (o << 3) | 0;
                  n = k;
                  l = b3[n >> 2] | 0;
                  n = b3[n + 4 >> 2] | 0;
                  c: do {
                    if ((l | 0) == 0 & (n | 0) == 0) {
                      w3 = k;
                      G3 = 16;
                    } else {
                      p2 = 0;
                      q2 = 0;
                      while (1) {
                        if ((p2 | 0) > (d3 | 0) | (p2 | 0) == (d3 | 0) & q2 >>> 0 > c3 >>> 0) {
                          j = 1;
                          break b;
                        }
                        if ((l | 0) == (r2 | 0) & (n | 0) == (s2 | 0)) {
                          break c;
                        }
                        k = Jd(o | 0, m | 0, 1, 0) | 0;
                        o = Qd(k | 0, H() | 0, c3 | 0, d3 | 0) | 0;
                        m = H() | 0;
                        q2 = Jd(q2 | 0, p2 | 0, 1, 0) | 0;
                        p2 = H() | 0;
                        k = i + (o << 3) | 0;
                        n = k;
                        l = b3[n >> 2] | 0;
                        n = b3[n + 4 >> 2] | 0;
                        if ((l | 0) == 0 & (n | 0) == 0) {
                          w3 = k;
                          G3 = 16;
                          break;
                        }
                      }
                    }
                  } while (0);
                  if ((G3 | 0) == 16 ? (G3 = 0, !((r2 | 0) == 0 & (s2 | 0) == 0)) : 0) {
                    q2 = w3;
                    b3[q2 >> 2] = r2;
                    b3[q2 + 4 >> 2] = s2;
                    q2 = h + (b3[g2 >> 2] << 3) | 0;
                    b3[q2 >> 2] = r2;
                    b3[q2 + 4 >> 2] = s2;
                    q2 = g2;
                    q2 = Jd(b3[q2 >> 2] | 0, b3[q2 + 4 >> 2] | 0, 1, 0) | 0;
                    r2 = H() | 0;
                    s2 = g2;
                    b3[s2 >> 2] = q2;
                    b3[s2 + 4 >> 2] = r2;
                  }
                  t2 = Jd(t2 | 0, u3 | 0, 1, 0) | 0;
                  u3 = H() | 0;
                  k = F2;
                  l = b3[k >> 2] | 0;
                  k = b3[k + 4 >> 2] | 0;
                  if (!((k | 0) > (u3 | 0) | (k | 0) == (u3 | 0) & l >>> 0 > t2 >>> 0)) {
                    l = 1;
                    break a;
                  }
                }
                l = 0;
              } else {
                l = 1;
              }
            } else {
              l = 0;
              j = k;
            }
          } while (0);
          v3 = v3 + 1 | 0;
          if (!l) {
            G3 = 21;
            break;
          }
          k = b3[a4 >> 2] | 0;
          if ((v3 | 0) >= (k | 0)) {
            j = 0;
            G3 = 21;
            break;
          }
        }
        if ((G3 | 0) == 21) {
          T = I2;
          return j | 0;
        }
        return 0;
      }
      function la(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F2 = 0, G3 = 0, I2 = 0, J2 = 0, K2 = 0;
        K2 = T;
        T = T + 112 | 0;
        F2 = K2 + 80 | 0;
        j = K2 + 72 | 0;
        G3 = K2;
        I2 = K2 + 56 | 0;
        f2 = _c(d3) | 0;
        if (f2 | 0) {
          J2 = f2;
          T = K2;
          return J2 | 0;
        }
        k = a4 + 8 | 0;
        J2 = Gd((b3[k >> 2] << 5) + 32 | 0) | 0;
        if (!J2) {
          J2 = 13;
          T = K2;
          return J2 | 0;
        }
        $c(a4, J2);
        f2 = _c(d3) | 0;
        if (!f2) {
          D3 = a4;
          E3 = b3[D3 + 4 >> 2] | 0;
          f2 = j;
          b3[f2 >> 2] = b3[D3 >> 2];
          b3[f2 + 4 >> 2] = E3;
          Zc(j, F2);
          f2 = Ha(F2, c3, G3) | 0;
          if (!f2) {
            f2 = b3[j >> 2] | 0;
            g2 = b3[k >> 2] | 0;
            if ((g2 | 0) > 0) {
              h = b3[a4 + 12 >> 2] | 0;
              d3 = 0;
              do {
                f2 = (b3[h + (d3 << 3) >> 2] | 0) + f2 | 0;
                d3 = d3 + 1 | 0;
              } while ((d3 | 0) != (g2 | 0));
              d3 = f2;
            } else {
              d3 = f2;
            }
            f2 = G3;
            g2 = b3[f2 >> 2] | 0;
            f2 = b3[f2 + 4 >> 2] | 0;
            h = ((d3 | 0) < 0) << 31 >> 31;
            if ((f2 | 0) < (h | 0) | (f2 | 0) == (h | 0) & g2 >>> 0 < d3 >>> 0) {
              f2 = G3;
              b3[f2 >> 2] = d3;
              b3[f2 + 4 >> 2] = h;
              f2 = h;
            } else {
              d3 = g2;
            }
            D3 = Jd(d3 | 0, f2 | 0, 12, 0) | 0;
            E3 = H() | 0;
            f2 = G3;
            b3[f2 >> 2] = D3;
            b3[f2 + 4 >> 2] = E3;
            f2 = 0;
          } else {
            D3 = 0;
            E3 = 0;
          }
          if (!f2) {
            d3 = Id(D3, 8) | 0;
            if (!d3) {
              Hd(J2);
              J2 = 13;
              T = K2;
              return J2 | 0;
            }
            i = Id(D3, 8) | 0;
            if (!i) {
              Hd(J2);
              Hd(d3);
              J2 = 13;
              T = K2;
              return J2 | 0;
            }
            B3 = F2;
            b3[B3 >> 2] = 0;
            b3[B3 + 4 >> 2] = 0;
            B3 = a4;
            C3 = b3[B3 + 4 >> 2] | 0;
            f2 = j;
            b3[f2 >> 2] = b3[B3 >> 2];
            b3[f2 + 4 >> 2] = C3;
            f2 = ka(j, D3, E3, c3, F2, d3, i) | 0;
            a: do {
              if (!f2) {
                b: do {
                  if ((b3[k >> 2] | 0) > 0) {
                    h = a4 + 12 | 0;
                    g2 = 0;
                    while (1) {
                      f2 = ka((b3[h >> 2] | 0) + (g2 << 3) | 0, D3, E3, c3, F2, d3, i) | 0;
                      g2 = g2 + 1 | 0;
                      if (f2 | 0) {
                        break;
                      }
                      if ((g2 | 0) >= (b3[k >> 2] | 0)) {
                        break b;
                      }
                    }
                    Hd(d3);
                    Hd(i);
                    Hd(J2);
                    break a;
                  }
                } while (0);
                if ((E3 | 0) > 0 | (E3 | 0) == 0 & D3 >>> 0 > 0) {
                  _d(i | 0, 0, D3 << 3 | 0) | 0;
                }
                C3 = F2;
                B3 = b3[C3 + 4 >> 2] | 0;
                c: do {
                  if ((B3 | 0) > 0 | (B3 | 0) == 0 & (b3[C3 >> 2] | 0) >>> 0 > 0) {
                    y2 = d3;
                    z2 = i;
                    A3 = d3;
                    B3 = i;
                    C3 = d3;
                    f2 = d3;
                    v3 = d3;
                    w3 = i;
                    x2 = i;
                    d3 = i;
                    d: while (1) {
                      r2 = 0;
                      s2 = 0;
                      t2 = 0;
                      u3 = 0;
                      g2 = 0;
                      h = 0;
                      while (1) {
                        i = G3;
                        j = i + 56 | 0;
                        do {
                          b3[i >> 2] = 0;
                          i = i + 4 | 0;
                        } while ((i | 0) < (j | 0));
                        c3 = y2 + (r2 << 3) | 0;
                        k = b3[c3 >> 2] | 0;
                        c3 = b3[c3 + 4 >> 2] | 0;
                        if (ca(k, c3, 1, G3, 0) | 0) {
                          i = G3;
                          j = i + 56 | 0;
                          do {
                            b3[i >> 2] = 0;
                            i = i + 4 | 0;
                          } while ((i | 0) < (j | 0));
                          i = Id(7, 4) | 0;
                          if (i | 0) {
                            da(k, c3, 1, G3, i, 7, 0, 0) | 0;
                            Hd(i);
                          }
                        }
                        q2 = 0;
                        while (1) {
                          p2 = G3 + (q2 << 3) | 0;
                          o = b3[p2 >> 2] | 0;
                          p2 = b3[p2 + 4 >> 2] | 0;
                          e: do {
                            if ((o | 0) == 0 & (p2 | 0) == 0) {
                              i = g2;
                              j = h;
                            } else {
                              l = Rd(o | 0, p2 | 0, D3 | 0, E3 | 0) | 0;
                              k = H() | 0;
                              i = e3 + (l << 3) | 0;
                              c3 = i;
                              j = b3[c3 >> 2] | 0;
                              c3 = b3[c3 + 4 >> 2] | 0;
                              if (!((j | 0) == 0 & (c3 | 0) == 0)) {
                                m = 0;
                                n = 0;
                                do {
                                  if ((m | 0) > (E3 | 0) | (m | 0) == (E3 | 0) & n >>> 0 > D3 >>> 0) {
                                    break d;
                                  }
                                  if ((j | 0) == (o | 0) & (c3 | 0) == (p2 | 0)) {
                                    i = g2;
                                    j = h;
                                    break e;
                                  }
                                  i = Jd(l | 0, k | 0, 1, 0) | 0;
                                  l = Qd(i | 0, H() | 0, D3 | 0, E3 | 0) | 0;
                                  k = H() | 0;
                                  n = Jd(n | 0, m | 0, 1, 0) | 0;
                                  m = H() | 0;
                                  i = e3 + (l << 3) | 0;
                                  c3 = i;
                                  j = b3[c3 >> 2] | 0;
                                  c3 = b3[c3 + 4 >> 2] | 0;
                                } while (!((j | 0) == 0 & (c3 | 0) == 0));
                              }
                              if ((o | 0) == 0 & (p2 | 0) == 0) {
                                i = g2;
                                j = h;
                                break;
                              }
                              ac(o, p2, I2) | 0;
                              if (ad(a4, J2, I2) | 0) {
                                n = Jd(g2 | 0, h | 0, 1, 0) | 0;
                                h = H() | 0;
                                m = i;
                                b3[m >> 2] = o;
                                b3[m + 4 >> 2] = p2;
                                g2 = z2 + (g2 << 3) | 0;
                                b3[g2 >> 2] = o;
                                b3[g2 + 4 >> 2] = p2;
                                g2 = n;
                              }
                              i = g2;
                              j = h;
                            }
                          } while (0);
                          q2 = q2 + 1 | 0;
                          if (q2 >>> 0 >= 7) {
                            break;
                          } else {
                            g2 = i;
                            h = j;
                          }
                        }
                        r2 = Jd(r2 | 0, s2 | 0, 1, 0) | 0;
                        s2 = H() | 0;
                        t2 = Jd(t2 | 0, u3 | 0, 1, 0) | 0;
                        u3 = H() | 0;
                        h = F2;
                        g2 = b3[h >> 2] | 0;
                        h = b3[h + 4 >> 2] | 0;
                        if (!((u3 | 0) < (h | 0) | (u3 | 0) == (h | 0) & t2 >>> 0 < g2 >>> 0)) {
                          break;
                        } else {
                          g2 = i;
                          h = j;
                        }
                      }
                      if ((h | 0) > 0 | (h | 0) == 0 & g2 >>> 0 > 0) {
                        g2 = 0;
                        h = 0;
                        do {
                          u3 = y2 + (g2 << 3) | 0;
                          b3[u3 >> 2] = 0;
                          b3[u3 + 4 >> 2] = 0;
                          g2 = Jd(g2 | 0, h | 0, 1, 0) | 0;
                          h = H() | 0;
                          u3 = F2;
                          t2 = b3[u3 + 4 >> 2] | 0;
                        } while ((h | 0) < (t2 | 0) | ((h | 0) == (t2 | 0) ? g2 >>> 0 < (b3[u3 >> 2] | 0) >>> 0 : 0));
                      }
                      u3 = F2;
                      b3[u3 >> 2] = i;
                      b3[u3 + 4 >> 2] = j;
                      if ((j | 0) > 0 | (j | 0) == 0 & i >>> 0 > 0) {
                        q2 = d3;
                        r2 = x2;
                        s2 = C3;
                        t2 = w3;
                        u3 = z2;
                        d3 = v3;
                        x2 = f2;
                        w3 = A3;
                        v3 = q2;
                        f2 = r2;
                        C3 = B3;
                        B3 = s2;
                        A3 = t2;
                        z2 = y2;
                        y2 = u3;
                      } else {
                        break c;
                      }
                    }
                    Hd(A3);
                    Hd(B3);
                    Hd(J2);
                    f2 = 1;
                    break a;
                  } else {
                    f2 = i;
                  }
                } while (0);
                Hd(J2);
                Hd(d3);
                Hd(f2);
                f2 = 0;
              } else {
                Hd(d3);
                Hd(i);
                Hd(J2);
              }
            } while (0);
            J2 = f2;
            T = K2;
            return J2 | 0;
          }
        }
        Hd(J2);
        J2 = f2;
        T = K2;
        return J2 | 0;
      }
      function ma(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        l = T;
        T = T + 176 | 0;
        j = l;
        if ((c3 | 0) < 1) {
          xd(d3, 0, 0);
          k = 0;
          T = l;
          return k | 0;
        }
        i = a4;
        i = Td(b3[i >> 2] | 0, b3[i + 4 >> 2] | 0, 52) | 0;
        H() | 0;
        xd(d3, (c3 | 0) > 6 ? c3 : 6, i & 15);
        i = 0;
        while (1) {
          e3 = a4 + (i << 3) | 0;
          e3 = bc(b3[e3 >> 2] | 0, b3[e3 + 4 >> 2] | 0, j) | 0;
          if (e3 | 0) {
            break;
          }
          e3 = b3[j >> 2] | 0;
          if ((e3 | 0) > 0) {
            h = 0;
            do {
              g2 = j + 8 + (h << 4) | 0;
              h = h + 1 | 0;
              e3 = j + 8 + (((h | 0) % (e3 | 0) | 0) << 4) | 0;
              f2 = Cd(d3, e3, g2) | 0;
              if (!f2) {
                Bd(d3, g2, e3) | 0;
              } else {
                Ad(d3, f2) | 0;
              }
              e3 = b3[j >> 2] | 0;
            } while ((h | 0) < (e3 | 0));
          }
          i = i + 1 | 0;
          if ((i | 0) >= (c3 | 0)) {
            e3 = 0;
            k = 13;
            break;
          }
        }
        if ((k | 0) == 13) {
          T = l;
          return e3 | 0;
        }
        yd(d3);
        k = e3;
        T = l;
        return k | 0;
      }
      function na(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        g2 = T;
        T = T + 32 | 0;
        e3 = g2;
        f2 = g2 + 16 | 0;
        a4 = ma(a4, c3, f2) | 0;
        if (a4 | 0) {
          d3 = a4;
          T = g2;
          return d3 | 0;
        }
        b3[d3 >> 2] = 0;
        b3[d3 + 4 >> 2] = 0;
        b3[d3 + 8 >> 2] = 0;
        a4 = zd(f2) | 0;
        if (a4 | 0) {
          do {
            c3 = Fc(d3) | 0;
            do {
              Gc(c3, a4) | 0;
              h = a4 + 16 | 0;
              b3[e3 >> 2] = b3[h >> 2];
              b3[e3 + 4 >> 2] = b3[h + 4 >> 2];
              b3[e3 + 8 >> 2] = b3[h + 8 >> 2];
              b3[e3 + 12 >> 2] = b3[h + 12 >> 2];
              Ad(f2, a4) | 0;
              a4 = Dd(f2, e3) | 0;
            } while ((a4 | 0) != 0);
            a4 = zd(f2) | 0;
          } while ((a4 | 0) != 0);
        }
        yd(f2);
        a4 = Ic(d3) | 0;
        if (!a4) {
          h = 0;
          T = g2;
          return h | 0;
        }
        Hc(d3);
        h = a4;
        T = g2;
        return h | 0;
      }
      function oa(a4) {
        a4 = a4 | 0;
        if (a4 >>> 0 > 121) {
          a4 = 0;
          return a4 | 0;
        }
        a4 = b3[7696 + (a4 * 28 | 0) + 16 >> 2] | 0;
        return a4 | 0;
      }
      function pa(a4) {
        a4 = a4 | 0;
        return (a4 | 0) == 4 | (a4 | 0) == 117 | 0;
      }
      function qa(a4) {
        a4 = a4 | 0;
        return b3[11120 + ((b3[a4 >> 2] | 0) * 216 | 0) + ((b3[a4 + 4 >> 2] | 0) * 72 | 0) + ((b3[a4 + 8 >> 2] | 0) * 24 | 0) + (b3[a4 + 12 >> 2] << 3) >> 2] | 0;
      }
      function ra(a4) {
        a4 = a4 | 0;
        return b3[11120 + ((b3[a4 >> 2] | 0) * 216 | 0) + ((b3[a4 + 4 >> 2] | 0) * 72 | 0) + ((b3[a4 + 8 >> 2] | 0) * 24 | 0) + (b3[a4 + 12 >> 2] << 3) + 4 >> 2] | 0;
      }
      function sa(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        a4 = 7696 + (a4 * 28 | 0) | 0;
        b3[c3 >> 2] = b3[a4 >> 2];
        b3[c3 + 4 >> 2] = b3[a4 + 4 >> 2];
        b3[c3 + 8 >> 2] = b3[a4 + 8 >> 2];
        b3[c3 + 12 >> 2] = b3[a4 + 12 >> 2];
        return;
      }
      function ta(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0;
        if (c3 >>> 0 > 20) {
          c3 = -1;
          return c3 | 0;
        }
        do {
          if ((b3[11120 + (c3 * 216 | 0) >> 2] | 0) != (a4 | 0)) {
            if ((b3[11120 + (c3 * 216 | 0) + 8 >> 2] | 0) != (a4 | 0)) {
              if ((b3[11120 + (c3 * 216 | 0) + 16 >> 2] | 0) != (a4 | 0)) {
                if ((b3[11120 + (c3 * 216 | 0) + 24 >> 2] | 0) != (a4 | 0)) {
                  if ((b3[11120 + (c3 * 216 | 0) + 32 >> 2] | 0) != (a4 | 0)) {
                    if ((b3[11120 + (c3 * 216 | 0) + 40 >> 2] | 0) != (a4 | 0)) {
                      if ((b3[11120 + (c3 * 216 | 0) + 48 >> 2] | 0) != (a4 | 0)) {
                        if ((b3[11120 + (c3 * 216 | 0) + 56 >> 2] | 0) != (a4 | 0)) {
                          if ((b3[11120 + (c3 * 216 | 0) + 64 >> 2] | 0) != (a4 | 0)) {
                            if ((b3[11120 + (c3 * 216 | 0) + 72 >> 2] | 0) != (a4 | 0)) {
                              if ((b3[11120 + (c3 * 216 | 0) + 80 >> 2] | 0) != (a4 | 0)) {
                                if ((b3[11120 + (c3 * 216 | 0) + 88 >> 2] | 0) != (a4 | 0)) {
                                  if ((b3[11120 + (c3 * 216 | 0) + 96 >> 2] | 0) != (a4 | 0)) {
                                    if ((b3[11120 + (c3 * 216 | 0) + 104 >> 2] | 0) != (a4 | 0)) {
                                      if ((b3[11120 + (c3 * 216 | 0) + 112 >> 2] | 0) != (a4 | 0)) {
                                        if ((b3[11120 + (c3 * 216 | 0) + 120 >> 2] | 0) != (a4 | 0)) {
                                          if ((b3[11120 + (c3 * 216 | 0) + 128 >> 2] | 0) != (a4 | 0)) {
                                            if ((b3[11120 + (c3 * 216 | 0) + 136 >> 2] | 0) == (a4 | 0)) {
                                              a4 = 2;
                                              d3 = 1;
                                              e3 = 2;
                                            } else {
                                              if ((b3[11120 + (c3 * 216 | 0) + 144 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 0;
                                                d3 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b3[11120 + (c3 * 216 | 0) + 152 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 0;
                                                d3 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b3[11120 + (c3 * 216 | 0) + 160 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 0;
                                                d3 = 2;
                                                e3 = 2;
                                                break;
                                              }
                                              if ((b3[11120 + (c3 * 216 | 0) + 168 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 1;
                                                d3 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b3[11120 + (c3 * 216 | 0) + 176 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 1;
                                                d3 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b3[11120 + (c3 * 216 | 0) + 184 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 1;
                                                d3 = 2;
                                                e3 = 2;
                                                break;
                                              }
                                              if ((b3[11120 + (c3 * 216 | 0) + 192 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 2;
                                                d3 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b3[11120 + (c3 * 216 | 0) + 200 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 2;
                                                d3 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b3[11120 + (c3 * 216 | 0) + 208 >> 2] | 0) == (a4 | 0)) {
                                                a4 = 2;
                                                d3 = 2;
                                                e3 = 2;
                                                break;
                                              } else {
                                                a4 = -1;
                                              }
                                              return a4 | 0;
                                            }
                                          } else {
                                            a4 = 2;
                                            d3 = 1;
                                            e3 = 1;
                                          }
                                        } else {
                                          a4 = 2;
                                          d3 = 1;
                                          e3 = 0;
                                        }
                                      } else {
                                        a4 = 1;
                                        d3 = 1;
                                        e3 = 2;
                                      }
                                    } else {
                                      a4 = 1;
                                      d3 = 1;
                                      e3 = 1;
                                    }
                                  } else {
                                    a4 = 1;
                                    d3 = 1;
                                    e3 = 0;
                                  }
                                } else {
                                  a4 = 0;
                                  d3 = 1;
                                  e3 = 2;
                                }
                              } else {
                                a4 = 0;
                                d3 = 1;
                                e3 = 1;
                              }
                            } else {
                              a4 = 0;
                              d3 = 1;
                              e3 = 0;
                            }
                          } else {
                            a4 = 2;
                            d3 = 0;
                            e3 = 2;
                          }
                        } else {
                          a4 = 2;
                          d3 = 0;
                          e3 = 1;
                        }
                      } else {
                        a4 = 2;
                        d3 = 0;
                        e3 = 0;
                      }
                    } else {
                      a4 = 1;
                      d3 = 0;
                      e3 = 2;
                    }
                  } else {
                    a4 = 1;
                    d3 = 0;
                    e3 = 1;
                  }
                } else {
                  a4 = 1;
                  d3 = 0;
                  e3 = 0;
                }
              } else {
                a4 = 0;
                d3 = 0;
                e3 = 2;
              }
            } else {
              a4 = 0;
              d3 = 0;
              e3 = 1;
            }
          } else {
            a4 = 0;
            d3 = 0;
            e3 = 0;
          }
        } while (0);
        c3 = b3[11120 + (c3 * 216 | 0) + (d3 * 72 | 0) + (a4 * 24 | 0) + (e3 << 3) + 4 >> 2] | 0;
        return c3 | 0;
      }
      function ua(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        if ((b3[7696 + (a4 * 28 | 0) + 20 >> 2] | 0) == (c3 | 0)) {
          c3 = 1;
          return c3 | 0;
        }
        c3 = (b3[7696 + (a4 * 28 | 0) + 24 >> 2] | 0) == (c3 | 0);
        return c3 | 0;
      }
      function va(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        return b3[848 + (a4 * 28 | 0) + (c3 << 2) >> 2] | 0;
      }
      function wa(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        if ((b3[848 + (a4 * 28 | 0) >> 2] | 0) == (c3 | 0)) {
          c3 = 0;
          return c3 | 0;
        }
        if ((b3[848 + (a4 * 28 | 0) + 4 >> 2] | 0) == (c3 | 0)) {
          c3 = 1;
          return c3 | 0;
        }
        if ((b3[848 + (a4 * 28 | 0) + 8 >> 2] | 0) == (c3 | 0)) {
          c3 = 2;
          return c3 | 0;
        }
        if ((b3[848 + (a4 * 28 | 0) + 12 >> 2] | 0) == (c3 | 0)) {
          c3 = 3;
          return c3 | 0;
        }
        if ((b3[848 + (a4 * 28 | 0) + 16 >> 2] | 0) == (c3 | 0)) {
          c3 = 4;
          return c3 | 0;
        }
        if ((b3[848 + (a4 * 28 | 0) + 20 >> 2] | 0) == (c3 | 0)) {
          c3 = 5;
          return c3 | 0;
        } else {
          return ((b3[848 + (a4 * 28 | 0) + 24 >> 2] | 0) == (c3 | 0) ? 6 : 7) | 0;
        }
        return 0;
      }
      function xa() {
        return 122;
      }
      function ya(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        c3 = 0;
        do {
          Ud(c3 | 0, 0, 45) | 0;
          e3 = H() | 0 | 134225919;
          d3 = a4 + (c3 << 3) | 0;
          b3[d3 >> 2] = -1;
          b3[d3 + 4 >> 2] = e3;
          c3 = c3 + 1 | 0;
        } while ((c3 | 0) != 122);
        return 0;
      }
      function za(a4) {
        a4 = a4 | 0;
        var b4 = 0, c3 = 0, d3 = 0;
        d3 = +e2[a4 + 16 >> 3];
        c3 = +e2[a4 + 24 >> 3];
        b4 = d3 - c3;
        return +(d3 < c3 ? b4 + 6.283185307179586 : b4);
      }
      function Aa(a4) {
        a4 = a4 | 0;
        return +e2[a4 + 16 >> 3] < +e2[a4 + 24 >> 3] | 0;
      }
      function Ba(a4) {
        a4 = a4 | 0;
        return +(+e2[a4 >> 3] - +e2[a4 + 8 >> 3]);
      }
      function Ca(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, f2 = 0;
        c3 = +e2[b4 >> 3];
        if (!(c3 >= +e2[a4 + 8 >> 3])) {
          b4 = 0;
          return b4 | 0;
        }
        if (!(c3 <= +e2[a4 >> 3])) {
          b4 = 0;
          return b4 | 0;
        }
        d3 = +e2[a4 + 16 >> 3];
        c3 = +e2[a4 + 24 >> 3];
        f2 = +e2[b4 + 8 >> 3];
        b4 = f2 >= c3;
        a4 = f2 <= d3 & 1;
        if (d3 < c3) {
          if (b4) {
            a4 = 1;
          }
        } else if (!b4) {
          a4 = 0;
        }
        b4 = (a4 | 0) != 0;
        return b4 | 0;
      }
      function Da(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        if (+e2[a4 >> 3] < +e2[b4 + 8 >> 3]) {
          d3 = 0;
          return d3 | 0;
        }
        if (+e2[a4 + 8 >> 3] > +e2[b4 >> 3]) {
          d3 = 0;
          return d3 | 0;
        }
        g2 = +e2[a4 + 16 >> 3];
        c3 = a4 + 24 | 0;
        l = +e2[c3 >> 3];
        h = g2 < l;
        d3 = b4 + 16 | 0;
        k = +e2[d3 >> 3];
        f2 = b4 + 24 | 0;
        j = +e2[f2 >> 3];
        i = k < j;
        b4 = l - k < j - g2;
        a4 = h ? i | b4 ? 1 : 2 : 0;
        b4 = i ? h ? 1 : b4 ? 2 : 1 : 0;
        g2 = +nc(g2, a4);
        if (g2 < +nc(+e2[f2 >> 3], b4)) {
          i = 0;
          return i | 0;
        }
        l = +nc(+e2[c3 >> 3], a4);
        if (l > +nc(+e2[d3 >> 3], b4)) {
          i = 0;
          return i | 0;
        }
        i = 1;
        return i | 0;
      }
      function Ea(a4, c3, d3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0;
        h = +e2[a4 + 16 >> 3];
        k = +e2[a4 + 24 >> 3];
        a4 = h < k;
        j = +e2[c3 + 16 >> 3];
        i = +e2[c3 + 24 >> 3];
        g2 = j < i;
        c3 = k - j < i - h;
        b3[d3 >> 2] = a4 ? g2 | c3 ? 1 : 2 : 0;
        b3[f2 >> 2] = g2 ? a4 ? 1 : c3 ? 2 : 1 : 0;
        return;
      }
      function Fa(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        if (+e2[a4 >> 3] < +e2[b4 >> 3]) {
          d3 = 0;
          return d3 | 0;
        }
        if (+e2[a4 + 8 >> 3] > +e2[b4 + 8 >> 3]) {
          d3 = 0;
          return d3 | 0;
        }
        d3 = a4 + 16 | 0;
        j = +e2[d3 >> 3];
        g2 = +e2[a4 + 24 >> 3];
        h = j < g2;
        c3 = b4 + 16 | 0;
        l = +e2[c3 >> 3];
        f2 = b4 + 24 | 0;
        k = +e2[f2 >> 3];
        i = l < k;
        b4 = g2 - l < k - j;
        a4 = h ? i | b4 ? 1 : 2 : 0;
        b4 = i ? h ? 1 : b4 ? 2 : 1 : 0;
        g2 = +nc(g2, a4);
        if (!(g2 <= +nc(+e2[f2 >> 3], b4))) {
          i = 0;
          return i | 0;
        }
        l = +nc(+e2[d3 >> 3], a4);
        i = l >= +nc(+e2[c3 >> 3], b4);
        return i | 0;
      }
      function Ga(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        g2 = T;
        T = T + 176 | 0;
        f2 = g2;
        b3[f2 >> 2] = 4;
        j = +e2[c3 >> 3];
        e2[f2 + 8 >> 3] = j;
        h = +e2[c3 + 16 >> 3];
        e2[f2 + 16 >> 3] = h;
        e2[f2 + 24 >> 3] = j;
        j = +e2[c3 + 24 >> 3];
        e2[f2 + 32 >> 3] = j;
        i = +e2[c3 + 8 >> 3];
        e2[f2 + 40 >> 3] = i;
        e2[f2 + 48 >> 3] = j;
        e2[f2 + 56 >> 3] = i;
        e2[f2 + 64 >> 3] = h;
        c3 = f2 + 72 | 0;
        d3 = c3 + 96 | 0;
        do {
          b3[c3 >> 2] = 0;
          c3 = c3 + 4 | 0;
        } while ((c3 | 0) < (d3 | 0));
        Zd(a4 | 0, f2 | 0, 168) | 0;
        T = g2;
        return;
      }
      function Ha(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0;
        t2 = T;
        T = T + 288 | 0;
        n = t2 + 264 | 0;
        o = t2 + 96 | 0;
        m = t2;
        k = m;
        l = k + 96 | 0;
        do {
          b3[k >> 2] = 0;
          k = k + 4 | 0;
        } while ((k | 0) < (l | 0));
        c3 = fc(c3, m) | 0;
        if (c3 | 0) {
          s2 = c3;
          T = t2;
          return s2 | 0;
        }
        l = m;
        m = b3[l >> 2] | 0;
        l = b3[l + 4 >> 2] | 0;
        ac(m, l, n) | 0;
        bc(m, l, o) | 0;
        j = +pc(n, o + 8 | 0);
        e2[n >> 3] = +e2[a4 >> 3];
        l = n + 8 | 0;
        e2[l >> 3] = +e2[a4 + 16 >> 3];
        e2[o >> 3] = +e2[a4 + 8 >> 3];
        m = o + 8 | 0;
        e2[m >> 3] = +e2[a4 + 24 >> 3];
        h = +pc(n, o);
        v3 = +e2[l >> 3] - +e2[m >> 3];
        i = +q(+v3);
        u3 = +e2[n >> 3] - +e2[o >> 3];
        g2 = +q(+u3);
        if (!(v3 == 0 | u3 == 0) ? (v3 = +Wd(+i, +g2), v3 = +A2(+(h * h / +Xd(+(v3 / +Xd(+i, +g2)), 3) / (j * (j * 2.59807621135) * 0.8))), e2[f >> 3] = v3, r2 = ~~v3 >>> 0, s2 = +q(v3) >= 1 ? v3 > 0 ? ~~+C2(+p(v3 / 4294967296), 4294967295) >>> 0 : ~~+A2((v3 - +(~~v3 >>> 0)) / 4294967296) >>> 0 : 0, !((b3[f + 4 >> 2] & 2146435072 | 0) == 2146435072)) : 0) {
          o = (r2 | 0) == 0 & (s2 | 0) == 0;
          c3 = d3;
          b3[c3 >> 2] = o ? 1 : r2;
          b3[c3 + 4 >> 2] = o ? 0 : s2;
          c3 = 0;
        } else {
          c3 = 1;
        }
        s2 = c3;
        T = t2;
        return s2 | 0;
      }
      function Ia(a4, c3, d3, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        m = T;
        T = T + 288 | 0;
        j = m + 264 | 0;
        k = m + 96 | 0;
        l = m;
        h = l;
        i = h + 96 | 0;
        do {
          b3[h >> 2] = 0;
          h = h + 4 | 0;
        } while ((h | 0) < (i | 0));
        d3 = fc(d3, l) | 0;
        if (d3 | 0) {
          g2 = d3;
          T = m;
          return g2 | 0;
        }
        d3 = l;
        h = b3[d3 >> 2] | 0;
        d3 = b3[d3 + 4 >> 2] | 0;
        ac(h, d3, j) | 0;
        bc(h, d3, k) | 0;
        n = +pc(j, k + 8 | 0);
        n = +A2(+(+pc(a4, c3) / (n * 2)));
        e2[f >> 3] = n;
        d3 = ~~n >>> 0;
        h = +q(n) >= 1 ? n > 0 ? ~~+C2(+p(n / 4294967296), 4294967295) >>> 0 : ~~+A2((n - +(~~n >>> 0)) / 4294967296) >>> 0 : 0;
        if ((b3[f + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          g2 = 1;
          T = m;
          return g2 | 0;
        }
        l = (d3 | 0) == 0 & (h | 0) == 0;
        b3[g2 >> 2] = l ? 1 : d3;
        b3[g2 + 4 >> 2] = l ? 0 : h;
        g2 = 0;
        T = m;
        return g2 | 0;
      }
      function Ja(a4, b4) {
        a4 = a4 | 0;
        b4 = +b4;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        g2 = a4 + 16 | 0;
        h = +e2[g2 >> 3];
        c3 = a4 + 24 | 0;
        f2 = +e2[c3 >> 3];
        d3 = h - f2;
        d3 = h < f2 ? d3 + 6.283185307179586 : d3;
        k = +e2[a4 >> 3];
        i = a4 + 8 | 0;
        j = +e2[i >> 3];
        l = k - j;
        d3 = (d3 * b4 - d3) * 0.5;
        b4 = (l * b4 - l) * 0.5;
        k = k + b4;
        e2[a4 >> 3] = k > 1.5707963267948966 ? 1.5707963267948966 : k;
        b4 = j - b4;
        e2[i >> 3] = b4 < -1.5707963267948966 ? -1.5707963267948966 : b4;
        b4 = h + d3;
        b4 = b4 > 3.141592653589793 ? b4 + -6.283185307179586 : b4;
        e2[g2 >> 3] = b4 < -3.141592653589793 ? b4 + 6.283185307179586 : b4;
        b4 = f2 - d3;
        b4 = b4 > 3.141592653589793 ? b4 + -6.283185307179586 : b4;
        e2[c3 >> 3] = b4 < -3.141592653589793 ? b4 + 6.283185307179586 : b4;
        return;
      }
      function Ka(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        b3[a4 >> 2] = c3;
        b3[a4 + 4 >> 2] = d3;
        b3[a4 + 8 >> 2] = e3;
        return;
      }
      function La(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        n = c3 + 8 | 0;
        b3[n >> 2] = 0;
        k = +e2[a4 >> 3];
        i = +q(+k);
        l = +e2[a4 + 8 >> 3];
        j = +q(+l) * 1.1547005383792515;
        i = i + j * 0.5;
        d3 = ~~i;
        a4 = ~~j;
        i = i - +(d3 | 0);
        j = j - +(a4 | 0);
        do {
          if (i < 0.5) {
            if (i < 0.3333333333333333) {
              b3[c3 >> 2] = d3;
              if (j < (i + 1) * 0.5) {
                b3[c3 + 4 >> 2] = a4;
                break;
              } else {
                a4 = a4 + 1 | 0;
                b3[c3 + 4 >> 2] = a4;
                break;
              }
            } else {
              o = 1 - i;
              a4 = (!(j < o) & 1) + a4 | 0;
              b3[c3 + 4 >> 2] = a4;
              if (o <= j & j < i * 2) {
                d3 = d3 + 1 | 0;
                b3[c3 >> 2] = d3;
                break;
              } else {
                b3[c3 >> 2] = d3;
                break;
              }
            }
          } else {
            if (!(i < 0.6666666666666666)) {
              d3 = d3 + 1 | 0;
              b3[c3 >> 2] = d3;
              if (j < i * 0.5) {
                b3[c3 + 4 >> 2] = a4;
                break;
              } else {
                a4 = a4 + 1 | 0;
                b3[c3 + 4 >> 2] = a4;
                break;
              }
            }
            if (j < 1 - i) {
              b3[c3 + 4 >> 2] = a4;
              if (i * 2 + -1 < j) {
                b3[c3 >> 2] = d3;
                break;
              }
            } else {
              a4 = a4 + 1 | 0;
              b3[c3 + 4 >> 2] = a4;
            }
            d3 = d3 + 1 | 0;
            b3[c3 >> 2] = d3;
          }
        } while (0);
        do {
          if (k < 0) {
            if (!(a4 & 1)) {
              m = (a4 | 0) / 2 | 0;
              m = Kd(d3 | 0, ((d3 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d3 = ~~(+(d3 | 0) - (+(m >>> 0) + 4294967296 * +(H() | 0)) * 2);
              b3[c3 >> 2] = d3;
              break;
            } else {
              m = (a4 + 1 | 0) / 2 | 0;
              m = Kd(d3 | 0, ((d3 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d3 = ~~(+(d3 | 0) - ((+(m >>> 0) + 4294967296 * +(H() | 0)) * 2 + 1));
              b3[c3 >> 2] = d3;
              break;
            }
          }
        } while (0);
        m = c3 + 4 | 0;
        if (l < 0) {
          d3 = d3 - ((a4 << 1 | 1 | 0) / 2 | 0) | 0;
          b3[c3 >> 2] = d3;
          a4 = 0 - a4 | 0;
          b3[m >> 2] = a4;
        }
        f2 = a4 - d3 | 0;
        if ((d3 | 0) < 0) {
          g2 = 0 - d3 | 0;
          b3[m >> 2] = f2;
          b3[n >> 2] = g2;
          b3[c3 >> 2] = 0;
          a4 = f2;
          d3 = 0;
        } else {
          g2 = 0;
        }
        if ((a4 | 0) < 0) {
          d3 = d3 - a4 | 0;
          b3[c3 >> 2] = d3;
          g2 = g2 - a4 | 0;
          b3[n >> 2] = g2;
          b3[m >> 2] = 0;
          a4 = 0;
        }
        h = d3 - g2 | 0;
        f2 = a4 - g2 | 0;
        if ((g2 | 0) < 0) {
          b3[c3 >> 2] = h;
          b3[m >> 2] = f2;
          b3[n >> 2] = 0;
          a4 = f2;
          d3 = h;
          g2 = 0;
        }
        f2 = (a4 | 0) < (d3 | 0) ? a4 : d3;
        f2 = (g2 | 0) < (f2 | 0) ? g2 : f2;
        if ((f2 | 0) <= 0) {
          return;
        }
        b3[c3 >> 2] = d3 - f2;
        b3[m >> 2] = a4 - f2;
        b3[n >> 2] = g2 - f2;
        return;
      }
      function Ma(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        c3 = b3[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        d3 = b3[h >> 2] | 0;
        if ((c3 | 0) < 0) {
          d3 = d3 - c3 | 0;
          b3[h >> 2] = d3;
          g2 = a4 + 8 | 0;
          b3[g2 >> 2] = (b3[g2 >> 2] | 0) - c3;
          b3[a4 >> 2] = 0;
          c3 = 0;
        }
        if ((d3 | 0) < 0) {
          c3 = c3 - d3 | 0;
          b3[a4 >> 2] = c3;
          g2 = a4 + 8 | 0;
          f2 = (b3[g2 >> 2] | 0) - d3 | 0;
          b3[g2 >> 2] = f2;
          b3[h >> 2] = 0;
          d3 = 0;
        } else {
          f2 = a4 + 8 | 0;
          g2 = f2;
          f2 = b3[f2 >> 2] | 0;
        }
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b3[a4 >> 2] = c3;
          d3 = d3 - f2 | 0;
          b3[h >> 2] = d3;
          b3[g2 >> 2] = 0;
          f2 = 0;
        }
        e3 = (d3 | 0) < (c3 | 0) ? d3 : c3;
        e3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = c3 - e3;
        b3[h >> 2] = d3 - e3;
        b3[g2 >> 2] = f2 - e3;
        return;
      }
      function Na(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0;
        f2 = b3[a4 + 8 >> 2] | 0;
        d3 = +((b3[a4 + 4 >> 2] | 0) - f2 | 0);
        e2[c3 >> 3] = +((b3[a4 >> 2] | 0) - f2 | 0) - d3 * 0.5;
        e2[c3 + 8 >> 3] = d3 * 0.8660254037844386;
        return;
      }
      function Oa(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        b3[d3 >> 2] = (b3[c3 >> 2] | 0) + (b3[a4 >> 2] | 0);
        b3[d3 + 4 >> 2] = (b3[c3 + 4 >> 2] | 0) + (b3[a4 + 4 >> 2] | 0);
        b3[d3 + 8 >> 2] = (b3[c3 + 8 >> 2] | 0) + (b3[a4 + 8 >> 2] | 0);
        return;
      }
      function Pa(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        b3[d3 >> 2] = (b3[a4 >> 2] | 0) - (b3[c3 >> 2] | 0);
        b3[d3 + 4 >> 2] = (b3[a4 + 4 >> 2] | 0) - (b3[c3 + 4 >> 2] | 0);
        b3[d3 + 8 >> 2] = (b3[a4 + 8 >> 2] | 0) - (b3[c3 + 8 >> 2] | 0);
        return;
      }
      function Qa(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0;
        d3 = B2(b3[a4 >> 2] | 0, c3) | 0;
        b3[a4 >> 2] = d3;
        d3 = a4 + 4 | 0;
        e3 = B2(b3[d3 >> 2] | 0, c3) | 0;
        b3[d3 >> 2] = e3;
        a4 = a4 + 8 | 0;
        c3 = B2(b3[a4 >> 2] | 0, c3) | 0;
        b3[a4 >> 2] = c3;
        return;
      }
      function Ra(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = b3[a4 >> 2] | 0;
        i = (h | 0) < 0;
        e3 = (b3[a4 + 4 >> 2] | 0) - (i ? h : 0) | 0;
        g2 = (e3 | 0) < 0;
        f2 = (g2 ? 0 - e3 | 0 : 0) + ((b3[a4 + 8 >> 2] | 0) - (i ? h : 0)) | 0;
        d3 = (f2 | 0) < 0;
        a4 = d3 ? 0 : f2;
        c3 = (g2 ? 0 : e3) - (d3 ? f2 : 0) | 0;
        f2 = (i ? 0 : h) - (g2 ? e3 : 0) - (d3 ? f2 : 0) | 0;
        d3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        d3 = (a4 | 0) < (d3 | 0) ? a4 : d3;
        e3 = (d3 | 0) > 0;
        a4 = a4 - (e3 ? d3 : 0) | 0;
        c3 = c3 - (e3 ? d3 : 0) | 0;
        a: do {
          switch (f2 - (e3 ? d3 : 0) | 0) {
            case 0:
              switch (c3 | 0) {
                case 0: {
                  i = (a4 | 0) == 0 ? 0 : (a4 | 0) == 1 ? 1 : 7;
                  return i | 0;
                }
                case 1: {
                  i = (a4 | 0) == 0 ? 2 : (a4 | 0) == 1 ? 3 : 7;
                  return i | 0;
                }
                default:
                  break a;
              }
            case 1:
              switch (c3 | 0) {
                case 0: {
                  i = (a4 | 0) == 0 ? 4 : (a4 | 0) == 1 ? 5 : 7;
                  return i | 0;
                }
                case 1: {
                  if (!a4) {
                    a4 = 6;
                  } else {
                    break a;
                  }
                  return a4 | 0;
                }
                default:
                  break a;
              }
            default:
          }
        } while (0);
        i = 7;
        return i | 0;
      }
      function Sa(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        j = a4 + 8 | 0;
        h = b3[j >> 2] | 0;
        i = (b3[a4 >> 2] | 0) - h | 0;
        k = a4 + 4 | 0;
        h = (b3[k >> 2] | 0) - h | 0;
        if (i >>> 0 > 715827881 | h >>> 0 > 715827881) {
          e3 = (i | 0) > 0;
          f2 = 2147483647 - i | 0;
          g2 = -2147483648 - i | 0;
          if (e3 ? (f2 | 0) < (i | 0) : (g2 | 0) > (i | 0)) {
            k = 1;
            return k | 0;
          }
          d3 = i << 1;
          if (e3 ? (2147483647 - d3 | 0) < (i | 0) : (-2147483648 - d3 | 0) > (i | 0)) {
            k = 1;
            return k | 0;
          }
          if ((h | 0) > 0 ? (2147483647 - h | 0) < (h | 0) : (-2147483648 - h | 0) > (h | 0)) {
            k = 1;
            return k | 0;
          }
          c3 = i * 3 | 0;
          d3 = h << 1;
          if ((e3 ? (f2 | 0) < (d3 | 0) : (g2 | 0) > (d3 | 0)) ? 1 : (i | 0) > -1 ? (c3 | -2147483648 | 0) >= (h | 0) : (c3 ^ -2147483648 | 0) < (h | 0)) {
            k = 1;
            return k | 0;
          }
        } else {
          d3 = h << 1;
          c3 = i * 3 | 0;
        }
        e3 = Fd(+(c3 - h | 0) * 0.14285714285714285) | 0;
        b3[a4 >> 2] = e3;
        f2 = Fd(+(d3 + i | 0) * 0.14285714285714285) | 0;
        b3[k >> 2] = f2;
        b3[j >> 2] = 0;
        d3 = (f2 | 0) < (e3 | 0);
        c3 = d3 ? e3 : f2;
        d3 = d3 ? f2 : e3;
        if ((d3 | 0) < 0) {
          if ((d3 | 0) == -2147483648 ? 1 : (c3 | 0) > 0 ? (2147483647 - c3 | 0) < (d3 | 0) : (-2147483648 - c3 | 0) > (d3 | 0)) {
            I(27795, 26892, 354, 26903);
          }
          if ((c3 | 0) > -1 ? (c3 | -2147483648 | 0) >= (d3 | 0) : (c3 ^ -2147483648 | 0) < (d3 | 0)) {
            I(27795, 26892, 354, 26903);
          }
        }
        c3 = f2 - e3 | 0;
        if ((e3 | 0) < 0) {
          d3 = 0 - e3 | 0;
          b3[k >> 2] = c3;
          b3[j >> 2] = d3;
          b3[a4 >> 2] = 0;
          e3 = 0;
        } else {
          c3 = f2;
          d3 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b3[a4 >> 2] = e3;
          d3 = d3 - c3 | 0;
          b3[j >> 2] = d3;
          b3[k >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = c3 - d3 | 0;
        if ((d3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[k >> 2] = f2;
          b3[j >> 2] = 0;
          c3 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          k = 0;
          return k | 0;
        }
        b3[a4 >> 2] = f2 - e3;
        b3[k >> 2] = c3 - e3;
        b3[j >> 2] = d3 - e3;
        k = 0;
        return k | 0;
      }
      function Ta(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        h = a4 + 8 | 0;
        f2 = b3[h >> 2] | 0;
        g2 = (b3[a4 >> 2] | 0) - f2 | 0;
        i = a4 + 4 | 0;
        f2 = (b3[i >> 2] | 0) - f2 | 0;
        if (g2 >>> 0 > 715827881 | f2 >>> 0 > 715827881) {
          d3 = (g2 | 0) > 0;
          if (d3 ? (2147483647 - g2 | 0) < (g2 | 0) : (-2147483648 - g2 | 0) > (g2 | 0)) {
            i = 1;
            return i | 0;
          }
          c3 = g2 << 1;
          e3 = (f2 | 0) > 0;
          if (e3 ? (2147483647 - f2 | 0) < (f2 | 0) : (-2147483648 - f2 | 0) > (f2 | 0)) {
            i = 1;
            return i | 0;
          }
          j = f2 << 1;
          if (e3 ? (2147483647 - j | 0) < (f2 | 0) : (-2147483648 - j | 0) > (f2 | 0)) {
            j = 1;
            return j | 0;
          }
          if (d3 ? (2147483647 - c3 | 0) < (f2 | 0) : (-2147483648 - c3 | 0) > (f2 | 0)) {
            j = 1;
            return j | 0;
          }
          d3 = f2 * 3 | 0;
          if ((f2 | 0) > -1 ? (d3 | -2147483648 | 0) >= (g2 | 0) : (d3 ^ -2147483648 | 0) < (g2 | 0)) {
            j = 1;
            return j | 0;
          }
        } else {
          d3 = f2 * 3 | 0;
          c3 = g2 << 1;
        }
        e3 = Fd(+(c3 + f2 | 0) * 0.14285714285714285) | 0;
        b3[a4 >> 2] = e3;
        f2 = Fd(+(d3 - g2 | 0) * 0.14285714285714285) | 0;
        b3[i >> 2] = f2;
        b3[h >> 2] = 0;
        d3 = (f2 | 0) < (e3 | 0);
        c3 = d3 ? e3 : f2;
        d3 = d3 ? f2 : e3;
        if ((d3 | 0) < 0) {
          if ((d3 | 0) == -2147483648 ? 1 : (c3 | 0) > 0 ? (2147483647 - c3 | 0) < (d3 | 0) : (-2147483648 - c3 | 0) > (d3 | 0)) {
            I(27795, 26892, 402, 26917);
          }
          if ((c3 | 0) > -1 ? (c3 | -2147483648 | 0) >= (d3 | 0) : (c3 ^ -2147483648 | 0) < (d3 | 0)) {
            I(27795, 26892, 402, 26917);
          }
        }
        c3 = f2 - e3 | 0;
        if ((e3 | 0) < 0) {
          d3 = 0 - e3 | 0;
          b3[i >> 2] = c3;
          b3[h >> 2] = d3;
          b3[a4 >> 2] = 0;
          e3 = 0;
        } else {
          c3 = f2;
          d3 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b3[a4 >> 2] = e3;
          d3 = d3 - c3 | 0;
          b3[h >> 2] = d3;
          b3[i >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = c3 - d3 | 0;
        if ((d3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[i >> 2] = f2;
          b3[h >> 2] = 0;
          c3 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          j = 0;
          return j | 0;
        }
        b3[a4 >> 2] = f2 - e3;
        b3[i >> 2] = c3 - e3;
        b3[h >> 2] = d3 - e3;
        j = 0;
        return j | 0;
      }
      function Ua(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = a4 + 8 | 0;
        d3 = b3[h >> 2] | 0;
        c3 = (b3[a4 >> 2] | 0) - d3 | 0;
        i = a4 + 4 | 0;
        d3 = (b3[i >> 2] | 0) - d3 | 0;
        e3 = Fd(+((c3 * 3 | 0) - d3 | 0) * 0.14285714285714285) | 0;
        b3[a4 >> 2] = e3;
        c3 = Fd(+((d3 << 1) + c3 | 0) * 0.14285714285714285) | 0;
        b3[i >> 2] = c3;
        b3[h >> 2] = 0;
        d3 = c3 - e3 | 0;
        if ((e3 | 0) < 0) {
          g2 = 0 - e3 | 0;
          b3[i >> 2] = d3;
          b3[h >> 2] = g2;
          b3[a4 >> 2] = 0;
          c3 = d3;
          e3 = 0;
          d3 = g2;
        } else {
          d3 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b3[a4 >> 2] = e3;
          d3 = d3 - c3 | 0;
          b3[h >> 2] = d3;
          b3[i >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = c3 - d3 | 0;
        if ((d3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[i >> 2] = f2;
          b3[h >> 2] = 0;
          c3 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = f2 - e3;
        b3[i >> 2] = c3 - e3;
        b3[h >> 2] = d3 - e3;
        return;
      }
      function Va(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = a4 + 8 | 0;
        d3 = b3[h >> 2] | 0;
        c3 = (b3[a4 >> 2] | 0) - d3 | 0;
        i = a4 + 4 | 0;
        d3 = (b3[i >> 2] | 0) - d3 | 0;
        e3 = Fd(+((c3 << 1) + d3 | 0) * 0.14285714285714285) | 0;
        b3[a4 >> 2] = e3;
        c3 = Fd(+((d3 * 3 | 0) - c3 | 0) * 0.14285714285714285) | 0;
        b3[i >> 2] = c3;
        b3[h >> 2] = 0;
        d3 = c3 - e3 | 0;
        if ((e3 | 0) < 0) {
          g2 = 0 - e3 | 0;
          b3[i >> 2] = d3;
          b3[h >> 2] = g2;
          b3[a4 >> 2] = 0;
          c3 = d3;
          e3 = 0;
          d3 = g2;
        } else {
          d3 = 0;
        }
        if ((c3 | 0) < 0) {
          e3 = e3 - c3 | 0;
          b3[a4 >> 2] = e3;
          d3 = d3 - c3 | 0;
          b3[h >> 2] = d3;
          b3[i >> 2] = 0;
          c3 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = c3 - d3 | 0;
        if ((d3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[i >> 2] = f2;
          b3[h >> 2] = 0;
          c3 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c3 | 0) < (f2 | 0) ? c3 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = f2 - e3;
        b3[i >> 2] = c3 - e3;
        b3[h >> 2] = d3 - e3;
        return;
      }
      function Wa(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        c3 = b3[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        d3 = b3[h >> 2] | 0;
        i = a4 + 8 | 0;
        e3 = b3[i >> 2] | 0;
        f2 = d3 + (c3 * 3 | 0) | 0;
        b3[a4 >> 2] = f2;
        d3 = e3 + (d3 * 3 | 0) | 0;
        b3[h >> 2] = d3;
        c3 = (e3 * 3 | 0) + c3 | 0;
        b3[i >> 2] = c3;
        e3 = d3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b3[h >> 2] = e3;
          b3[i >> 2] = c3;
          b3[a4 >> 2] = 0;
          d3 = e3;
          e3 = 0;
        } else {
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b3[a4 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b3[i >> 2] = c3;
          b3[h >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[h >> 2] = f2;
          b3[i >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = e3 - d3;
        b3[h >> 2] = f2 - d3;
        b3[i >> 2] = c3 - d3;
        return;
      }
      function Xa(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = b3[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        c3 = b3[h >> 2] | 0;
        i = a4 + 8 | 0;
        d3 = b3[i >> 2] | 0;
        e3 = (c3 * 3 | 0) + f2 | 0;
        f2 = d3 + (f2 * 3 | 0) | 0;
        b3[a4 >> 2] = f2;
        b3[h >> 2] = e3;
        c3 = (d3 * 3 | 0) + c3 | 0;
        b3[i >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b3[h >> 2] = d3;
          b3[i >> 2] = c3;
          b3[a4 >> 2] = 0;
          f2 = 0;
        } else {
          d3 = e3;
        }
        if ((d3 | 0) < 0) {
          f2 = f2 - d3 | 0;
          b3[a4 >> 2] = f2;
          c3 = c3 - d3 | 0;
          b3[i >> 2] = c3;
          b3[h >> 2] = 0;
          d3 = 0;
        }
        g2 = f2 - c3 | 0;
        e3 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[h >> 2] = e3;
          b3[i >> 2] = 0;
          f2 = g2;
          c3 = 0;
        } else {
          e3 = d3;
        }
        d3 = (e3 | 0) < (f2 | 0) ? e3 : f2;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = f2 - d3;
        b3[h >> 2] = e3 - d3;
        b3[i >> 2] = c3 - d3;
        return;
      }
      function Ya(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        if ((c3 + -1 | 0) >>> 0 >= 6) {
          return;
        }
        f2 = (b3[15440 + (c3 * 12 | 0) >> 2] | 0) + (b3[a4 >> 2] | 0) | 0;
        b3[a4 >> 2] = f2;
        i = a4 + 4 | 0;
        e3 = (b3[15440 + (c3 * 12 | 0) + 4 >> 2] | 0) + (b3[i >> 2] | 0) | 0;
        b3[i >> 2] = e3;
        h = a4 + 8 | 0;
        c3 = (b3[15440 + (c3 * 12 | 0) + 8 >> 2] | 0) + (b3[h >> 2] | 0) | 0;
        b3[h >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b3[i >> 2] = d3;
          b3[h >> 2] = c3;
          b3[a4 >> 2] = 0;
          e3 = 0;
        } else {
          d3 = e3;
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b3[a4 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b3[h >> 2] = c3;
          b3[i >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[i >> 2] = f2;
          b3[h >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = e3 - d3;
        b3[i >> 2] = f2 - d3;
        b3[h >> 2] = c3 - d3;
        return;
      }
      function Za(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = b3[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        c3 = b3[h >> 2] | 0;
        i = a4 + 8 | 0;
        d3 = b3[i >> 2] | 0;
        e3 = c3 + f2 | 0;
        f2 = d3 + f2 | 0;
        b3[a4 >> 2] = f2;
        b3[h >> 2] = e3;
        c3 = d3 + c3 | 0;
        b3[i >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b3[h >> 2] = d3;
          b3[i >> 2] = c3;
          b3[a4 >> 2] = 0;
          e3 = 0;
        } else {
          d3 = e3;
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b3[a4 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b3[i >> 2] = c3;
          b3[h >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[h >> 2] = f2;
          b3[i >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = e3 - d3;
        b3[h >> 2] = f2 - d3;
        b3[i >> 2] = c3 - d3;
        return;
      }
      function _a(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        c3 = b3[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        e3 = b3[h >> 2] | 0;
        i = a4 + 8 | 0;
        d3 = b3[i >> 2] | 0;
        f2 = e3 + c3 | 0;
        b3[a4 >> 2] = f2;
        e3 = d3 + e3 | 0;
        b3[h >> 2] = e3;
        c3 = d3 + c3 | 0;
        b3[i >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b3[h >> 2] = d3;
          b3[i >> 2] = c3;
          b3[a4 >> 2] = 0;
          e3 = 0;
        } else {
          d3 = e3;
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b3[a4 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b3[i >> 2] = c3;
          b3[h >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[h >> 2] = f2;
          b3[i >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = e3 - d3;
        b3[h >> 2] = f2 - d3;
        b3[i >> 2] = c3 - d3;
        return;
      }
      function $a(a4) {
        a4 = a4 | 0;
        switch (a4 | 0) {
          case 1: {
            a4 = 5;
            break;
          }
          case 5: {
            a4 = 4;
            break;
          }
          case 4: {
            a4 = 6;
            break;
          }
          case 6: {
            a4 = 2;
            break;
          }
          case 2: {
            a4 = 3;
            break;
          }
          case 3: {
            a4 = 1;
            break;
          }
          default:
        }
        return a4 | 0;
      }
      function ab(a4) {
        a4 = a4 | 0;
        switch (a4 | 0) {
          case 1: {
            a4 = 3;
            break;
          }
          case 3: {
            a4 = 2;
            break;
          }
          case 2: {
            a4 = 6;
            break;
          }
          case 6: {
            a4 = 4;
            break;
          }
          case 4: {
            a4 = 5;
            break;
          }
          case 5: {
            a4 = 1;
            break;
          }
          default:
        }
        return a4 | 0;
      }
      function bb(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        c3 = b3[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        d3 = b3[h >> 2] | 0;
        i = a4 + 8 | 0;
        e3 = b3[i >> 2] | 0;
        f2 = d3 + (c3 << 1) | 0;
        b3[a4 >> 2] = f2;
        d3 = e3 + (d3 << 1) | 0;
        b3[h >> 2] = d3;
        c3 = (e3 << 1) + c3 | 0;
        b3[i >> 2] = c3;
        e3 = d3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b3[h >> 2] = e3;
          b3[i >> 2] = c3;
          b3[a4 >> 2] = 0;
          d3 = e3;
          e3 = 0;
        } else {
          e3 = f2;
        }
        if ((d3 | 0) < 0) {
          e3 = e3 - d3 | 0;
          b3[a4 >> 2] = e3;
          c3 = c3 - d3 | 0;
          b3[i >> 2] = c3;
          b3[h >> 2] = 0;
          d3 = 0;
        }
        g2 = e3 - c3 | 0;
        f2 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[h >> 2] = f2;
          b3[i >> 2] = 0;
          e3 = g2;
          c3 = 0;
        } else {
          f2 = d3;
        }
        d3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = e3 - d3;
        b3[h >> 2] = f2 - d3;
        b3[i >> 2] = c3 - d3;
        return;
      }
      function cb(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = b3[a4 >> 2] | 0;
        h = a4 + 4 | 0;
        c3 = b3[h >> 2] | 0;
        i = a4 + 8 | 0;
        d3 = b3[i >> 2] | 0;
        e3 = (c3 << 1) + f2 | 0;
        f2 = d3 + (f2 << 1) | 0;
        b3[a4 >> 2] = f2;
        b3[h >> 2] = e3;
        c3 = (d3 << 1) + c3 | 0;
        b3[i >> 2] = c3;
        d3 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c3 = c3 - f2 | 0;
          b3[h >> 2] = d3;
          b3[i >> 2] = c3;
          b3[a4 >> 2] = 0;
          f2 = 0;
        } else {
          d3 = e3;
        }
        if ((d3 | 0) < 0) {
          f2 = f2 - d3 | 0;
          b3[a4 >> 2] = f2;
          c3 = c3 - d3 | 0;
          b3[i >> 2] = c3;
          b3[h >> 2] = 0;
          d3 = 0;
        }
        g2 = f2 - c3 | 0;
        e3 = d3 - c3 | 0;
        if ((c3 | 0) < 0) {
          b3[a4 >> 2] = g2;
          b3[h >> 2] = e3;
          b3[i >> 2] = 0;
          f2 = g2;
          c3 = 0;
        } else {
          e3 = d3;
        }
        d3 = (e3 | 0) < (f2 | 0) ? e3 : f2;
        d3 = (c3 | 0) < (d3 | 0) ? c3 : d3;
        if ((d3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = f2 - d3;
        b3[h >> 2] = e3 - d3;
        b3[i >> 2] = c3 - d3;
        return;
      }
      function db(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = (b3[a4 >> 2] | 0) - (b3[c3 >> 2] | 0) | 0;
        i = (h | 0) < 0;
        e3 = (b3[a4 + 4 >> 2] | 0) - (b3[c3 + 4 >> 2] | 0) - (i ? h : 0) | 0;
        g2 = (e3 | 0) < 0;
        f2 = (i ? 0 - h | 0 : 0) + (b3[a4 + 8 >> 2] | 0) - (b3[c3 + 8 >> 2] | 0) + (g2 ? 0 - e3 | 0 : 0) | 0;
        a4 = (f2 | 0) < 0;
        c3 = a4 ? 0 : f2;
        d3 = (g2 ? 0 : e3) - (a4 ? f2 : 0) | 0;
        f2 = (i ? 0 : h) - (g2 ? e3 : 0) - (a4 ? f2 : 0) | 0;
        a4 = (d3 | 0) < (f2 | 0) ? d3 : f2;
        a4 = (c3 | 0) < (a4 | 0) ? c3 : a4;
        e3 = (a4 | 0) > 0;
        c3 = c3 - (e3 ? a4 : 0) | 0;
        d3 = d3 - (e3 ? a4 : 0) | 0;
        a4 = f2 - (e3 ? a4 : 0) | 0;
        a4 = (a4 | 0) > -1 ? a4 : 0 - a4 | 0;
        d3 = (d3 | 0) > -1 ? d3 : 0 - d3 | 0;
        c3 = (c3 | 0) > -1 ? c3 : 0 - c3 | 0;
        c3 = (d3 | 0) > (c3 | 0) ? d3 : c3;
        return ((a4 | 0) > (c3 | 0) ? a4 : c3) | 0;
      }
      function eb(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0;
        d3 = b3[a4 + 8 >> 2] | 0;
        b3[c3 >> 2] = (b3[a4 >> 2] | 0) - d3;
        b3[c3 + 4 >> 2] = (b3[a4 + 4 >> 2] | 0) - d3;
        return;
      }
      function fb(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        e3 = b3[a4 >> 2] | 0;
        b3[c3 >> 2] = e3;
        f2 = b3[a4 + 4 >> 2] | 0;
        h = c3 + 4 | 0;
        b3[h >> 2] = f2;
        i = c3 + 8 | 0;
        b3[i >> 2] = 0;
        d3 = (f2 | 0) < (e3 | 0);
        a4 = d3 ? e3 : f2;
        d3 = d3 ? f2 : e3;
        if ((d3 | 0) < 0) {
          if ((d3 | 0) == -2147483648 ? 1 : (a4 | 0) > 0 ? (2147483647 - a4 | 0) < (d3 | 0) : (-2147483648 - a4 | 0) > (d3 | 0)) {
            c3 = 1;
            return c3 | 0;
          }
          if ((a4 | 0) > -1 ? (a4 | -2147483648 | 0) >= (d3 | 0) : (a4 ^ -2147483648 | 0) < (d3 | 0)) {
            c3 = 1;
            return c3 | 0;
          }
        }
        a4 = f2 - e3 | 0;
        if ((e3 | 0) < 0) {
          d3 = 0 - e3 | 0;
          b3[h >> 2] = a4;
          b3[i >> 2] = d3;
          b3[c3 >> 2] = 0;
          e3 = 0;
        } else {
          a4 = f2;
          d3 = 0;
        }
        if ((a4 | 0) < 0) {
          e3 = e3 - a4 | 0;
          b3[c3 >> 2] = e3;
          d3 = d3 - a4 | 0;
          b3[i >> 2] = d3;
          b3[h >> 2] = 0;
          a4 = 0;
        }
        g2 = e3 - d3 | 0;
        f2 = a4 - d3 | 0;
        if ((d3 | 0) < 0) {
          b3[c3 >> 2] = g2;
          b3[h >> 2] = f2;
          b3[i >> 2] = 0;
          a4 = f2;
          f2 = g2;
          d3 = 0;
        } else {
          f2 = e3;
        }
        e3 = (a4 | 0) < (f2 | 0) ? a4 : f2;
        e3 = (d3 | 0) < (e3 | 0) ? d3 : e3;
        if ((e3 | 0) <= 0) {
          c3 = 0;
          return c3 | 0;
        }
        b3[c3 >> 2] = f2 - e3;
        b3[h >> 2] = a4 - e3;
        b3[i >> 2] = d3 - e3;
        c3 = 0;
        return c3 | 0;
      }
      function gb(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0;
        c3 = a4 + 8 | 0;
        f2 = b3[c3 >> 2] | 0;
        d3 = f2 - (b3[a4 >> 2] | 0) | 0;
        b3[a4 >> 2] = d3;
        e3 = a4 + 4 | 0;
        a4 = (b3[e3 >> 2] | 0) - f2 | 0;
        b3[e3 >> 2] = a4;
        b3[c3 >> 2] = 0 - (a4 + d3);
        return;
      }
      function hb(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        d3 = b3[a4 >> 2] | 0;
        c3 = 0 - d3 | 0;
        b3[a4 >> 2] = c3;
        h = a4 + 8 | 0;
        b3[h >> 2] = 0;
        i = a4 + 4 | 0;
        e3 = b3[i >> 2] | 0;
        f2 = e3 + d3 | 0;
        if ((d3 | 0) > 0) {
          b3[i >> 2] = f2;
          b3[h >> 2] = d3;
          b3[a4 >> 2] = 0;
          c3 = 0;
          e3 = f2;
        } else {
          d3 = 0;
        }
        if ((e3 | 0) < 0) {
          g2 = c3 - e3 | 0;
          b3[a4 >> 2] = g2;
          d3 = d3 - e3 | 0;
          b3[h >> 2] = d3;
          b3[i >> 2] = 0;
          f2 = g2 - d3 | 0;
          c3 = 0 - d3 | 0;
          if ((d3 | 0) < 0) {
            b3[a4 >> 2] = f2;
            b3[i >> 2] = c3;
            b3[h >> 2] = 0;
            e3 = c3;
            d3 = 0;
          } else {
            e3 = 0;
            f2 = g2;
          }
        } else {
          f2 = c3;
        }
        c3 = (e3 | 0) < (f2 | 0) ? e3 : f2;
        c3 = (d3 | 0) < (c3 | 0) ? d3 : c3;
        if ((c3 | 0) <= 0) {
          return;
        }
        b3[a4 >> 2] = f2 - c3;
        b3[i >> 2] = e3 - c3;
        b3[h >> 2] = d3 - c3;
        return;
      }
      function ib(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        m = T;
        T = T + 64 | 0;
        l = m;
        i = m + 56 | 0;
        if (!(true & (c3 & 2013265920 | 0) == 134217728 & (true & (e3 & 2013265920 | 0) == 134217728))) {
          f2 = 5;
          T = m;
          return f2 | 0;
        }
        if ((a4 | 0) == (d3 | 0) & (c3 | 0) == (e3 | 0)) {
          b3[f2 >> 2] = 0;
          f2 = 0;
          T = m;
          return f2 | 0;
        }
        h = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        h = h & 15;
        k = Td(d3 | 0, e3 | 0, 52) | 0;
        H() | 0;
        if ((h | 0) != (k & 15 | 0)) {
          f2 = 12;
          T = m;
          return f2 | 0;
        }
        g2 = h + -1 | 0;
        if (h >>> 0 > 1) {
          Ib(a4, c3, g2, l) | 0;
          Ib(d3, e3, g2, i) | 0;
          k = l;
          j = b3[k >> 2] | 0;
          k = b3[k + 4 >> 2] | 0;
          a: do {
            if ((j | 0) == (b3[i >> 2] | 0) ? (k | 0) == (b3[i + 4 >> 2] | 0) : 0) {
              h = (h ^ 15) * 3 | 0;
              g2 = Td(a4 | 0, c3 | 0, h | 0) | 0;
              H() | 0;
              g2 = g2 & 7;
              h = Td(d3 | 0, e3 | 0, h | 0) | 0;
              H() | 0;
              h = h & 7;
              do {
                if (!((g2 | 0) == 0 | (h | 0) == 0)) {
                  if ((g2 | 0) == 7) {
                    g2 = 5;
                  } else {
                    if ((g2 | 0) == 1 | (h | 0) == 1 ? Kb(j, k) | 0 : 0) {
                      g2 = 5;
                      break;
                    }
                    if ((b3[15536 + (g2 << 2) >> 2] | 0) != (h | 0) ? (b3[15568 + (g2 << 2) >> 2] | 0) != (h | 0) : 0) {
                      break a;
                    }
                    b3[f2 >> 2] = 1;
                    g2 = 0;
                  }
                } else {
                  b3[f2 >> 2] = 1;
                  g2 = 0;
                }
              } while (0);
              f2 = g2;
              T = m;
              return f2 | 0;
            }
          } while (0);
        }
        g2 = l;
        h = g2 + 56 | 0;
        do {
          b3[g2 >> 2] = 0;
          g2 = g2 + 4 | 0;
        } while ((g2 | 0) < (h | 0));
        aa(a4, c3, 1, l) | 0;
        c3 = l;
        if (((((!((b3[c3 >> 2] | 0) == (d3 | 0) ? (b3[c3 + 4 >> 2] | 0) == (e3 | 0) : 0) ? (c3 = l + 8 | 0, !((b3[c3 >> 2] | 0) == (d3 | 0) ? (b3[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l + 16 | 0, !((b3[c3 >> 2] | 0) == (d3 | 0) ? (b3[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l + 24 | 0, !((b3[c3 >> 2] | 0) == (d3 | 0) ? (b3[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l + 32 | 0, !((b3[c3 >> 2] | 0) == (d3 | 0) ? (b3[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c3 = l + 40 | 0, !((b3[c3 >> 2] | 0) == (d3 | 0) ? (b3[c3 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) {
          g2 = l + 48 | 0;
          g2 = ((b3[g2 >> 2] | 0) == (d3 | 0) ? (b3[g2 + 4 >> 2] | 0) == (e3 | 0) : 0) & 1;
        } else {
          g2 = 1;
        }
        b3[f2 >> 2] = g2;
        f2 = 0;
        T = m;
        return f2 | 0;
      }
      function jb(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        d3 = ia(a4, c3, d3, e3) | 0;
        if ((d3 | 0) == 7) {
          f2 = 11;
          return f2 | 0;
        }
        e3 = Ud(d3 | 0, 0, 56) | 0;
        c3 = c3 & -2130706433 | (H() | 0) | 268435456;
        b3[f2 >> 2] = a4 | e3;
        b3[f2 + 4 >> 2] = c3;
        f2 = 0;
        return f2 | 0;
      }
      function kb(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          d3 = 6;
          return d3 | 0;
        }
        b3[d3 >> 2] = a4;
        b3[d3 + 4 >> 2] = c3 & -2130706433 | 134217728;
        d3 = 0;
        return d3 | 0;
      }
      function lb(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        f2 = T;
        T = T + 16 | 0;
        e3 = f2;
        b3[e3 >> 2] = 0;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          e3 = 6;
          T = f2;
          return e3 | 0;
        }
        g2 = Td(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        e3 = ea(a4, c3 & -2130706433 | 134217728, g2 & 7, e3, d3) | 0;
        T = f2;
        return e3 | 0;
      }
      function mb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0;
        c3 = Td(a4 | 0, b4 | 0, 56) | 0;
        H() | 0;
        switch (c3 & 7) {
          case 0:
          case 7: {
            c3 = 0;
            return c3 | 0;
          }
          default:
        }
        c3 = b4 & -2130706433 | 134217728;
        if (!(true & (b4 & 2013265920 | 0) == 268435456)) {
          c3 = 0;
          return c3 | 0;
        }
        if (true & (b4 & 117440512 | 0) == 16777216 & (Kb(a4, c3) | 0) != 0) {
          c3 = 0;
          return c3 | 0;
        }
        c3 = Fb(a4, c3) | 0;
        return c3 | 0;
      }
      function nb(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        f2 = T;
        T = T + 16 | 0;
        e3 = f2;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          e3 = 6;
          T = f2;
          return e3 | 0;
        }
        g2 = c3 & -2130706433 | 134217728;
        h = d3;
        b3[h >> 2] = a4;
        b3[h + 4 >> 2] = g2;
        b3[e3 >> 2] = 0;
        c3 = Td(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        e3 = ea(a4, g2, c3 & 7, e3, d3 + 8 | 0) | 0;
        T = f2;
        return e3 | 0;
      }
      function ob(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0;
        f2 = (Kb(a4, c3) | 0) == 0;
        c3 = c3 & -2130706433;
        e3 = d3;
        b3[e3 >> 2] = f2 ? a4 : 0;
        b3[e3 + 4 >> 2] = f2 ? c3 | 285212672 : 0;
        e3 = d3 + 8 | 0;
        b3[e3 >> 2] = a4;
        b3[e3 + 4 >> 2] = c3 | 301989888;
        e3 = d3 + 16 | 0;
        b3[e3 >> 2] = a4;
        b3[e3 + 4 >> 2] = c3 | 318767104;
        e3 = d3 + 24 | 0;
        b3[e3 >> 2] = a4;
        b3[e3 + 4 >> 2] = c3 | 335544320;
        e3 = d3 + 32 | 0;
        b3[e3 >> 2] = a4;
        b3[e3 + 4 >> 2] = c3 | 352321536;
        d3 = d3 + 40 | 0;
        b3[d3 >> 2] = a4;
        b3[d3 + 4 >> 2] = c3 | 369098752;
        return 0;
      }
      function pb(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        h = T;
        T = T + 16 | 0;
        f2 = h;
        g2 = c3 & -2130706433 | 134217728;
        if (!(true & (c3 & 2013265920 | 0) == 268435456)) {
          g2 = 6;
          T = h;
          return g2 | 0;
        }
        e3 = Td(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        e3 = rd(a4, g2, e3 & 7) | 0;
        if ((e3 | 0) == -1) {
          b3[d3 >> 2] = 0;
          g2 = 6;
          T = h;
          return g2 | 0;
        }
        if ($b(a4, g2, f2) | 0) {
          I(27795, 26932, 282, 26947);
        }
        c3 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        c3 = c3 & 15;
        if (!(Kb(a4, g2) | 0)) {
          zb(f2, c3, e3, 2, d3);
        } else {
          vb(f2, c3, e3, 2, d3);
        }
        g2 = 0;
        T = h;
        return g2 | 0;
      }
      function qb(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0;
        d3 = T;
        T = T + 16 | 0;
        e3 = d3;
        rb(a4, b4, c3, e3);
        La(e3, c3 + 4 | 0);
        T = d3;
        return;
      }
      function rb(a4, c3, d3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0;
        j = T;
        T = T + 16 | 0;
        k = j;
        sb(a4, d3, k);
        h = +w2(+(1 - +e2[k >> 3] * 0.5));
        if (h < 1e-16) {
          b3[f2 >> 2] = 0;
          b3[f2 + 4 >> 2] = 0;
          b3[f2 + 8 >> 2] = 0;
          b3[f2 + 12 >> 2] = 0;
          T = j;
          return;
        }
        k = b3[d3 >> 2] | 0;
        g2 = +e2[15920 + (k * 24 | 0) >> 3];
        g2 = +lc(g2 - +lc(+rc(15600 + (k << 4) | 0, a4)));
        if (!(Yb(c3) | 0)) {
          i = g2;
        } else {
          i = +lc(g2 + -0.3334731722518321);
        }
        g2 = +v2(+h) * 2.618033988749896;
        if ((c3 | 0) > 0) {
          a4 = 0;
          do {
            g2 = g2 * 2.6457513110645907;
            a4 = a4 + 1 | 0;
          } while ((a4 | 0) != (c3 | 0));
        }
        h = +t(+i) * g2;
        e2[f2 >> 3] = h;
        i = +u2(+i) * g2;
        e2[f2 + 8 >> 3] = i;
        T = j;
        return;
      }
      function sb(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        h = T;
        T = T + 32 | 0;
        g2 = h;
        qd(a4, g2);
        b3[c3 >> 2] = 0;
        e2[d3 >> 3] = 5;
        f2 = +pd(16400, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 0;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16424, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 1;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16448, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 2;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16472, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 3;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16496, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 4;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16520, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 5;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16544, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 6;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16568, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 7;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16592, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 8;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16616, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 9;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16640, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 10;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16664, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 11;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16688, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 12;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16712, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 13;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16736, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 14;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16760, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 15;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16784, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 16;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16808, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 17;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16832, g2);
        if (f2 < +e2[d3 >> 3]) {
          b3[c3 >> 2] = 18;
          e2[d3 >> 3] = f2;
        }
        f2 = +pd(16856, g2);
        if (!(f2 < +e2[d3 >> 3])) {
          T = h;
          return;
        }
        b3[c3 >> 2] = 19;
        e2[d3 >> 3] = f2;
        T = h;
        return;
      }
      function tb(a4, c3, d3, f2, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0;
        h = +md(a4);
        if (h < 1e-16) {
          c3 = 15600 + (c3 << 4) | 0;
          b3[g2 >> 2] = b3[c3 >> 2];
          b3[g2 + 4 >> 2] = b3[c3 + 4 >> 2];
          b3[g2 + 8 >> 2] = b3[c3 + 8 >> 2];
          b3[g2 + 12 >> 2] = b3[c3 + 12 >> 2];
          return;
        }
        i = +z(+ +e2[a4 + 8 >> 3], + +e2[a4 >> 3]);
        if ((d3 | 0) > 0) {
          a4 = 0;
          do {
            h = h * 0.37796447300922725;
            a4 = a4 + 1 | 0;
          } while ((a4 | 0) != (d3 | 0));
        }
        j = h * 0.3333333333333333;
        if (!f2) {
          h = +y(+(h * 0.381966011250105));
          if (Yb(d3) | 0) {
            i = +lc(i + 0.3334731722518321);
          }
        } else {
          d3 = (Yb(d3) | 0) == 0;
          h = +y(+((d3 ? j : j * 0.37796447300922725) * 0.381966011250105));
        }
        sc(15600 + (c3 << 4) | 0, +lc(+e2[15920 + (c3 * 24 | 0) >> 3] - i), h, g2);
        return;
      }
      function ub(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0;
        e3 = T;
        T = T + 16 | 0;
        f2 = e3;
        Na(a4 + 4 | 0, f2);
        tb(f2, b3[a4 >> 2] | 0, c3, 0, d3);
        T = e3;
        return;
      }
      function vb(a4, c3, d3, f2, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F2 = 0, G3 = 0, H2 = 0, J2 = 0;
        G3 = T;
        T = T + 272 | 0;
        h = G3 + 256 | 0;
        u3 = G3 + 240 | 0;
        D3 = G3;
        E3 = G3 + 224 | 0;
        F2 = G3 + 208 | 0;
        v3 = G3 + 176 | 0;
        w3 = G3 + 160 | 0;
        x2 = G3 + 192 | 0;
        y2 = G3 + 144 | 0;
        z2 = G3 + 128 | 0;
        A3 = G3 + 112 | 0;
        B3 = G3 + 96 | 0;
        C3 = G3 + 80 | 0;
        b3[h >> 2] = c3;
        b3[u3 >> 2] = b3[a4 >> 2];
        b3[u3 + 4 >> 2] = b3[a4 + 4 >> 2];
        b3[u3 + 8 >> 2] = b3[a4 + 8 >> 2];
        b3[u3 + 12 >> 2] = b3[a4 + 12 >> 2];
        wb(u3, h, D3);
        b3[g2 >> 2] = 0;
        u3 = f2 + d3 + ((f2 | 0) == 5 & 1) | 0;
        if ((u3 | 0) <= (d3 | 0)) {
          T = G3;
          return;
        }
        k = b3[h >> 2] | 0;
        l = E3 + 4 | 0;
        m = v3 + 4 | 0;
        n = d3 + 5 | 0;
        o = 16880 + (k << 2) | 0;
        p2 = 16960 + (k << 2) | 0;
        q2 = z2 + 8 | 0;
        r2 = A3 + 8 | 0;
        s2 = B3 + 8 | 0;
        t2 = F2 + 4 | 0;
        j = d3;
        a: while (1) {
          i = D3 + (((j | 0) % 5 | 0) << 4) | 0;
          b3[F2 >> 2] = b3[i >> 2];
          b3[F2 + 4 >> 2] = b3[i + 4 >> 2];
          b3[F2 + 8 >> 2] = b3[i + 8 >> 2];
          b3[F2 + 12 >> 2] = b3[i + 12 >> 2];
          do {
          } while ((xb(F2, k, 0, 1) | 0) == 2);
          if ((j | 0) > (d3 | 0) & (Yb(c3) | 0) != 0) {
            b3[v3 >> 2] = b3[F2 >> 2];
            b3[v3 + 4 >> 2] = b3[F2 + 4 >> 2];
            b3[v3 + 8 >> 2] = b3[F2 + 8 >> 2];
            b3[v3 + 12 >> 2] = b3[F2 + 12 >> 2];
            Na(l, w3);
            f2 = b3[v3 >> 2] | 0;
            h = b3[17040 + (f2 * 80 | 0) + (b3[E3 >> 2] << 2) >> 2] | 0;
            b3[v3 >> 2] = b3[18640 + (f2 * 80 | 0) + (h * 20 | 0) >> 2];
            i = b3[18640 + (f2 * 80 | 0) + (h * 20 | 0) + 16 >> 2] | 0;
            if ((i | 0) > 0) {
              a4 = 0;
              do {
                Za(m);
                a4 = a4 + 1 | 0;
              } while ((a4 | 0) < (i | 0));
            }
            i = 18640 + (f2 * 80 | 0) + (h * 20 | 0) + 4 | 0;
            b3[x2 >> 2] = b3[i >> 2];
            b3[x2 + 4 >> 2] = b3[i + 4 >> 2];
            b3[x2 + 8 >> 2] = b3[i + 8 >> 2];
            Qa(x2, (b3[o >> 2] | 0) * 3 | 0);
            Oa(m, x2, m);
            Ma(m);
            Na(m, y2);
            H2 = +(b3[p2 >> 2] | 0);
            e2[z2 >> 3] = H2 * 3;
            e2[q2 >> 3] = 0;
            J2 = H2 * -1.5;
            e2[A3 >> 3] = J2;
            e2[r2 >> 3] = H2 * 2.598076211353316;
            e2[B3 >> 3] = J2;
            e2[s2 >> 3] = H2 * -2.598076211353316;
            switch (b3[17040 + ((b3[v3 >> 2] | 0) * 80 | 0) + (b3[F2 >> 2] << 2) >> 2] | 0) {
              case 1: {
                a4 = A3;
                f2 = z2;
                break;
              }
              case 3: {
                a4 = B3;
                f2 = A3;
                break;
              }
              case 2: {
                a4 = z2;
                f2 = B3;
                break;
              }
              default: {
                a4 = 12;
                break a;
              }
            }
            nd(w3, y2, f2, a4, C3);
            tb(C3, b3[v3 >> 2] | 0, k, 1, g2 + 8 + (b3[g2 >> 2] << 4) | 0);
            b3[g2 >> 2] = (b3[g2 >> 2] | 0) + 1;
          }
          if ((j | 0) < (n | 0)) {
            Na(t2, v3);
            tb(v3, b3[F2 >> 2] | 0, k, 1, g2 + 8 + (b3[g2 >> 2] << 4) | 0);
            b3[g2 >> 2] = (b3[g2 >> 2] | 0) + 1;
          }
          b3[E3 >> 2] = b3[F2 >> 2];
          b3[E3 + 4 >> 2] = b3[F2 + 4 >> 2];
          b3[E3 + 8 >> 2] = b3[F2 + 8 >> 2];
          b3[E3 + 12 >> 2] = b3[F2 + 12 >> 2];
          j = j + 1 | 0;
          if ((j | 0) >= (u3 | 0)) {
            a4 = 3;
            break;
          }
        }
        if ((a4 | 0) == 3) {
          T = G3;
          return;
        } else if ((a4 | 0) == 12) {
          I(26970, 27017, 572, 27027);
        }
      }
      function wb(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 128 | 0;
        e3 = j + 64 | 0;
        f2 = j;
        g2 = e3;
        h = 20240;
        i = g2 + 60 | 0;
        do {
          b3[g2 >> 2] = b3[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        g2 = f2;
        h = 20304;
        i = g2 + 60 | 0;
        do {
          b3[g2 >> 2] = b3[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        i = (Yb(b3[c3 >> 2] | 0) | 0) == 0;
        e3 = i ? e3 : f2;
        f2 = a4 + 4 | 0;
        bb(f2);
        cb(f2);
        if (Yb(b3[c3 >> 2] | 0) | 0) {
          Xa(f2);
          b3[c3 >> 2] = (b3[c3 >> 2] | 0) + 1;
        }
        b3[d3 >> 2] = b3[a4 >> 2];
        c3 = d3 + 4 | 0;
        Oa(f2, e3, c3);
        Ma(c3);
        b3[d3 + 16 >> 2] = b3[a4 >> 2];
        c3 = d3 + 20 | 0;
        Oa(f2, e3 + 12 | 0, c3);
        Ma(c3);
        b3[d3 + 32 >> 2] = b3[a4 >> 2];
        c3 = d3 + 36 | 0;
        Oa(f2, e3 + 24 | 0, c3);
        Ma(c3);
        b3[d3 + 48 >> 2] = b3[a4 >> 2];
        c3 = d3 + 52 | 0;
        Oa(f2, e3 + 36 | 0, c3);
        Ma(c3);
        b3[d3 + 64 >> 2] = b3[a4 >> 2];
        d3 = d3 + 68 | 0;
        Oa(f2, e3 + 48 | 0, d3);
        Ma(d3);
        T = j;
        return;
      }
      function xb(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        p2 = T;
        T = T + 32 | 0;
        n = p2 + 12 | 0;
        i = p2;
        o = a4 + 4 | 0;
        m = b3[16960 + (c3 << 2) >> 2] | 0;
        l = (e3 | 0) != 0;
        m = l ? m * 3 | 0 : m;
        f2 = b3[o >> 2] | 0;
        k = a4 + 8 | 0;
        h = b3[k >> 2] | 0;
        if (l) {
          g2 = a4 + 12 | 0;
          e3 = b3[g2 >> 2] | 0;
          f2 = h + f2 + e3 | 0;
          if ((f2 | 0) == (m | 0)) {
            o = 1;
            T = p2;
            return o | 0;
          } else {
            j = g2;
          }
        } else {
          j = a4 + 12 | 0;
          e3 = b3[j >> 2] | 0;
          f2 = h + f2 + e3 | 0;
        }
        if ((f2 | 0) <= (m | 0)) {
          o = 0;
          T = p2;
          return o | 0;
        }
        do {
          if ((e3 | 0) > 0) {
            e3 = b3[a4 >> 2] | 0;
            if ((h | 0) > 0) {
              g2 = 18640 + (e3 * 80 | 0) + 60 | 0;
              e3 = a4;
              break;
            }
            e3 = 18640 + (e3 * 80 | 0) + 40 | 0;
            if (!d3) {
              g2 = e3;
              e3 = a4;
            } else {
              Ka(n, m, 0, 0);
              Pa(o, n, i);
              _a(i);
              Oa(i, n, o);
              g2 = e3;
              e3 = a4;
            }
          } else {
            g2 = 18640 + ((b3[a4 >> 2] | 0) * 80 | 0) + 20 | 0;
            e3 = a4;
          }
        } while (0);
        b3[e3 >> 2] = b3[g2 >> 2];
        f2 = g2 + 16 | 0;
        if ((b3[f2 >> 2] | 0) > 0) {
          e3 = 0;
          do {
            Za(o);
            e3 = e3 + 1 | 0;
          } while ((e3 | 0) < (b3[f2 >> 2] | 0));
        }
        a4 = g2 + 4 | 0;
        b3[n >> 2] = b3[a4 >> 2];
        b3[n + 4 >> 2] = b3[a4 + 4 >> 2];
        b3[n + 8 >> 2] = b3[a4 + 8 >> 2];
        c3 = b3[16880 + (c3 << 2) >> 2] | 0;
        Qa(n, l ? c3 * 3 | 0 : c3);
        Oa(o, n, o);
        Ma(o);
        if (l) {
          e3 = ((b3[k >> 2] | 0) + (b3[o >> 2] | 0) + (b3[j >> 2] | 0) | 0) == (m | 0) ? 1 : 2;
        } else {
          e3 = 2;
        }
        o = e3;
        T = p2;
        return o | 0;
      }
      function yb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0;
        do {
          c3 = xb(a4, b4, 0, 1) | 0;
        } while ((c3 | 0) == 2);
        return c3 | 0;
      }
      function zb(a4, c3, d3, f2, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0;
        B3 = T;
        T = T + 240 | 0;
        h = B3 + 224 | 0;
        x2 = B3 + 208 | 0;
        y2 = B3;
        z2 = B3 + 192 | 0;
        A3 = B3 + 176 | 0;
        s2 = B3 + 160 | 0;
        t2 = B3 + 144 | 0;
        u3 = B3 + 128 | 0;
        v3 = B3 + 112 | 0;
        w3 = B3 + 96 | 0;
        b3[h >> 2] = c3;
        b3[x2 >> 2] = b3[a4 >> 2];
        b3[x2 + 4 >> 2] = b3[a4 + 4 >> 2];
        b3[x2 + 8 >> 2] = b3[a4 + 8 >> 2];
        b3[x2 + 12 >> 2] = b3[a4 + 12 >> 2];
        Ab(x2, h, y2);
        b3[g2 >> 2] = 0;
        r2 = f2 + d3 + ((f2 | 0) == 6 & 1) | 0;
        if ((r2 | 0) <= (d3 | 0)) {
          T = B3;
          return;
        }
        k = b3[h >> 2] | 0;
        l = d3 + 6 | 0;
        m = 16960 + (k << 2) | 0;
        n = t2 + 8 | 0;
        o = u3 + 8 | 0;
        p2 = v3 + 8 | 0;
        q2 = z2 + 4 | 0;
        i = 0;
        j = d3;
        f2 = -1;
        a: while (1) {
          h = (j | 0) % 6 | 0;
          a4 = y2 + (h << 4) | 0;
          b3[z2 >> 2] = b3[a4 >> 2];
          b3[z2 + 4 >> 2] = b3[a4 + 4 >> 2];
          b3[z2 + 8 >> 2] = b3[a4 + 8 >> 2];
          b3[z2 + 12 >> 2] = b3[a4 + 12 >> 2];
          a4 = i;
          i = xb(z2, k, 0, 1) | 0;
          if ((j | 0) > (d3 | 0) & (Yb(c3) | 0) != 0 ? (a4 | 0) != 1 ? (b3[z2 >> 2] | 0) != (f2 | 0) : 0 : 0) {
            Na(y2 + (((h + 5 | 0) % 6 | 0) << 4) + 4 | 0, A3);
            Na(y2 + (h << 4) + 4 | 0, s2);
            C3 = +(b3[m >> 2] | 0);
            e2[t2 >> 3] = C3 * 3;
            e2[n >> 3] = 0;
            D3 = C3 * -1.5;
            e2[u3 >> 3] = D3;
            e2[o >> 3] = C3 * 2.598076211353316;
            e2[v3 >> 3] = D3;
            e2[p2 >> 3] = C3 * -2.598076211353316;
            h = b3[x2 >> 2] | 0;
            switch (b3[17040 + (h * 80 | 0) + (((f2 | 0) == (h | 0) ? b3[z2 >> 2] | 0 : f2) << 2) >> 2] | 0) {
              case 1: {
                a4 = u3;
                f2 = t2;
                break;
              }
              case 3: {
                a4 = v3;
                f2 = u3;
                break;
              }
              case 2: {
                a4 = t2;
                f2 = v3;
                break;
              }
              default: {
                a4 = 8;
                break a;
              }
            }
            nd(A3, s2, f2, a4, w3);
            if (!(od(A3, w3) | 0) ? !(od(s2, w3) | 0) : 0) {
              tb(w3, b3[x2 >> 2] | 0, k, 1, g2 + 8 + (b3[g2 >> 2] << 4) | 0);
              b3[g2 >> 2] = (b3[g2 >> 2] | 0) + 1;
            }
          }
          if ((j | 0) < (l | 0)) {
            Na(q2, A3);
            tb(A3, b3[z2 >> 2] | 0, k, 1, g2 + 8 + (b3[g2 >> 2] << 4) | 0);
            b3[g2 >> 2] = (b3[g2 >> 2] | 0) + 1;
          }
          j = j + 1 | 0;
          if ((j | 0) >= (r2 | 0)) {
            a4 = 3;
            break;
          } else {
            f2 = b3[z2 >> 2] | 0;
          }
        }
        if ((a4 | 0) == 3) {
          T = B3;
          return;
        } else if ((a4 | 0) == 8) {
          I(27054, 27017, 737, 27099);
        }
      }
      function Ab(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 160 | 0;
        e3 = j + 80 | 0;
        f2 = j;
        g2 = e3;
        h = 20368;
        i = g2 + 72 | 0;
        do {
          b3[g2 >> 2] = b3[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        g2 = f2;
        h = 20448;
        i = g2 + 72 | 0;
        do {
          b3[g2 >> 2] = b3[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        i = (Yb(b3[c3 >> 2] | 0) | 0) == 0;
        e3 = i ? e3 : f2;
        f2 = a4 + 4 | 0;
        bb(f2);
        cb(f2);
        if (Yb(b3[c3 >> 2] | 0) | 0) {
          Xa(f2);
          b3[c3 >> 2] = (b3[c3 >> 2] | 0) + 1;
        }
        b3[d3 >> 2] = b3[a4 >> 2];
        c3 = d3 + 4 | 0;
        Oa(f2, e3, c3);
        Ma(c3);
        b3[d3 + 16 >> 2] = b3[a4 >> 2];
        c3 = d3 + 20 | 0;
        Oa(f2, e3 + 12 | 0, c3);
        Ma(c3);
        b3[d3 + 32 >> 2] = b3[a4 >> 2];
        c3 = d3 + 36 | 0;
        Oa(f2, e3 + 24 | 0, c3);
        Ma(c3);
        b3[d3 + 48 >> 2] = b3[a4 >> 2];
        c3 = d3 + 52 | 0;
        Oa(f2, e3 + 36 | 0, c3);
        Ma(c3);
        b3[d3 + 64 >> 2] = b3[a4 >> 2];
        c3 = d3 + 68 | 0;
        Oa(f2, e3 + 48 | 0, c3);
        Ma(c3);
        b3[d3 + 80 >> 2] = b3[a4 >> 2];
        d3 = d3 + 84 | 0;
        Oa(f2, e3 + 60 | 0, d3);
        Ma(d3);
        T = j;
        return;
      }
      function Bb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        b4 = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        return b4 & 15 | 0;
      }
      function Cb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        b4 = Td(a4 | 0, b4 | 0, 45) | 0;
        H() | 0;
        return b4 & 127 | 0;
      }
      function Db(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        if ((d3 + -1 | 0) >>> 0 > 14) {
          e3 = 4;
          return e3 | 0;
        }
        d3 = Td(a4 | 0, c3 | 0, (15 - d3 | 0) * 3 | 0) | 0;
        H() | 0;
        b3[e3 >> 2] = d3 & 7;
        e3 = 0;
        return e3 | 0;
      }
      function Eb(c3, d3, e3, f2) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        if (c3 >>> 0 > 15) {
          f2 = 4;
          return f2 | 0;
        }
        if (d3 >>> 0 > 121) {
          f2 = 17;
          return f2 | 0;
        }
        i = Ud(c3 | 0, 0, 52) | 0;
        g2 = H() | 0;
        j = Ud(d3 | 0, 0, 45) | 0;
        g2 = g2 | (H() | 0) | 134225919;
        a: do {
          if ((c3 | 0) >= 1) {
            j = 1;
            i = (a3[20528 + d3 >> 0] | 0) != 0;
            h = -1;
            while (1) {
              d3 = b3[e3 + (j + -1 << 2) >> 2] | 0;
              if (d3 >>> 0 > 6) {
                g2 = 18;
                d3 = 10;
                break;
              }
              if (!((d3 | 0) == 0 | i ^ 1)) {
                if ((d3 | 0) == 1) {
                  g2 = 19;
                  d3 = 10;
                  break;
                } else {
                  i = 0;
                }
              }
              l = (15 - j | 0) * 3 | 0;
              k = Ud(7, 0, l | 0) | 0;
              g2 = g2 & ~(H() | 0);
              d3 = Ud(d3 | 0, ((d3 | 0) < 0) << 31 >> 31 | 0, l | 0) | 0;
              h = d3 | h & ~k;
              g2 = H() | 0 | g2;
              if ((j | 0) < (c3 | 0)) {
                j = j + 1 | 0;
              } else {
                break a;
              }
            }
            if ((d3 | 0) == 10) {
              return g2 | 0;
            }
          } else {
            h = -1;
          }
        } while (0);
        l = f2;
        b3[l >> 2] = h;
        b3[l + 4 >> 2] = g2;
        l = 0;
        return l | 0;
      }
      function Fb(b4, c3) {
        b4 = b4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        if (!(true & (c3 & -16777216 | 0) == 134217728)) {
          b4 = 0;
          return b4 | 0;
        }
        e3 = Td(b4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        d3 = Td(b4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        d3 = d3 & 127;
        if (d3 >>> 0 > 121) {
          b4 = 0;
          return b4 | 0;
        }
        h = (e3 ^ 15) * 3 | 0;
        f2 = Td(b4 | 0, c3 | 0, h | 0) | 0;
        h = Ud(f2 | 0, H() | 0, h | 0) | 0;
        f2 = H() | 0;
        g2 = Kd(-1227133514, -1171, h | 0, f2 | 0) | 0;
        if (!((h & 613566756 & g2 | 0) == 0 & (f2 & 4681 & (H() | 0) | 0) == 0)) {
          h = 0;
          return h | 0;
        }
        h = (e3 * 3 | 0) + 19 | 0;
        g2 = Ud(~b4 | 0, ~c3 | 0, h | 0) | 0;
        h = Td(g2 | 0, H() | 0, h | 0) | 0;
        if (!((e3 | 0) == 15 | (h | 0) == 0 & (H() | 0) == 0)) {
          h = 0;
          return h | 0;
        }
        if (!(a3[20528 + d3 >> 0] | 0)) {
          h = 1;
          return h | 0;
        }
        c3 = c3 & 8191;
        if ((b4 | 0) == 0 & (c3 | 0) == 0) {
          h = 1;
          return h | 0;
        } else {
          h = Vd(b4 | 0, c3 | 0, 0) | 0;
          H() | 0;
          return ((63 - h | 0) % 3 | 0 | 0) != 0 | 0;
        }
        return 0;
      }
      function Gb(b4, c3) {
        b4 = b4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        if (((true & (c3 & -16777216 | 0) == 134217728 ? (e3 = Td(b4 | 0, c3 | 0, 52) | 0, H() | 0, e3 = e3 & 15, d3 = Td(b4 | 0, c3 | 0, 45) | 0, H() | 0, d3 = d3 & 127, d3 >>> 0 <= 121) : 0) ? (h = (e3 ^ 15) * 3 | 0, f2 = Td(b4 | 0, c3 | 0, h | 0) | 0, h = Ud(f2 | 0, H() | 0, h | 0) | 0, f2 = H() | 0, g2 = Kd(-1227133514, -1171, h | 0, f2 | 0) | 0, (h & 613566756 & g2 | 0) == 0 & (f2 & 4681 & (H() | 0) | 0) == 0) : 0) ? (h = (e3 * 3 | 0) + 19 | 0, g2 = Ud(~b4 | 0, ~c3 | 0, h | 0) | 0, h = Td(g2 | 0, H() | 0, h | 0) | 0, (e3 | 0) == 15 | (h | 0) == 0 & (H() | 0) == 0) : 0) {
          if (!(a3[20528 + d3 >> 0] | 0)) {
            h = 1;
            return h | 0;
          }
          d3 = c3 & 8191;
          if ((b4 | 0) == 0 & (d3 | 0) == 0) {
            h = 1;
            return h | 0;
          }
          h = Vd(b4 | 0, d3 | 0, 0) | 0;
          H() | 0;
          if ((63 - h | 0) % 3 | 0 | 0) {
            h = 1;
            return h | 0;
          }
        }
        if (mb(b4, c3) | 0) {
          h = 1;
          return h | 0;
        }
        h = (wd(b4, c3) | 0) != 0 & 1;
        return h | 0;
      }
      function Hb(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = Ud(c3 | 0, 0, 52) | 0;
        g2 = H() | 0;
        d3 = Ud(d3 | 0, 0, 45) | 0;
        d3 = g2 | (H() | 0) | 134225919;
        if ((c3 | 0) < 1) {
          g2 = -1;
          e3 = d3;
          c3 = a4;
          b3[c3 >> 2] = g2;
          a4 = a4 + 4 | 0;
          b3[a4 >> 2] = e3;
          return;
        }
        g2 = 1;
        f2 = -1;
        while (1) {
          h = (15 - g2 | 0) * 3 | 0;
          i = Ud(7, 0, h | 0) | 0;
          d3 = d3 & ~(H() | 0);
          h = Ud(e3 | 0, 0, h | 0) | 0;
          f2 = f2 & ~i | h;
          d3 = d3 | (H() | 0);
          if ((g2 | 0) == (c3 | 0)) {
            break;
          } else {
            g2 = g2 + 1 | 0;
          }
        }
        i = a4;
        h = i;
        b3[h >> 2] = f2;
        i = i + 4 | 0;
        b3[i >> 2] = d3;
        return;
      }
      function Ib(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        g2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        if (d3 >>> 0 > 15) {
          e3 = 4;
          return e3 | 0;
        }
        if ((g2 | 0) < (d3 | 0)) {
          e3 = 12;
          return e3 | 0;
        }
        if ((g2 | 0) == (d3 | 0)) {
          b3[e3 >> 2] = a4;
          b3[e3 + 4 >> 2] = c3;
          e3 = 0;
          return e3 | 0;
        }
        f2 = Ud(d3 | 0, 0, 52) | 0;
        f2 = f2 | a4;
        a4 = H() | 0 | c3 & -15728641;
        if ((g2 | 0) > (d3 | 0)) {
          do {
            c3 = Ud(7, 0, (14 - d3 | 0) * 3 | 0) | 0;
            d3 = d3 + 1 | 0;
            f2 = c3 | f2;
            a4 = H() | 0 | a4;
          } while ((d3 | 0) < (g2 | 0));
        }
        b3[e3 >> 2] = f2;
        b3[e3 + 4 >> 2] = a4;
        e3 = 0;
        return e3 | 0;
      }
      function Jb(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        g2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        if (!((d3 | 0) < 16 & (g2 | 0) <= (d3 | 0))) {
          e3 = 4;
          return e3 | 0;
        }
        f2 = d3 - g2 | 0;
        d3 = Td(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        a: do {
          if (!(oa(d3 & 127) | 0)) {
            d3 = Rc(7, 0, f2, ((f2 | 0) < 0) << 31 >> 31) | 0;
            f2 = H() | 0;
          } else {
            b: do {
              if (g2 | 0) {
                d3 = 1;
                while (1) {
                  h = Ud(7, 0, (15 - d3 | 0) * 3 | 0) | 0;
                  if (!((h & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
                    break;
                  }
                  if (d3 >>> 0 < g2 >>> 0) {
                    d3 = d3 + 1 | 0;
                  } else {
                    break b;
                  }
                }
                d3 = Rc(7, 0, f2, ((f2 | 0) < 0) << 31 >> 31) | 0;
                f2 = H() | 0;
                break a;
              }
            } while (0);
            d3 = Rc(7, 0, f2, ((f2 | 0) < 0) << 31 >> 31) | 0;
            d3 = Pd(d3 | 0, H() | 0, 5, 0) | 0;
            d3 = Jd(d3 | 0, H() | 0, -5, -1) | 0;
            d3 = Nd(d3 | 0, H() | 0, 6, 0) | 0;
            d3 = Jd(d3 | 0, H() | 0, 1, 0) | 0;
            f2 = H() | 0;
          }
        } while (0);
        h = e3;
        b3[h >> 2] = d3;
        b3[h + 4 >> 2] = f2;
        h = 0;
        return h | 0;
      }
      function Kb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        e3 = Td(a4 | 0, b4 | 0, 45) | 0;
        H() | 0;
        if (!(oa(e3 & 127) | 0)) {
          e3 = 0;
          return e3 | 0;
        }
        e3 = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        a: do {
          if (!e3) {
            c3 = 0;
          } else {
            d3 = 1;
            while (1) {
              c3 = Td(a4 | 0, b4 | 0, (15 - d3 | 0) * 3 | 0) | 0;
              H() | 0;
              c3 = c3 & 7;
              if (c3 | 0) {
                break a;
              }
              if (d3 >>> 0 < e3 >>> 0) {
                d3 = d3 + 1 | 0;
              } else {
                c3 = 0;
                break;
              }
            }
          }
        } while (0);
        e3 = (c3 | 0) == 0 & 1;
        return e3 | 0;
      }
      function Lb(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        h = T;
        T = T + 16 | 0;
        g2 = h;
        ic(g2, a4, c3, d3);
        c3 = g2;
        a4 = b3[c3 >> 2] | 0;
        c3 = b3[c3 + 4 >> 2] | 0;
        if ((a4 | 0) == 0 & (c3 | 0) == 0) {
          T = h;
          return 0;
        }
        f2 = 0;
        d3 = 0;
        do {
          i = e3 + (f2 << 3) | 0;
          b3[i >> 2] = a4;
          b3[i + 4 >> 2] = c3;
          f2 = Jd(f2 | 0, d3 | 0, 1, 0) | 0;
          d3 = H() | 0;
          kc(g2);
          i = g2;
          a4 = b3[i >> 2] | 0;
          c3 = b3[i + 4 >> 2] | 0;
        } while (!((a4 | 0) == 0 & (c3 | 0) == 0));
        T = h;
        return 0;
      }
      function Mb(a4, b4, c3, d3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        if ((d3 | 0) < (c3 | 0)) {
          c3 = b4;
          d3 = a4;
          G2(c3 | 0);
          return d3 | 0;
        }
        c3 = Ud(-1, -1, ((d3 - c3 | 0) * 3 | 0) + 3 | 0) | 0;
        d3 = Ud(~c3 | 0, ~(H() | 0) | 0, (15 - d3 | 0) * 3 | 0) | 0;
        c3 = ~(H() | 0) & b4;
        d3 = ~d3 & a4;
        G2(c3 | 0);
        return d3 | 0;
      }
      function Nb(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0;
        f2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        if (!((d3 | 0) < 16 & (f2 | 0) <= (d3 | 0))) {
          e3 = 4;
          return e3 | 0;
        }
        if ((f2 | 0) < (d3 | 0)) {
          f2 = Ud(-1, -1, ((d3 + -1 - f2 | 0) * 3 | 0) + 3 | 0) | 0;
          f2 = Ud(~f2 | 0, ~(H() | 0) | 0, (15 - d3 | 0) * 3 | 0) | 0;
          c3 = ~(H() | 0) & c3;
          a4 = ~f2 & a4;
        }
        f2 = Ud(d3 | 0, 0, 52) | 0;
        d3 = c3 & -15728641 | (H() | 0);
        b3[e3 >> 2] = a4 | f2;
        b3[e3 + 4 >> 2] = d3;
        e3 = 0;
        return e3 | 0;
      }
      function Ob(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0;
        if ((d3 | 0) == 0 & (e3 | 0) == 0) {
          E3 = 0;
          return E3 | 0;
        }
        f2 = a4;
        g2 = b3[f2 >> 2] | 0;
        f2 = b3[f2 + 4 >> 2] | 0;
        if (true & (f2 & 15728640 | 0) == 0) {
          if (!((e3 | 0) > 0 | (e3 | 0) == 0 & d3 >>> 0 > 0)) {
            E3 = 0;
            return E3 | 0;
          }
          E3 = c3;
          b3[E3 >> 2] = g2;
          b3[E3 + 4 >> 2] = f2;
          if ((d3 | 0) == 1 & (e3 | 0) == 0) {
            E3 = 0;
            return E3 | 0;
          }
          f2 = 1;
          g2 = 0;
          do {
            C3 = a4 + (f2 << 3) | 0;
            D3 = b3[C3 + 4 >> 2] | 0;
            E3 = c3 + (f2 << 3) | 0;
            b3[E3 >> 2] = b3[C3 >> 2];
            b3[E3 + 4 >> 2] = D3;
            f2 = Jd(f2 | 0, g2 | 0, 1, 0) | 0;
            g2 = H() | 0;
          } while ((g2 | 0) < (e3 | 0) | (g2 | 0) == (e3 | 0) & f2 >>> 0 < d3 >>> 0);
          f2 = 0;
          return f2 | 0;
        }
        B3 = d3 << 3;
        D3 = Gd(B3) | 0;
        if (!D3) {
          E3 = 13;
          return E3 | 0;
        }
        Zd(D3 | 0, a4 | 0, B3 | 0) | 0;
        C3 = Id(d3, 8) | 0;
        if (!C3) {
          Hd(D3);
          E3 = 13;
          return E3 | 0;
        }
        a: while (1) {
          f2 = D3;
          k = b3[f2 >> 2] | 0;
          f2 = b3[f2 + 4 >> 2] | 0;
          z2 = Td(k | 0, f2 | 0, 52) | 0;
          H() | 0;
          z2 = z2 & 15;
          A3 = z2 + -1 | 0;
          y2 = (z2 | 0) != 0;
          x2 = (e3 | 0) > 0 | (e3 | 0) == 0 & d3 >>> 0 > 0;
          b: do {
            if (y2 & x2) {
              t2 = Ud(A3 | 0, 0, 52) | 0;
              u3 = H() | 0;
              if (A3 >>> 0 > 15) {
                if (!((k | 0) == 0 & (f2 | 0) == 0)) {
                  E3 = 16;
                  break a;
                }
                g2 = 0;
                a4 = 0;
                while (1) {
                  g2 = Jd(g2 | 0, a4 | 0, 1, 0) | 0;
                  a4 = H() | 0;
                  if (!((a4 | 0) < (e3 | 0) | (a4 | 0) == (e3 | 0) & g2 >>> 0 < d3 >>> 0)) {
                    break b;
                  }
                  h = D3 + (g2 << 3) | 0;
                  w3 = b3[h >> 2] | 0;
                  h = b3[h + 4 >> 2] | 0;
                  if (!((w3 | 0) == 0 & (h | 0) == 0)) {
                    f2 = h;
                    E3 = 16;
                    break a;
                  }
                }
              }
              i = k;
              a4 = f2;
              g2 = 0;
              h = 0;
              while (1) {
                if (!((i | 0) == 0 & (a4 | 0) == 0)) {
                  if (!(true & (a4 & 117440512 | 0) == 0)) {
                    E3 = 21;
                    break a;
                  }
                  l = Td(i | 0, a4 | 0, 52) | 0;
                  H() | 0;
                  l = l & 15;
                  if ((l | 0) < (A3 | 0)) {
                    f2 = 12;
                    E3 = 27;
                    break a;
                  }
                  if ((l | 0) != (A3 | 0)) {
                    i = i | t2;
                    a4 = a4 & -15728641 | u3;
                    if (l >>> 0 >= z2 >>> 0) {
                      j = A3;
                      do {
                        w3 = Ud(7, 0, (14 - j | 0) * 3 | 0) | 0;
                        j = j + 1 | 0;
                        i = w3 | i;
                        a4 = H() | 0 | a4;
                      } while (j >>> 0 < l >>> 0);
                    }
                  }
                  n = Rd(i | 0, a4 | 0, d3 | 0, e3 | 0) | 0;
                  o = H() | 0;
                  j = C3 + (n << 3) | 0;
                  l = j;
                  m = b3[l >> 2] | 0;
                  l = b3[l + 4 >> 2] | 0;
                  if (!((m | 0) == 0 & (l | 0) == 0)) {
                    r2 = 0;
                    s2 = 0;
                    do {
                      if ((r2 | 0) > (e3 | 0) | (r2 | 0) == (e3 | 0) & s2 >>> 0 > d3 >>> 0) {
                        E3 = 31;
                        break a;
                      }
                      if ((m | 0) == (i | 0) & (l & -117440513 | 0) == (a4 | 0)) {
                        p2 = Td(m | 0, l | 0, 56) | 0;
                        H() | 0;
                        p2 = p2 & 7;
                        q2 = p2 + 1 | 0;
                        w3 = Td(m | 0, l | 0, 45) | 0;
                        H() | 0;
                        c: do {
                          if (!(oa(w3 & 127) | 0)) {
                            l = 7;
                          } else {
                            m = Td(m | 0, l | 0, 52) | 0;
                            H() | 0;
                            m = m & 15;
                            if (!m) {
                              l = 6;
                              break;
                            }
                            l = 1;
                            while (1) {
                              w3 = Ud(7, 0, (15 - l | 0) * 3 | 0) | 0;
                              if (!((w3 & i | 0) == 0 & ((H() | 0) & a4 | 0) == 0)) {
                                l = 7;
                                break c;
                              }
                              if (l >>> 0 < m >>> 0) {
                                l = l + 1 | 0;
                              } else {
                                l = 6;
                                break;
                              }
                            }
                          }
                        } while (0);
                        if ((p2 + 2 | 0) >>> 0 > l >>> 0) {
                          E3 = 41;
                          break a;
                        }
                        w3 = Ud(q2 | 0, 0, 56) | 0;
                        a4 = H() | 0 | a4 & -117440513;
                        v3 = j;
                        b3[v3 >> 2] = 0;
                        b3[v3 + 4 >> 2] = 0;
                        i = w3 | i;
                      } else {
                        n = Jd(n | 0, o | 0, 1, 0) | 0;
                        n = Qd(n | 0, H() | 0, d3 | 0, e3 | 0) | 0;
                        o = H() | 0;
                      }
                      s2 = Jd(s2 | 0, r2 | 0, 1, 0) | 0;
                      r2 = H() | 0;
                      j = C3 + (n << 3) | 0;
                      l = j;
                      m = b3[l >> 2] | 0;
                      l = b3[l + 4 >> 2] | 0;
                    } while (!((m | 0) == 0 & (l | 0) == 0));
                  }
                  w3 = j;
                  b3[w3 >> 2] = i;
                  b3[w3 + 4 >> 2] = a4;
                }
                g2 = Jd(g2 | 0, h | 0, 1, 0) | 0;
                h = H() | 0;
                if (!((h | 0) < (e3 | 0) | (h | 0) == (e3 | 0) & g2 >>> 0 < d3 >>> 0)) {
                  break b;
                }
                a4 = D3 + (g2 << 3) | 0;
                i = b3[a4 >> 2] | 0;
                a4 = b3[a4 + 4 >> 2] | 0;
              }
            }
          } while (0);
          w3 = Jd(d3 | 0, e3 | 0, 5, 0) | 0;
          v3 = H() | 0;
          if (v3 >>> 0 < 0 | (v3 | 0) == 0 & w3 >>> 0 < 11) {
            E3 = 85;
            break;
          }
          w3 = Nd(d3 | 0, e3 | 0, 6, 0) | 0;
          H() | 0;
          w3 = Id(w3, 8) | 0;
          if (!w3) {
            E3 = 48;
            break;
          }
          do {
            if (x2) {
              q2 = 0;
              a4 = 0;
              p2 = 0;
              r2 = 0;
              while (1) {
                l = C3 + (q2 << 3) | 0;
                h = l;
                g2 = b3[h >> 2] | 0;
                h = b3[h + 4 >> 2] | 0;
                if (!((g2 | 0) == 0 & (h | 0) == 0)) {
                  m = Td(g2 | 0, h | 0, 56) | 0;
                  H() | 0;
                  m = m & 7;
                  i = m + 1 | 0;
                  n = h & -117440513;
                  v3 = Td(g2 | 0, h | 0, 45) | 0;
                  H() | 0;
                  d: do {
                    if (oa(v3 & 127) | 0) {
                      o = Td(g2 | 0, h | 0, 52) | 0;
                      H() | 0;
                      o = o & 15;
                      if (o | 0) {
                        j = 1;
                        while (1) {
                          v3 = Ud(7, 0, (15 - j | 0) * 3 | 0) | 0;
                          if (!((g2 & v3 | 0) == 0 & (n & (H() | 0) | 0) == 0)) {
                            break d;
                          }
                          if (j >>> 0 < o >>> 0) {
                            j = j + 1 | 0;
                          } else {
                            break;
                          }
                        }
                      }
                      h = Ud(i | 0, 0, 56) | 0;
                      g2 = h | g2;
                      h = H() | 0 | n;
                      i = l;
                      b3[i >> 2] = g2;
                      b3[i + 4 >> 2] = h;
                      i = m + 2 | 0;
                    }
                  } while (0);
                  if ((i | 0) == 7) {
                    v3 = w3 + (a4 << 3) | 0;
                    b3[v3 >> 2] = g2;
                    b3[v3 + 4 >> 2] = h & -117440513;
                    a4 = Jd(a4 | 0, p2 | 0, 1, 0) | 0;
                    v3 = H() | 0;
                  } else {
                    v3 = p2;
                  }
                } else {
                  v3 = p2;
                }
                q2 = Jd(q2 | 0, r2 | 0, 1, 0) | 0;
                r2 = H() | 0;
                if (!((r2 | 0) < (e3 | 0) | (r2 | 0) == (e3 | 0) & q2 >>> 0 < d3 >>> 0)) {
                  break;
                } else {
                  p2 = v3;
                }
              }
              if (x2) {
                s2 = A3 >>> 0 > 15;
                t2 = Ud(A3 | 0, 0, 52) | 0;
                u3 = H() | 0;
                if (!y2) {
                  g2 = 0;
                  j = 0;
                  i = 0;
                  h = 0;
                  while (1) {
                    if (!((k | 0) == 0 & (f2 | 0) == 0)) {
                      A3 = c3 + (g2 << 3) | 0;
                      b3[A3 >> 2] = k;
                      b3[A3 + 4 >> 2] = f2;
                      g2 = Jd(g2 | 0, j | 0, 1, 0) | 0;
                      j = H() | 0;
                    }
                    i = Jd(i | 0, h | 0, 1, 0) | 0;
                    h = H() | 0;
                    if (!((h | 0) < (e3 | 0) | (h | 0) == (e3 | 0) & i >>> 0 < d3 >>> 0)) {
                      break;
                    }
                    f2 = D3 + (i << 3) | 0;
                    k = b3[f2 >> 2] | 0;
                    f2 = b3[f2 + 4 >> 2] | 0;
                  }
                  f2 = v3;
                  break;
                }
                g2 = 0;
                j = 0;
                h = 0;
                i = 0;
                while (1) {
                  do {
                    if (!((k | 0) == 0 & (f2 | 0) == 0)) {
                      o = Td(k | 0, f2 | 0, 52) | 0;
                      H() | 0;
                      o = o & 15;
                      if (s2 | (o | 0) < (A3 | 0)) {
                        E3 = 80;
                        break a;
                      }
                      if ((o | 0) != (A3 | 0)) {
                        l = k | t2;
                        m = f2 & -15728641 | u3;
                        if (o >>> 0 >= z2 >>> 0) {
                          n = A3;
                          do {
                            y2 = Ud(7, 0, (14 - n | 0) * 3 | 0) | 0;
                            n = n + 1 | 0;
                            l = y2 | l;
                            m = H() | 0 | m;
                          } while (n >>> 0 < o >>> 0);
                        }
                      } else {
                        l = k;
                        m = f2;
                      }
                      p2 = Rd(l | 0, m | 0, d3 | 0, e3 | 0) | 0;
                      n = 0;
                      o = 0;
                      r2 = H() | 0;
                      do {
                        if ((n | 0) > (e3 | 0) | (n | 0) == (e3 | 0) & o >>> 0 > d3 >>> 0) {
                          E3 = 81;
                          break a;
                        }
                        y2 = C3 + (p2 << 3) | 0;
                        q2 = b3[y2 + 4 >> 2] | 0;
                        if ((q2 & -117440513 | 0) == (m | 0) ? (b3[y2 >> 2] | 0) == (l | 0) : 0) {
                          E3 = 65;
                          break;
                        }
                        y2 = Jd(p2 | 0, r2 | 0, 1, 0) | 0;
                        p2 = Qd(y2 | 0, H() | 0, d3 | 0, e3 | 0) | 0;
                        r2 = H() | 0;
                        o = Jd(o | 0, n | 0, 1, 0) | 0;
                        n = H() | 0;
                        y2 = C3 + (p2 << 3) | 0;
                      } while (!((b3[y2 >> 2] | 0) == (l | 0) ? (b3[y2 + 4 >> 2] | 0) == (m | 0) : 0));
                      if ((E3 | 0) == 65 ? (E3 = 0, true & (q2 & 117440512 | 0) == 100663296) : 0) {
                        break;
                      }
                      y2 = c3 + (g2 << 3) | 0;
                      b3[y2 >> 2] = k;
                      b3[y2 + 4 >> 2] = f2;
                      g2 = Jd(g2 | 0, j | 0, 1, 0) | 0;
                      j = H() | 0;
                    }
                  } while (0);
                  h = Jd(h | 0, i | 0, 1, 0) | 0;
                  i = H() | 0;
                  if (!((i | 0) < (e3 | 0) | (i | 0) == (e3 | 0) & h >>> 0 < d3 >>> 0)) {
                    break;
                  }
                  f2 = D3 + (h << 3) | 0;
                  k = b3[f2 >> 2] | 0;
                  f2 = b3[f2 + 4 >> 2] | 0;
                }
                f2 = v3;
              } else {
                g2 = 0;
                f2 = v3;
              }
            } else {
              g2 = 0;
              a4 = 0;
              f2 = 0;
            }
          } while (0);
          _d(C3 | 0, 0, B3 | 0) | 0;
          Zd(D3 | 0, w3 | 0, a4 << 3 | 0) | 0;
          Hd(w3);
          if ((a4 | 0) == 0 & (f2 | 0) == 0) {
            E3 = 89;
            break;
          } else {
            c3 = c3 + (g2 << 3) | 0;
            e3 = f2;
            d3 = a4;
          }
        }
        if ((E3 | 0) == 16) {
          if (true & (f2 & 117440512 | 0) == 0) {
            f2 = 4;
            E3 = 27;
          } else {
            E3 = 21;
          }
        } else if ((E3 | 0) == 31) {
          I(27795, 27122, 620, 27132);
        } else if ((E3 | 0) == 41) {
          Hd(D3);
          Hd(C3);
          E3 = 10;
          return E3 | 0;
        } else if ((E3 | 0) == 48) {
          Hd(D3);
          Hd(C3);
          E3 = 13;
          return E3 | 0;
        } else if ((E3 | 0) == 80) {
          I(27795, 27122, 711, 27132);
        } else if ((E3 | 0) == 81) {
          I(27795, 27122, 723, 27132);
        } else if ((E3 | 0) == 85) {
          Zd(c3 | 0, D3 | 0, d3 << 3 | 0) | 0;
          E3 = 89;
        }
        if ((E3 | 0) == 21) {
          Hd(D3);
          Hd(C3);
          E3 = 5;
          return E3 | 0;
        } else if ((E3 | 0) == 27) {
          Hd(D3);
          Hd(C3);
          E3 = f2;
          return E3 | 0;
        } else if ((E3 | 0) == 89) {
          Hd(D3);
          Hd(C3);
          E3 = 0;
          return E3 | 0;
        }
        return 0;
      }
      function Pb(a4, c3, d3, e3, f2, g2, h) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h = h | 0;
        var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0;
        q2 = T;
        T = T + 16 | 0;
        p2 = q2;
        if (!((d3 | 0) > 0 | (d3 | 0) == 0 & c3 >>> 0 > 0)) {
          p2 = 0;
          T = q2;
          return p2 | 0;
        }
        if ((h | 0) >= 16) {
          p2 = 12;
          T = q2;
          return p2 | 0;
        }
        n = 0;
        o = 0;
        m = 0;
        i = 0;
        a: while (1) {
          k = a4 + (n << 3) | 0;
          j = b3[k >> 2] | 0;
          k = b3[k + 4 >> 2] | 0;
          l = Td(j | 0, k | 0, 52) | 0;
          H() | 0;
          if ((l & 15 | 0) > (h | 0)) {
            i = 12;
            j = 11;
            break;
          }
          ic(p2, j, k, h);
          l = p2;
          k = b3[l >> 2] | 0;
          l = b3[l + 4 >> 2] | 0;
          if ((k | 0) == 0 & (l | 0) == 0) {
            j = m;
          } else {
            j = m;
            do {
              if (!((i | 0) < (g2 | 0) | (i | 0) == (g2 | 0) & j >>> 0 < f2 >>> 0)) {
                j = 10;
                break a;
              }
              m = e3 + (j << 3) | 0;
              b3[m >> 2] = k;
              b3[m + 4 >> 2] = l;
              j = Jd(j | 0, i | 0, 1, 0) | 0;
              i = H() | 0;
              kc(p2);
              m = p2;
              k = b3[m >> 2] | 0;
              l = b3[m + 4 >> 2] | 0;
            } while (!((k | 0) == 0 & (l | 0) == 0));
          }
          n = Jd(n | 0, o | 0, 1, 0) | 0;
          o = H() | 0;
          if (!((o | 0) < (d3 | 0) | (o | 0) == (d3 | 0) & n >>> 0 < c3 >>> 0)) {
            i = 0;
            j = 11;
            break;
          } else {
            m = j;
          }
        }
        if ((j | 0) == 10) {
          p2 = 14;
          T = q2;
          return p2 | 0;
        } else if ((j | 0) == 11) {
          T = q2;
          return i | 0;
        }
        return 0;
      }
      function Qb(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        n = T;
        T = T + 16 | 0;
        m = n;
        a: do {
          if ((d3 | 0) > 0 | (d3 | 0) == 0 & c3 >>> 0 > 0) {
            k = 0;
            h = 0;
            g2 = 0;
            l = 0;
            while (1) {
              j = a4 + (k << 3) | 0;
              i = b3[j >> 2] | 0;
              j = b3[j + 4 >> 2] | 0;
              if (!((i | 0) == 0 & (j | 0) == 0)) {
                j = (Jb(i, j, e3, m) | 0) == 0;
                i = m;
                h = Jd(b3[i >> 2] | 0, b3[i + 4 >> 2] | 0, h | 0, g2 | 0) | 0;
                g2 = H() | 0;
                if (!j) {
                  g2 = 12;
                  break;
                }
              }
              k = Jd(k | 0, l | 0, 1, 0) | 0;
              l = H() | 0;
              if (!((l | 0) < (d3 | 0) | (l | 0) == (d3 | 0) & k >>> 0 < c3 >>> 0)) {
                break a;
              }
            }
            T = n;
            return g2 | 0;
          } else {
            h = 0;
            g2 = 0;
          }
        } while (0);
        b3[f2 >> 2] = h;
        b3[f2 + 4 >> 2] = g2;
        f2 = 0;
        T = n;
        return f2 | 0;
      }
      function Rb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        b4 = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        return b4 & 1 | 0;
      }
      function Sb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        e3 = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        if (!e3) {
          e3 = 0;
          return e3 | 0;
        }
        d3 = 1;
        while (1) {
          c3 = Td(a4 | 0, b4 | 0, (15 - d3 | 0) * 3 | 0) | 0;
          H() | 0;
          c3 = c3 & 7;
          if (c3 | 0) {
            d3 = 5;
            break;
          }
          if (d3 >>> 0 < e3 >>> 0) {
            d3 = d3 + 1 | 0;
          } else {
            c3 = 0;
            d3 = 5;
            break;
          }
        }
        if ((d3 | 0) == 5) {
          return c3 | 0;
        }
        return 0;
      }
      function Tb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        i = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        if (!i) {
          h = b4;
          i = a4;
          G2(h | 0);
          return i | 0;
        }
        h = 1;
        c3 = 0;
        while (1) {
          f2 = (15 - h | 0) * 3 | 0;
          d3 = Ud(7, 0, f2 | 0) | 0;
          e3 = H() | 0;
          g2 = Td(a4 | 0, b4 | 0, f2 | 0) | 0;
          H() | 0;
          f2 = Ud($a(g2 & 7) | 0, 0, f2 | 0) | 0;
          g2 = H() | 0;
          a4 = f2 | a4 & ~d3;
          b4 = g2 | b4 & ~e3;
          a: do {
            if (!c3) {
              if (!((f2 & d3 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                d3 = Td(a4 | 0, b4 | 0, 52) | 0;
                H() | 0;
                d3 = d3 & 15;
                if (!d3) {
                  c3 = 1;
                } else {
                  c3 = 1;
                  b: while (1) {
                    g2 = Td(a4 | 0, b4 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                    H() | 0;
                    switch (g2 & 7) {
                      case 1:
                        break b;
                      case 0:
                        break;
                      default: {
                        c3 = 1;
                        break a;
                      }
                    }
                    if (c3 >>> 0 < d3 >>> 0) {
                      c3 = c3 + 1 | 0;
                    } else {
                      c3 = 1;
                      break a;
                    }
                  }
                  c3 = 1;
                  while (1) {
                    g2 = (15 - c3 | 0) * 3 | 0;
                    e3 = Td(a4 | 0, b4 | 0, g2 | 0) | 0;
                    H() | 0;
                    f2 = Ud(7, 0, g2 | 0) | 0;
                    b4 = b4 & ~(H() | 0);
                    g2 = Ud($a(e3 & 7) | 0, 0, g2 | 0) | 0;
                    a4 = a4 & ~f2 | g2;
                    b4 = b4 | (H() | 0);
                    if (c3 >>> 0 < d3 >>> 0) {
                      c3 = c3 + 1 | 0;
                    } else {
                      c3 = 1;
                      break;
                    }
                  }
                }
              } else {
                c3 = 0;
              }
            }
          } while (0);
          if (h >>> 0 < i >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        G2(b4 | 0);
        return a4 | 0;
      }
      function Ub(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0;
        d3 = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        d3 = d3 & 15;
        if (!d3) {
          c3 = b4;
          d3 = a4;
          G2(c3 | 0);
          return d3 | 0;
        }
        c3 = 1;
        while (1) {
          f2 = (15 - c3 | 0) * 3 | 0;
          g2 = Td(a4 | 0, b4 | 0, f2 | 0) | 0;
          H() | 0;
          e3 = Ud(7, 0, f2 | 0) | 0;
          b4 = b4 & ~(H() | 0);
          f2 = Ud($a(g2 & 7) | 0, 0, f2 | 0) | 0;
          a4 = f2 | a4 & ~e3;
          b4 = H() | 0 | b4;
          if (c3 >>> 0 < d3 >>> 0) {
            c3 = c3 + 1 | 0;
          } else {
            break;
          }
        }
        G2(b4 | 0);
        return a4 | 0;
      }
      function Vb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        i = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        if (!i) {
          h = b4;
          i = a4;
          G2(h | 0);
          return i | 0;
        }
        h = 1;
        c3 = 0;
        while (1) {
          f2 = (15 - h | 0) * 3 | 0;
          d3 = Ud(7, 0, f2 | 0) | 0;
          e3 = H() | 0;
          g2 = Td(a4 | 0, b4 | 0, f2 | 0) | 0;
          H() | 0;
          f2 = Ud(ab(g2 & 7) | 0, 0, f2 | 0) | 0;
          g2 = H() | 0;
          a4 = f2 | a4 & ~d3;
          b4 = g2 | b4 & ~e3;
          a: do {
            if (!c3) {
              if (!((f2 & d3 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                d3 = Td(a4 | 0, b4 | 0, 52) | 0;
                H() | 0;
                d3 = d3 & 15;
                if (!d3) {
                  c3 = 1;
                } else {
                  c3 = 1;
                  b: while (1) {
                    g2 = Td(a4 | 0, b4 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                    H() | 0;
                    switch (g2 & 7) {
                      case 1:
                        break b;
                      case 0:
                        break;
                      default: {
                        c3 = 1;
                        break a;
                      }
                    }
                    if (c3 >>> 0 < d3 >>> 0) {
                      c3 = c3 + 1 | 0;
                    } else {
                      c3 = 1;
                      break a;
                    }
                  }
                  c3 = 1;
                  while (1) {
                    e3 = (15 - c3 | 0) * 3 | 0;
                    f2 = Ud(7, 0, e3 | 0) | 0;
                    g2 = b4 & ~(H() | 0);
                    b4 = Td(a4 | 0, b4 | 0, e3 | 0) | 0;
                    H() | 0;
                    b4 = Ud(ab(b4 & 7) | 0, 0, e3 | 0) | 0;
                    a4 = a4 & ~f2 | b4;
                    b4 = g2 | (H() | 0);
                    if (c3 >>> 0 < d3 >>> 0) {
                      c3 = c3 + 1 | 0;
                    } else {
                      c3 = 1;
                      break;
                    }
                  }
                }
              } else {
                c3 = 0;
              }
            }
          } while (0);
          if (h >>> 0 < i >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        G2(b4 | 0);
        return a4 | 0;
      }
      function Wb(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0;
        d3 = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        d3 = d3 & 15;
        if (!d3) {
          c3 = b4;
          d3 = a4;
          G2(c3 | 0);
          return d3 | 0;
        }
        c3 = 1;
        while (1) {
          g2 = (15 - c3 | 0) * 3 | 0;
          f2 = Ud(7, 0, g2 | 0) | 0;
          e3 = b4 & ~(H() | 0);
          b4 = Td(a4 | 0, b4 | 0, g2 | 0) | 0;
          H() | 0;
          b4 = Ud(ab(b4 & 7) | 0, 0, g2 | 0) | 0;
          a4 = b4 | a4 & ~f2;
          b4 = H() | 0 | e3;
          if (c3 >>> 0 < d3 >>> 0) {
            c3 = c3 + 1 | 0;
          } else {
            break;
          }
        }
        G2(b4 | 0);
        return a4 | 0;
      }
      function Xb(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        j = T;
        T = T + 64 | 0;
        i = j + 40 | 0;
        e3 = j + 24 | 0;
        f2 = j + 12 | 0;
        g2 = j;
        Ud(c3 | 0, 0, 52) | 0;
        d3 = H() | 0 | 134225919;
        if (!c3) {
          if ((b3[a4 + 4 >> 2] | 0) > 2) {
            h = 0;
            i = 0;
            G2(h | 0);
            T = j;
            return i | 0;
          }
          if ((b3[a4 + 8 >> 2] | 0) > 2) {
            h = 0;
            i = 0;
            G2(h | 0);
            T = j;
            return i | 0;
          }
          if ((b3[a4 + 12 >> 2] | 0) > 2) {
            h = 0;
            i = 0;
            G2(h | 0);
            T = j;
            return i | 0;
          }
          Ud(qa(a4) | 0, 0, 45) | 0;
          h = H() | 0 | d3;
          i = -1;
          G2(h | 0);
          T = j;
          return i | 0;
        }
        b3[i >> 2] = b3[a4 >> 2];
        b3[i + 4 >> 2] = b3[a4 + 4 >> 2];
        b3[i + 8 >> 2] = b3[a4 + 8 >> 2];
        b3[i + 12 >> 2] = b3[a4 + 12 >> 2];
        h = i + 4 | 0;
        if ((c3 | 0) > 0) {
          a4 = -1;
          while (1) {
            b3[e3 >> 2] = b3[h >> 2];
            b3[e3 + 4 >> 2] = b3[h + 4 >> 2];
            b3[e3 + 8 >> 2] = b3[h + 8 >> 2];
            if (!(c3 & 1)) {
              Va(h);
              b3[f2 >> 2] = b3[h >> 2];
              b3[f2 + 4 >> 2] = b3[h + 4 >> 2];
              b3[f2 + 8 >> 2] = b3[h + 8 >> 2];
              Xa(f2);
            } else {
              Ua(h);
              b3[f2 >> 2] = b3[h >> 2];
              b3[f2 + 4 >> 2] = b3[h + 4 >> 2];
              b3[f2 + 8 >> 2] = b3[h + 8 >> 2];
              Wa(f2);
            }
            Pa(e3, f2, g2);
            Ma(g2);
            l = (15 - c3 | 0) * 3 | 0;
            k = Ud(7, 0, l | 0) | 0;
            d3 = d3 & ~(H() | 0);
            l = Ud(Ra(g2) | 0, 0, l | 0) | 0;
            a4 = l | a4 & ~k;
            d3 = H() | 0 | d3;
            if ((c3 | 0) > 1) {
              c3 = c3 + -1 | 0;
            } else {
              break;
            }
          }
        } else {
          a4 = -1;
        }
        a: do {
          if (((b3[h >> 2] | 0) <= 2 ? (b3[i + 8 >> 2] | 0) <= 2 : 0) ? (b3[i + 12 >> 2] | 0) <= 2 : 0) {
            e3 = qa(i) | 0;
            c3 = Ud(e3 | 0, 0, 45) | 0;
            c3 = c3 | a4;
            a4 = H() | 0 | d3 & -1040385;
            g2 = ra(i) | 0;
            if (!(oa(e3) | 0)) {
              if ((g2 | 0) <= 0) {
                break;
              }
              f2 = 0;
              while (1) {
                e3 = Td(c3 | 0, a4 | 0, 52) | 0;
                H() | 0;
                e3 = e3 & 15;
                if (e3) {
                  d3 = 1;
                  while (1) {
                    l = (15 - d3 | 0) * 3 | 0;
                    i = Td(c3 | 0, a4 | 0, l | 0) | 0;
                    H() | 0;
                    k = Ud(7, 0, l | 0) | 0;
                    a4 = a4 & ~(H() | 0);
                    l = Ud($a(i & 7) | 0, 0, l | 0) | 0;
                    c3 = c3 & ~k | l;
                    a4 = a4 | (H() | 0);
                    if (d3 >>> 0 < e3 >>> 0) {
                      d3 = d3 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                }
                f2 = f2 + 1 | 0;
                if ((f2 | 0) == (g2 | 0)) {
                  break a;
                }
              }
            }
            f2 = Td(c3 | 0, a4 | 0, 52) | 0;
            H() | 0;
            f2 = f2 & 15;
            b: do {
              if (f2) {
                d3 = 1;
                c: while (1) {
                  l = Td(c3 | 0, a4 | 0, (15 - d3 | 0) * 3 | 0) | 0;
                  H() | 0;
                  switch (l & 7) {
                    case 1:
                      break c;
                    case 0:
                      break;
                    default:
                      break b;
                  }
                  if (d3 >>> 0 < f2 >>> 0) {
                    d3 = d3 + 1 | 0;
                  } else {
                    break b;
                  }
                }
                if (ua(e3, b3[i >> 2] | 0) | 0) {
                  d3 = 1;
                  while (1) {
                    i = (15 - d3 | 0) * 3 | 0;
                    k = Ud(7, 0, i | 0) | 0;
                    l = a4 & ~(H() | 0);
                    a4 = Td(c3 | 0, a4 | 0, i | 0) | 0;
                    H() | 0;
                    a4 = Ud(ab(a4 & 7) | 0, 0, i | 0) | 0;
                    c3 = c3 & ~k | a4;
                    a4 = l | (H() | 0);
                    if (d3 >>> 0 < f2 >>> 0) {
                      d3 = d3 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                } else {
                  d3 = 1;
                  while (1) {
                    l = (15 - d3 | 0) * 3 | 0;
                    i = Td(c3 | 0, a4 | 0, l | 0) | 0;
                    H() | 0;
                    k = Ud(7, 0, l | 0) | 0;
                    a4 = a4 & ~(H() | 0);
                    l = Ud($a(i & 7) | 0, 0, l | 0) | 0;
                    c3 = c3 & ~k | l;
                    a4 = a4 | (H() | 0);
                    if (d3 >>> 0 < f2 >>> 0) {
                      d3 = d3 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                }
              }
            } while (0);
            if ((g2 | 0) > 0) {
              d3 = 0;
              do {
                c3 = Tb(c3, a4) | 0;
                a4 = H() | 0;
                d3 = d3 + 1 | 0;
              } while ((d3 | 0) != (g2 | 0));
            }
          } else {
            c3 = 0;
            a4 = 0;
          }
        } while (0);
        k = a4;
        l = c3;
        G2(k | 0);
        T = j;
        return l | 0;
      }
      function Yb(a4) {
        a4 = a4 | 0;
        return (a4 | 0) % 2 | 0 | 0;
      }
      function Zb(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0;
        f2 = T;
        T = T + 16 | 0;
        e3 = f2;
        if (c3 >>> 0 > 15) {
          e3 = 4;
          T = f2;
          return e3 | 0;
        }
        if ((b3[a4 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          e3 = 3;
          T = f2;
          return e3 | 0;
        }
        if ((b3[a4 + 8 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          e3 = 3;
          T = f2;
          return e3 | 0;
        }
        qb(a4, c3, e3);
        c3 = Xb(e3, c3) | 0;
        e3 = H() | 0;
        b3[d3 >> 2] = c3;
        b3[d3 + 4 >> 2] = e3;
        if ((c3 | 0) == 0 & (e3 | 0) == 0) {
          I(27795, 27122, 1050, 27145);
        }
        e3 = 0;
        T = f2;
        return e3 | 0;
      }
      function _b(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        f2 = d3 + 4 | 0;
        g2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        h = Td(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        e3 = (g2 | 0) == 0;
        if (!(oa(h & 127) | 0)) {
          if (e3) {
            h = 0;
            return h | 0;
          }
          if ((b3[f2 >> 2] | 0) == 0 ? (b3[d3 + 8 >> 2] | 0) == 0 : 0) {
            e3 = (b3[d3 + 12 >> 2] | 0) != 0 & 1;
          } else {
            e3 = 1;
          }
        } else if (e3) {
          h = 1;
          return h | 0;
        } else {
          e3 = 1;
        }
        d3 = 1;
        while (1) {
          if (!(d3 & 1)) {
            Xa(f2);
          } else {
            Wa(f2);
          }
          h = Td(a4 | 0, c3 | 0, (15 - d3 | 0) * 3 | 0) | 0;
          H() | 0;
          Ya(f2, h & 7);
          if (d3 >>> 0 < g2 >>> 0) {
            d3 = d3 + 1 | 0;
          } else {
            break;
          }
        }
        return e3 | 0;
      }
      function $b(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        l = T;
        T = T + 16 | 0;
        j = l;
        k = Td(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        k = k & 127;
        if (k >>> 0 > 121) {
          b3[d3 >> 2] = 0;
          b3[d3 + 4 >> 2] = 0;
          b3[d3 + 8 >> 2] = 0;
          b3[d3 + 12 >> 2] = 0;
          k = 5;
          T = l;
          return k | 0;
        }
        a: do {
          if ((oa(k) | 0) != 0 ? (g2 = Td(a4 | 0, c3 | 0, 52) | 0, H() | 0, g2 = g2 & 15, (g2 | 0) != 0) : 0) {
            e3 = 1;
            b: while (1) {
              i = Td(a4 | 0, c3 | 0, (15 - e3 | 0) * 3 | 0) | 0;
              H() | 0;
              switch (i & 7) {
                case 5:
                  break b;
                case 0:
                  break;
                default: {
                  e3 = c3;
                  break a;
                }
              }
              if (e3 >>> 0 < g2 >>> 0) {
                e3 = e3 + 1 | 0;
              } else {
                e3 = c3;
                break a;
              }
            }
            f2 = 1;
            e3 = c3;
            while (1) {
              c3 = (15 - f2 | 0) * 3 | 0;
              h = Ud(7, 0, c3 | 0) | 0;
              i = e3 & ~(H() | 0);
              e3 = Td(a4 | 0, e3 | 0, c3 | 0) | 0;
              H() | 0;
              e3 = Ud(ab(e3 & 7) | 0, 0, c3 | 0) | 0;
              a4 = a4 & ~h | e3;
              e3 = i | (H() | 0);
              if (f2 >>> 0 < g2 >>> 0) {
                f2 = f2 + 1 | 0;
              } else {
                break;
              }
            }
          } else {
            e3 = c3;
          }
        } while (0);
        i = 7696 + (k * 28 | 0) | 0;
        b3[d3 >> 2] = b3[i >> 2];
        b3[d3 + 4 >> 2] = b3[i + 4 >> 2];
        b3[d3 + 8 >> 2] = b3[i + 8 >> 2];
        b3[d3 + 12 >> 2] = b3[i + 12 >> 2];
        if (!(_b(a4, e3, d3) | 0)) {
          k = 0;
          T = l;
          return k | 0;
        }
        h = d3 + 4 | 0;
        b3[j >> 2] = b3[h >> 2];
        b3[j + 4 >> 2] = b3[h + 4 >> 2];
        b3[j + 8 >> 2] = b3[h + 8 >> 2];
        g2 = Td(a4 | 0, e3 | 0, 52) | 0;
        H() | 0;
        i = g2 & 15;
        if (!(g2 & 1)) {
          g2 = i;
        } else {
          Xa(h);
          g2 = i + 1 | 0;
        }
        if (!(oa(k) | 0)) {
          e3 = 0;
        } else {
          c: do {
            if (!i) {
              e3 = 0;
            } else {
              c3 = 1;
              while (1) {
                f2 = Td(a4 | 0, e3 | 0, (15 - c3 | 0) * 3 | 0) | 0;
                H() | 0;
                f2 = f2 & 7;
                if (f2 | 0) {
                  e3 = f2;
                  break c;
                }
                if (c3 >>> 0 < i >>> 0) {
                  c3 = c3 + 1 | 0;
                } else {
                  e3 = 0;
                  break;
                }
              }
            }
          } while (0);
          e3 = (e3 | 0) == 4 & 1;
        }
        if (!(xb(d3, g2, e3, 0) | 0)) {
          if ((g2 | 0) != (i | 0)) {
            b3[h >> 2] = b3[j >> 2];
            b3[h + 4 >> 2] = b3[j + 4 >> 2];
            b3[h + 8 >> 2] = b3[j + 8 >> 2];
          }
        } else {
          if (oa(k) | 0) {
            do {
            } while ((xb(d3, g2, 0, 0) | 0) != 0);
          }
          if ((g2 | 0) != (i | 0)) {
            Va(h);
          }
        }
        k = 0;
        T = l;
        return k | 0;
      }
      function ac(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0;
        f2 = T;
        T = T + 16 | 0;
        d3 = f2;
        e3 = $b(a4, b4, d3) | 0;
        if (e3 | 0) {
          T = f2;
          return e3 | 0;
        }
        e3 = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        ub(d3, e3 & 15, c3);
        e3 = 0;
        T = f2;
        return e3 | 0;
      }
      function bc(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        g2 = T;
        T = T + 16 | 0;
        f2 = g2;
        d3 = $b(a4, b4, f2) | 0;
        if (d3 | 0) {
          f2 = d3;
          T = g2;
          return f2 | 0;
        }
        d3 = Td(a4 | 0, b4 | 0, 45) | 0;
        H() | 0;
        d3 = (oa(d3 & 127) | 0) == 0;
        e3 = Td(a4 | 0, b4 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        a: do {
          if (!d3) {
            if (e3 | 0) {
              d3 = 1;
              while (1) {
                h = Ud(7, 0, (15 - d3 | 0) * 3 | 0) | 0;
                if (!((h & a4 | 0) == 0 & ((H() | 0) & b4 | 0) == 0)) {
                  break a;
                }
                if (d3 >>> 0 < e3 >>> 0) {
                  d3 = d3 + 1 | 0;
                } else {
                  break;
                }
              }
            }
            vb(f2, e3, 0, 5, c3);
            h = 0;
            T = g2;
            return h | 0;
          }
        } while (0);
        zb(f2, e3, 0, 6, c3);
        h = 0;
        T = g2;
        return h | 0;
      }
      function cc(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        f2 = Td(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        if (!(oa(f2 & 127) | 0)) {
          f2 = 2;
          b3[d3 >> 2] = f2;
          return 0;
        }
        f2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        if (!f2) {
          f2 = 5;
          b3[d3 >> 2] = f2;
          return 0;
        }
        e3 = 1;
        while (1) {
          g2 = Ud(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
          if (!((g2 & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
            e3 = 2;
            a4 = 6;
            break;
          }
          if (e3 >>> 0 < f2 >>> 0) {
            e3 = e3 + 1 | 0;
          } else {
            e3 = 5;
            a4 = 6;
            break;
          }
        }
        if ((a4 | 0) == 6) {
          b3[d3 >> 2] = e3;
          return 0;
        }
        return 0;
      }
      function dc(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        m = T;
        T = T + 128 | 0;
        k = m + 112 | 0;
        g2 = m + 96 | 0;
        l = m;
        f2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        i = f2 & 15;
        b3[k >> 2] = i;
        h = Td(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        h = h & 127;
        a: do {
          if (oa(h) | 0) {
            if (i | 0) {
              e3 = 1;
              while (1) {
                j = Ud(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                if (!((j & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
                  f2 = 0;
                  break a;
                }
                if (e3 >>> 0 < i >>> 0) {
                  e3 = e3 + 1 | 0;
                } else {
                  break;
                }
              }
            }
            if (!(f2 & 1)) {
              j = Ud(i + 1 | 0, 0, 52) | 0;
              l = H() | 0 | c3 & -15728641;
              k = Ud(7, 0, (14 - i | 0) * 3 | 0) | 0;
              l = dc((j | a4) & ~k, l & ~(H() | 0), d3) | 0;
              T = m;
              return l | 0;
            } else {
              f2 = 1;
            }
          } else {
            f2 = 0;
          }
        } while (0);
        e3 = $b(a4, c3, g2) | 0;
        if (!e3) {
          if (f2) {
            wb(g2, k, l);
            j = 5;
          } else {
            Ab(g2, k, l);
            j = 6;
          }
          b: do {
            if (oa(h) | 0) {
              if (!i) {
                a4 = 5;
              } else {
                e3 = 1;
                while (1) {
                  h = Ud(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                  if (!((h & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0)) {
                    a4 = 2;
                    break b;
                  }
                  if (e3 >>> 0 < i >>> 0) {
                    e3 = e3 + 1 | 0;
                  } else {
                    a4 = 5;
                    break;
                  }
                }
              }
            } else {
              a4 = 2;
            }
          } while (0);
          _d(d3 | 0, -1, a4 << 2 | 0) | 0;
          c: do {
            if (f2) {
              g2 = 0;
              while (1) {
                h = l + (g2 << 4) | 0;
                yb(h, b3[k >> 2] | 0) | 0;
                h = b3[h >> 2] | 0;
                i = b3[d3 >> 2] | 0;
                if ((i | 0) == -1 | (i | 0) == (h | 0)) {
                  e3 = d3;
                } else {
                  f2 = 0;
                  do {
                    f2 = f2 + 1 | 0;
                    if (f2 >>> 0 >= a4 >>> 0) {
                      e3 = 1;
                      break c;
                    }
                    e3 = d3 + (f2 << 2) | 0;
                    i = b3[e3 >> 2] | 0;
                  } while (!((i | 0) == -1 | (i | 0) == (h | 0)));
                }
                b3[e3 >> 2] = h;
                g2 = g2 + 1 | 0;
                if (g2 >>> 0 >= j >>> 0) {
                  e3 = 0;
                  break;
                }
              }
            } else {
              g2 = 0;
              while (1) {
                h = l + (g2 << 4) | 0;
                xb(h, b3[k >> 2] | 0, 0, 1) | 0;
                h = b3[h >> 2] | 0;
                i = b3[d3 >> 2] | 0;
                if ((i | 0) == -1 | (i | 0) == (h | 0)) {
                  e3 = d3;
                } else {
                  f2 = 0;
                  do {
                    f2 = f2 + 1 | 0;
                    if (f2 >>> 0 >= a4 >>> 0) {
                      e3 = 1;
                      break c;
                    }
                    e3 = d3 + (f2 << 2) | 0;
                    i = b3[e3 >> 2] | 0;
                  } while (!((i | 0) == -1 | (i | 0) == (h | 0)));
                }
                b3[e3 >> 2] = h;
                g2 = g2 + 1 | 0;
                if (g2 >>> 0 >= j >>> 0) {
                  e3 = 0;
                  break;
                }
              }
            }
          } while (0);
        }
        l = e3;
        T = m;
        return l | 0;
      }
      function ec() {
        return 12;
      }
      function fc(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        if (a4 >>> 0 > 15) {
          i = 4;
          return i | 0;
        }
        Ud(a4 | 0, 0, 52) | 0;
        i = H() | 0 | 134225919;
        if (!a4) {
          d3 = 0;
          e3 = 0;
          do {
            if (oa(e3) | 0) {
              Ud(e3 | 0, 0, 45) | 0;
              h = i | (H() | 0);
              a4 = c3 + (d3 << 3) | 0;
              b3[a4 >> 2] = -1;
              b3[a4 + 4 >> 2] = h;
              d3 = d3 + 1 | 0;
            }
            e3 = e3 + 1 | 0;
          } while ((e3 | 0) != 122);
          d3 = 0;
          return d3 | 0;
        }
        d3 = 0;
        h = 0;
        do {
          if (oa(h) | 0) {
            Ud(h | 0, 0, 45) | 0;
            e3 = 1;
            f2 = -1;
            g2 = i | (H() | 0);
            while (1) {
              j = Ud(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
              f2 = f2 & ~j;
              g2 = g2 & ~(H() | 0);
              if ((e3 | 0) == (a4 | 0)) {
                break;
              } else {
                e3 = e3 + 1 | 0;
              }
            }
            j = c3 + (d3 << 3) | 0;
            b3[j >> 2] = f2;
            b3[j + 4 >> 2] = g2;
            d3 = d3 + 1 | 0;
          }
          h = h + 1 | 0;
        } while ((h | 0) != 122);
        d3 = 0;
        return d3 | 0;
      }
      function gc(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0;
        t2 = T;
        T = T + 16 | 0;
        r2 = t2;
        s2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        s2 = s2 & 15;
        if (d3 >>> 0 > 15) {
          s2 = 4;
          T = t2;
          return s2 | 0;
        }
        if ((s2 | 0) < (d3 | 0)) {
          s2 = 12;
          T = t2;
          return s2 | 0;
        }
        if ((s2 | 0) != (d3 | 0)) {
          g2 = Ud(d3 | 0, 0, 52) | 0;
          g2 = g2 | a4;
          i = H() | 0 | c3 & -15728641;
          if ((s2 | 0) > (d3 | 0)) {
            j = d3;
            do {
              q2 = Ud(7, 0, (14 - j | 0) * 3 | 0) | 0;
              j = j + 1 | 0;
              g2 = q2 | g2;
              i = H() | 0 | i;
            } while ((j | 0) < (s2 | 0));
            q2 = g2;
          } else {
            q2 = g2;
          }
        } else {
          q2 = a4;
          i = c3;
        }
        p2 = Td(q2 | 0, i | 0, 45) | 0;
        H() | 0;
        a: do {
          if (oa(p2 & 127) | 0) {
            j = Td(q2 | 0, i | 0, 52) | 0;
            H() | 0;
            j = j & 15;
            if (j | 0) {
              g2 = 1;
              while (1) {
                p2 = Ud(7, 0, (15 - g2 | 0) * 3 | 0) | 0;
                if (!((p2 & q2 | 0) == 0 & ((H() | 0) & i | 0) == 0)) {
                  k = 33;
                  break a;
                }
                if (g2 >>> 0 < j >>> 0) {
                  g2 = g2 + 1 | 0;
                } else {
                  break;
                }
              }
            }
            p2 = e3;
            b3[p2 >> 2] = 0;
            b3[p2 + 4 >> 2] = 0;
            if ((s2 | 0) > (d3 | 0)) {
              p2 = c3 & -15728641;
              o = s2;
              while (1) {
                n = o;
                o = o + -1 | 0;
                if (o >>> 0 > 15 | (s2 | 0) < (o | 0)) {
                  k = 19;
                  break;
                }
                if ((s2 | 0) != (o | 0)) {
                  g2 = Ud(o | 0, 0, 52) | 0;
                  g2 = g2 | a4;
                  j = H() | 0 | p2;
                  if ((s2 | 0) < (n | 0)) {
                    m = g2;
                  } else {
                    k = o;
                    do {
                      m = Ud(7, 0, (14 - k | 0) * 3 | 0) | 0;
                      k = k + 1 | 0;
                      g2 = m | g2;
                      j = H() | 0 | j;
                    } while ((k | 0) < (s2 | 0));
                    m = g2;
                  }
                } else {
                  m = a4;
                  j = c3;
                }
                l = Td(m | 0, j | 0, 45) | 0;
                H() | 0;
                if (!(oa(l & 127) | 0)) {
                  g2 = 0;
                } else {
                  l = Td(m | 0, j | 0, 52) | 0;
                  H() | 0;
                  l = l & 15;
                  b: do {
                    if (!l) {
                      g2 = 0;
                    } else {
                      k = 1;
                      while (1) {
                        g2 = Td(m | 0, j | 0, (15 - k | 0) * 3 | 0) | 0;
                        H() | 0;
                        g2 = g2 & 7;
                        if (g2 | 0) {
                          break b;
                        }
                        if (k >>> 0 < l >>> 0) {
                          k = k + 1 | 0;
                        } else {
                          g2 = 0;
                          break;
                        }
                      }
                    }
                  } while (0);
                  g2 = (g2 | 0) == 0 & 1;
                }
                j = Td(a4 | 0, c3 | 0, (15 - n | 0) * 3 | 0) | 0;
                H() | 0;
                j = j & 7;
                if ((j | 0) == 7) {
                  f2 = 5;
                  k = 42;
                  break;
                }
                g2 = (g2 | 0) != 0;
                if ((j | 0) == 1 & g2) {
                  f2 = 5;
                  k = 42;
                  break;
                }
                m = j + (((j | 0) != 0 & g2) << 31 >> 31) | 0;
                if (m | 0) {
                  k = s2 - n | 0;
                  k = Rc(7, 0, k, ((k | 0) < 0) << 31 >> 31) | 0;
                  l = H() | 0;
                  if (g2) {
                    g2 = Pd(k | 0, l | 0, 5, 0) | 0;
                    g2 = Jd(g2 | 0, H() | 0, -5, -1) | 0;
                    g2 = Nd(g2 | 0, H() | 0, 6, 0) | 0;
                    g2 = Jd(g2 | 0, H() | 0, 1, 0) | 0;
                    j = H() | 0;
                  } else {
                    g2 = k;
                    j = l;
                  }
                  n = m + -1 | 0;
                  n = Pd(k | 0, l | 0, n | 0, ((n | 0) < 0) << 31 >> 31 | 0) | 0;
                  n = Jd(g2 | 0, j | 0, n | 0, H() | 0) | 0;
                  m = H() | 0;
                  l = e3;
                  l = Jd(n | 0, m | 0, b3[l >> 2] | 0, b3[l + 4 >> 2] | 0) | 0;
                  m = H() | 0;
                  n = e3;
                  b3[n >> 2] = l;
                  b3[n + 4 >> 2] = m;
                }
                if ((o | 0) <= (d3 | 0)) {
                  k = 37;
                  break;
                }
              }
              if ((k | 0) == 19) {
                I(27795, 27122, 1367, 27158);
              } else if ((k | 0) == 37) {
                h = e3;
                f2 = b3[h + 4 >> 2] | 0;
                h = b3[h >> 2] | 0;
                break;
              } else if ((k | 0) == 42) {
                T = t2;
                return f2 | 0;
              }
            } else {
              f2 = 0;
              h = 0;
            }
          } else {
            k = 33;
          }
        } while (0);
        c: do {
          if ((k | 0) == 33) {
            p2 = e3;
            b3[p2 >> 2] = 0;
            b3[p2 + 4 >> 2] = 0;
            if ((s2 | 0) > (d3 | 0)) {
              g2 = s2;
              while (1) {
                f2 = Td(a4 | 0, c3 | 0, (15 - g2 | 0) * 3 | 0) | 0;
                H() | 0;
                f2 = f2 & 7;
                if ((f2 | 0) == 7) {
                  f2 = 5;
                  break;
                }
                h = s2 - g2 | 0;
                h = Rc(7, 0, h, ((h | 0) < 0) << 31 >> 31) | 0;
                f2 = Pd(h | 0, H() | 0, f2 | 0, 0) | 0;
                h = H() | 0;
                p2 = e3;
                h = Jd(b3[p2 >> 2] | 0, b3[p2 + 4 >> 2] | 0, f2 | 0, h | 0) | 0;
                f2 = H() | 0;
                p2 = e3;
                b3[p2 >> 2] = h;
                b3[p2 + 4 >> 2] = f2;
                g2 = g2 + -1 | 0;
                if ((g2 | 0) <= (d3 | 0)) {
                  break c;
                }
              }
              T = t2;
              return f2 | 0;
            } else {
              f2 = 0;
              h = 0;
            }
          }
        } while (0);
        if (Jb(q2, i, s2, r2) | 0) {
          I(27795, 27122, 1327, 27173);
        }
        s2 = r2;
        r2 = b3[s2 + 4 >> 2] | 0;
        if (((f2 | 0) > -1 | (f2 | 0) == -1 & h >>> 0 > 4294967295) & ((r2 | 0) > (f2 | 0) | ((r2 | 0) == (f2 | 0) ? (b3[s2 >> 2] | 0) >>> 0 > h >>> 0 : 0))) {
          s2 = 0;
          T = t2;
          return s2 | 0;
        } else {
          I(27795, 27122, 1407, 27158);
        }
        return 0;
      }
      function hc(a4, c3, d3, e3, f2, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0;
        m = T;
        T = T + 16 | 0;
        h = m;
        if (f2 >>> 0 > 15) {
          g2 = 4;
          T = m;
          return g2 | 0;
        }
        i = Td(d3 | 0, e3 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        if ((i | 0) > (f2 | 0)) {
          g2 = 12;
          T = m;
          return g2 | 0;
        }
        if (Jb(d3, e3, f2, h) | 0) {
          I(27795, 27122, 1327, 27173);
        }
        l = h;
        k = b3[l + 4 >> 2] | 0;
        if (!(((c3 | 0) > -1 | (c3 | 0) == -1 & a4 >>> 0 > 4294967295) & ((k | 0) > (c3 | 0) | ((k | 0) == (c3 | 0) ? (b3[l >> 2] | 0) >>> 0 > a4 >>> 0 : 0)))) {
          g2 = 2;
          T = m;
          return g2 | 0;
        }
        l = f2 - i | 0;
        f2 = Ud(f2 | 0, 0, 52) | 0;
        j = H() | 0 | e3 & -15728641;
        k = g2;
        b3[k >> 2] = f2 | d3;
        b3[k + 4 >> 2] = j;
        k = Td(d3 | 0, e3 | 0, 45) | 0;
        H() | 0;
        a: do {
          if (oa(k & 127) | 0) {
            if (i | 0) {
              h = 1;
              while (1) {
                k = Ud(7, 0, (15 - h | 0) * 3 | 0) | 0;
                if (!((k & d3 | 0) == 0 & ((H() | 0) & e3 | 0) == 0)) {
                  break a;
                }
                if (h >>> 0 < i >>> 0) {
                  h = h + 1 | 0;
                } else {
                  break;
                }
              }
            }
            if ((l | 0) < 1) {
              g2 = 0;
              T = m;
              return g2 | 0;
            }
            k = i ^ 15;
            e3 = -1;
            j = 1;
            h = 1;
            while (1) {
              i = l - j | 0;
              i = Rc(7, 0, i, ((i | 0) < 0) << 31 >> 31) | 0;
              d3 = H() | 0;
              do {
                if (h) {
                  h = Pd(i | 0, d3 | 0, 5, 0) | 0;
                  h = Jd(h | 0, H() | 0, -5, -1) | 0;
                  h = Nd(h | 0, H() | 0, 6, 0) | 0;
                  f2 = H() | 0;
                  if ((c3 | 0) > (f2 | 0) | (c3 | 0) == (f2 | 0) & a4 >>> 0 > h >>> 0) {
                    c3 = Jd(a4 | 0, c3 | 0, -1, -1) | 0;
                    c3 = Kd(c3 | 0, H() | 0, h | 0, f2 | 0) | 0;
                    h = H() | 0;
                    n = g2;
                    p2 = b3[n >> 2] | 0;
                    n = b3[n + 4 >> 2] | 0;
                    q2 = (k + e3 | 0) * 3 | 0;
                    o = Ud(7, 0, q2 | 0) | 0;
                    n = n & ~(H() | 0);
                    e3 = Nd(c3 | 0, h | 0, i | 0, d3 | 0) | 0;
                    a4 = H() | 0;
                    f2 = Jd(e3 | 0, a4 | 0, 2, 0) | 0;
                    q2 = Ud(f2 | 0, H() | 0, q2 | 0) | 0;
                    n = H() | 0 | n;
                    f2 = g2;
                    b3[f2 >> 2] = q2 | p2 & ~o;
                    b3[f2 + 4 >> 2] = n;
                    a4 = Pd(e3 | 0, a4 | 0, i | 0, d3 | 0) | 0;
                    a4 = Kd(c3 | 0, h | 0, a4 | 0, H() | 0) | 0;
                    h = 0;
                    c3 = H() | 0;
                    break;
                  } else {
                    q2 = g2;
                    o = b3[q2 >> 2] | 0;
                    q2 = b3[q2 + 4 >> 2] | 0;
                    p2 = Ud(7, 0, (k + e3 | 0) * 3 | 0) | 0;
                    q2 = q2 & ~(H() | 0);
                    h = g2;
                    b3[h >> 2] = o & ~p2;
                    b3[h + 4 >> 2] = q2;
                    h = 1;
                    break;
                  }
                } else {
                  o = g2;
                  f2 = b3[o >> 2] | 0;
                  o = b3[o + 4 >> 2] | 0;
                  e3 = (k + e3 | 0) * 3 | 0;
                  n = Ud(7, 0, e3 | 0) | 0;
                  o = o & ~(H() | 0);
                  q2 = Nd(a4 | 0, c3 | 0, i | 0, d3 | 0) | 0;
                  h = H() | 0;
                  e3 = Ud(q2 | 0, h | 0, e3 | 0) | 0;
                  o = H() | 0 | o;
                  p2 = g2;
                  b3[p2 >> 2] = e3 | f2 & ~n;
                  b3[p2 + 4 >> 2] = o;
                  h = Pd(q2 | 0, h | 0, i | 0, d3 | 0) | 0;
                  a4 = Kd(a4 | 0, c3 | 0, h | 0, H() | 0) | 0;
                  h = 0;
                  c3 = H() | 0;
                }
              } while (0);
              if ((l | 0) > (j | 0)) {
                e3 = ~j;
                j = j + 1 | 0;
              } else {
                c3 = 0;
                break;
              }
            }
            T = m;
            return c3 | 0;
          }
        } while (0);
        if ((l | 0) < 1) {
          q2 = 0;
          T = m;
          return q2 | 0;
        }
        f2 = i ^ 15;
        h = 1;
        while (1) {
          p2 = l - h | 0;
          p2 = Rc(7, 0, p2, ((p2 | 0) < 0) << 31 >> 31) | 0;
          q2 = H() | 0;
          j = g2;
          d3 = b3[j >> 2] | 0;
          j = b3[j + 4 >> 2] | 0;
          i = (f2 - h | 0) * 3 | 0;
          e3 = Ud(7, 0, i | 0) | 0;
          j = j & ~(H() | 0);
          n = Nd(a4 | 0, c3 | 0, p2 | 0, q2 | 0) | 0;
          o = H() | 0;
          i = Ud(n | 0, o | 0, i | 0) | 0;
          j = H() | 0 | j;
          k = g2;
          b3[k >> 2] = i | d3 & ~e3;
          b3[k + 4 >> 2] = j;
          q2 = Pd(n | 0, o | 0, p2 | 0, q2 | 0) | 0;
          a4 = Kd(a4 | 0, c3 | 0, q2 | 0, H() | 0) | 0;
          c3 = H() | 0;
          if ((l | 0) <= (h | 0)) {
            c3 = 0;
            break;
          } else {
            h = h + 1 | 0;
          }
        }
        T = m;
        return c3 | 0;
      }
      function ic(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        f2 = Td(c3 | 0, d3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        if ((c3 | 0) == 0 & (d3 | 0) == 0 | ((e3 | 0) > 15 | (f2 | 0) > (e3 | 0))) {
          g2 = -1;
          c3 = -1;
          d3 = 0;
          f2 = 0;
        } else {
          c3 = Mb(c3, d3, f2 + 1 | 0, e3) | 0;
          h = (H() | 0) & -15728641;
          d3 = Ud(e3 | 0, 0, 52) | 0;
          d3 = c3 | d3;
          h = h | (H() | 0);
          c3 = (Kb(d3, h) | 0) == 0;
          g2 = f2;
          c3 = c3 ? -1 : e3;
          f2 = h;
        }
        h = a4;
        b3[h >> 2] = d3;
        b3[h + 4 >> 2] = f2;
        b3[a4 + 8 >> 2] = g2;
        b3[a4 + 12 >> 2] = c3;
        return;
      }
      function jc(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        f2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        g2 = e3 + 8 | 0;
        b3[g2 >> 2] = f2;
        if ((a4 | 0) == 0 & (c3 | 0) == 0 | ((d3 | 0) > 15 | (f2 | 0) > (d3 | 0))) {
          d3 = e3;
          b3[d3 >> 2] = 0;
          b3[d3 + 4 >> 2] = 0;
          b3[g2 >> 2] = -1;
          b3[e3 + 12 >> 2] = -1;
          return;
        }
        a4 = Mb(a4, c3, f2 + 1 | 0, d3) | 0;
        g2 = (H() | 0) & -15728641;
        f2 = Ud(d3 | 0, 0, 52) | 0;
        f2 = a4 | f2;
        g2 = g2 | (H() | 0);
        a4 = e3;
        b3[a4 >> 2] = f2;
        b3[a4 + 4 >> 2] = g2;
        a4 = e3 + 12 | 0;
        if (!(Kb(f2, g2) | 0)) {
          b3[a4 >> 2] = -1;
          return;
        } else {
          b3[a4 >> 2] = d3;
          return;
        }
      }
      function kc(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        d3 = a4;
        c3 = b3[d3 >> 2] | 0;
        d3 = b3[d3 + 4 >> 2] | 0;
        if ((c3 | 0) == 0 & (d3 | 0) == 0) {
          return;
        }
        e3 = Td(c3 | 0, d3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        i = Ud(1, 0, (e3 ^ 15) * 3 | 0) | 0;
        c3 = Jd(i | 0, H() | 0, c3 | 0, d3 | 0) | 0;
        d3 = H() | 0;
        i = a4;
        b3[i >> 2] = c3;
        b3[i + 4 >> 2] = d3;
        i = a4 + 8 | 0;
        h = b3[i >> 2] | 0;
        if ((e3 | 0) < (h | 0)) {
          return;
        }
        j = a4 + 12 | 0;
        g2 = e3;
        while (1) {
          if ((g2 | 0) == (h | 0)) {
            e3 = 5;
            break;
          }
          k = (g2 | 0) == (b3[j >> 2] | 0);
          f2 = (15 - g2 | 0) * 3 | 0;
          e3 = Td(c3 | 0, d3 | 0, f2 | 0) | 0;
          H() | 0;
          e3 = e3 & 7;
          if (k & ((e3 | 0) == 1 & true)) {
            e3 = 7;
            break;
          }
          if (!((e3 | 0) == 7 & true)) {
            e3 = 10;
            break;
          }
          k = Ud(1, 0, f2 | 0) | 0;
          c3 = Jd(c3 | 0, d3 | 0, k | 0, H() | 0) | 0;
          d3 = H() | 0;
          k = a4;
          b3[k >> 2] = c3;
          b3[k + 4 >> 2] = d3;
          if ((g2 | 0) > (h | 0)) {
            g2 = g2 + -1 | 0;
          } else {
            e3 = 10;
            break;
          }
        }
        if ((e3 | 0) == 5) {
          k = a4;
          b3[k >> 2] = 0;
          b3[k + 4 >> 2] = 0;
          b3[i >> 2] = -1;
          b3[j >> 2] = -1;
          return;
        } else if ((e3 | 0) == 7) {
          h = Ud(1, 0, f2 | 0) | 0;
          h = Jd(c3 | 0, d3 | 0, h | 0, H() | 0) | 0;
          i = H() | 0;
          k = a4;
          b3[k >> 2] = h;
          b3[k + 4 >> 2] = i;
          b3[j >> 2] = g2 + -1;
          return;
        } else if ((e3 | 0) == 10) {
          return;
        }
      }
      function lc(a4) {
        a4 = +a4;
        var b4 = 0;
        b4 = a4 < 0 ? a4 + 6.283185307179586 : a4;
        return +(!(a4 >= 6.283185307179586) ? b4 : b4 + -6.283185307179586);
      }
      function mc(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        if (!(+q(+(+e2[a4 >> 3] - +e2[b4 >> 3])) < 17453292519943298e-27)) {
          b4 = 0;
          return b4 | 0;
        }
        b4 = +q(+(+e2[a4 + 8 >> 3] - +e2[b4 + 8 >> 3])) < 17453292519943298e-27;
        return b4 | 0;
      }
      function nc(a4, b4) {
        a4 = +a4;
        b4 = b4 | 0;
        switch (b4 | 0) {
          case 1: {
            a4 = a4 < 0 ? a4 + 6.283185307179586 : a4;
            break;
          }
          case 2: {
            a4 = a4 > 0 ? a4 + -6.283185307179586 : a4;
            break;
          }
          default:
        }
        return +a4;
      }
      function oc(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0;
        f2 = +e2[b4 >> 3];
        d3 = +e2[a4 >> 3];
        g2 = +u2(+((f2 - d3) * 0.5));
        c3 = +u2(+((+e2[b4 + 8 >> 3] - +e2[a4 + 8 >> 3]) * 0.5));
        c3 = g2 * g2 + c3 * (+t(+f2) * +t(+d3) * c3);
        return +(+z(+ +r(+c3), + +r(+(1 - c3))) * 2);
      }
      function pc(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0;
        f2 = +e2[b4 >> 3];
        d3 = +e2[a4 >> 3];
        g2 = +u2(+((f2 - d3) * 0.5));
        c3 = +u2(+((+e2[b4 + 8 >> 3] - +e2[a4 + 8 >> 3]) * 0.5));
        c3 = g2 * g2 + c3 * (+t(+f2) * +t(+d3) * c3);
        return +(+z(+ +r(+c3), + +r(+(1 - c3))) * 2 * 6371.007180918475);
      }
      function qc(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0;
        f2 = +e2[b4 >> 3];
        d3 = +e2[a4 >> 3];
        g2 = +u2(+((f2 - d3) * 0.5));
        c3 = +u2(+((+e2[b4 + 8 >> 3] - +e2[a4 + 8 >> 3]) * 0.5));
        c3 = g2 * g2 + c3 * (+t(+f2) * +t(+d3) * c3);
        return +(+z(+ +r(+c3), + +r(+(1 - c3))) * 2 * 6371.007180918475 * 1e3);
      }
      function rc(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0;
        g2 = +e2[b4 >> 3];
        d3 = +t(+g2);
        f2 = +e2[b4 + 8 >> 3] - +e2[a4 + 8 >> 3];
        h = d3 * +u2(+f2);
        c3 = +e2[a4 >> 3];
        return + +z(+h, +(+u2(+g2) * +t(+c3) - +t(+f2) * (d3 * +u2(+c3))));
      }
      function sc(a4, c3, d3, f2) {
        a4 = a4 | 0;
        c3 = +c3;
        d3 = +d3;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0;
        if (d3 < 1e-16) {
          b3[f2 >> 2] = b3[a4 >> 2];
          b3[f2 + 4 >> 2] = b3[a4 + 4 >> 2];
          b3[f2 + 8 >> 2] = b3[a4 + 8 >> 2];
          b3[f2 + 12 >> 2] = b3[a4 + 12 >> 2];
          return;
        }
        h = c3 < 0 ? c3 + 6.283185307179586 : c3;
        h = !(c3 >= 6.283185307179586) ? h : h + -6.283185307179586;
        do {
          if (h < 1e-16) {
            c3 = +e2[a4 >> 3] + d3;
            e2[f2 >> 3] = c3;
            g2 = f2;
          } else {
            g2 = +q(+(h + -3.141592653589793)) < 1e-16;
            c3 = +e2[a4 >> 3];
            if (g2) {
              c3 = c3 - d3;
              e2[f2 >> 3] = c3;
              g2 = f2;
              break;
            }
            i = +t(+d3);
            d3 = +u2(+d3);
            c3 = i * +u2(+c3) + +t(+h) * (d3 * +t(+c3));
            c3 = c3 > 1 ? 1 : c3;
            c3 = +x(+(c3 < -1 ? -1 : c3));
            e2[f2 >> 3] = c3;
            if (+q(+(c3 + -1.5707963267948966)) < 1e-16) {
              e2[f2 >> 3] = 1.5707963267948966;
              e2[f2 + 8 >> 3] = 0;
              return;
            }
            if (+q(+(c3 + 1.5707963267948966)) < 1e-16) {
              e2[f2 >> 3] = -1.5707963267948966;
              e2[f2 + 8 >> 3] = 0;
              return;
            }
            j = 1 / +t(+c3);
            h = d3 * +u2(+h) * j;
            d3 = +e2[a4 >> 3];
            c3 = j * ((i - +u2(+c3) * +u2(+d3)) / +t(+d3));
            i = h > 1 ? 1 : h;
            c3 = c3 > 1 ? 1 : c3;
            c3 = +e2[a4 + 8 >> 3] + +z(+(i < -1 ? -1 : i), +(c3 < -1 ? -1 : c3));
            if (c3 > 3.141592653589793) {
              do {
                c3 = c3 + -6.283185307179586;
              } while (c3 > 3.141592653589793);
            }
            if (c3 < -3.141592653589793) {
              do {
                c3 = c3 + 6.283185307179586;
              } while (c3 < -3.141592653589793);
            }
            e2[f2 + 8 >> 3] = c3;
            return;
          }
        } while (0);
        if (+q(+(c3 + -1.5707963267948966)) < 1e-16) {
          e2[g2 >> 3] = 1.5707963267948966;
          e2[f2 + 8 >> 3] = 0;
          return;
        }
        if (+q(+(c3 + 1.5707963267948966)) < 1e-16) {
          e2[g2 >> 3] = -1.5707963267948966;
          e2[f2 + 8 >> 3] = 0;
          return;
        }
        c3 = +e2[a4 + 8 >> 3];
        if (c3 > 3.141592653589793) {
          do {
            c3 = c3 + -6.283185307179586;
          } while (c3 > 3.141592653589793);
        }
        if (c3 < -3.141592653589793) {
          do {
            c3 = c3 + 6.283185307179586;
          } while (c3 < -3.141592653589793);
        }
        e2[f2 + 8 >> 3] = c3;
        return;
      }
      function tc(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        if (a4 >>> 0 > 15) {
          b4 = 4;
          return b4 | 0;
        }
        e2[b4 >> 3] = +e2[20656 + (a4 << 3) >> 3];
        b4 = 0;
        return b4 | 0;
      }
      function uc(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        if (a4 >>> 0 > 15) {
          b4 = 4;
          return b4 | 0;
        }
        e2[b4 >> 3] = +e2[20784 + (a4 << 3) >> 3];
        b4 = 0;
        return b4 | 0;
      }
      function vc(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        if (a4 >>> 0 > 15) {
          b4 = 4;
          return b4 | 0;
        }
        e2[b4 >> 3] = +e2[20912 + (a4 << 3) >> 3];
        b4 = 0;
        return b4 | 0;
      }
      function wc(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        if (a4 >>> 0 > 15) {
          b4 = 4;
          return b4 | 0;
        }
        e2[b4 >> 3] = +e2[21040 + (a4 << 3) >> 3];
        b4 = 0;
        return b4 | 0;
      }
      function xc(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0;
        if (a4 >>> 0 > 15) {
          c3 = 4;
          return c3 | 0;
        }
        d3 = Rc(7, 0, a4, ((a4 | 0) < 0) << 31 >> 31) | 0;
        d3 = Pd(d3 | 0, H() | 0, 120, 0) | 0;
        a4 = H() | 0;
        b3[c3 >> 2] = d3 | 2;
        b3[c3 + 4 >> 2] = a4;
        c3 = 0;
        return c3 | 0;
      }
      function yc(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        n = +e2[b4 >> 3];
        l = +e2[a4 >> 3];
        j = +u2(+((n - l) * 0.5));
        g2 = +e2[b4 + 8 >> 3];
        k = +e2[a4 + 8 >> 3];
        h = +u2(+((g2 - k) * 0.5));
        i = +t(+l);
        m = +t(+n);
        h = j * j + h * (m * i * h);
        h = +z(+ +r(+h), + +r(+(1 - h))) * 2;
        j = +e2[c3 >> 3];
        n = +u2(+((j - n) * 0.5));
        d3 = +e2[c3 + 8 >> 3];
        g2 = +u2(+((d3 - g2) * 0.5));
        f2 = +t(+j);
        g2 = n * n + g2 * (m * f2 * g2);
        g2 = +z(+ +r(+g2), + +r(+(1 - g2))) * 2;
        j = +u2(+((l - j) * 0.5));
        d3 = +u2(+((k - d3) * 0.5));
        d3 = j * j + d3 * (i * f2 * d3);
        d3 = +z(+ +r(+d3), + +r(+(1 - d3))) * 2;
        f2 = (h + g2 + d3) * 0.5;
        return +(+y(+ +r(+(+v2(+(f2 * 0.5)) * +v2(+((f2 - h) * 0.5)) * +v2(+((f2 - g2) * 0.5)) * +v2(+((f2 - d3) * 0.5))))) * 4);
      }
      function zc(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 192 | 0;
        h = j + 168 | 0;
        i = j;
        g2 = ac(a4, c3, h) | 0;
        if (g2 | 0) {
          d3 = g2;
          T = j;
          return d3 | 0;
        }
        if (bc(a4, c3, i) | 0) {
          I(27795, 27190, 415, 27199);
        }
        c3 = b3[i >> 2] | 0;
        if ((c3 | 0) > 0) {
          f2 = +yc(i + 8 | 0, i + 8 + (((c3 | 0) != 1 & 1) << 4) | 0, h) + 0;
          if ((c3 | 0) != 1) {
            a4 = 1;
            do {
              g2 = a4;
              a4 = a4 + 1 | 0;
              f2 = f2 + +yc(i + 8 + (g2 << 4) | 0, i + 8 + (((a4 | 0) % (c3 | 0) | 0) << 4) | 0, h);
            } while ((a4 | 0) < (c3 | 0));
          }
        } else {
          f2 = 0;
        }
        e2[d3 >> 3] = f2;
        d3 = 0;
        T = j;
        return d3 | 0;
      }
      function Ac(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        a4 = zc(a4, b4, c3) | 0;
        if (a4 | 0) {
          return a4 | 0;
        }
        e2[c3 >> 3] = +e2[c3 >> 3] * 6371.007180918475 * 6371.007180918475;
        return a4 | 0;
      }
      function Bc(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        a4 = zc(a4, b4, c3) | 0;
        if (a4 | 0) {
          return a4 | 0;
        }
        e2[c3 >> 3] = +e2[c3 >> 3] * 6371.007180918475 * 6371.007180918475 * 1e3 * 1e3;
        return a4 | 0;
      }
      function Cc(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T;
        T = T + 176 | 0;
        i = j;
        a4 = pb(a4, c3, i) | 0;
        if (a4 | 0) {
          i = a4;
          T = j;
          return i | 0;
        }
        e2[d3 >> 3] = 0;
        a4 = b3[i >> 2] | 0;
        if ((a4 | 0) <= 1) {
          i = 0;
          T = j;
          return i | 0;
        }
        c3 = a4 + -1 | 0;
        a4 = 0;
        f2 = +e2[i + 8 >> 3];
        g2 = +e2[i + 16 >> 3];
        h = 0;
        do {
          a4 = a4 + 1 | 0;
          l = f2;
          f2 = +e2[i + 8 + (a4 << 4) >> 3];
          m = +u2(+((f2 - l) * 0.5));
          k = g2;
          g2 = +e2[i + 8 + (a4 << 4) + 8 >> 3];
          k = +u2(+((g2 - k) * 0.5));
          k = m * m + k * (+t(+f2) * +t(+l) * k);
          h = h + +z(+ +r(+k), + +r(+(1 - k))) * 2;
        } while ((a4 | 0) < (c3 | 0));
        e2[d3 >> 3] = h;
        i = 0;
        T = j;
        return i | 0;
      }
      function Dc(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T;
        T = T + 176 | 0;
        i = j;
        a4 = pb(a4, c3, i) | 0;
        if (a4 | 0) {
          i = a4;
          h = +e2[d3 >> 3];
          h = h * 6371.007180918475;
          e2[d3 >> 3] = h;
          T = j;
          return i | 0;
        }
        e2[d3 >> 3] = 0;
        a4 = b3[i >> 2] | 0;
        if ((a4 | 0) <= 1) {
          i = 0;
          h = 0;
          h = h * 6371.007180918475;
          e2[d3 >> 3] = h;
          T = j;
          return i | 0;
        }
        c3 = a4 + -1 | 0;
        a4 = 0;
        f2 = +e2[i + 8 >> 3];
        g2 = +e2[i + 16 >> 3];
        h = 0;
        do {
          a4 = a4 + 1 | 0;
          l = f2;
          f2 = +e2[i + 8 + (a4 << 4) >> 3];
          m = +u2(+((f2 - l) * 0.5));
          k = g2;
          g2 = +e2[i + 8 + (a4 << 4) + 8 >> 3];
          k = +u2(+((g2 - k) * 0.5));
          k = m * m + k * (+t(+l) * +t(+f2) * k);
          h = h + +z(+ +r(+k), + +r(+(1 - k))) * 2;
        } while ((a4 | 0) != (c3 | 0));
        e2[d3 >> 3] = h;
        i = 0;
        m = h;
        m = m * 6371.007180918475;
        e2[d3 >> 3] = m;
        T = j;
        return i | 0;
      }
      function Ec(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T;
        T = T + 176 | 0;
        i = j;
        a4 = pb(a4, c3, i) | 0;
        if (a4 | 0) {
          i = a4;
          h = +e2[d3 >> 3];
          h = h * 6371.007180918475;
          h = h * 1e3;
          e2[d3 >> 3] = h;
          T = j;
          return i | 0;
        }
        e2[d3 >> 3] = 0;
        a4 = b3[i >> 2] | 0;
        if ((a4 | 0) <= 1) {
          i = 0;
          h = 0;
          h = h * 6371.007180918475;
          h = h * 1e3;
          e2[d3 >> 3] = h;
          T = j;
          return i | 0;
        }
        c3 = a4 + -1 | 0;
        a4 = 0;
        f2 = +e2[i + 8 >> 3];
        g2 = +e2[i + 16 >> 3];
        h = 0;
        do {
          a4 = a4 + 1 | 0;
          l = f2;
          f2 = +e2[i + 8 + (a4 << 4) >> 3];
          m = +u2(+((f2 - l) * 0.5));
          k = g2;
          g2 = +e2[i + 8 + (a4 << 4) + 8 >> 3];
          k = +u2(+((g2 - k) * 0.5));
          k = m * m + k * (+t(+l) * +t(+f2) * k);
          h = h + +z(+ +r(+k), + +r(+(1 - k))) * 2;
        } while ((a4 | 0) != (c3 | 0));
        e2[d3 >> 3] = h;
        i = 0;
        m = h;
        m = m * 6371.007180918475;
        m = m * 1e3;
        e2[d3 >> 3] = m;
        T = j;
        return i | 0;
      }
      function Fc(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        c3 = Id(1, 12) | 0;
        if (!c3) {
          I(27280, 27235, 49, 27293);
        }
        d3 = a4 + 4 | 0;
        e3 = b3[d3 >> 2] | 0;
        if (e3 | 0) {
          e3 = e3 + 8 | 0;
          b3[e3 >> 2] = c3;
          b3[d3 >> 2] = c3;
          return c3 | 0;
        }
        if (b3[a4 >> 2] | 0) {
          I(27310, 27235, 61, 27333);
        }
        e3 = a4;
        b3[e3 >> 2] = c3;
        b3[d3 >> 2] = c3;
        return c3 | 0;
      }
      function Gc(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0;
        e3 = Gd(24) | 0;
        if (!e3) {
          I(27347, 27235, 78, 27361);
        }
        b3[e3 >> 2] = b3[c3 >> 2];
        b3[e3 + 4 >> 2] = b3[c3 + 4 >> 2];
        b3[e3 + 8 >> 2] = b3[c3 + 8 >> 2];
        b3[e3 + 12 >> 2] = b3[c3 + 12 >> 2];
        b3[e3 + 16 >> 2] = 0;
        c3 = a4 + 4 | 0;
        d3 = b3[c3 >> 2] | 0;
        if (d3 | 0) {
          b3[d3 + 16 >> 2] = e3;
          b3[c3 >> 2] = e3;
          return e3 | 0;
        }
        if (b3[a4 >> 2] | 0) {
          I(27376, 27235, 82, 27361);
        }
        b3[a4 >> 2] = e3;
        b3[c3 >> 2] = e3;
        return e3 | 0;
      }
      function Hc(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0;
        if (!a4) {
          return;
        }
        e3 = 1;
        while (1) {
          c3 = b3[a4 >> 2] | 0;
          if (c3 | 0) {
            do {
              d3 = b3[c3 >> 2] | 0;
              if (d3 | 0) {
                do {
                  f2 = d3;
                  d3 = b3[d3 + 16 >> 2] | 0;
                  Hd(f2);
                } while ((d3 | 0) != 0);
              }
              f2 = c3;
              c3 = b3[c3 + 8 >> 2] | 0;
              Hd(f2);
            } while ((c3 | 0) != 0);
          }
          c3 = a4;
          a4 = b3[a4 + 8 >> 2] | 0;
          if (!e3) {
            Hd(c3);
          }
          if (!a4) {
            break;
          } else {
            e3 = 0;
          }
        }
        return;
      }
      function Ic(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0, B3 = 0, C3 = 0, D3 = 0, E3 = 0, F2 = 0, G3 = 0, H2 = 0, J2 = 0, K2 = 0;
        g2 = a4 + 8 | 0;
        if (b3[g2 >> 2] | 0) {
          K2 = 1;
          return K2 | 0;
        }
        f2 = b3[a4 >> 2] | 0;
        if (!f2) {
          K2 = 0;
          return K2 | 0;
        }
        c3 = f2;
        d3 = 0;
        do {
          d3 = d3 + 1 | 0;
          c3 = b3[c3 + 8 >> 2] | 0;
        } while ((c3 | 0) != 0);
        if (d3 >>> 0 < 2) {
          K2 = 0;
          return K2 | 0;
        }
        H2 = Gd(d3 << 2) | 0;
        if (!H2) {
          I(27396, 27235, 317, 27415);
        }
        G3 = Gd(d3 << 5) | 0;
        if (!G3) {
          I(27437, 27235, 321, 27415);
        }
        b3[a4 >> 2] = 0;
        z2 = a4 + 4 | 0;
        b3[z2 >> 2] = 0;
        b3[g2 >> 2] = 0;
        d3 = 0;
        F2 = 0;
        y2 = 0;
        n = 0;
        a: while (1) {
          m = b3[f2 >> 2] | 0;
          if (m) {
            h = 0;
            i = m;
            do {
              k = +e2[i + 8 >> 3];
              c3 = i;
              i = b3[i + 16 >> 2] | 0;
              l = (i | 0) == 0;
              g2 = l ? m : i;
              j = +e2[g2 + 8 >> 3];
              if (+q(+(k - j)) > 3.141592653589793) {
                K2 = 14;
                break;
              }
              h = h + (j - k) * (+e2[c3 >> 3] + +e2[g2 >> 3]);
            } while (!l);
            if ((K2 | 0) == 14) {
              K2 = 0;
              h = 0;
              c3 = m;
              do {
                x2 = +e2[c3 + 8 >> 3];
                E3 = c3 + 16 | 0;
                D3 = b3[E3 >> 2] | 0;
                D3 = (D3 | 0) == 0 ? m : D3;
                w3 = +e2[D3 + 8 >> 3];
                h = h + (+e2[c3 >> 3] + +e2[D3 >> 3]) * ((w3 < 0 ? w3 + 6.283185307179586 : w3) - (x2 < 0 ? x2 + 6.283185307179586 : x2));
                c3 = b3[((c3 | 0) == 0 ? f2 : E3) >> 2] | 0;
              } while ((c3 | 0) != 0);
            }
            if (h > 0) {
              b3[H2 + (F2 << 2) >> 2] = f2;
              F2 = F2 + 1 | 0;
              g2 = y2;
              c3 = n;
            } else {
              K2 = 19;
            }
          } else {
            K2 = 19;
          }
          if ((K2 | 0) == 19) {
            K2 = 0;
            do {
              if (!d3) {
                if (!n) {
                  if (!(b3[a4 >> 2] | 0)) {
                    g2 = z2;
                    i = a4;
                    c3 = f2;
                    d3 = a4;
                    break;
                  } else {
                    K2 = 27;
                    break a;
                  }
                } else {
                  g2 = z2;
                  i = n + 8 | 0;
                  c3 = f2;
                  d3 = a4;
                  break;
                }
              } else {
                c3 = d3 + 8 | 0;
                if (b3[c3 >> 2] | 0) {
                  K2 = 21;
                  break a;
                }
                d3 = Id(1, 12) | 0;
                if (!d3) {
                  K2 = 23;
                  break a;
                }
                b3[c3 >> 2] = d3;
                g2 = d3 + 4 | 0;
                i = d3;
                c3 = n;
              }
            } while (0);
            b3[i >> 2] = f2;
            b3[g2 >> 2] = f2;
            i = G3 + (y2 << 5) | 0;
            l = b3[f2 >> 2] | 0;
            if (l) {
              m = G3 + (y2 << 5) + 8 | 0;
              e2[m >> 3] = 17976931348623157e292;
              n = G3 + (y2 << 5) + 24 | 0;
              e2[n >> 3] = 17976931348623157e292;
              e2[i >> 3] = -17976931348623157e292;
              o = G3 + (y2 << 5) + 16 | 0;
              e2[o >> 3] = -17976931348623157e292;
              u3 = 17976931348623157e292;
              v3 = -17976931348623157e292;
              g2 = 0;
              p2 = l;
              k = 17976931348623157e292;
              s2 = 17976931348623157e292;
              t2 = -17976931348623157e292;
              j = -17976931348623157e292;
              while (1) {
                h = +e2[p2 >> 3];
                x2 = +e2[p2 + 8 >> 3];
                p2 = b3[p2 + 16 >> 2] | 0;
                r2 = (p2 | 0) == 0;
                w3 = +e2[(r2 ? l : p2) + 8 >> 3];
                if (h < k) {
                  e2[m >> 3] = h;
                  k = h;
                }
                if (x2 < s2) {
                  e2[n >> 3] = x2;
                  s2 = x2;
                }
                if (h > t2) {
                  e2[i >> 3] = h;
                } else {
                  h = t2;
                }
                if (x2 > j) {
                  e2[o >> 3] = x2;
                  j = x2;
                }
                u3 = x2 > 0 & x2 < u3 ? x2 : u3;
                v3 = x2 < 0 & x2 > v3 ? x2 : v3;
                g2 = g2 | +q(+(x2 - w3)) > 3.141592653589793;
                if (r2) {
                  break;
                } else {
                  t2 = h;
                }
              }
              if (g2) {
                e2[o >> 3] = v3;
                e2[n >> 3] = u3;
              }
            } else {
              b3[i >> 2] = 0;
              b3[i + 4 >> 2] = 0;
              b3[i + 8 >> 2] = 0;
              b3[i + 12 >> 2] = 0;
              b3[i + 16 >> 2] = 0;
              b3[i + 20 >> 2] = 0;
              b3[i + 24 >> 2] = 0;
              b3[i + 28 >> 2] = 0;
            }
            g2 = y2 + 1 | 0;
          }
          E3 = f2 + 8 | 0;
          f2 = b3[E3 >> 2] | 0;
          b3[E3 >> 2] = 0;
          if (!f2) {
            K2 = 45;
            break;
          } else {
            y2 = g2;
            n = c3;
          }
        }
        if ((K2 | 0) == 21) {
          I(27213, 27235, 35, 27247);
        } else if ((K2 | 0) == 23) {
          I(27267, 27235, 37, 27247);
        } else if ((K2 | 0) == 27) {
          I(27310, 27235, 61, 27333);
        } else if ((K2 | 0) == 45) {
          b: do {
            if ((F2 | 0) > 0) {
              E3 = (g2 | 0) == 0;
              C3 = g2 << 2;
              D3 = (a4 | 0) == 0;
              B3 = 0;
              c3 = 0;
              while (1) {
                A3 = b3[H2 + (B3 << 2) >> 2] | 0;
                if (!E3) {
                  y2 = Gd(C3) | 0;
                  if (!y2) {
                    K2 = 50;
                    break;
                  }
                  z2 = Gd(C3) | 0;
                  if (!z2) {
                    K2 = 52;
                    break;
                  }
                  c: do {
                    if (!D3) {
                      g2 = 0;
                      d3 = 0;
                      i = a4;
                      while (1) {
                        f2 = G3 + (g2 << 5) | 0;
                        if (Jc(b3[i >> 2] | 0, f2, b3[A3 >> 2] | 0) | 0) {
                          b3[y2 + (d3 << 2) >> 2] = i;
                          b3[z2 + (d3 << 2) >> 2] = f2;
                          r2 = d3 + 1 | 0;
                        } else {
                          r2 = d3;
                        }
                        i = b3[i + 8 >> 2] | 0;
                        if (!i) {
                          break;
                        } else {
                          g2 = g2 + 1 | 0;
                          d3 = r2;
                        }
                      }
                      if ((r2 | 0) > 0) {
                        f2 = b3[y2 >> 2] | 0;
                        if ((r2 | 0) == 1) {
                          d3 = f2;
                        } else {
                          o = 0;
                          p2 = -1;
                          d3 = f2;
                          n = f2;
                          while (1) {
                            l = b3[n >> 2] | 0;
                            f2 = 0;
                            i = 0;
                            while (1) {
                              g2 = b3[b3[y2 + (i << 2) >> 2] >> 2] | 0;
                              if ((g2 | 0) == (l | 0)) {
                                m = f2;
                              } else {
                                m = f2 + ((Jc(g2, b3[z2 + (i << 2) >> 2] | 0, b3[l >> 2] | 0) | 0) & 1) | 0;
                              }
                              i = i + 1 | 0;
                              if ((i | 0) == (r2 | 0)) {
                                break;
                              } else {
                                f2 = m;
                              }
                            }
                            g2 = (m | 0) > (p2 | 0);
                            d3 = g2 ? n : d3;
                            f2 = o + 1 | 0;
                            if ((f2 | 0) == (r2 | 0)) {
                              break c;
                            }
                            o = f2;
                            p2 = g2 ? m : p2;
                            n = b3[y2 + (f2 << 2) >> 2] | 0;
                          }
                        }
                      } else {
                        d3 = 0;
                      }
                    } else {
                      d3 = 0;
                    }
                  } while (0);
                  Hd(y2);
                  Hd(z2);
                  if (d3) {
                    g2 = d3 + 4 | 0;
                    f2 = b3[g2 >> 2] | 0;
                    if (!f2) {
                      if (b3[d3 >> 2] | 0) {
                        K2 = 70;
                        break;
                      }
                    } else {
                      d3 = f2 + 8 | 0;
                    }
                    b3[d3 >> 2] = A3;
                    b3[g2 >> 2] = A3;
                  } else {
                    K2 = 73;
                  }
                } else {
                  K2 = 73;
                }
                if ((K2 | 0) == 73) {
                  K2 = 0;
                  c3 = b3[A3 >> 2] | 0;
                  if (c3 | 0) {
                    do {
                      z2 = c3;
                      c3 = b3[c3 + 16 >> 2] | 0;
                      Hd(z2);
                    } while ((c3 | 0) != 0);
                  }
                  Hd(A3);
                  c3 = 1;
                }
                B3 = B3 + 1 | 0;
                if ((B3 | 0) >= (F2 | 0)) {
                  J2 = c3;
                  break b;
                }
              }
              if ((K2 | 0) == 50) {
                I(27452, 27235, 249, 27471);
              } else if ((K2 | 0) == 52) {
                I(27490, 27235, 252, 27471);
              } else if ((K2 | 0) == 70) {
                I(27310, 27235, 61, 27333);
              }
            } else {
              J2 = 0;
            }
          } while (0);
          Hd(H2);
          Hd(G3);
          K2 = J2;
          return K2 | 0;
        }
        return 0;
      }
      function Jc(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        if (!(Ca(c3, d3) | 0)) {
          a4 = 0;
          return a4 | 0;
        }
        c3 = Aa(c3) | 0;
        f2 = +e2[d3 >> 3];
        g2 = +e2[d3 + 8 >> 3];
        g2 = c3 & g2 < 0 ? g2 + 6.283185307179586 : g2;
        a4 = b3[a4 >> 2] | 0;
        if (!a4) {
          a4 = 0;
          return a4 | 0;
        }
        if (c3) {
          c3 = 0;
          l = g2;
          d3 = a4;
          a: while (1) {
            while (1) {
              i = +e2[d3 >> 3];
              g2 = +e2[d3 + 8 >> 3];
              d3 = d3 + 16 | 0;
              m = b3[d3 >> 2] | 0;
              m = (m | 0) == 0 ? a4 : m;
              h = +e2[m >> 3];
              j = +e2[m + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d3 = b3[d3 >> 2] | 0;
              if (!d3) {
                d3 = 22;
                break a;
              }
            }
            j = i < 0 ? i + 6.283185307179586 : i;
            i = g2 < 0 ? g2 + 6.283185307179586 : g2;
            l = j == l | i == l ? l + -2220446049250313e-31 : l;
            k = j + (i - j) * ((f2 - h) / (k - h));
            if ((k < 0 ? k + 6.283185307179586 : k) > l) {
              c3 = c3 ^ 1;
            }
            d3 = b3[d3 >> 2] | 0;
            if (!d3) {
              d3 = 22;
              break;
            }
          }
          if ((d3 | 0) == 22) {
            return c3 | 0;
          }
        } else {
          c3 = 0;
          l = g2;
          d3 = a4;
          b: while (1) {
            while (1) {
              i = +e2[d3 >> 3];
              g2 = +e2[d3 + 8 >> 3];
              d3 = d3 + 16 | 0;
              m = b3[d3 >> 2] | 0;
              m = (m | 0) == 0 ? a4 : m;
              h = +e2[m >> 3];
              j = +e2[m + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d3 = b3[d3 >> 2] | 0;
              if (!d3) {
                d3 = 22;
                break b;
              }
            }
            l = i == l | g2 == l ? l + -2220446049250313e-31 : l;
            if (i + (g2 - i) * ((f2 - h) / (k - h)) > l) {
              c3 = c3 ^ 1;
            }
            d3 = b3[d3 >> 2] | 0;
            if (!d3) {
              d3 = 22;
              break;
            }
          }
          if ((d3 | 0) == 22) {
            return c3 | 0;
          }
        }
        return 0;
      }
      function Kc(c3, d3, e3, f2, g2) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0;
        u3 = T;
        T = T + 32 | 0;
        t2 = u3 + 16 | 0;
        s2 = u3;
        h = Td(c3 | 0, d3 | 0, 52) | 0;
        H() | 0;
        h = h & 15;
        p2 = Td(e3 | 0, f2 | 0, 52) | 0;
        H() | 0;
        if ((h | 0) != (p2 & 15 | 0)) {
          t2 = 12;
          T = u3;
          return t2 | 0;
        }
        l = Td(c3 | 0, d3 | 0, 45) | 0;
        H() | 0;
        l = l & 127;
        m = Td(e3 | 0, f2 | 0, 45) | 0;
        H() | 0;
        m = m & 127;
        if (l >>> 0 > 121 | m >>> 0 > 121) {
          t2 = 5;
          T = u3;
          return t2 | 0;
        }
        p2 = (l | 0) != (m | 0);
        if (p2) {
          j = wa(l, m) | 0;
          if ((j | 0) == 7) {
            t2 = 1;
            T = u3;
            return t2 | 0;
          }
          k = wa(m, l) | 0;
          if ((k | 0) == 7) {
            I(27514, 27538, 161, 27548);
          } else {
            q2 = j;
            i = k;
          }
        } else {
          q2 = 0;
          i = 0;
        }
        n = oa(l) | 0;
        o = oa(m) | 0;
        b3[t2 >> 2] = 0;
        b3[t2 + 4 >> 2] = 0;
        b3[t2 + 8 >> 2] = 0;
        b3[t2 + 12 >> 2] = 0;
        do {
          if (!q2) {
            _b(e3, f2, t2) | 0;
            if ((n | 0) != 0 & (o | 0) != 0) {
              if ((m | 0) != (l | 0)) {
                I(27621, 27538, 261, 27548);
              }
              i = Sb(c3, d3) | 0;
              h = Sb(e3, f2) | 0;
              if (!((i | 0) == 7 | (h | 0) == 7)) {
                if (!(a3[22e3 + (i * 7 | 0) + h >> 0] | 0)) {
                  i = b3[21168 + (i * 28 | 0) + (h << 2) >> 2] | 0;
                  if ((i | 0) > 0) {
                    j = t2 + 4 | 0;
                    h = 0;
                    do {
                      _a(j);
                      h = h + 1 | 0;
                    } while ((h | 0) != (i | 0));
                    r2 = 51;
                  } else {
                    r2 = 51;
                  }
                } else {
                  h = 1;
                }
              } else {
                h = 5;
              }
            } else {
              r2 = 51;
            }
          } else {
            m = b3[4272 + (l * 28 | 0) + (q2 << 2) >> 2] | 0;
            j = (m | 0) > 0;
            if (!o) {
              if (j) {
                l = 0;
                k = e3;
                j = f2;
                do {
                  k = Wb(k, j) | 0;
                  j = H() | 0;
                  i = ab(i) | 0;
                  l = l + 1 | 0;
                } while ((l | 0) != (m | 0));
                m = i;
                l = k;
                k = j;
              } else {
                m = i;
                l = e3;
                k = f2;
              }
            } else if (j) {
              l = 0;
              k = e3;
              j = f2;
              do {
                k = Vb(k, j) | 0;
                j = H() | 0;
                i = ab(i) | 0;
                if ((i | 0) == 1) {
                  i = ab(1) | 0;
                }
                l = l + 1 | 0;
              } while ((l | 0) != (m | 0));
              m = i;
              l = k;
              k = j;
            } else {
              m = i;
              l = e3;
              k = f2;
            }
            _b(l, k, t2) | 0;
            if (!p2) {
              I(27563, 27538, 191, 27548);
            }
            j = (n | 0) != 0;
            i = (o | 0) != 0;
            if (j & i) {
              I(27590, 27538, 192, 27548);
            }
            if (!j) {
              if (i) {
                i = Sb(l, k) | 0;
                if ((i | 0) == 7) {
                  h = 5;
                  break;
                }
                if (a3[22e3 + (i * 7 | 0) + m >> 0] | 0) {
                  h = 1;
                  break;
                }
                l = 0;
                k = b3[21168 + (m * 28 | 0) + (i << 2) >> 2] | 0;
              } else {
                l = 0;
                k = 0;
              }
            } else {
              i = Sb(c3, d3) | 0;
              if ((i | 0) == 7) {
                h = 5;
                break;
              }
              if (a3[22e3 + (i * 7 | 0) + q2 >> 0] | 0) {
                h = 1;
                break;
              }
              k = b3[21168 + (i * 28 | 0) + (q2 << 2) >> 2] | 0;
              l = k;
            }
            if ((l | k | 0) < 0) {
              h = 5;
            } else {
              if ((k | 0) > 0) {
                j = t2 + 4 | 0;
                i = 0;
                do {
                  _a(j);
                  i = i + 1 | 0;
                } while ((i | 0) != (k | 0));
              }
              b3[s2 >> 2] = 0;
              b3[s2 + 4 >> 2] = 0;
              b3[s2 + 8 >> 2] = 0;
              Ya(s2, q2);
              if (h | 0) {
                while (1) {
                  if (!(Yb(h) | 0)) {
                    Xa(s2);
                  } else {
                    Wa(s2);
                  }
                  if ((h | 0) > 1) {
                    h = h + -1 | 0;
                  } else {
                    break;
                  }
                }
              }
              if ((l | 0) > 0) {
                h = 0;
                do {
                  _a(s2);
                  h = h + 1 | 0;
                } while ((h | 0) != (l | 0));
              }
              r2 = t2 + 4 | 0;
              Oa(r2, s2, r2);
              Ma(r2);
              r2 = 51;
            }
          }
        } while (0);
        if ((r2 | 0) == 51) {
          h = t2 + 4 | 0;
          b3[g2 >> 2] = b3[h >> 2];
          b3[g2 + 4 >> 2] = b3[h + 4 >> 2];
          b3[g2 + 8 >> 2] = b3[h + 8 >> 2];
          h = 0;
        }
        t2 = h;
        T = u3;
        return t2 | 0;
      }
      function Lc(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0;
        q2 = T;
        T = T + 48 | 0;
        k = q2 + 36 | 0;
        h = q2 + 24 | 0;
        i = q2 + 12 | 0;
        j = q2;
        f2 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        n = Td(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        n = n & 127;
        if (n >>> 0 > 121) {
          e3 = 5;
          T = q2;
          return e3 | 0;
        }
        l = oa(n) | 0;
        Ud(f2 | 0, 0, 52) | 0;
        r2 = H() | 0 | 134225919;
        g2 = e3;
        b3[g2 >> 2] = -1;
        b3[g2 + 4 >> 2] = r2;
        if (!f2) {
          f2 = Ra(d3) | 0;
          if ((f2 | 0) == 7) {
            r2 = 1;
            T = q2;
            return r2 | 0;
          }
          f2 = va(n, f2) | 0;
          if ((f2 | 0) == 127) {
            r2 = 1;
            T = q2;
            return r2 | 0;
          }
          o = Ud(f2 | 0, 0, 45) | 0;
          p2 = H() | 0;
          n = e3;
          p2 = b3[n + 4 >> 2] & -1040385 | p2;
          r2 = e3;
          b3[r2 >> 2] = b3[n >> 2] | o;
          b3[r2 + 4 >> 2] = p2;
          r2 = 0;
          T = q2;
          return r2 | 0;
        }
        b3[k >> 2] = b3[d3 >> 2];
        b3[k + 4 >> 2] = b3[d3 + 4 >> 2];
        b3[k + 8 >> 2] = b3[d3 + 8 >> 2];
        d3 = f2;
        while (1) {
          g2 = d3;
          d3 = d3 + -1 | 0;
          b3[h >> 2] = b3[k >> 2];
          b3[h + 4 >> 2] = b3[k + 4 >> 2];
          b3[h + 8 >> 2] = b3[k + 8 >> 2];
          if (!(Yb(g2) | 0)) {
            f2 = Ta(k) | 0;
            if (f2 | 0) {
              d3 = 13;
              break;
            }
            b3[i >> 2] = b3[k >> 2];
            b3[i + 4 >> 2] = b3[k + 4 >> 2];
            b3[i + 8 >> 2] = b3[k + 8 >> 2];
            Xa(i);
          } else {
            f2 = Sa(k) | 0;
            if (f2 | 0) {
              d3 = 13;
              break;
            }
            b3[i >> 2] = b3[k >> 2];
            b3[i + 4 >> 2] = b3[k + 4 >> 2];
            b3[i + 8 >> 2] = b3[k + 8 >> 2];
            Wa(i);
          }
          Pa(h, i, j);
          Ma(j);
          f2 = e3;
          t2 = b3[f2 >> 2] | 0;
          f2 = b3[f2 + 4 >> 2] | 0;
          u3 = (15 - g2 | 0) * 3 | 0;
          s2 = Ud(7, 0, u3 | 0) | 0;
          f2 = f2 & ~(H() | 0);
          u3 = Ud(Ra(j) | 0, 0, u3 | 0) | 0;
          f2 = H() | 0 | f2;
          r2 = e3;
          b3[r2 >> 2] = u3 | t2 & ~s2;
          b3[r2 + 4 >> 2] = f2;
          if ((g2 | 0) <= 1) {
            d3 = 14;
            break;
          }
        }
        a: do {
          if ((d3 | 0) != 13) {
            if ((d3 | 0) == 14) {
              if (((b3[k >> 2] | 0) <= 1 ? (b3[k + 4 >> 2] | 0) <= 1 : 0) ? (b3[k + 8 >> 2] | 0) <= 1 : 0) {
                d3 = Ra(k) | 0;
                f2 = va(n, d3) | 0;
                if ((f2 | 0) == 127) {
                  j = 0;
                } else {
                  j = oa(f2) | 0;
                }
                b: do {
                  if (!d3) {
                    if ((l | 0) != 0 & (j | 0) != 0) {
                      d3 = Sb(a4, c3) | 0;
                      g2 = e3;
                      g2 = Sb(b3[g2 >> 2] | 0, b3[g2 + 4 >> 2] | 0) | 0;
                      if ((d3 | 0) == 7 | (g2 | 0) == 7) {
                        f2 = 5;
                        break a;
                      }
                      g2 = b3[21376 + (d3 * 28 | 0) + (g2 << 2) >> 2] | 0;
                      if ((g2 | 0) < 0) {
                        f2 = 5;
                        break a;
                      }
                      if (!g2) {
                        d3 = 59;
                      } else {
                        i = e3;
                        d3 = 0;
                        h = b3[i >> 2] | 0;
                        i = b3[i + 4 >> 2] | 0;
                        do {
                          h = Ub(h, i) | 0;
                          i = H() | 0;
                          u3 = e3;
                          b3[u3 >> 2] = h;
                          b3[u3 + 4 >> 2] = i;
                          d3 = d3 + 1 | 0;
                        } while ((d3 | 0) < (g2 | 0));
                        d3 = 58;
                      }
                    } else {
                      d3 = 58;
                    }
                  } else {
                    if (l) {
                      f2 = Sb(a4, c3) | 0;
                      if ((f2 | 0) == 7) {
                        f2 = 5;
                        break a;
                      }
                      g2 = b3[21376 + (f2 * 28 | 0) + (d3 << 2) >> 2] | 0;
                      if ((g2 | 0) > 0) {
                        f2 = d3;
                        d3 = 0;
                        do {
                          f2 = $a(f2) | 0;
                          d3 = d3 + 1 | 0;
                        } while ((d3 | 0) != (g2 | 0));
                      } else {
                        f2 = d3;
                      }
                      if ((f2 | 0) == 1) {
                        f2 = 9;
                        break a;
                      }
                      d3 = va(n, f2) | 0;
                      if ((d3 | 0) == 127) {
                        I(27648, 27538, 411, 27678);
                      }
                      if (!(oa(d3) | 0)) {
                        p2 = d3;
                        o = g2;
                        m = f2;
                      } else {
                        I(27693, 27538, 412, 27678);
                      }
                    } else {
                      p2 = f2;
                      o = 0;
                      m = d3;
                    }
                    i = b3[4272 + (n * 28 | 0) + (m << 2) >> 2] | 0;
                    if ((i | 0) <= -1) {
                      I(27724, 27538, 419, 27678);
                    }
                    if (!j) {
                      if ((o | 0) < 0) {
                        f2 = 5;
                        break a;
                      }
                      if (o | 0) {
                        g2 = e3;
                        f2 = 0;
                        d3 = b3[g2 >> 2] | 0;
                        g2 = b3[g2 + 4 >> 2] | 0;
                        do {
                          d3 = Ub(d3, g2) | 0;
                          g2 = H() | 0;
                          u3 = e3;
                          b3[u3 >> 2] = d3;
                          b3[u3 + 4 >> 2] = g2;
                          f2 = f2 + 1 | 0;
                        } while ((f2 | 0) < (o | 0));
                      }
                      if ((i | 0) <= 0) {
                        f2 = p2;
                        d3 = 58;
                        break;
                      }
                      g2 = e3;
                      f2 = 0;
                      d3 = b3[g2 >> 2] | 0;
                      g2 = b3[g2 + 4 >> 2] | 0;
                      while (1) {
                        d3 = Ub(d3, g2) | 0;
                        g2 = H() | 0;
                        u3 = e3;
                        b3[u3 >> 2] = d3;
                        b3[u3 + 4 >> 2] = g2;
                        f2 = f2 + 1 | 0;
                        if ((f2 | 0) == (i | 0)) {
                          f2 = p2;
                          d3 = 58;
                          break b;
                        }
                      }
                    }
                    h = wa(p2, n) | 0;
                    if ((h | 0) == 7) {
                      I(27514, 27538, 428, 27678);
                    }
                    f2 = e3;
                    d3 = b3[f2 >> 2] | 0;
                    f2 = b3[f2 + 4 >> 2] | 0;
                    if ((i | 0) > 0) {
                      g2 = 0;
                      do {
                        d3 = Ub(d3, f2) | 0;
                        f2 = H() | 0;
                        u3 = e3;
                        b3[u3 >> 2] = d3;
                        b3[u3 + 4 >> 2] = f2;
                        g2 = g2 + 1 | 0;
                      } while ((g2 | 0) != (i | 0));
                    }
                    f2 = Sb(d3, f2) | 0;
                    if ((f2 | 0) == 7) {
                      I(27795, 27538, 440, 27678);
                    }
                    d3 = pa(p2) | 0;
                    d3 = b3[(d3 ? 21792 : 21584) + (h * 28 | 0) + (f2 << 2) >> 2] | 0;
                    if ((d3 | 0) < 0) {
                      I(27795, 27538, 454, 27678);
                    }
                    if (!d3) {
                      f2 = p2;
                      d3 = 58;
                    } else {
                      h = e3;
                      f2 = 0;
                      g2 = b3[h >> 2] | 0;
                      h = b3[h + 4 >> 2] | 0;
                      do {
                        g2 = Tb(g2, h) | 0;
                        h = H() | 0;
                        u3 = e3;
                        b3[u3 >> 2] = g2;
                        b3[u3 + 4 >> 2] = h;
                        f2 = f2 + 1 | 0;
                      } while ((f2 | 0) < (d3 | 0));
                      f2 = p2;
                      d3 = 58;
                    }
                  }
                } while (0);
                if ((d3 | 0) == 58) {
                  if (j) {
                    d3 = 59;
                  }
                }
                if ((d3 | 0) == 59) {
                  u3 = e3;
                  if ((Sb(b3[u3 >> 2] | 0, b3[u3 + 4 >> 2] | 0) | 0) == 1) {
                    f2 = 9;
                    break;
                  }
                }
                u3 = e3;
                s2 = b3[u3 >> 2] | 0;
                u3 = b3[u3 + 4 >> 2] & -1040385;
                t2 = Ud(f2 | 0, 0, 45) | 0;
                u3 = u3 | (H() | 0);
                f2 = e3;
                b3[f2 >> 2] = s2 | t2;
                b3[f2 + 4 >> 2] = u3;
                f2 = 0;
              } else {
                f2 = 1;
              }
            }
          }
        } while (0);
        u3 = f2;
        T = q2;
        return u3 | 0;
      }
      function Mc(a4, b4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0;
        h = T;
        T = T + 16 | 0;
        g2 = h;
        if (!e3) {
          a4 = Kc(a4, b4, c3, d3, g2) | 0;
          if (!a4) {
            eb(g2, f2);
            a4 = 0;
          }
        } else {
          a4 = 15;
        }
        T = h;
        return a4 | 0;
      }
      function Nc(a4, b4, c3, d3, e3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        g2 = T;
        T = T + 16 | 0;
        f2 = g2;
        if (!d3) {
          c3 = fb(c3, f2) | 0;
          if (!c3) {
            c3 = Lc(a4, b4, f2, e3) | 0;
          }
        } else {
          c3 = 15;
        }
        T = g2;
        return c3 | 0;
      }
      function Oc(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 32 | 0;
        h = j + 12 | 0;
        i = j;
        g2 = Kc(a4, c3, a4, c3, h) | 0;
        if (g2 | 0) {
          i = g2;
          T = j;
          return i | 0;
        }
        a4 = Kc(a4, c3, d3, e3, i) | 0;
        if (a4 | 0) {
          i = a4;
          T = j;
          return i | 0;
        }
        h = db(h, i) | 0;
        i = f2;
        b3[i >> 2] = h;
        b3[i + 4 >> 2] = ((h | 0) < 0) << 31 >> 31;
        i = 0;
        T = j;
        return i | 0;
      }
      function Pc(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 32 | 0;
        h = j + 12 | 0;
        i = j;
        g2 = Kc(a4, c3, a4, c3, h) | 0;
        if (!g2) {
          g2 = Kc(a4, c3, d3, e3, i) | 0;
          if (!g2) {
            e3 = db(h, i) | 0;
            e3 = Jd(e3 | 0, ((e3 | 0) < 0) << 31 >> 31 | 0, 1, 0) | 0;
            h = H() | 0;
            i = f2;
            b3[i >> 2] = e3;
            b3[i + 4 >> 2] = h;
            i = 0;
            T = j;
            return i | 0;
          }
        }
        i = g2;
        T = j;
        return i | 0;
      }
      function Qc(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0;
        z2 = T;
        T = T + 48 | 0;
        x2 = z2 + 24 | 0;
        h = z2 + 12 | 0;
        y2 = z2;
        g2 = Kc(a4, c3, a4, c3, x2) | 0;
        if (!g2) {
          g2 = Kc(a4, c3, d3, e3, h) | 0;
          if (!g2) {
            v3 = db(x2, h) | 0;
            w3 = ((v3 | 0) < 0) << 31 >> 31;
            b3[x2 >> 2] = 0;
            b3[x2 + 4 >> 2] = 0;
            b3[x2 + 8 >> 2] = 0;
            b3[h >> 2] = 0;
            b3[h + 4 >> 2] = 0;
            b3[h + 8 >> 2] = 0;
            if (Kc(a4, c3, a4, c3, x2) | 0) {
              I(27795, 27538, 692, 27747);
            }
            if (Kc(a4, c3, d3, e3, h) | 0) {
              I(27795, 27538, 697, 27747);
            }
            gb(x2);
            gb(h);
            l = (v3 | 0) == 0 ? 0 : 1 / +(v3 | 0);
            d3 = b3[x2 >> 2] | 0;
            r2 = l * +((b3[h >> 2] | 0) - d3 | 0);
            s2 = x2 + 4 | 0;
            e3 = b3[s2 >> 2] | 0;
            t2 = l * +((b3[h + 4 >> 2] | 0) - e3 | 0);
            u3 = x2 + 8 | 0;
            g2 = b3[u3 >> 2] | 0;
            l = l * +((b3[h + 8 >> 2] | 0) - g2 | 0);
            b3[y2 >> 2] = d3;
            m = y2 + 4 | 0;
            b3[m >> 2] = e3;
            n = y2 + 8 | 0;
            b3[n >> 2] = g2;
            a: do {
              if ((v3 | 0) < 0) {
                g2 = 0;
              } else {
                o = 0;
                p2 = 0;
                while (1) {
                  j = +(p2 >>> 0) + 4294967296 * +(o | 0);
                  A3 = r2 * j + +(d3 | 0);
                  i = t2 * j + +(e3 | 0);
                  j = l * j + +(g2 | 0);
                  d3 = ~~+Yd(+A3);
                  h = ~~+Yd(+i);
                  g2 = ~~+Yd(+j);
                  A3 = +q(+(+(d3 | 0) - A3));
                  i = +q(+(+(h | 0) - i));
                  j = +q(+(+(g2 | 0) - j));
                  do {
                    if (!(A3 > i & A3 > j)) {
                      k = 0 - d3 | 0;
                      if (i > j) {
                        e3 = k - g2 | 0;
                        break;
                      } else {
                        e3 = h;
                        g2 = k - h | 0;
                        break;
                      }
                    } else {
                      d3 = 0 - (h + g2) | 0;
                      e3 = h;
                    }
                  } while (0);
                  b3[y2 >> 2] = d3;
                  b3[m >> 2] = e3;
                  b3[n >> 2] = g2;
                  hb(y2);
                  g2 = Lc(a4, c3, y2, f2 + (p2 << 3) | 0) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  if (!((o | 0) < (w3 | 0) | (o | 0) == (w3 | 0) & p2 >>> 0 < v3 >>> 0)) {
                    g2 = 0;
                    break a;
                  }
                  d3 = Jd(p2 | 0, o | 0, 1, 0) | 0;
                  e3 = H() | 0;
                  o = e3;
                  p2 = d3;
                  d3 = b3[x2 >> 2] | 0;
                  e3 = b3[s2 >> 2] | 0;
                  g2 = b3[u3 >> 2] | 0;
                }
              }
            } while (0);
            y2 = g2;
            T = z2;
            return y2 | 0;
          }
        }
        y2 = g2;
        T = z2;
        return y2 | 0;
      }
      function Rc(a4, b4, c3, d3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        if ((c3 | 0) == 0 & (d3 | 0) == 0) {
          e3 = 0;
          f2 = 1;
          G2(e3 | 0);
          return f2 | 0;
        }
        f2 = a4;
        e3 = b4;
        a4 = 1;
        b4 = 0;
        do {
          g2 = (c3 & 1 | 0) == 0 & true;
          a4 = Pd((g2 ? 1 : f2) | 0, (g2 ? 0 : e3) | 0, a4 | 0, b4 | 0) | 0;
          b4 = H() | 0;
          c3 = Sd(c3 | 0, d3 | 0, 1) | 0;
          d3 = H() | 0;
          f2 = Pd(f2 | 0, e3 | 0, f2 | 0, e3 | 0) | 0;
          e3 = H() | 0;
        } while (!((c3 | 0) == 0 & (d3 | 0) == 0));
        G2(b4 | 0);
        return a4 | 0;
      }
      function Sc(a4, c3, d3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T;
        T = T + 16 | 0;
        h = j;
        i = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        do {
          if (!i) {
            g2 = Td(a4 | 0, c3 | 0, 45) | 0;
            H() | 0;
            g2 = g2 & 127;
            if (g2 >>> 0 > 121) {
              i = 5;
              T = j;
              return i | 0;
            } else {
              h = 22064 + (g2 << 5) | 0;
              b3[d3 >> 2] = b3[h >> 2];
              b3[d3 + 4 >> 2] = b3[h + 4 >> 2];
              b3[d3 + 8 >> 2] = b3[h + 8 >> 2];
              b3[d3 + 12 >> 2] = b3[h + 12 >> 2];
              b3[d3 + 16 >> 2] = b3[h + 16 >> 2];
              b3[d3 + 20 >> 2] = b3[h + 20 >> 2];
              b3[d3 + 24 >> 2] = b3[h + 24 >> 2];
              b3[d3 + 28 >> 2] = b3[h + 28 >> 2];
              break;
            }
          } else {
            g2 = ac(a4, c3, h) | 0;
            if (!g2) {
              l = +e2[h >> 3];
              k = 1 / +t(+l);
              m = +e2[25968 + (i << 3) >> 3];
              e2[d3 >> 3] = l + m;
              e2[d3 + 8 >> 3] = l - m;
              l = +e2[h + 8 >> 3];
              k = m * k;
              e2[d3 + 16 >> 3] = k + l;
              e2[d3 + 24 >> 3] = l - k;
              break;
            }
            i = g2;
            T = j;
            return i | 0;
          }
        } while (0);
        Ja(d3, f2 ? 1.4 : 1.1);
        f2 = 26096 + (i << 3) | 0;
        if ((b3[f2 >> 2] | 0) == (a4 | 0) ? (b3[f2 + 4 >> 2] | 0) == (c3 | 0) : 0) {
          e2[d3 >> 3] = 1.5707963267948966;
        }
        i = 26224 + (i << 3) | 0;
        if ((b3[i >> 2] | 0) == (a4 | 0) ? (b3[i + 4 >> 2] | 0) == (c3 | 0) : 0) {
          e2[d3 + 8 >> 3] = -1.5707963267948966;
        }
        if (!(+e2[d3 >> 3] == 1.5707963267948966) ? !(+e2[d3 + 8 >> 3] == -1.5707963267948966) : 0) {
          i = 0;
          T = j;
          return i | 0;
        }
        e2[d3 + 16 >> 3] = 3.141592653589793;
        e2[d3 + 24 >> 3] = -3.141592653589793;
        i = 0;
        T = j;
        return i | 0;
      }
      function Tc(c3, d3, e3, f2) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        l = T;
        T = T + 48 | 0;
        i = l + 32 | 0;
        h = l + 40 | 0;
        j = l;
        Hb(i, 0, 0, 0);
        k = b3[i >> 2] | 0;
        i = b3[i + 4 >> 2] | 0;
        do {
          if (e3 >>> 0 <= 15) {
            g2 = _c(f2) | 0;
            if (g2 | 0) {
              f2 = j;
              b3[f2 >> 2] = 0;
              b3[f2 + 4 >> 2] = 0;
              b3[j + 8 >> 2] = g2;
              b3[j + 12 >> 2] = -1;
              f2 = j + 16 | 0;
              k = j + 29 | 0;
              b3[f2 >> 2] = 0;
              b3[f2 + 4 >> 2] = 0;
              b3[f2 + 8 >> 2] = 0;
              a3[f2 + 12 >> 0] = 0;
              a3[k >> 0] = a3[h >> 0] | 0;
              a3[k + 1 >> 0] = a3[h + 1 >> 0] | 0;
              a3[k + 2 >> 0] = a3[h + 2 >> 0] | 0;
              break;
            }
            g2 = Id((b3[d3 + 8 >> 2] | 0) + 1 | 0, 32) | 0;
            if (!g2) {
              f2 = j;
              b3[f2 >> 2] = 0;
              b3[f2 + 4 >> 2] = 0;
              b3[j + 8 >> 2] = 13;
              b3[j + 12 >> 2] = -1;
              f2 = j + 16 | 0;
              k = j + 29 | 0;
              b3[f2 >> 2] = 0;
              b3[f2 + 4 >> 2] = 0;
              b3[f2 + 8 >> 2] = 0;
              a3[f2 + 12 >> 0] = 0;
              a3[k >> 0] = a3[h >> 0] | 0;
              a3[k + 1 >> 0] = a3[h + 1 >> 0] | 0;
              a3[k + 2 >> 0] = a3[h + 2 >> 0] | 0;
              break;
            } else {
              $c(d3, g2);
              m = j;
              b3[m >> 2] = k;
              b3[m + 4 >> 2] = i;
              b3[j + 8 >> 2] = 0;
              b3[j + 12 >> 2] = e3;
              b3[j + 16 >> 2] = f2;
              b3[j + 20 >> 2] = d3;
              b3[j + 24 >> 2] = g2;
              a3[j + 28 >> 0] = 0;
              k = j + 29 | 0;
              a3[k >> 0] = a3[h >> 0] | 0;
              a3[k + 1 >> 0] = a3[h + 1 >> 0] | 0;
              a3[k + 2 >> 0] = a3[h + 2 >> 0] | 0;
              break;
            }
          } else {
            k = j;
            b3[k >> 2] = 0;
            b3[k + 4 >> 2] = 0;
            b3[j + 8 >> 2] = 4;
            b3[j + 12 >> 2] = -1;
            k = j + 16 | 0;
            m = j + 29 | 0;
            b3[k >> 2] = 0;
            b3[k + 4 >> 2] = 0;
            b3[k + 8 >> 2] = 0;
            a3[k + 12 >> 0] = 0;
            a3[m >> 0] = a3[h >> 0] | 0;
            a3[m + 1 >> 0] = a3[h + 1 >> 0] | 0;
            a3[m + 2 >> 0] = a3[h + 2 >> 0] | 0;
          }
        } while (0);
        Uc(j);
        b3[c3 >> 2] = b3[j >> 2];
        b3[c3 + 4 >> 2] = b3[j + 4 >> 2];
        b3[c3 + 8 >> 2] = b3[j + 8 >> 2];
        b3[c3 + 12 >> 2] = b3[j + 12 >> 2];
        b3[c3 + 16 >> 2] = b3[j + 16 >> 2];
        b3[c3 + 20 >> 2] = b3[j + 20 >> 2];
        b3[c3 + 24 >> 2] = b3[j + 24 >> 2];
        b3[c3 + 28 >> 2] = b3[j + 28 >> 2];
        T = l;
        return;
      }
      function Uc(c3) {
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0;
        w3 = T;
        T = T + 336 | 0;
        p2 = w3 + 168 | 0;
        q2 = w3;
        f2 = c3;
        e3 = b3[f2 >> 2] | 0;
        f2 = b3[f2 + 4 >> 2] | 0;
        if ((e3 | 0) == 0 & (f2 | 0) == 0) {
          T = w3;
          return;
        }
        d3 = c3 + 28 | 0;
        if (!(a3[d3 >> 0] | 0)) {
          a3[d3 >> 0] = 1;
        } else {
          e3 = Vc(e3, f2) | 0;
          f2 = H() | 0;
        }
        v3 = c3 + 20 | 0;
        if (!(b3[b3[v3 >> 2] >> 2] | 0)) {
          d3 = c3 + 24 | 0;
          e3 = b3[d3 >> 2] | 0;
          if (e3 | 0) {
            Hd(e3);
          }
          u3 = c3;
          b3[u3 >> 2] = 0;
          b3[u3 + 4 >> 2] = 0;
          b3[c3 + 8 >> 2] = 0;
          b3[v3 >> 2] = 0;
          b3[c3 + 12 >> 2] = -1;
          b3[c3 + 16 >> 2] = 0;
          b3[d3 >> 2] = 0;
          T = w3;
          return;
        }
        u3 = c3 + 16 | 0;
        d3 = b3[u3 >> 2] | 0;
        g2 = d3 & 15;
        a: do {
          if (!((e3 | 0) == 0 & (f2 | 0) == 0)) {
            r2 = c3 + 12 | 0;
            n = (g2 | 0) == 3;
            m = d3 & 255;
            k = (g2 | 1 | 0) == 3;
            o = c3 + 24 | 0;
            l = (g2 + -1 | 0) >>> 0 < 3;
            i = (g2 | 2 | 0) == 3;
            j = q2 + 8 | 0;
            b: while (1) {
              h = Td(e3 | 0, f2 | 0, 52) | 0;
              H() | 0;
              h = h & 15;
              if ((h | 0) == (b3[r2 >> 2] | 0)) {
                switch (m & 15) {
                  case 0:
                  case 2:
                  case 3: {
                    g2 = ac(e3, f2, p2) | 0;
                    if (g2 | 0) {
                      s2 = 15;
                      break b;
                    }
                    if (ad(b3[v3 >> 2] | 0, b3[o >> 2] | 0, p2) | 0) {
                      s2 = 19;
                      break b;
                    }
                    break;
                  }
                  default:
                }
                if (k ? (g2 = b3[(b3[v3 >> 2] | 0) + 4 >> 2] | 0, b3[p2 >> 2] = b3[g2 >> 2], b3[p2 + 4 >> 2] = b3[g2 + 4 >> 2], b3[p2 + 8 >> 2] = b3[g2 + 8 >> 2], b3[p2 + 12 >> 2] = b3[g2 + 12 >> 2], Ca(26832, p2) | 0) : 0) {
                  if (Zb(b3[(b3[v3 >> 2] | 0) + 4 >> 2] | 0, h, q2) | 0) {
                    s2 = 25;
                    break;
                  }
                  g2 = q2;
                  if ((b3[g2 >> 2] | 0) == (e3 | 0) ? (b3[g2 + 4 >> 2] | 0) == (f2 | 0) : 0) {
                    s2 = 29;
                    break;
                  }
                }
                if (l) {
                  g2 = bc(e3, f2, p2) | 0;
                  if (g2 | 0) {
                    s2 = 32;
                    break;
                  }
                  if (Sc(e3, f2, q2, 0) | 0) {
                    s2 = 36;
                    break;
                  }
                  if (i ? bd(b3[v3 >> 2] | 0, b3[o >> 2] | 0, p2, q2) | 0 : 0) {
                    s2 = 42;
                    break;
                  }
                  if (k ? dd(b3[v3 >> 2] | 0, b3[o >> 2] | 0, p2, q2) | 0 : 0) {
                    s2 = 42;
                    break;
                  }
                }
                if (n) {
                  d3 = Sc(e3, f2, p2, 1) | 0;
                  g2 = b3[o >> 2] | 0;
                  if (d3 | 0) {
                    s2 = 45;
                    break;
                  }
                  if (Da(g2, p2) | 0) {
                    Ga(q2, p2);
                    if (Fa(p2, b3[o >> 2] | 0) | 0) {
                      s2 = 53;
                      break;
                    }
                    if (ad(b3[v3 >> 2] | 0, b3[o >> 2] | 0, j) | 0) {
                      s2 = 53;
                      break;
                    }
                    if (dd(b3[v3 >> 2] | 0, b3[o >> 2] | 0, q2, p2) | 0) {
                      s2 = 53;
                      break;
                    }
                  }
                }
              }
              do {
                if ((h | 0) < (b3[r2 >> 2] | 0)) {
                  d3 = Sc(e3, f2, p2, 1) | 0;
                  g2 = b3[o >> 2] | 0;
                  if (d3 | 0) {
                    s2 = 58;
                    break b;
                  }
                  if (!(Da(g2, p2) | 0)) {
                    s2 = 73;
                    break;
                  }
                  if (Fa(b3[o >> 2] | 0, p2) | 0 ? (Ga(q2, p2), bd(b3[v3 >> 2] | 0, b3[o >> 2] | 0, q2, p2) | 0) : 0) {
                    s2 = 65;
                    break b;
                  }
                  e3 = Nb(e3, f2, h + 1 | 0, q2) | 0;
                  if (e3 | 0) {
                    s2 = 67;
                    break b;
                  }
                  f2 = q2;
                  e3 = b3[f2 >> 2] | 0;
                  f2 = b3[f2 + 4 >> 2] | 0;
                } else {
                  s2 = 73;
                }
              } while (0);
              if ((s2 | 0) == 73) {
                s2 = 0;
                e3 = Vc(e3, f2) | 0;
                f2 = H() | 0;
              }
              if ((e3 | 0) == 0 & (f2 | 0) == 0) {
                t2 = o;
                break a;
              }
            }
            switch (s2 | 0) {
              case 15: {
                d3 = b3[o >> 2] | 0;
                if (d3 | 0) {
                  Hd(d3);
                }
                s2 = c3;
                b3[s2 >> 2] = 0;
                b3[s2 + 4 >> 2] = 0;
                b3[v3 >> 2] = 0;
                b3[r2 >> 2] = -1;
                b3[u3 >> 2] = 0;
                b3[o >> 2] = 0;
                b3[c3 + 8 >> 2] = g2;
                s2 = 20;
                break;
              }
              case 19: {
                b3[c3 >> 2] = e3;
                b3[c3 + 4 >> 2] = f2;
                s2 = 20;
                break;
              }
              case 25: {
                I(27795, 27761, 470, 27772);
                break;
              }
              case 29: {
                b3[c3 >> 2] = e3;
                b3[c3 + 4 >> 2] = f2;
                T = w3;
                return;
              }
              case 32: {
                d3 = b3[o >> 2] | 0;
                if (d3 | 0) {
                  Hd(d3);
                }
                t2 = c3;
                b3[t2 >> 2] = 0;
                b3[t2 + 4 >> 2] = 0;
                b3[v3 >> 2] = 0;
                b3[r2 >> 2] = -1;
                b3[u3 >> 2] = 0;
                b3[o >> 2] = 0;
                b3[c3 + 8 >> 2] = g2;
                T = w3;
                return;
              }
              case 36: {
                I(27795, 27761, 493, 27772);
                break;
              }
              case 42: {
                b3[c3 >> 2] = e3;
                b3[c3 + 4 >> 2] = f2;
                T = w3;
                return;
              }
              case 45: {
                if (g2 | 0) {
                  Hd(g2);
                }
                s2 = c3;
                b3[s2 >> 2] = 0;
                b3[s2 + 4 >> 2] = 0;
                b3[v3 >> 2] = 0;
                b3[r2 >> 2] = -1;
                b3[u3 >> 2] = 0;
                b3[o >> 2] = 0;
                b3[c3 + 8 >> 2] = d3;
                s2 = 55;
                break;
              }
              case 53: {
                b3[c3 >> 2] = e3;
                b3[c3 + 4 >> 2] = f2;
                s2 = 55;
                break;
              }
              case 58: {
                if (g2 | 0) {
                  Hd(g2);
                }
                s2 = c3;
                b3[s2 >> 2] = 0;
                b3[s2 + 4 >> 2] = 0;
                b3[v3 >> 2] = 0;
                b3[r2 >> 2] = -1;
                b3[u3 >> 2] = 0;
                b3[o >> 2] = 0;
                b3[c3 + 8 >> 2] = d3;
                s2 = 71;
                break;
              }
              case 65: {
                b3[c3 >> 2] = e3;
                b3[c3 + 4 >> 2] = f2;
                s2 = 71;
                break;
              }
              case 67: {
                d3 = b3[o >> 2] | 0;
                if (d3 | 0) {
                  Hd(d3);
                }
                t2 = c3;
                b3[t2 >> 2] = 0;
                b3[t2 + 4 >> 2] = 0;
                b3[v3 >> 2] = 0;
                b3[r2 >> 2] = -1;
                b3[u3 >> 2] = 0;
                b3[o >> 2] = 0;
                b3[c3 + 8 >> 2] = e3;
                T = w3;
                return;
              }
            }
            if ((s2 | 0) == 20) {
              T = w3;
              return;
            } else if ((s2 | 0) == 55) {
              T = w3;
              return;
            } else if ((s2 | 0) == 71) {
              T = w3;
              return;
            }
          } else {
            t2 = c3 + 24 | 0;
          }
        } while (0);
        d3 = b3[t2 >> 2] | 0;
        if (d3 | 0) {
          Hd(d3);
        }
        s2 = c3;
        b3[s2 >> 2] = 0;
        b3[s2 + 4 >> 2] = 0;
        b3[c3 + 8 >> 2] = 0;
        b3[v3 >> 2] = 0;
        b3[c3 + 12 >> 2] = -1;
        b3[u3 >> 2] = 0;
        b3[t2 >> 2] = 0;
        T = w3;
        return;
      }
      function Vc(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        m = T;
        T = T + 16 | 0;
        l = m;
        e3 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        d3 = Td(a4 | 0, c3 | 0, 45) | 0;
        H() | 0;
        do {
          if (e3) {
            while (1) {
              d3 = Ud(e3 + 4095 | 0, 0, 52) | 0;
              f2 = H() | 0 | c3 & -15728641;
              g2 = (15 - e3 | 0) * 3 | 0;
              h = Ud(7, 0, g2 | 0) | 0;
              i = H() | 0;
              d3 = d3 | a4 | h;
              f2 = f2 | i;
              j = Td(a4 | 0, c3 | 0, g2 | 0) | 0;
              H() | 0;
              j = j & 7;
              e3 = e3 + -1 | 0;
              if (j >>> 0 < 6) {
                break;
              }
              if (!e3) {
                k = 4;
                break;
              } else {
                c3 = f2;
                a4 = d3;
              }
            }
            if ((k | 0) == 4) {
              d3 = Td(d3 | 0, f2 | 0, 45) | 0;
              H() | 0;
              break;
            }
            l = (j | 0) == 0 & (Kb(d3, f2) | 0) != 0;
            l = Ud((l ? 2 : 1) + j | 0, 0, g2 | 0) | 0;
            k = H() | 0 | c3 & ~i;
            l = l | a4 & ~h;
            G2(k | 0);
            T = m;
            return l | 0;
          }
        } while (0);
        d3 = d3 & 127;
        if (d3 >>> 0 > 120) {
          k = 0;
          l = 0;
          G2(k | 0);
          T = m;
          return l | 0;
        }
        Hb(l, 0, d3 + 1 | 0, 0);
        k = b3[l + 4 >> 2] | 0;
        l = b3[l >> 2] | 0;
        G2(k | 0);
        T = m;
        return l | 0;
      }
      function Wc(a4, c3, d3, e3, f2, g2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0;
        r2 = T;
        T = T + 160 | 0;
        m = r2 + 80 | 0;
        i = r2 + 64 | 0;
        n = r2 + 112 | 0;
        q2 = r2;
        Tc(m, a4, c3, d3);
        k = m;
        ic(i, b3[k >> 2] | 0, b3[k + 4 >> 2] | 0, c3);
        k = i;
        j = b3[k >> 2] | 0;
        k = b3[k + 4 >> 2] | 0;
        h = b3[m + 8 >> 2] | 0;
        o = n + 4 | 0;
        b3[o >> 2] = b3[m >> 2];
        b3[o + 4 >> 2] = b3[m + 4 >> 2];
        b3[o + 8 >> 2] = b3[m + 8 >> 2];
        b3[o + 12 >> 2] = b3[m + 12 >> 2];
        b3[o + 16 >> 2] = b3[m + 16 >> 2];
        b3[o + 20 >> 2] = b3[m + 20 >> 2];
        b3[o + 24 >> 2] = b3[m + 24 >> 2];
        b3[o + 28 >> 2] = b3[m + 28 >> 2];
        o = q2;
        b3[o >> 2] = j;
        b3[o + 4 >> 2] = k;
        o = q2 + 8 | 0;
        b3[o >> 2] = h;
        a4 = q2 + 12 | 0;
        c3 = n;
        d3 = a4 + 36 | 0;
        do {
          b3[a4 >> 2] = b3[c3 >> 2];
          a4 = a4 + 4 | 0;
          c3 = c3 + 4 | 0;
        } while ((a4 | 0) < (d3 | 0));
        n = q2 + 48 | 0;
        b3[n >> 2] = b3[i >> 2];
        b3[n + 4 >> 2] = b3[i + 4 >> 2];
        b3[n + 8 >> 2] = b3[i + 8 >> 2];
        b3[n + 12 >> 2] = b3[i + 12 >> 2];
        if ((j | 0) == 0 & (k | 0) == 0) {
          q2 = h;
          T = r2;
          return q2 | 0;
        }
        d3 = q2 + 16 | 0;
        l = q2 + 24 | 0;
        m = q2 + 28 | 0;
        h = 0;
        i = 0;
        c3 = j;
        a4 = k;
        do {
          if (!((h | 0) < (f2 | 0) | (h | 0) == (f2 | 0) & i >>> 0 < e3 >>> 0)) {
            p2 = 4;
            break;
          }
          k = i;
          i = Jd(i | 0, h | 0, 1, 0) | 0;
          h = H() | 0;
          k = g2 + (k << 3) | 0;
          b3[k >> 2] = c3;
          b3[k + 4 >> 2] = a4;
          kc(n);
          a4 = n;
          c3 = b3[a4 >> 2] | 0;
          a4 = b3[a4 + 4 >> 2] | 0;
          if ((c3 | 0) == 0 & (a4 | 0) == 0) {
            Uc(d3);
            c3 = d3;
            a4 = b3[c3 >> 2] | 0;
            c3 = b3[c3 + 4 >> 2] | 0;
            if ((a4 | 0) == 0 & (c3 | 0) == 0) {
              p2 = 10;
              break;
            }
            jc(a4, c3, b3[m >> 2] | 0, n);
            a4 = n;
            c3 = b3[a4 >> 2] | 0;
            a4 = b3[a4 + 4 >> 2] | 0;
          }
          k = q2;
          b3[k >> 2] = c3;
          b3[k + 4 >> 2] = a4;
        } while (!((c3 | 0) == 0 & (a4 | 0) == 0));
        if ((p2 | 0) == 4) {
          a4 = q2 + 40 | 0;
          c3 = b3[a4 >> 2] | 0;
          if (c3 | 0) {
            Hd(c3);
          }
          p2 = q2 + 16 | 0;
          b3[p2 >> 2] = 0;
          b3[p2 + 4 >> 2] = 0;
          b3[l >> 2] = 0;
          b3[q2 + 36 >> 2] = 0;
          b3[m >> 2] = -1;
          b3[q2 + 32 >> 2] = 0;
          b3[a4 >> 2] = 0;
          jc(0, 0, 0, n);
          b3[q2 >> 2] = 0;
          b3[q2 + 4 >> 2] = 0;
          b3[o >> 2] = 0;
          q2 = 14;
          T = r2;
          return q2 | 0;
        } else if ((p2 | 0) == 10) {
          b3[q2 >> 2] = 0;
          b3[q2 + 4 >> 2] = 0;
          b3[o >> 2] = b3[l >> 2];
        }
        q2 = b3[o >> 2] | 0;
        T = r2;
        return q2 | 0;
      }
      function Xc(c3, d3, f2, g2) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0;
        o = T;
        T = T + 48 | 0;
        l = o + 32 | 0;
        k = o + 40 | 0;
        m = o;
        if (!(b3[c3 >> 2] | 0)) {
          n = g2;
          b3[n >> 2] = 0;
          b3[n + 4 >> 2] = 0;
          n = 0;
          T = o;
          return n | 0;
        }
        Hb(l, 0, 0, 0);
        j = l;
        h = b3[j >> 2] | 0;
        j = b3[j + 4 >> 2] | 0;
        do {
          if (d3 >>> 0 > 15) {
            n = m;
            b3[n >> 2] = 0;
            b3[n + 4 >> 2] = 0;
            b3[m + 8 >> 2] = 4;
            b3[m + 12 >> 2] = -1;
            n = m + 16 | 0;
            f2 = m + 29 | 0;
            b3[n >> 2] = 0;
            b3[n + 4 >> 2] = 0;
            b3[n + 8 >> 2] = 0;
            a3[n + 12 >> 0] = 0;
            a3[f2 >> 0] = a3[k >> 0] | 0;
            a3[f2 + 1 >> 0] = a3[k + 1 >> 0] | 0;
            a3[f2 + 2 >> 0] = a3[k + 2 >> 0] | 0;
            f2 = 4;
            n = 9;
          } else {
            f2 = _c(f2) | 0;
            if (f2 | 0) {
              l = m;
              b3[l >> 2] = 0;
              b3[l + 4 >> 2] = 0;
              b3[m + 8 >> 2] = f2;
              b3[m + 12 >> 2] = -1;
              l = m + 16 | 0;
              n = m + 29 | 0;
              b3[l >> 2] = 0;
              b3[l + 4 >> 2] = 0;
              b3[l + 8 >> 2] = 0;
              a3[l + 12 >> 0] = 0;
              a3[n >> 0] = a3[k >> 0] | 0;
              a3[n + 1 >> 0] = a3[k + 1 >> 0] | 0;
              a3[n + 2 >> 0] = a3[k + 2 >> 0] | 0;
              n = 9;
              break;
            }
            f2 = Id((b3[c3 + 8 >> 2] | 0) + 1 | 0, 32) | 0;
            if (!f2) {
              n = m;
              b3[n >> 2] = 0;
              b3[n + 4 >> 2] = 0;
              b3[m + 8 >> 2] = 13;
              b3[m + 12 >> 2] = -1;
              n = m + 16 | 0;
              f2 = m + 29 | 0;
              b3[n >> 2] = 0;
              b3[n + 4 >> 2] = 0;
              b3[n + 8 >> 2] = 0;
              a3[n + 12 >> 0] = 0;
              a3[f2 >> 0] = a3[k >> 0] | 0;
              a3[f2 + 1 >> 0] = a3[k + 1 >> 0] | 0;
              a3[f2 + 2 >> 0] = a3[k + 2 >> 0] | 0;
              f2 = 13;
              n = 9;
              break;
            }
            $c(c3, f2);
            r2 = m;
            b3[r2 >> 2] = h;
            b3[r2 + 4 >> 2] = j;
            j = m + 8 | 0;
            b3[j >> 2] = 0;
            b3[m + 12 >> 2] = d3;
            b3[m + 20 >> 2] = c3;
            b3[m + 24 >> 2] = f2;
            a3[m + 28 >> 0] = 0;
            h = m + 29 | 0;
            a3[h >> 0] = a3[k >> 0] | 0;
            a3[h + 1 >> 0] = a3[k + 1 >> 0] | 0;
            a3[h + 2 >> 0] = a3[k + 2 >> 0] | 0;
            b3[m + 16 >> 2] = 3;
            p2 = +Ba(f2);
            p2 = p2 * +za(f2);
            i = +q(+ +e2[f2 >> 3]);
            i = p2 / +t(+ +Xd(+i, + +q(+ +e2[f2 + 8 >> 3]))) * 6371.007180918475 * 6371.007180918475;
            h = m + 12 | 0;
            f2 = b3[h >> 2] | 0;
            a: do {
              if ((f2 | 0) > 0) {
                do {
                  tc(f2 + -1 | 0, l) | 0;
                  if (!(i / +e2[l >> 3] > 10)) {
                    break a;
                  }
                  r2 = b3[h >> 2] | 0;
                  f2 = r2 + -1 | 0;
                  b3[h >> 2] = f2;
                } while ((r2 | 0) > 1);
              }
            } while (0);
            Uc(m);
            h = g2;
            b3[h >> 2] = 0;
            b3[h + 4 >> 2] = 0;
            h = m;
            f2 = b3[h >> 2] | 0;
            h = b3[h + 4 >> 2] | 0;
            if (!((f2 | 0) == 0 & (h | 0) == 0)) {
              do {
                Jb(f2, h, d3, l) | 0;
                k = l;
                c3 = g2;
                k = Jd(b3[c3 >> 2] | 0, b3[c3 + 4 >> 2] | 0, b3[k >> 2] | 0, b3[k + 4 >> 2] | 0) | 0;
                c3 = H() | 0;
                r2 = g2;
                b3[r2 >> 2] = k;
                b3[r2 + 4 >> 2] = c3;
                Uc(m);
                r2 = m;
                f2 = b3[r2 >> 2] | 0;
                h = b3[r2 + 4 >> 2] | 0;
              } while (!((f2 | 0) == 0 & (h | 0) == 0));
            }
            f2 = b3[j >> 2] | 0;
          }
        } while (0);
        r2 = f2;
        T = o;
        return r2 | 0;
      }
      function Yc(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        if (!(Ca(c3, d3) | 0)) {
          o = 0;
          return o | 0;
        }
        c3 = Aa(c3) | 0;
        f2 = +e2[d3 >> 3];
        g2 = +e2[d3 + 8 >> 3];
        g2 = c3 & g2 < 0 ? g2 + 6.283185307179586 : g2;
        o = b3[a4 >> 2] | 0;
        if ((o | 0) <= 0) {
          o = 0;
          return o | 0;
        }
        n = b3[a4 + 4 >> 2] | 0;
        if (c3) {
          c3 = 0;
          m = g2;
          d3 = -1;
          a4 = 0;
          a: while (1) {
            l = a4;
            while (1) {
              i = +e2[n + (l << 4) >> 3];
              g2 = +e2[n + (l << 4) + 8 >> 3];
              a4 = (d3 + 2 | 0) % (o | 0) | 0;
              h = +e2[n + (a4 << 4) >> 3];
              j = +e2[n + (a4 << 4) + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d3 = l + 1 | 0;
              if ((d3 | 0) >= (o | 0)) {
                d3 = 22;
                break a;
              } else {
                a4 = l;
                l = d3;
                d3 = a4;
              }
            }
            j = i < 0 ? i + 6.283185307179586 : i;
            i = g2 < 0 ? g2 + 6.283185307179586 : g2;
            m = j == m | i == m ? m + -2220446049250313e-31 : m;
            k = j + (i - j) * ((f2 - h) / (k - h));
            if ((k < 0 ? k + 6.283185307179586 : k) > m) {
              c3 = c3 ^ 1;
            }
            a4 = l + 1 | 0;
            if ((a4 | 0) >= (o | 0)) {
              d3 = 22;
              break;
            } else {
              d3 = l;
            }
          }
          if ((d3 | 0) == 22) {
            return c3 | 0;
          }
        } else {
          c3 = 0;
          m = g2;
          d3 = -1;
          a4 = 0;
          b: while (1) {
            l = a4;
            while (1) {
              i = +e2[n + (l << 4) >> 3];
              g2 = +e2[n + (l << 4) + 8 >> 3];
              a4 = (d3 + 2 | 0) % (o | 0) | 0;
              h = +e2[n + (a4 << 4) >> 3];
              j = +e2[n + (a4 << 4) + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d3 = l + 1 | 0;
              if ((d3 | 0) >= (o | 0)) {
                d3 = 22;
                break b;
              } else {
                a4 = l;
                l = d3;
                d3 = a4;
              }
            }
            m = i == m | g2 == m ? m + -2220446049250313e-31 : m;
            if (i + (g2 - i) * ((f2 - h) / (k - h)) > m) {
              c3 = c3 ^ 1;
            }
            a4 = l + 1 | 0;
            if ((a4 | 0) >= (o | 0)) {
              d3 = 22;
              break;
            } else {
              d3 = l;
            }
          }
          if ((d3 | 0) == 22) {
            return c3 | 0;
          }
        }
        return 0;
      }
      function Zc(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0;
        r2 = b3[a4 >> 2] | 0;
        if (!r2) {
          b3[c3 >> 2] = 0;
          b3[c3 + 4 >> 2] = 0;
          b3[c3 + 8 >> 2] = 0;
          b3[c3 + 12 >> 2] = 0;
          b3[c3 + 16 >> 2] = 0;
          b3[c3 + 20 >> 2] = 0;
          b3[c3 + 24 >> 2] = 0;
          b3[c3 + 28 >> 2] = 0;
          return;
        }
        s2 = c3 + 8 | 0;
        e2[s2 >> 3] = 17976931348623157e292;
        t2 = c3 + 24 | 0;
        e2[t2 >> 3] = 17976931348623157e292;
        e2[c3 >> 3] = -17976931348623157e292;
        u3 = c3 + 16 | 0;
        e2[u3 >> 3] = -17976931348623157e292;
        if ((r2 | 0) <= 0) {
          return;
        }
        o = b3[a4 + 4 >> 2] | 0;
        l = 17976931348623157e292;
        m = -17976931348623157e292;
        n = 0;
        a4 = -1;
        h = 17976931348623157e292;
        i = 17976931348623157e292;
        k = -17976931348623157e292;
        f2 = -17976931348623157e292;
        p2 = 0;
        while (1) {
          d3 = +e2[o + (p2 << 4) >> 3];
          j = +e2[o + (p2 << 4) + 8 >> 3];
          a4 = a4 + 2 | 0;
          g2 = +e2[o + (((a4 | 0) == (r2 | 0) ? 0 : a4) << 4) + 8 >> 3];
          if (d3 < h) {
            e2[s2 >> 3] = d3;
            h = d3;
          }
          if (j < i) {
            e2[t2 >> 3] = j;
            i = j;
          }
          if (d3 > k) {
            e2[c3 >> 3] = d3;
          } else {
            d3 = k;
          }
          if (j > f2) {
            e2[u3 >> 3] = j;
            f2 = j;
          }
          l = j > 0 & j < l ? j : l;
          m = j < 0 & j > m ? j : m;
          n = n | +q(+(j - g2)) > 3.141592653589793;
          a4 = p2 + 1 | 0;
          if ((a4 | 0) == (r2 | 0)) {
            break;
          } else {
            v3 = p2;
            k = d3;
            p2 = a4;
            a4 = v3;
          }
        }
        if (!n) {
          return;
        }
        e2[u3 >> 3] = m;
        e2[t2 >> 3] = l;
        return;
      }
      function _c(a4) {
        a4 = a4 | 0;
        return (a4 >>> 0 < 4 ? 0 : 15) | 0;
      }
      function $c(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0;
        r2 = b3[a4 >> 2] | 0;
        if (r2) {
          s2 = c3 + 8 | 0;
          e2[s2 >> 3] = 17976931348623157e292;
          t2 = c3 + 24 | 0;
          e2[t2 >> 3] = 17976931348623157e292;
          e2[c3 >> 3] = -17976931348623157e292;
          u3 = c3 + 16 | 0;
          e2[u3 >> 3] = -17976931348623157e292;
          if ((r2 | 0) > 0) {
            g2 = b3[a4 + 4 >> 2] | 0;
            o = 17976931348623157e292;
            p2 = -17976931348623157e292;
            f2 = 0;
            d3 = -1;
            k = 17976931348623157e292;
            l = 17976931348623157e292;
            n = -17976931348623157e292;
            i = -17976931348623157e292;
            v3 = 0;
            while (1) {
              h = +e2[g2 + (v3 << 4) >> 3];
              m = +e2[g2 + (v3 << 4) + 8 >> 3];
              z2 = d3 + 2 | 0;
              j = +e2[g2 + (((z2 | 0) == (r2 | 0) ? 0 : z2) << 4) + 8 >> 3];
              if (h < k) {
                e2[s2 >> 3] = h;
                k = h;
              }
              if (m < l) {
                e2[t2 >> 3] = m;
                l = m;
              }
              if (h > n) {
                e2[c3 >> 3] = h;
              } else {
                h = n;
              }
              if (m > i) {
                e2[u3 >> 3] = m;
                i = m;
              }
              o = m > 0 & m < o ? m : o;
              p2 = m < 0 & m > p2 ? m : p2;
              f2 = f2 | +q(+(m - j)) > 3.141592653589793;
              d3 = v3 + 1 | 0;
              if ((d3 | 0) == (r2 | 0)) {
                break;
              } else {
                z2 = v3;
                n = h;
                v3 = d3;
                d3 = z2;
              }
            }
            if (f2) {
              e2[u3 >> 3] = p2;
              e2[t2 >> 3] = o;
            }
          }
        } else {
          b3[c3 >> 2] = 0;
          b3[c3 + 4 >> 2] = 0;
          b3[c3 + 8 >> 2] = 0;
          b3[c3 + 12 >> 2] = 0;
          b3[c3 + 16 >> 2] = 0;
          b3[c3 + 20 >> 2] = 0;
          b3[c3 + 24 >> 2] = 0;
          b3[c3 + 28 >> 2] = 0;
        }
        z2 = a4 + 8 | 0;
        d3 = b3[z2 >> 2] | 0;
        if ((d3 | 0) <= 0) {
          return;
        }
        y2 = a4 + 12 | 0;
        x2 = 0;
        do {
          g2 = b3[y2 >> 2] | 0;
          f2 = x2;
          x2 = x2 + 1 | 0;
          t2 = c3 + (x2 << 5) | 0;
          u3 = b3[g2 + (f2 << 3) >> 2] | 0;
          if (u3) {
            v3 = c3 + (x2 << 5) + 8 | 0;
            e2[v3 >> 3] = 17976931348623157e292;
            a4 = c3 + (x2 << 5) + 24 | 0;
            e2[a4 >> 3] = 17976931348623157e292;
            e2[t2 >> 3] = -17976931348623157e292;
            w3 = c3 + (x2 << 5) + 16 | 0;
            e2[w3 >> 3] = -17976931348623157e292;
            if ((u3 | 0) > 0) {
              r2 = b3[g2 + (f2 << 3) + 4 >> 2] | 0;
              o = 17976931348623157e292;
              p2 = -17976931348623157e292;
              g2 = 0;
              f2 = -1;
              s2 = 0;
              k = 17976931348623157e292;
              l = 17976931348623157e292;
              m = -17976931348623157e292;
              i = -17976931348623157e292;
              while (1) {
                h = +e2[r2 + (s2 << 4) >> 3];
                n = +e2[r2 + (s2 << 4) + 8 >> 3];
                f2 = f2 + 2 | 0;
                j = +e2[r2 + (((f2 | 0) == (u3 | 0) ? 0 : f2) << 4) + 8 >> 3];
                if (h < k) {
                  e2[v3 >> 3] = h;
                  k = h;
                }
                if (n < l) {
                  e2[a4 >> 3] = n;
                  l = n;
                }
                if (h > m) {
                  e2[t2 >> 3] = h;
                } else {
                  h = m;
                }
                if (n > i) {
                  e2[w3 >> 3] = n;
                  i = n;
                }
                o = n > 0 & n < o ? n : o;
                p2 = n < 0 & n > p2 ? n : p2;
                g2 = g2 | +q(+(n - j)) > 3.141592653589793;
                f2 = s2 + 1 | 0;
                if ((f2 | 0) == (u3 | 0)) {
                  break;
                } else {
                  A3 = s2;
                  s2 = f2;
                  m = h;
                  f2 = A3;
                }
              }
              if (g2) {
                e2[w3 >> 3] = p2;
                e2[a4 >> 3] = o;
              }
            }
          } else {
            b3[t2 >> 2] = 0;
            b3[t2 + 4 >> 2] = 0;
            b3[t2 + 8 >> 2] = 0;
            b3[t2 + 12 >> 2] = 0;
            b3[t2 + 16 >> 2] = 0;
            b3[t2 + 20 >> 2] = 0;
            b3[t2 + 24 >> 2] = 0;
            b3[t2 + 28 >> 2] = 0;
            d3 = b3[z2 >> 2] | 0;
          }
        } while ((x2 | 0) < (d3 | 0));
        return;
      }
      function ad(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        if (!(Yc(a4, c3, d3) | 0)) {
          f2 = 0;
          return f2 | 0;
        }
        f2 = a4 + 8 | 0;
        if ((b3[f2 >> 2] | 0) <= 0) {
          f2 = 1;
          return f2 | 0;
        }
        e3 = a4 + 12 | 0;
        a4 = 0;
        while (1) {
          g2 = a4;
          a4 = a4 + 1 | 0;
          if (Yc((b3[e3 >> 2] | 0) + (g2 << 3) | 0, c3 + (a4 << 5) | 0, d3) | 0) {
            a4 = 0;
            e3 = 6;
            break;
          }
          if ((a4 | 0) >= (b3[f2 >> 2] | 0)) {
            a4 = 1;
            e3 = 6;
            break;
          }
        }
        if ((e3 | 0) == 6) {
          return a4 | 0;
        }
        return 0;
      }
      function bd(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        k = T;
        T = T + 16 | 0;
        i = k;
        h = d3 + 8 | 0;
        if (!(Yc(a4, c3, h) | 0)) {
          j = 0;
          T = k;
          return j | 0;
        }
        j = a4 + 8 | 0;
        a: do {
          if ((b3[j >> 2] | 0) > 0) {
            g2 = a4 + 12 | 0;
            f2 = 0;
            while (1) {
              l = f2;
              f2 = f2 + 1 | 0;
              if (Yc((b3[g2 >> 2] | 0) + (l << 3) | 0, c3 + (f2 << 5) | 0, h) | 0) {
                f2 = 0;
                break;
              }
              if ((f2 | 0) >= (b3[j >> 2] | 0)) {
                break a;
              }
            }
            T = k;
            return f2 | 0;
          }
        } while (0);
        if (cd(a4, c3, d3, e3) | 0) {
          l = 0;
          T = k;
          return l | 0;
        }
        b3[i >> 2] = b3[d3 >> 2];
        b3[i + 4 >> 2] = h;
        f2 = b3[j >> 2] | 0;
        b: do {
          if ((f2 | 0) > 0) {
            a4 = a4 + 12 | 0;
            h = 0;
            g2 = f2;
            while (1) {
              f2 = b3[a4 >> 2] | 0;
              if ((b3[f2 + (h << 3) >> 2] | 0) > 0) {
                if (Yc(i, e3, b3[f2 + (h << 3) + 4 >> 2] | 0) | 0) {
                  f2 = 0;
                  break b;
                }
                f2 = h + 1 | 0;
                if (cd((b3[a4 >> 2] | 0) + (h << 3) | 0, c3 + (f2 << 5) | 0, d3, e3) | 0) {
                  f2 = 0;
                  break b;
                }
                g2 = b3[j >> 2] | 0;
              } else {
                f2 = h + 1 | 0;
              }
              if ((f2 | 0) < (g2 | 0)) {
                h = f2;
              } else {
                f2 = 1;
                break;
              }
            }
          } else {
            f2 = 1;
          }
        } while (0);
        l = f2;
        T = k;
        return l | 0;
      }
      function cd(a4, c3, d3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0, x2 = 0, y2 = 0, z2 = 0, A3 = 0;
        y2 = T;
        T = T + 176 | 0;
        u3 = y2 + 172 | 0;
        g2 = y2 + 168 | 0;
        v3 = y2;
        if (!(Da(c3, f2) | 0)) {
          a4 = 0;
          T = y2;
          return a4 | 0;
        }
        Ea(c3, f2, u3, g2);
        Zd(v3 | 0, d3 | 0, 168) | 0;
        if ((b3[d3 >> 2] | 0) > 0) {
          c3 = 0;
          do {
            z2 = v3 + 8 + (c3 << 4) + 8 | 0;
            t2 = +nc(+e2[z2 >> 3], b3[g2 >> 2] | 0);
            e2[z2 >> 3] = t2;
            c3 = c3 + 1 | 0;
          } while ((c3 | 0) < (b3[d3 >> 2] | 0));
        }
        r2 = +e2[f2 >> 3];
        s2 = +e2[f2 + 8 >> 3];
        t2 = +nc(+e2[f2 + 16 >> 3], b3[g2 >> 2] | 0);
        p2 = +nc(+e2[f2 + 24 >> 3], b3[g2 >> 2] | 0);
        a: do {
          if ((b3[a4 >> 2] | 0) > 0) {
            f2 = a4 + 4 | 0;
            g2 = b3[v3 >> 2] | 0;
            if ((g2 | 0) <= 0) {
              c3 = 0;
              while (1) {
                c3 = c3 + 1 | 0;
                if ((c3 | 0) >= (b3[a4 >> 2] | 0)) {
                  c3 = 0;
                  break a;
                }
              }
            }
            d3 = 0;
            while (1) {
              c3 = b3[f2 >> 2] | 0;
              o = +e2[c3 + (d3 << 4) >> 3];
              q2 = +nc(+e2[c3 + (d3 << 4) + 8 >> 3], b3[u3 >> 2] | 0);
              c3 = b3[f2 >> 2] | 0;
              d3 = d3 + 1 | 0;
              z2 = (d3 | 0) % (b3[a4 >> 2] | 0) | 0;
              h = +e2[c3 + (z2 << 4) >> 3];
              i = +nc(+e2[c3 + (z2 << 4) + 8 >> 3], b3[u3 >> 2] | 0);
              if (((!(o >= r2) | !(h >= r2) ? !(o <= s2) | !(h <= s2) : 0) ? !(q2 <= p2) | !(i <= p2) : 0) ? !(q2 >= t2) | !(i >= t2) : 0) {
                n = h - o;
                l = i - q2;
                c3 = 0;
                do {
                  A3 = c3;
                  c3 = c3 + 1 | 0;
                  z2 = (c3 | 0) == (g2 | 0) ? 0 : c3;
                  h = +e2[v3 + 8 + (A3 << 4) + 8 >> 3];
                  i = +e2[v3 + 8 + (z2 << 4) + 8 >> 3] - h;
                  j = +e2[v3 + 8 + (A3 << 4) >> 3];
                  k = +e2[v3 + 8 + (z2 << 4) >> 3] - j;
                  m = n * i - l * k;
                  if ((m != 0 ? (w3 = q2 - h, x2 = o - j, k = (w3 * k - i * x2) / m, !(k < 0 | k > 1)) : 0) ? (m = (n * w3 - l * x2) / m, m >= 0 & m <= 1) : 0) {
                    c3 = 1;
                    break a;
                  }
                } while ((c3 | 0) < (g2 | 0));
              }
              if ((d3 | 0) >= (b3[a4 >> 2] | 0)) {
                c3 = 0;
                break;
              }
            }
          } else {
            c3 = 0;
          }
        } while (0);
        A3 = c3;
        T = y2;
        return A3 | 0;
      }
      function dd(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        if (cd(a4, c3, d3, e3) | 0) {
          g2 = 1;
          return g2 | 0;
        }
        g2 = a4 + 8 | 0;
        if ((b3[g2 >> 2] | 0) <= 0) {
          g2 = 0;
          return g2 | 0;
        }
        f2 = a4 + 12 | 0;
        a4 = 0;
        while (1) {
          h = a4;
          a4 = a4 + 1 | 0;
          if (cd((b3[f2 >> 2] | 0) + (h << 3) | 0, c3 + (a4 << 5) | 0, d3, e3) | 0) {
            a4 = 1;
            f2 = 6;
            break;
          }
          if ((a4 | 0) >= (b3[g2 >> 2] | 0)) {
            a4 = 0;
            f2 = 6;
            break;
          }
        }
        if ((f2 | 0) == 6) {
          return a4 | 0;
        }
        return 0;
      }
      function ed() {
        return 8;
      }
      function fd() {
        return 16;
      }
      function gd() {
        return 168;
      }
      function hd() {
        return 8;
      }
      function id() {
        return 16;
      }
      function jd() {
        return 12;
      }
      function kd() {
        return 8;
      }
      function ld(a4) {
        a4 = a4 | 0;
        return +(+((b3[a4 >> 2] | 0) >>> 0) + 4294967296 * +(b3[a4 + 4 >> 2] | 0));
      }
      function md(a4) {
        a4 = a4 | 0;
        var b4 = 0, c3 = 0;
        c3 = +e2[a4 >> 3];
        b4 = +e2[a4 + 8 >> 3];
        return + +r(+(c3 * c3 + b4 * b4));
      }
      function nd(a4, b4, c3, d3, f2) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        k = +e2[a4 >> 3];
        j = +e2[b4 >> 3] - k;
        i = +e2[a4 + 8 >> 3];
        h = +e2[b4 + 8 >> 3] - i;
        m = +e2[c3 >> 3];
        g2 = +e2[d3 >> 3] - m;
        n = +e2[c3 + 8 >> 3];
        l = +e2[d3 + 8 >> 3] - n;
        g2 = (g2 * (i - n) - (k - m) * l) / (j * l - h * g2);
        e2[f2 >> 3] = k + j * g2;
        e2[f2 + 8 >> 3] = i + h * g2;
        return;
      }
      function od(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        if (!(+q(+(+e2[a4 >> 3] - +e2[b4 >> 3])) < 11920928955078125e-23)) {
          b4 = 0;
          return b4 | 0;
        }
        b4 = +q(+(+e2[a4 + 8 >> 3] - +e2[b4 + 8 >> 3])) < 11920928955078125e-23;
        return b4 | 0;
      }
      function pd(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, f2 = 0;
        f2 = +e2[a4 >> 3] - +e2[b4 >> 3];
        d3 = +e2[a4 + 8 >> 3] - +e2[b4 + 8 >> 3];
        c3 = +e2[a4 + 16 >> 3] - +e2[b4 + 16 >> 3];
        return +(f2 * f2 + d3 * d3 + c3 * c3);
      }
      function qd(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, f2 = 0;
        c3 = +e2[a4 >> 3];
        d3 = +t(+c3);
        c3 = +u2(+c3);
        e2[b4 + 16 >> 3] = c3;
        c3 = +e2[a4 + 8 >> 3];
        f2 = d3 * +t(+c3);
        e2[b4 >> 3] = f2;
        c3 = d3 * +u2(+c3);
        e2[b4 + 8 >> 3] = c3;
        return;
      }
      function rd(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        g2 = T;
        T = T + 16 | 0;
        f2 = g2;
        e3 = Kb(a4, c3) | 0;
        if ((d3 + -1 | 0) >>> 0 > 5) {
          f2 = -1;
          T = g2;
          return f2 | 0;
        }
        e3 = (e3 | 0) != 0;
        if ((d3 | 0) == 1 & e3) {
          f2 = -1;
          T = g2;
          return f2 | 0;
        }
        do {
          if (!(sd(a4, c3, f2) | 0)) {
            if (e3) {
              e3 = ((b3[26352 + (d3 << 2) >> 2] | 0) + 5 - (b3[f2 >> 2] | 0) | 0) % 5 | 0;
              break;
            } else {
              e3 = ((b3[26384 + (d3 << 2) >> 2] | 0) + 6 - (b3[f2 >> 2] | 0) | 0) % 6 | 0;
              break;
            }
          } else {
            e3 = -1;
          }
        } while (0);
        f2 = e3;
        T = g2;
        return f2 | 0;
      }
      function sd(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        l = T;
        T = T + 32 | 0;
        i = l + 16 | 0;
        j = l;
        e3 = $b(a4, c3, i) | 0;
        if (e3 | 0) {
          d3 = e3;
          T = l;
          return d3 | 0;
        }
        g2 = Cb(a4, c3) | 0;
        k = Sb(a4, c3) | 0;
        sa(g2, j);
        e3 = ta(g2, b3[i >> 2] | 0) | 0;
        do {
          if (oa(g2) | 0) {
            do {
              switch (g2 | 0) {
                case 4: {
                  f2 = 0;
                  break;
                }
                case 14: {
                  f2 = 1;
                  break;
                }
                case 24: {
                  f2 = 2;
                  break;
                }
                case 38: {
                  f2 = 3;
                  break;
                }
                case 49: {
                  f2 = 4;
                  break;
                }
                case 58: {
                  f2 = 5;
                  break;
                }
                case 63: {
                  f2 = 6;
                  break;
                }
                case 72: {
                  f2 = 7;
                  break;
                }
                case 83: {
                  f2 = 8;
                  break;
                }
                case 97: {
                  f2 = 9;
                  break;
                }
                case 107: {
                  f2 = 10;
                  break;
                }
                case 117: {
                  f2 = 11;
                  break;
                }
                default:
                  I(27795, 27797, 75, 27806);
              }
            } while (0);
            h = b3[26416 + (f2 * 24 | 0) + 8 >> 2] | 0;
            c3 = b3[26416 + (f2 * 24 | 0) + 16 >> 2] | 0;
            a4 = b3[i >> 2] | 0;
            if ((a4 | 0) != (b3[j >> 2] | 0)) {
              j = pa(g2) | 0;
              a4 = b3[i >> 2] | 0;
              if (j | (a4 | 0) == (c3 | 0)) {
                e3 = (e3 + 1 | 0) % 6 | 0;
              }
            }
            if ((k | 0) == 3 & (a4 | 0) == (c3 | 0)) {
              e3 = (e3 + 5 | 0) % 6 | 0;
              break;
            }
            if ((k | 0) == 5 & (a4 | 0) == (h | 0)) {
              e3 = (e3 + 1 | 0) % 6 | 0;
            }
          }
        } while (0);
        b3[d3 >> 2] = e3;
        d3 = 0;
        T = l;
        return d3 | 0;
      }
      function td(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0;
        u3 = T;
        T = T + 32 | 0;
        t2 = u3 + 24 | 0;
        r2 = u3 + 20 | 0;
        p2 = u3 + 8 | 0;
        o = u3 + 16 | 0;
        n = u3;
        j = (Kb(a4, c3) | 0) == 0;
        j = j ? 6 : 5;
        l = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        l = l & 15;
        if (j >>> 0 <= d3 >>> 0) {
          e3 = 2;
          T = u3;
          return e3 | 0;
        }
        m = (l | 0) == 0;
        if (!m ? (q2 = Ud(7, 0, (l ^ 15) * 3 | 0) | 0, (q2 & a4 | 0) == 0 & ((H() | 0) & c3 | 0) == 0) : 0) {
          f2 = d3;
        } else {
          g2 = 4;
        }
        a: do {
          if ((g2 | 0) == 4) {
            f2 = (Kb(a4, c3) | 0) != 0;
            if (((f2 ? 4 : 5) | 0) < (d3 | 0)) {
              e3 = 1;
              T = u3;
              return e3 | 0;
            }
            if (sd(a4, c3, t2) | 0) {
              e3 = 1;
              T = u3;
              return e3 | 0;
            }
            g2 = (b3[t2 >> 2] | 0) + d3 | 0;
            if (f2) {
              f2 = 26704 + (((g2 | 0) % 5 | 0) << 2) | 0;
            } else {
              f2 = 26736 + (((g2 | 0) % 6 | 0) << 2) | 0;
            }
            q2 = b3[f2 >> 2] | 0;
            if ((q2 | 0) == 7) {
              e3 = 1;
              T = u3;
              return e3 | 0;
            }
            b3[r2 >> 2] = 0;
            f2 = ea(a4, c3, q2, r2, p2) | 0;
            do {
              if (!f2) {
                i = p2;
                k = b3[i >> 2] | 0;
                i = b3[i + 4 >> 2] | 0;
                h = i >>> 0 < c3 >>> 0 | (i | 0) == (c3 | 0) & k >>> 0 < a4 >>> 0;
                g2 = h ? k : a4;
                h = h ? i : c3;
                if (!m ? (m = Ud(7, 0, (l ^ 15) * 3 | 0) | 0, (k & m | 0) == 0 & (i & (H() | 0) | 0) == 0) : 0) {
                  f2 = d3;
                } else {
                  i = (d3 + -1 + j | 0) % (j | 0) | 0;
                  f2 = Kb(a4, c3) | 0;
                  if ((i | 0) < 0) {
                    I(27795, 27797, 248, 27822);
                  }
                  j = (f2 | 0) != 0;
                  if (((j ? 4 : 5) | 0) < (i | 0)) {
                    I(27795, 27797, 248, 27822);
                  }
                  if (sd(a4, c3, t2) | 0) {
                    I(27795, 27797, 248, 27822);
                  }
                  f2 = (b3[t2 >> 2] | 0) + i | 0;
                  if (j) {
                    f2 = 26704 + (((f2 | 0) % 5 | 0) << 2) | 0;
                  } else {
                    f2 = 26736 + (((f2 | 0) % 6 | 0) << 2) | 0;
                  }
                  i = b3[f2 >> 2] | 0;
                  if ((i | 0) == 7) {
                    I(27795, 27797, 248, 27822);
                  }
                  b3[o >> 2] = 0;
                  f2 = ea(a4, c3, i, o, n) | 0;
                  if (f2 | 0) {
                    break;
                  }
                  k = n;
                  j = b3[k >> 2] | 0;
                  k = b3[k + 4 >> 2] | 0;
                  do {
                    if (k >>> 0 < h >>> 0 | (k | 0) == (h | 0) & j >>> 0 < g2 >>> 0) {
                      if (!(Kb(j, k) | 0)) {
                        g2 = b3[26800 + ((((b3[o >> 2] | 0) + (b3[26768 + (i << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0;
                      } else {
                        g2 = ia(j, k, a4, c3) | 0;
                      }
                      f2 = Kb(j, k) | 0;
                      if ((g2 + -1 | 0) >>> 0 > 5) {
                        f2 = -1;
                        g2 = j;
                        h = k;
                        break;
                      }
                      f2 = (f2 | 0) != 0;
                      if ((g2 | 0) == 1 & f2) {
                        f2 = -1;
                        g2 = j;
                        h = k;
                        break;
                      }
                      do {
                        if (!(sd(j, k, t2) | 0)) {
                          if (f2) {
                            f2 = ((b3[26352 + (g2 << 2) >> 2] | 0) + 5 - (b3[t2 >> 2] | 0) | 0) % 5 | 0;
                            break;
                          } else {
                            f2 = ((b3[26384 + (g2 << 2) >> 2] | 0) + 6 - (b3[t2 >> 2] | 0) | 0) % 6 | 0;
                            break;
                          }
                        } else {
                          f2 = -1;
                        }
                      } while (0);
                      g2 = j;
                      h = k;
                    } else {
                      f2 = d3;
                    }
                  } while (0);
                  i = p2;
                  k = b3[i >> 2] | 0;
                  i = b3[i + 4 >> 2] | 0;
                }
                if ((g2 | 0) == (k | 0) & (h | 0) == (i | 0)) {
                  j = (Kb(k, i) | 0) != 0;
                  if (j) {
                    a4 = ia(k, i, a4, c3) | 0;
                  } else {
                    a4 = b3[26800 + ((((b3[r2 >> 2] | 0) + (b3[26768 + (q2 << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0;
                  }
                  f2 = Kb(k, i) | 0;
                  if ((a4 + -1 | 0) >>> 0 <= 5 ? (s2 = (f2 | 0) != 0, !((a4 | 0) == 1 & s2)) : 0) {
                    do {
                      if (!(sd(k, i, t2) | 0)) {
                        if (s2) {
                          f2 = ((b3[26352 + (a4 << 2) >> 2] | 0) + 5 - (b3[t2 >> 2] | 0) | 0) % 5 | 0;
                          break;
                        } else {
                          f2 = ((b3[26384 + (a4 << 2) >> 2] | 0) + 6 - (b3[t2 >> 2] | 0) | 0) % 6 | 0;
                          break;
                        }
                      } else {
                        f2 = -1;
                      }
                    } while (0);
                  } else {
                    f2 = -1;
                  }
                  f2 = f2 + 1 | 0;
                  f2 = (f2 | 0) == 6 | j & (f2 | 0) == 5 ? 0 : f2;
                }
                c3 = h;
                a4 = g2;
                break a;
              }
            } while (0);
            e3 = f2;
            T = u3;
            return e3 | 0;
          }
        } while (0);
        s2 = Ud(f2 | 0, 0, 56) | 0;
        t2 = H() | 0 | c3 & -2130706433 | 536870912;
        b3[e3 >> 2] = s2 | a4;
        b3[e3 + 4 >> 2] = t2;
        e3 = 0;
        T = u3;
        return e3 | 0;
      }
      function ud(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        g2 = (Kb(a4, c3) | 0) == 0;
        e3 = td(a4, c3, 0, d3) | 0;
        f2 = (e3 | 0) == 0;
        if (g2) {
          if (!f2) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = td(a4, c3, 1, d3 + 8 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = td(a4, c3, 2, d3 + 16 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = td(a4, c3, 3, d3 + 24 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = td(a4, c3, 4, d3 + 32 | 0) | 0;
          if (!e3) {
            return td(a4, c3, 5, d3 + 40 | 0) | 0;
          } else {
            g2 = e3;
            return g2 | 0;
          }
        }
        if (!f2) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = td(a4, c3, 1, d3 + 8 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = td(a4, c3, 2, d3 + 16 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = td(a4, c3, 3, d3 + 24 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = td(a4, c3, 4, d3 + 32 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        g2 = d3 + 40 | 0;
        b3[g2 >> 2] = 0;
        b3[g2 + 4 >> 2] = 0;
        g2 = 0;
        return g2 | 0;
      }
      function vd(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T;
        T = T + 192 | 0;
        f2 = j;
        g2 = j + 168 | 0;
        h = Td(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        h = h & 7;
        i = c3 & -2130706433 | 134217728;
        e3 = $b(a4, i, g2) | 0;
        if (e3 | 0) {
          i = e3;
          T = j;
          return i | 0;
        }
        c3 = Td(a4 | 0, c3 | 0, 52) | 0;
        H() | 0;
        c3 = c3 & 15;
        if (!(Kb(a4, i) | 0)) {
          zb(g2, c3, h, 1, f2);
        } else {
          vb(g2, c3, h, 1, f2);
        }
        i = f2 + 8 | 0;
        b3[d3 >> 2] = b3[i >> 2];
        b3[d3 + 4 >> 2] = b3[i + 4 >> 2];
        b3[d3 + 8 >> 2] = b3[i + 8 >> 2];
        b3[d3 + 12 >> 2] = b3[i + 12 >> 2];
        i = 0;
        T = j;
        return i | 0;
      }
      function wd(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, e3 = 0, f2 = 0, g2 = 0;
        f2 = T;
        T = T + 16 | 0;
        d3 = f2;
        if (!(true & (c3 & 2013265920 | 0) == 536870912)) {
          e3 = 0;
          T = f2;
          return e3 | 0;
        }
        e3 = c3 & -2130706433 | 134217728;
        if (!(Fb(a4, e3) | 0)) {
          e3 = 0;
          T = f2;
          return e3 | 0;
        }
        g2 = Td(a4 | 0, c3 | 0, 56) | 0;
        H() | 0;
        g2 = (td(a4, e3, g2 & 7, d3) | 0) == 0;
        e3 = d3;
        e3 = g2 & ((b3[e3 >> 2] | 0) == (a4 | 0) ? (b3[e3 + 4 >> 2] | 0) == (c3 | 0) : 0) & 1;
        T = f2;
        return e3 | 0;
      }
      function xd(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0;
        if ((c3 | 0) > 0) {
          e3 = Id(c3, 4) | 0;
          b3[a4 >> 2] = e3;
          if (!e3) {
            I(27835, 27858, 40, 27872);
          }
        } else {
          b3[a4 >> 2] = 0;
        }
        b3[a4 + 4 >> 2] = c3;
        b3[a4 + 8 >> 2] = 0;
        b3[a4 + 12 >> 2] = d3;
        return;
      }
      function yd(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        g2 = a4 + 4 | 0;
        h = a4 + 12 | 0;
        i = a4 + 8 | 0;
        a: while (1) {
          d3 = b3[g2 >> 2] | 0;
          c3 = 0;
          while (1) {
            if ((c3 | 0) >= (d3 | 0)) {
              break a;
            }
            f2 = b3[a4 >> 2] | 0;
            j = b3[f2 + (c3 << 2) >> 2] | 0;
            if (!j) {
              c3 = c3 + 1 | 0;
            } else {
              break;
            }
          }
          c3 = f2 + (~~(+q(+(+s(10, + +(15 - (b3[h >> 2] | 0) | 0)) * (+e2[j >> 3] + +e2[j + 8 >> 3]))) % +(d3 | 0)) >>> 0 << 2) | 0;
          d3 = b3[c3 >> 2] | 0;
          b: do {
            if (d3 | 0) {
              f2 = j + 32 | 0;
              if ((d3 | 0) == (j | 0)) {
                b3[c3 >> 2] = b3[f2 >> 2];
              } else {
                d3 = d3 + 32 | 0;
                c3 = b3[d3 >> 2] | 0;
                if (!c3) {
                  break;
                }
                while (1) {
                  if ((c3 | 0) == (j | 0)) {
                    break;
                  }
                  d3 = c3 + 32 | 0;
                  c3 = b3[d3 >> 2] | 0;
                  if (!c3) {
                    break b;
                  }
                }
                b3[d3 >> 2] = b3[f2 >> 2];
              }
              Hd(j);
              b3[i >> 2] = (b3[i >> 2] | 0) + -1;
            }
          } while (0);
        }
        Hd(b3[a4 >> 2] | 0);
        return;
      }
      function zd(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        e3 = b3[a4 + 4 >> 2] | 0;
        d3 = 0;
        while (1) {
          if ((d3 | 0) >= (e3 | 0)) {
            c3 = 0;
            d3 = 4;
            break;
          }
          c3 = b3[(b3[a4 >> 2] | 0) + (d3 << 2) >> 2] | 0;
          if (!c3) {
            d3 = d3 + 1 | 0;
          } else {
            d3 = 4;
            break;
          }
        }
        if ((d3 | 0) == 4) {
          return c3 | 0;
        }
        return 0;
      }
      function Ad(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0, f2 = 0, g2 = 0, h = 0;
        d3 = ~~(+q(+(+s(10, + +(15 - (b3[a4 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b3[a4 + 4 >> 2] | 0)) >>> 0;
        d3 = (b3[a4 >> 2] | 0) + (d3 << 2) | 0;
        f2 = b3[d3 >> 2] | 0;
        if (!f2) {
          h = 1;
          return h | 0;
        }
        h = c3 + 32 | 0;
        do {
          if ((f2 | 0) != (c3 | 0)) {
            d3 = b3[f2 + 32 >> 2] | 0;
            if (!d3) {
              h = 1;
              return h | 0;
            }
            g2 = d3;
            while (1) {
              if ((g2 | 0) == (c3 | 0)) {
                g2 = 8;
                break;
              }
              d3 = b3[g2 + 32 >> 2] | 0;
              if (!d3) {
                d3 = 1;
                g2 = 10;
                break;
              } else {
                f2 = g2;
                g2 = d3;
              }
            }
            if ((g2 | 0) == 8) {
              b3[f2 + 32 >> 2] = b3[h >> 2];
              break;
            } else if ((g2 | 0) == 10) {
              return d3 | 0;
            }
          } else {
            b3[d3 >> 2] = b3[h >> 2];
          }
        } while (0);
        Hd(c3);
        h = a4 + 8 | 0;
        b3[h >> 2] = (b3[h >> 2] | 0) + -1;
        h = 0;
        return h | 0;
      }
      function Bd(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        h = Gd(40) | 0;
        if (!h) {
          I(27888, 27858, 98, 27901);
        }
        b3[h >> 2] = b3[c3 >> 2];
        b3[h + 4 >> 2] = b3[c3 + 4 >> 2];
        b3[h + 8 >> 2] = b3[c3 + 8 >> 2];
        b3[h + 12 >> 2] = b3[c3 + 12 >> 2];
        g2 = h + 16 | 0;
        b3[g2 >> 2] = b3[d3 >> 2];
        b3[g2 + 4 >> 2] = b3[d3 + 4 >> 2];
        b3[g2 + 8 >> 2] = b3[d3 + 8 >> 2];
        b3[g2 + 12 >> 2] = b3[d3 + 12 >> 2];
        b3[h + 32 >> 2] = 0;
        g2 = ~~(+q(+(+s(10, + +(15 - (b3[a4 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b3[a4 + 4 >> 2] | 0)) >>> 0;
        g2 = (b3[a4 >> 2] | 0) + (g2 << 2) | 0;
        f2 = b3[g2 >> 2] | 0;
        do {
          if (!f2) {
            b3[g2 >> 2] = h;
          } else {
            while (1) {
              if (mc(f2, c3) | 0 ? mc(f2 + 16 | 0, d3) | 0 : 0) {
                break;
              }
              g2 = b3[f2 + 32 >> 2] | 0;
              f2 = (g2 | 0) == 0 ? f2 : g2;
              if (!(b3[f2 + 32 >> 2] | 0)) {
                i = 10;
                break;
              }
            }
            if ((i | 0) == 10) {
              b3[f2 + 32 >> 2] = h;
              break;
            }
            Hd(h);
            i = f2;
            return i | 0;
          }
        } while (0);
        i = a4 + 8 | 0;
        b3[i >> 2] = (b3[i >> 2] | 0) + 1;
        i = h;
        return i | 0;
      }
      function Cd(a4, c3, d3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var f2 = 0, g2 = 0;
        g2 = ~~(+q(+(+s(10, + +(15 - (b3[a4 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b3[a4 + 4 >> 2] | 0)) >>> 0;
        g2 = b3[(b3[a4 >> 2] | 0) + (g2 << 2) >> 2] | 0;
        if (!g2) {
          d3 = 0;
          return d3 | 0;
        }
        if (!d3) {
          a4 = g2;
          while (1) {
            if (mc(a4, c3) | 0) {
              f2 = 10;
              break;
            }
            a4 = b3[a4 + 32 >> 2] | 0;
            if (!a4) {
              a4 = 0;
              f2 = 10;
              break;
            }
          }
          if ((f2 | 0) == 10) {
            return a4 | 0;
          }
        }
        a4 = g2;
        while (1) {
          if (mc(a4, c3) | 0 ? mc(a4 + 16 | 0, d3) | 0 : 0) {
            f2 = 10;
            break;
          }
          a4 = b3[a4 + 32 >> 2] | 0;
          if (!a4) {
            a4 = 0;
            f2 = 10;
            break;
          }
        }
        if ((f2 | 0) == 10) {
          return a4 | 0;
        }
        return 0;
      }
      function Dd(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0;
        d3 = ~~(+q(+(+s(10, + +(15 - (b3[a4 + 12 >> 2] | 0) | 0)) * (+e2[c3 >> 3] + +e2[c3 + 8 >> 3]))) % +(b3[a4 + 4 >> 2] | 0)) >>> 0;
        a4 = b3[(b3[a4 >> 2] | 0) + (d3 << 2) >> 2] | 0;
        if (!a4) {
          d3 = 0;
          return d3 | 0;
        }
        while (1) {
          if (mc(a4, c3) | 0) {
            c3 = 5;
            break;
          }
          a4 = b3[a4 + 32 >> 2] | 0;
          if (!a4) {
            a4 = 0;
            c3 = 5;
            break;
          }
        }
        if ((c3 | 0) == 5) {
          return a4 | 0;
        }
        return 0;
      }
      function Ed() {
        return 27920;
      }
      function Fd(a4) {
        a4 = +a4;
        return ~~+$d(+a4) | 0;
      }
      function Gd(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t2 = 0, u3 = 0, v3 = 0, w3 = 0;
        w3 = T;
        T = T + 16 | 0;
        n = w3;
        do {
          if (a4 >>> 0 < 245) {
            k = a4 >>> 0 < 11 ? 16 : a4 + 11 & -8;
            a4 = k >>> 3;
            m = b3[6981] | 0;
            d3 = m >>> a4;
            if (d3 & 3 | 0) {
              c3 = (d3 & 1 ^ 1) + a4 | 0;
              a4 = 27964 + (c3 << 1 << 2) | 0;
              d3 = a4 + 8 | 0;
              e3 = b3[d3 >> 2] | 0;
              f2 = e3 + 8 | 0;
              g2 = b3[f2 >> 2] | 0;
              if ((g2 | 0) == (a4 | 0)) {
                b3[6981] = m & ~(1 << c3);
              } else {
                b3[g2 + 12 >> 2] = a4;
                b3[d3 >> 2] = g2;
              }
              v3 = c3 << 3;
              b3[e3 + 4 >> 2] = v3 | 3;
              v3 = e3 + v3 + 4 | 0;
              b3[v3 >> 2] = b3[v3 >> 2] | 1;
              v3 = f2;
              T = w3;
              return v3 | 0;
            }
            l = b3[6983] | 0;
            if (k >>> 0 > l >>> 0) {
              if (d3 | 0) {
                c3 = 2 << a4;
                c3 = d3 << a4 & (c3 | 0 - c3);
                c3 = (c3 & 0 - c3) + -1 | 0;
                i = c3 >>> 12 & 16;
                c3 = c3 >>> i;
                d3 = c3 >>> 5 & 8;
                c3 = c3 >>> d3;
                g2 = c3 >>> 2 & 4;
                c3 = c3 >>> g2;
                a4 = c3 >>> 1 & 2;
                c3 = c3 >>> a4;
                e3 = c3 >>> 1 & 1;
                e3 = (d3 | i | g2 | a4 | e3) + (c3 >>> e3) | 0;
                c3 = 27964 + (e3 << 1 << 2) | 0;
                a4 = c3 + 8 | 0;
                g2 = b3[a4 >> 2] | 0;
                i = g2 + 8 | 0;
                d3 = b3[i >> 2] | 0;
                if ((d3 | 0) == (c3 | 0)) {
                  a4 = m & ~(1 << e3);
                  b3[6981] = a4;
                } else {
                  b3[d3 + 12 >> 2] = c3;
                  b3[a4 >> 2] = d3;
                  a4 = m;
                }
                v3 = e3 << 3;
                h = v3 - k | 0;
                b3[g2 + 4 >> 2] = k | 3;
                f2 = g2 + k | 0;
                b3[f2 + 4 >> 2] = h | 1;
                b3[g2 + v3 >> 2] = h;
                if (l | 0) {
                  e3 = b3[6986] | 0;
                  c3 = l >>> 3;
                  d3 = 27964 + (c3 << 1 << 2) | 0;
                  c3 = 1 << c3;
                  if (!(a4 & c3)) {
                    b3[6981] = a4 | c3;
                    c3 = d3;
                    a4 = d3 + 8 | 0;
                  } else {
                    a4 = d3 + 8 | 0;
                    c3 = b3[a4 >> 2] | 0;
                  }
                  b3[a4 >> 2] = e3;
                  b3[c3 + 12 >> 2] = e3;
                  b3[e3 + 8 >> 2] = c3;
                  b3[e3 + 12 >> 2] = d3;
                }
                b3[6983] = h;
                b3[6986] = f2;
                v3 = i;
                T = w3;
                return v3 | 0;
              }
              g2 = b3[6982] | 0;
              if (g2) {
                d3 = (g2 & 0 - g2) + -1 | 0;
                f2 = d3 >>> 12 & 16;
                d3 = d3 >>> f2;
                e3 = d3 >>> 5 & 8;
                d3 = d3 >>> e3;
                h = d3 >>> 2 & 4;
                d3 = d3 >>> h;
                i = d3 >>> 1 & 2;
                d3 = d3 >>> i;
                j = d3 >>> 1 & 1;
                j = b3[28228 + ((e3 | f2 | h | i | j) + (d3 >>> j) << 2) >> 2] | 0;
                d3 = j;
                i = j;
                j = (b3[j + 4 >> 2] & -8) - k | 0;
                while (1) {
                  a4 = b3[d3 + 16 >> 2] | 0;
                  if (!a4) {
                    a4 = b3[d3 + 20 >> 2] | 0;
                    if (!a4) {
                      break;
                    }
                  }
                  h = (b3[a4 + 4 >> 2] & -8) - k | 0;
                  f2 = h >>> 0 < j >>> 0;
                  d3 = a4;
                  i = f2 ? a4 : i;
                  j = f2 ? h : j;
                }
                h = i + k | 0;
                if (h >>> 0 > i >>> 0) {
                  f2 = b3[i + 24 >> 2] | 0;
                  c3 = b3[i + 12 >> 2] | 0;
                  do {
                    if ((c3 | 0) == (i | 0)) {
                      a4 = i + 20 | 0;
                      c3 = b3[a4 >> 2] | 0;
                      if (!c3) {
                        a4 = i + 16 | 0;
                        c3 = b3[a4 >> 2] | 0;
                        if (!c3) {
                          d3 = 0;
                          break;
                        }
                      }
                      while (1) {
                        e3 = c3 + 20 | 0;
                        d3 = b3[e3 >> 2] | 0;
                        if (!d3) {
                          e3 = c3 + 16 | 0;
                          d3 = b3[e3 >> 2] | 0;
                          if (!d3) {
                            break;
                          } else {
                            c3 = d3;
                            a4 = e3;
                          }
                        } else {
                          c3 = d3;
                          a4 = e3;
                        }
                      }
                      b3[a4 >> 2] = 0;
                      d3 = c3;
                    } else {
                      d3 = b3[i + 8 >> 2] | 0;
                      b3[d3 + 12 >> 2] = c3;
                      b3[c3 + 8 >> 2] = d3;
                      d3 = c3;
                    }
                  } while (0);
                  do {
                    if (f2 | 0) {
                      c3 = b3[i + 28 >> 2] | 0;
                      a4 = 28228 + (c3 << 2) | 0;
                      if ((i | 0) == (b3[a4 >> 2] | 0)) {
                        b3[a4 >> 2] = d3;
                        if (!d3) {
                          b3[6982] = g2 & ~(1 << c3);
                          break;
                        }
                      } else {
                        v3 = f2 + 16 | 0;
                        b3[((b3[v3 >> 2] | 0) == (i | 0) ? v3 : f2 + 20 | 0) >> 2] = d3;
                        if (!d3) {
                          break;
                        }
                      }
                      b3[d3 + 24 >> 2] = f2;
                      c3 = b3[i + 16 >> 2] | 0;
                      if (c3 | 0) {
                        b3[d3 + 16 >> 2] = c3;
                        b3[c3 + 24 >> 2] = d3;
                      }
                      c3 = b3[i + 20 >> 2] | 0;
                      if (c3 | 0) {
                        b3[d3 + 20 >> 2] = c3;
                        b3[c3 + 24 >> 2] = d3;
                      }
                    }
                  } while (0);
                  if (j >>> 0 < 16) {
                    v3 = j + k | 0;
                    b3[i + 4 >> 2] = v3 | 3;
                    v3 = i + v3 + 4 | 0;
                    b3[v3 >> 2] = b3[v3 >> 2] | 1;
                  } else {
                    b3[i + 4 >> 2] = k | 3;
                    b3[h + 4 >> 2] = j | 1;
                    b3[h + j >> 2] = j;
                    if (l | 0) {
                      e3 = b3[6986] | 0;
                      c3 = l >>> 3;
                      d3 = 27964 + (c3 << 1 << 2) | 0;
                      c3 = 1 << c3;
                      if (!(c3 & m)) {
                        b3[6981] = c3 | m;
                        c3 = d3;
                        a4 = d3 + 8 | 0;
                      } else {
                        a4 = d3 + 8 | 0;
                        c3 = b3[a4 >> 2] | 0;
                      }
                      b3[a4 >> 2] = e3;
                      b3[c3 + 12 >> 2] = e3;
                      b3[e3 + 8 >> 2] = c3;
                      b3[e3 + 12 >> 2] = d3;
                    }
                    b3[6983] = j;
                    b3[6986] = h;
                  }
                  v3 = i + 8 | 0;
                  T = w3;
                  return v3 | 0;
                } else {
                  m = k;
                }
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else if (a4 >>> 0 <= 4294967231) {
            a4 = a4 + 11 | 0;
            k = a4 & -8;
            e3 = b3[6982] | 0;
            if (e3) {
              f2 = 0 - k | 0;
              a4 = a4 >>> 8;
              if (a4) {
                if (k >>> 0 > 16777215) {
                  j = 31;
                } else {
                  m = (a4 + 1048320 | 0) >>> 16 & 8;
                  q2 = a4 << m;
                  i = (q2 + 520192 | 0) >>> 16 & 4;
                  q2 = q2 << i;
                  j = (q2 + 245760 | 0) >>> 16 & 2;
                  j = 14 - (i | m | j) + (q2 << j >>> 15) | 0;
                  j = k >>> (j + 7 | 0) & 1 | j << 1;
                }
              } else {
                j = 0;
              }
              d3 = b3[28228 + (j << 2) >> 2] | 0;
              a: do {
                if (!d3) {
                  d3 = 0;
                  a4 = 0;
                  q2 = 61;
                } else {
                  a4 = 0;
                  i = k << ((j | 0) == 31 ? 0 : 25 - (j >>> 1) | 0);
                  g2 = 0;
                  while (1) {
                    h = (b3[d3 + 4 >> 2] & -8) - k | 0;
                    if (h >>> 0 < f2 >>> 0) {
                      if (!h) {
                        a4 = d3;
                        f2 = 0;
                        q2 = 65;
                        break a;
                      } else {
                        a4 = d3;
                        f2 = h;
                      }
                    }
                    q2 = b3[d3 + 20 >> 2] | 0;
                    d3 = b3[d3 + 16 + (i >>> 31 << 2) >> 2] | 0;
                    g2 = (q2 | 0) == 0 | (q2 | 0) == (d3 | 0) ? g2 : q2;
                    if (!d3) {
                      d3 = g2;
                      q2 = 61;
                      break;
                    } else {
                      i = i << 1;
                    }
                  }
                }
              } while (0);
              if ((q2 | 0) == 61) {
                if ((d3 | 0) == 0 & (a4 | 0) == 0) {
                  a4 = 2 << j;
                  a4 = (a4 | 0 - a4) & e3;
                  if (!a4) {
                    m = k;
                    break;
                  }
                  m = (a4 & 0 - a4) + -1 | 0;
                  h = m >>> 12 & 16;
                  m = m >>> h;
                  g2 = m >>> 5 & 8;
                  m = m >>> g2;
                  i = m >>> 2 & 4;
                  m = m >>> i;
                  j = m >>> 1 & 2;
                  m = m >>> j;
                  d3 = m >>> 1 & 1;
                  a4 = 0;
                  d3 = b3[28228 + ((g2 | h | i | j | d3) + (m >>> d3) << 2) >> 2] | 0;
                }
                if (!d3) {
                  i = a4;
                  h = f2;
                } else {
                  q2 = 65;
                }
              }
              if ((q2 | 0) == 65) {
                g2 = d3;
                while (1) {
                  m = (b3[g2 + 4 >> 2] & -8) - k | 0;
                  d3 = m >>> 0 < f2 >>> 0;
                  f2 = d3 ? m : f2;
                  a4 = d3 ? g2 : a4;
                  d3 = b3[g2 + 16 >> 2] | 0;
                  if (!d3) {
                    d3 = b3[g2 + 20 >> 2] | 0;
                  }
                  if (!d3) {
                    i = a4;
                    h = f2;
                    break;
                  } else {
                    g2 = d3;
                  }
                }
              }
              if (((i | 0) != 0 ? h >>> 0 < ((b3[6983] | 0) - k | 0) >>> 0 : 0) ? (l = i + k | 0, l >>> 0 > i >>> 0) : 0) {
                g2 = b3[i + 24 >> 2] | 0;
                c3 = b3[i + 12 >> 2] | 0;
                do {
                  if ((c3 | 0) == (i | 0)) {
                    a4 = i + 20 | 0;
                    c3 = b3[a4 >> 2] | 0;
                    if (!c3) {
                      a4 = i + 16 | 0;
                      c3 = b3[a4 >> 2] | 0;
                      if (!c3) {
                        c3 = 0;
                        break;
                      }
                    }
                    while (1) {
                      f2 = c3 + 20 | 0;
                      d3 = b3[f2 >> 2] | 0;
                      if (!d3) {
                        f2 = c3 + 16 | 0;
                        d3 = b3[f2 >> 2] | 0;
                        if (!d3) {
                          break;
                        } else {
                          c3 = d3;
                          a4 = f2;
                        }
                      } else {
                        c3 = d3;
                        a4 = f2;
                      }
                    }
                    b3[a4 >> 2] = 0;
                  } else {
                    v3 = b3[i + 8 >> 2] | 0;
                    b3[v3 + 12 >> 2] = c3;
                    b3[c3 + 8 >> 2] = v3;
                  }
                } while (0);
                do {
                  if (g2) {
                    a4 = b3[i + 28 >> 2] | 0;
                    d3 = 28228 + (a4 << 2) | 0;
                    if ((i | 0) == (b3[d3 >> 2] | 0)) {
                      b3[d3 >> 2] = c3;
                      if (!c3) {
                        e3 = e3 & ~(1 << a4);
                        b3[6982] = e3;
                        break;
                      }
                    } else {
                      v3 = g2 + 16 | 0;
                      b3[((b3[v3 >> 2] | 0) == (i | 0) ? v3 : g2 + 20 | 0) >> 2] = c3;
                      if (!c3) {
                        break;
                      }
                    }
                    b3[c3 + 24 >> 2] = g2;
                    a4 = b3[i + 16 >> 2] | 0;
                    if (a4 | 0) {
                      b3[c3 + 16 >> 2] = a4;
                      b3[a4 + 24 >> 2] = c3;
                    }
                    a4 = b3[i + 20 >> 2] | 0;
                    if (a4) {
                      b3[c3 + 20 >> 2] = a4;
                      b3[a4 + 24 >> 2] = c3;
                    }
                  }
                } while (0);
                b: do {
                  if (h >>> 0 < 16) {
                    v3 = h + k | 0;
                    b3[i + 4 >> 2] = v3 | 3;
                    v3 = i + v3 + 4 | 0;
                    b3[v3 >> 2] = b3[v3 >> 2] | 1;
                  } else {
                    b3[i + 4 >> 2] = k | 3;
                    b3[l + 4 >> 2] = h | 1;
                    b3[l + h >> 2] = h;
                    c3 = h >>> 3;
                    if (h >>> 0 < 256) {
                      d3 = 27964 + (c3 << 1 << 2) | 0;
                      a4 = b3[6981] | 0;
                      c3 = 1 << c3;
                      if (!(a4 & c3)) {
                        b3[6981] = a4 | c3;
                        c3 = d3;
                        a4 = d3 + 8 | 0;
                      } else {
                        a4 = d3 + 8 | 0;
                        c3 = b3[a4 >> 2] | 0;
                      }
                      b3[a4 >> 2] = l;
                      b3[c3 + 12 >> 2] = l;
                      b3[l + 8 >> 2] = c3;
                      b3[l + 12 >> 2] = d3;
                      break;
                    }
                    c3 = h >>> 8;
                    if (c3) {
                      if (h >>> 0 > 16777215) {
                        d3 = 31;
                      } else {
                        u3 = (c3 + 1048320 | 0) >>> 16 & 8;
                        v3 = c3 << u3;
                        t2 = (v3 + 520192 | 0) >>> 16 & 4;
                        v3 = v3 << t2;
                        d3 = (v3 + 245760 | 0) >>> 16 & 2;
                        d3 = 14 - (t2 | u3 | d3) + (v3 << d3 >>> 15) | 0;
                        d3 = h >>> (d3 + 7 | 0) & 1 | d3 << 1;
                      }
                    } else {
                      d3 = 0;
                    }
                    c3 = 28228 + (d3 << 2) | 0;
                    b3[l + 28 >> 2] = d3;
                    a4 = l + 16 | 0;
                    b3[a4 + 4 >> 2] = 0;
                    b3[a4 >> 2] = 0;
                    a4 = 1 << d3;
                    if (!(e3 & a4)) {
                      b3[6982] = e3 | a4;
                      b3[c3 >> 2] = l;
                      b3[l + 24 >> 2] = c3;
                      b3[l + 12 >> 2] = l;
                      b3[l + 8 >> 2] = l;
                      break;
                    }
                    c3 = b3[c3 >> 2] | 0;
                    c: do {
                      if ((b3[c3 + 4 >> 2] & -8 | 0) != (h | 0)) {
                        e3 = h << ((d3 | 0) == 31 ? 0 : 25 - (d3 >>> 1) | 0);
                        while (1) {
                          d3 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                          a4 = b3[d3 >> 2] | 0;
                          if (!a4) {
                            break;
                          }
                          if ((b3[a4 + 4 >> 2] & -8 | 0) == (h | 0)) {
                            c3 = a4;
                            break c;
                          } else {
                            e3 = e3 << 1;
                            c3 = a4;
                          }
                        }
                        b3[d3 >> 2] = l;
                        b3[l + 24 >> 2] = c3;
                        b3[l + 12 >> 2] = l;
                        b3[l + 8 >> 2] = l;
                        break b;
                      }
                    } while (0);
                    u3 = c3 + 8 | 0;
                    v3 = b3[u3 >> 2] | 0;
                    b3[v3 + 12 >> 2] = l;
                    b3[u3 >> 2] = l;
                    b3[l + 8 >> 2] = v3;
                    b3[l + 12 >> 2] = c3;
                    b3[l + 24 >> 2] = 0;
                  }
                } while (0);
                v3 = i + 8 | 0;
                T = w3;
                return v3 | 0;
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else {
            m = -1;
          }
        } while (0);
        d3 = b3[6983] | 0;
        if (d3 >>> 0 >= m >>> 0) {
          c3 = d3 - m | 0;
          a4 = b3[6986] | 0;
          if (c3 >>> 0 > 15) {
            v3 = a4 + m | 0;
            b3[6986] = v3;
            b3[6983] = c3;
            b3[v3 + 4 >> 2] = c3 | 1;
            b3[a4 + d3 >> 2] = c3;
            b3[a4 + 4 >> 2] = m | 3;
          } else {
            b3[6983] = 0;
            b3[6986] = 0;
            b3[a4 + 4 >> 2] = d3 | 3;
            v3 = a4 + d3 + 4 | 0;
            b3[v3 >> 2] = b3[v3 >> 2] | 1;
          }
          v3 = a4 + 8 | 0;
          T = w3;
          return v3 | 0;
        }
        h = b3[6984] | 0;
        if (h >>> 0 > m >>> 0) {
          t2 = h - m | 0;
          b3[6984] = t2;
          v3 = b3[6987] | 0;
          u3 = v3 + m | 0;
          b3[6987] = u3;
          b3[u3 + 4 >> 2] = t2 | 1;
          b3[v3 + 4 >> 2] = m | 3;
          v3 = v3 + 8 | 0;
          T = w3;
          return v3 | 0;
        }
        if (!(b3[7099] | 0)) {
          b3[7101] = 4096;
          b3[7100] = 4096;
          b3[7102] = -1;
          b3[7103] = -1;
          b3[7104] = 0;
          b3[7092] = 0;
          b3[7099] = n & -16 ^ 1431655768;
          a4 = 4096;
        } else {
          a4 = b3[7101] | 0;
        }
        i = m + 48 | 0;
        j = m + 47 | 0;
        g2 = a4 + j | 0;
        f2 = 0 - a4 | 0;
        k = g2 & f2;
        if (k >>> 0 <= m >>> 0) {
          v3 = 0;
          T = w3;
          return v3 | 0;
        }
        a4 = b3[7091] | 0;
        if (a4 | 0 ? (l = b3[7089] | 0, n = l + k | 0, n >>> 0 <= l >>> 0 | n >>> 0 > a4 >>> 0) : 0) {
          v3 = 0;
          T = w3;
          return v3 | 0;
        }
        d: do {
          if (!(b3[7092] & 4)) {
            d3 = b3[6987] | 0;
            e: do {
              if (d3) {
                e3 = 28372;
                while (1) {
                  n = b3[e3 >> 2] | 0;
                  if (n >>> 0 <= d3 >>> 0 ? (n + (b3[e3 + 4 >> 2] | 0) | 0) >>> 0 > d3 >>> 0 : 0) {
                    break;
                  }
                  a4 = b3[e3 + 8 >> 2] | 0;
                  if (!a4) {
                    q2 = 128;
                    break e;
                  } else {
                    e3 = a4;
                  }
                }
                c3 = g2 - h & f2;
                if (c3 >>> 0 < 2147483647) {
                  a4 = ae(c3 | 0) | 0;
                  if ((a4 | 0) == ((b3[e3 >> 2] | 0) + (b3[e3 + 4 >> 2] | 0) | 0)) {
                    if ((a4 | 0) != (-1 | 0)) {
                      h = c3;
                      g2 = a4;
                      q2 = 145;
                      break d;
                    }
                  } else {
                    e3 = a4;
                    q2 = 136;
                  }
                } else {
                  c3 = 0;
                }
              } else {
                q2 = 128;
              }
            } while (0);
            do {
              if ((q2 | 0) == 128) {
                d3 = ae(0) | 0;
                if ((d3 | 0) != (-1 | 0) ? (c3 = d3, o = b3[7100] | 0, p2 = o + -1 | 0, c3 = ((p2 & c3 | 0) == 0 ? 0 : (p2 + c3 & 0 - o) - c3 | 0) + k | 0, o = b3[7089] | 0, p2 = c3 + o | 0, c3 >>> 0 > m >>> 0 & c3 >>> 0 < 2147483647) : 0) {
                  n = b3[7091] | 0;
                  if (n | 0 ? p2 >>> 0 <= o >>> 0 | p2 >>> 0 > n >>> 0 : 0) {
                    c3 = 0;
                    break;
                  }
                  a4 = ae(c3 | 0) | 0;
                  if ((a4 | 0) == (d3 | 0)) {
                    h = c3;
                    g2 = d3;
                    q2 = 145;
                    break d;
                  } else {
                    e3 = a4;
                    q2 = 136;
                  }
                } else {
                  c3 = 0;
                }
              }
            } while (0);
            do {
              if ((q2 | 0) == 136) {
                d3 = 0 - c3 | 0;
                if (!(i >>> 0 > c3 >>> 0 & (c3 >>> 0 < 2147483647 & (e3 | 0) != (-1 | 0)))) {
                  if ((e3 | 0) == (-1 | 0)) {
                    c3 = 0;
                    break;
                  } else {
                    h = c3;
                    g2 = e3;
                    q2 = 145;
                    break d;
                  }
                }
                a4 = b3[7101] | 0;
                a4 = j - c3 + a4 & 0 - a4;
                if (a4 >>> 0 >= 2147483647) {
                  h = c3;
                  g2 = e3;
                  q2 = 145;
                  break d;
                }
                if ((ae(a4 | 0) | 0) == (-1 | 0)) {
                  ae(d3 | 0) | 0;
                  c3 = 0;
                  break;
                } else {
                  h = a4 + c3 | 0;
                  g2 = e3;
                  q2 = 145;
                  break d;
                }
              }
            } while (0);
            b3[7092] = b3[7092] | 4;
            q2 = 143;
          } else {
            c3 = 0;
            q2 = 143;
          }
        } while (0);
        if (((q2 | 0) == 143 ? k >>> 0 < 2147483647 : 0) ? (t2 = ae(k | 0) | 0, p2 = ae(0) | 0, r2 = p2 - t2 | 0, s2 = r2 >>> 0 > (m + 40 | 0) >>> 0, !((t2 | 0) == (-1 | 0) | s2 ^ 1 | t2 >>> 0 < p2 >>> 0 & ((t2 | 0) != (-1 | 0) & (p2 | 0) != (-1 | 0)) ^ 1)) : 0) {
          h = s2 ? r2 : c3;
          g2 = t2;
          q2 = 145;
        }
        if ((q2 | 0) == 145) {
          c3 = (b3[7089] | 0) + h | 0;
          b3[7089] = c3;
          if (c3 >>> 0 > (b3[7090] | 0) >>> 0) {
            b3[7090] = c3;
          }
          j = b3[6987] | 0;
          f: do {
            if (j) {
              c3 = 28372;
              while (1) {
                a4 = b3[c3 >> 2] | 0;
                d3 = b3[c3 + 4 >> 2] | 0;
                if ((g2 | 0) == (a4 + d3 | 0)) {
                  q2 = 154;
                  break;
                }
                e3 = b3[c3 + 8 >> 2] | 0;
                if (!e3) {
                  break;
                } else {
                  c3 = e3;
                }
              }
              if (((q2 | 0) == 154 ? (u3 = c3 + 4 | 0, (b3[c3 + 12 >> 2] & 8 | 0) == 0) : 0) ? g2 >>> 0 > j >>> 0 & a4 >>> 0 <= j >>> 0 : 0) {
                b3[u3 >> 2] = d3 + h;
                v3 = (b3[6984] | 0) + h | 0;
                t2 = j + 8 | 0;
                t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
                u3 = j + t2 | 0;
                t2 = v3 - t2 | 0;
                b3[6987] = u3;
                b3[6984] = t2;
                b3[u3 + 4 >> 2] = t2 | 1;
                b3[j + v3 + 4 >> 2] = 40;
                b3[6988] = b3[7103];
                break;
              }
              if (g2 >>> 0 < (b3[6985] | 0) >>> 0) {
                b3[6985] = g2;
              }
              d3 = g2 + h | 0;
              c3 = 28372;
              while (1) {
                if ((b3[c3 >> 2] | 0) == (d3 | 0)) {
                  q2 = 162;
                  break;
                }
                a4 = b3[c3 + 8 >> 2] | 0;
                if (!a4) {
                  break;
                } else {
                  c3 = a4;
                }
              }
              if ((q2 | 0) == 162 ? (b3[c3 + 12 >> 2] & 8 | 0) == 0 : 0) {
                b3[c3 >> 2] = g2;
                l = c3 + 4 | 0;
                b3[l >> 2] = (b3[l >> 2] | 0) + h;
                l = g2 + 8 | 0;
                l = g2 + ((l & 7 | 0) == 0 ? 0 : 0 - l & 7) | 0;
                c3 = d3 + 8 | 0;
                c3 = d3 + ((c3 & 7 | 0) == 0 ? 0 : 0 - c3 & 7) | 0;
                k = l + m | 0;
                i = c3 - l - m | 0;
                b3[l + 4 >> 2] = m | 3;
                g: do {
                  if ((j | 0) == (c3 | 0)) {
                    v3 = (b3[6984] | 0) + i | 0;
                    b3[6984] = v3;
                    b3[6987] = k;
                    b3[k + 4 >> 2] = v3 | 1;
                  } else {
                    if ((b3[6986] | 0) == (c3 | 0)) {
                      v3 = (b3[6983] | 0) + i | 0;
                      b3[6983] = v3;
                      b3[6986] = k;
                      b3[k + 4 >> 2] = v3 | 1;
                      b3[k + v3 >> 2] = v3;
                      break;
                    }
                    a4 = b3[c3 + 4 >> 2] | 0;
                    if ((a4 & 3 | 0) == 1) {
                      h = a4 & -8;
                      e3 = a4 >>> 3;
                      h: do {
                        if (a4 >>> 0 < 256) {
                          a4 = b3[c3 + 8 >> 2] | 0;
                          d3 = b3[c3 + 12 >> 2] | 0;
                          if ((d3 | 0) == (a4 | 0)) {
                            b3[6981] = b3[6981] & ~(1 << e3);
                            break;
                          } else {
                            b3[a4 + 12 >> 2] = d3;
                            b3[d3 + 8 >> 2] = a4;
                            break;
                          }
                        } else {
                          g2 = b3[c3 + 24 >> 2] | 0;
                          a4 = b3[c3 + 12 >> 2] | 0;
                          do {
                            if ((a4 | 0) == (c3 | 0)) {
                              d3 = c3 + 16 | 0;
                              e3 = d3 + 4 | 0;
                              a4 = b3[e3 >> 2] | 0;
                              if (!a4) {
                                a4 = b3[d3 >> 2] | 0;
                                if (!a4) {
                                  a4 = 0;
                                  break;
                                }
                              } else {
                                d3 = e3;
                              }
                              while (1) {
                                f2 = a4 + 20 | 0;
                                e3 = b3[f2 >> 2] | 0;
                                if (!e3) {
                                  f2 = a4 + 16 | 0;
                                  e3 = b3[f2 >> 2] | 0;
                                  if (!e3) {
                                    break;
                                  } else {
                                    a4 = e3;
                                    d3 = f2;
                                  }
                                } else {
                                  a4 = e3;
                                  d3 = f2;
                                }
                              }
                              b3[d3 >> 2] = 0;
                            } else {
                              v3 = b3[c3 + 8 >> 2] | 0;
                              b3[v3 + 12 >> 2] = a4;
                              b3[a4 + 8 >> 2] = v3;
                            }
                          } while (0);
                          if (!g2) {
                            break;
                          }
                          d3 = b3[c3 + 28 >> 2] | 0;
                          e3 = 28228 + (d3 << 2) | 0;
                          do {
                            if ((b3[e3 >> 2] | 0) != (c3 | 0)) {
                              v3 = g2 + 16 | 0;
                              b3[((b3[v3 >> 2] | 0) == (c3 | 0) ? v3 : g2 + 20 | 0) >> 2] = a4;
                              if (!a4) {
                                break h;
                              }
                            } else {
                              b3[e3 >> 2] = a4;
                              if (a4 | 0) {
                                break;
                              }
                              b3[6982] = b3[6982] & ~(1 << d3);
                              break h;
                            }
                          } while (0);
                          b3[a4 + 24 >> 2] = g2;
                          d3 = c3 + 16 | 0;
                          e3 = b3[d3 >> 2] | 0;
                          if (e3 | 0) {
                            b3[a4 + 16 >> 2] = e3;
                            b3[e3 + 24 >> 2] = a4;
                          }
                          d3 = b3[d3 + 4 >> 2] | 0;
                          if (!d3) {
                            break;
                          }
                          b3[a4 + 20 >> 2] = d3;
                          b3[d3 + 24 >> 2] = a4;
                        }
                      } while (0);
                      c3 = c3 + h | 0;
                      f2 = h + i | 0;
                    } else {
                      f2 = i;
                    }
                    c3 = c3 + 4 | 0;
                    b3[c3 >> 2] = b3[c3 >> 2] & -2;
                    b3[k + 4 >> 2] = f2 | 1;
                    b3[k + f2 >> 2] = f2;
                    c3 = f2 >>> 3;
                    if (f2 >>> 0 < 256) {
                      d3 = 27964 + (c3 << 1 << 2) | 0;
                      a4 = b3[6981] | 0;
                      c3 = 1 << c3;
                      if (!(a4 & c3)) {
                        b3[6981] = a4 | c3;
                        c3 = d3;
                        a4 = d3 + 8 | 0;
                      } else {
                        a4 = d3 + 8 | 0;
                        c3 = b3[a4 >> 2] | 0;
                      }
                      b3[a4 >> 2] = k;
                      b3[c3 + 12 >> 2] = k;
                      b3[k + 8 >> 2] = c3;
                      b3[k + 12 >> 2] = d3;
                      break;
                    }
                    c3 = f2 >>> 8;
                    do {
                      if (!c3) {
                        e3 = 0;
                      } else {
                        if (f2 >>> 0 > 16777215) {
                          e3 = 31;
                          break;
                        }
                        u3 = (c3 + 1048320 | 0) >>> 16 & 8;
                        v3 = c3 << u3;
                        t2 = (v3 + 520192 | 0) >>> 16 & 4;
                        v3 = v3 << t2;
                        e3 = (v3 + 245760 | 0) >>> 16 & 2;
                        e3 = 14 - (t2 | u3 | e3) + (v3 << e3 >>> 15) | 0;
                        e3 = f2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                      }
                    } while (0);
                    c3 = 28228 + (e3 << 2) | 0;
                    b3[k + 28 >> 2] = e3;
                    a4 = k + 16 | 0;
                    b3[a4 + 4 >> 2] = 0;
                    b3[a4 >> 2] = 0;
                    a4 = b3[6982] | 0;
                    d3 = 1 << e3;
                    if (!(a4 & d3)) {
                      b3[6982] = a4 | d3;
                      b3[c3 >> 2] = k;
                      b3[k + 24 >> 2] = c3;
                      b3[k + 12 >> 2] = k;
                      b3[k + 8 >> 2] = k;
                      break;
                    }
                    c3 = b3[c3 >> 2] | 0;
                    i: do {
                      if ((b3[c3 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                        e3 = f2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                        while (1) {
                          d3 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                          a4 = b3[d3 >> 2] | 0;
                          if (!a4) {
                            break;
                          }
                          if ((b3[a4 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                            c3 = a4;
                            break i;
                          } else {
                            e3 = e3 << 1;
                            c3 = a4;
                          }
                        }
                        b3[d3 >> 2] = k;
                        b3[k + 24 >> 2] = c3;
                        b3[k + 12 >> 2] = k;
                        b3[k + 8 >> 2] = k;
                        break g;
                      }
                    } while (0);
                    u3 = c3 + 8 | 0;
                    v3 = b3[u3 >> 2] | 0;
                    b3[v3 + 12 >> 2] = k;
                    b3[u3 >> 2] = k;
                    b3[k + 8 >> 2] = v3;
                    b3[k + 12 >> 2] = c3;
                    b3[k + 24 >> 2] = 0;
                  }
                } while (0);
                v3 = l + 8 | 0;
                T = w3;
                return v3 | 0;
              }
              c3 = 28372;
              while (1) {
                a4 = b3[c3 >> 2] | 0;
                if (a4 >>> 0 <= j >>> 0 ? (v3 = a4 + (b3[c3 + 4 >> 2] | 0) | 0, v3 >>> 0 > j >>> 0) : 0) {
                  break;
                }
                c3 = b3[c3 + 8 >> 2] | 0;
              }
              f2 = v3 + -47 | 0;
              a4 = f2 + 8 | 0;
              a4 = f2 + ((a4 & 7 | 0) == 0 ? 0 : 0 - a4 & 7) | 0;
              f2 = j + 16 | 0;
              a4 = a4 >>> 0 < f2 >>> 0 ? j : a4;
              c3 = a4 + 8 | 0;
              d3 = h + -40 | 0;
              t2 = g2 + 8 | 0;
              t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
              u3 = g2 + t2 | 0;
              t2 = d3 - t2 | 0;
              b3[6987] = u3;
              b3[6984] = t2;
              b3[u3 + 4 >> 2] = t2 | 1;
              b3[g2 + d3 + 4 >> 2] = 40;
              b3[6988] = b3[7103];
              d3 = a4 + 4 | 0;
              b3[d3 >> 2] = 27;
              b3[c3 >> 2] = b3[7093];
              b3[c3 + 4 >> 2] = b3[7094];
              b3[c3 + 8 >> 2] = b3[7095];
              b3[c3 + 12 >> 2] = b3[7096];
              b3[7093] = g2;
              b3[7094] = h;
              b3[7096] = 0;
              b3[7095] = c3;
              c3 = a4 + 24 | 0;
              do {
                u3 = c3;
                c3 = c3 + 4 | 0;
                b3[c3 >> 2] = 7;
              } while ((u3 + 8 | 0) >>> 0 < v3 >>> 0);
              if ((a4 | 0) != (j | 0)) {
                g2 = a4 - j | 0;
                b3[d3 >> 2] = b3[d3 >> 2] & -2;
                b3[j + 4 >> 2] = g2 | 1;
                b3[a4 >> 2] = g2;
                c3 = g2 >>> 3;
                if (g2 >>> 0 < 256) {
                  d3 = 27964 + (c3 << 1 << 2) | 0;
                  a4 = b3[6981] | 0;
                  c3 = 1 << c3;
                  if (!(a4 & c3)) {
                    b3[6981] = a4 | c3;
                    c3 = d3;
                    a4 = d3 + 8 | 0;
                  } else {
                    a4 = d3 + 8 | 0;
                    c3 = b3[a4 >> 2] | 0;
                  }
                  b3[a4 >> 2] = j;
                  b3[c3 + 12 >> 2] = j;
                  b3[j + 8 >> 2] = c3;
                  b3[j + 12 >> 2] = d3;
                  break;
                }
                c3 = g2 >>> 8;
                if (c3) {
                  if (g2 >>> 0 > 16777215) {
                    e3 = 31;
                  } else {
                    u3 = (c3 + 1048320 | 0) >>> 16 & 8;
                    v3 = c3 << u3;
                    t2 = (v3 + 520192 | 0) >>> 16 & 4;
                    v3 = v3 << t2;
                    e3 = (v3 + 245760 | 0) >>> 16 & 2;
                    e3 = 14 - (t2 | u3 | e3) + (v3 << e3 >>> 15) | 0;
                    e3 = g2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                  }
                } else {
                  e3 = 0;
                }
                d3 = 28228 + (e3 << 2) | 0;
                b3[j + 28 >> 2] = e3;
                b3[j + 20 >> 2] = 0;
                b3[f2 >> 2] = 0;
                c3 = b3[6982] | 0;
                a4 = 1 << e3;
                if (!(c3 & a4)) {
                  b3[6982] = c3 | a4;
                  b3[d3 >> 2] = j;
                  b3[j + 24 >> 2] = d3;
                  b3[j + 12 >> 2] = j;
                  b3[j + 8 >> 2] = j;
                  break;
                }
                c3 = b3[d3 >> 2] | 0;
                j: do {
                  if ((b3[c3 + 4 >> 2] & -8 | 0) != (g2 | 0)) {
                    e3 = g2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                    while (1) {
                      d3 = c3 + 16 + (e3 >>> 31 << 2) | 0;
                      a4 = b3[d3 >> 2] | 0;
                      if (!a4) {
                        break;
                      }
                      if ((b3[a4 + 4 >> 2] & -8 | 0) == (g2 | 0)) {
                        c3 = a4;
                        break j;
                      } else {
                        e3 = e3 << 1;
                        c3 = a4;
                      }
                    }
                    b3[d3 >> 2] = j;
                    b3[j + 24 >> 2] = c3;
                    b3[j + 12 >> 2] = j;
                    b3[j + 8 >> 2] = j;
                    break f;
                  }
                } while (0);
                u3 = c3 + 8 | 0;
                v3 = b3[u3 >> 2] | 0;
                b3[v3 + 12 >> 2] = j;
                b3[u3 >> 2] = j;
                b3[j + 8 >> 2] = v3;
                b3[j + 12 >> 2] = c3;
                b3[j + 24 >> 2] = 0;
              }
            } else {
              v3 = b3[6985] | 0;
              if ((v3 | 0) == 0 | g2 >>> 0 < v3 >>> 0) {
                b3[6985] = g2;
              }
              b3[7093] = g2;
              b3[7094] = h;
              b3[7096] = 0;
              b3[6990] = b3[7099];
              b3[6989] = -1;
              b3[6994] = 27964;
              b3[6993] = 27964;
              b3[6996] = 27972;
              b3[6995] = 27972;
              b3[6998] = 27980;
              b3[6997] = 27980;
              b3[7e3] = 27988;
              b3[6999] = 27988;
              b3[7002] = 27996;
              b3[7001] = 27996;
              b3[7004] = 28004;
              b3[7003] = 28004;
              b3[7006] = 28012;
              b3[7005] = 28012;
              b3[7008] = 28020;
              b3[7007] = 28020;
              b3[7010] = 28028;
              b3[7009] = 28028;
              b3[7012] = 28036;
              b3[7011] = 28036;
              b3[7014] = 28044;
              b3[7013] = 28044;
              b3[7016] = 28052;
              b3[7015] = 28052;
              b3[7018] = 28060;
              b3[7017] = 28060;
              b3[7020] = 28068;
              b3[7019] = 28068;
              b3[7022] = 28076;
              b3[7021] = 28076;
              b3[7024] = 28084;
              b3[7023] = 28084;
              b3[7026] = 28092;
              b3[7025] = 28092;
              b3[7028] = 28100;
              b3[7027] = 28100;
              b3[7030] = 28108;
              b3[7029] = 28108;
              b3[7032] = 28116;
              b3[7031] = 28116;
              b3[7034] = 28124;
              b3[7033] = 28124;
              b3[7036] = 28132;
              b3[7035] = 28132;
              b3[7038] = 28140;
              b3[7037] = 28140;
              b3[7040] = 28148;
              b3[7039] = 28148;
              b3[7042] = 28156;
              b3[7041] = 28156;
              b3[7044] = 28164;
              b3[7043] = 28164;
              b3[7046] = 28172;
              b3[7045] = 28172;
              b3[7048] = 28180;
              b3[7047] = 28180;
              b3[7050] = 28188;
              b3[7049] = 28188;
              b3[7052] = 28196;
              b3[7051] = 28196;
              b3[7054] = 28204;
              b3[7053] = 28204;
              b3[7056] = 28212;
              b3[7055] = 28212;
              v3 = h + -40 | 0;
              t2 = g2 + 8 | 0;
              t2 = (t2 & 7 | 0) == 0 ? 0 : 0 - t2 & 7;
              u3 = g2 + t2 | 0;
              t2 = v3 - t2 | 0;
              b3[6987] = u3;
              b3[6984] = t2;
              b3[u3 + 4 >> 2] = t2 | 1;
              b3[g2 + v3 + 4 >> 2] = 40;
              b3[6988] = b3[7103];
            }
          } while (0);
          c3 = b3[6984] | 0;
          if (c3 >>> 0 > m >>> 0) {
            t2 = c3 - m | 0;
            b3[6984] = t2;
            v3 = b3[6987] | 0;
            u3 = v3 + m | 0;
            b3[6987] = u3;
            b3[u3 + 4 >> 2] = t2 | 1;
            b3[v3 + 4 >> 2] = m | 3;
            v3 = v3 + 8 | 0;
            T = w3;
            return v3 | 0;
          }
        }
        v3 = Ed() | 0;
        b3[v3 >> 2] = 12;
        v3 = 0;
        T = w3;
        return v3 | 0;
      }
      function Hd(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        if (!a4) {
          return;
        }
        d3 = a4 + -8 | 0;
        f2 = b3[6985] | 0;
        a4 = b3[a4 + -4 >> 2] | 0;
        c3 = a4 & -8;
        j = d3 + c3 | 0;
        do {
          if (!(a4 & 1)) {
            e3 = b3[d3 >> 2] | 0;
            if (!(a4 & 3)) {
              return;
            }
            h = d3 + (0 - e3) | 0;
            g2 = e3 + c3 | 0;
            if (h >>> 0 < f2 >>> 0) {
              return;
            }
            if ((b3[6986] | 0) == (h | 0)) {
              a4 = j + 4 | 0;
              c3 = b3[a4 >> 2] | 0;
              if ((c3 & 3 | 0) != 3) {
                i = h;
                c3 = g2;
                break;
              }
              b3[6983] = g2;
              b3[a4 >> 2] = c3 & -2;
              b3[h + 4 >> 2] = g2 | 1;
              b3[h + g2 >> 2] = g2;
              return;
            }
            d3 = e3 >>> 3;
            if (e3 >>> 0 < 256) {
              a4 = b3[h + 8 >> 2] | 0;
              c3 = b3[h + 12 >> 2] | 0;
              if ((c3 | 0) == (a4 | 0)) {
                b3[6981] = b3[6981] & ~(1 << d3);
                i = h;
                c3 = g2;
                break;
              } else {
                b3[a4 + 12 >> 2] = c3;
                b3[c3 + 8 >> 2] = a4;
                i = h;
                c3 = g2;
                break;
              }
            }
            f2 = b3[h + 24 >> 2] | 0;
            a4 = b3[h + 12 >> 2] | 0;
            do {
              if ((a4 | 0) == (h | 0)) {
                c3 = h + 16 | 0;
                d3 = c3 + 4 | 0;
                a4 = b3[d3 >> 2] | 0;
                if (!a4) {
                  a4 = b3[c3 >> 2] | 0;
                  if (!a4) {
                    a4 = 0;
                    break;
                  }
                } else {
                  c3 = d3;
                }
                while (1) {
                  e3 = a4 + 20 | 0;
                  d3 = b3[e3 >> 2] | 0;
                  if (!d3) {
                    e3 = a4 + 16 | 0;
                    d3 = b3[e3 >> 2] | 0;
                    if (!d3) {
                      break;
                    } else {
                      a4 = d3;
                      c3 = e3;
                    }
                  } else {
                    a4 = d3;
                    c3 = e3;
                  }
                }
                b3[c3 >> 2] = 0;
              } else {
                i = b3[h + 8 >> 2] | 0;
                b3[i + 12 >> 2] = a4;
                b3[a4 + 8 >> 2] = i;
              }
            } while (0);
            if (f2) {
              c3 = b3[h + 28 >> 2] | 0;
              d3 = 28228 + (c3 << 2) | 0;
              if ((b3[d3 >> 2] | 0) == (h | 0)) {
                b3[d3 >> 2] = a4;
                if (!a4) {
                  b3[6982] = b3[6982] & ~(1 << c3);
                  i = h;
                  c3 = g2;
                  break;
                }
              } else {
                i = f2 + 16 | 0;
                b3[((b3[i >> 2] | 0) == (h | 0) ? i : f2 + 20 | 0) >> 2] = a4;
                if (!a4) {
                  i = h;
                  c3 = g2;
                  break;
                }
              }
              b3[a4 + 24 >> 2] = f2;
              c3 = h + 16 | 0;
              d3 = b3[c3 >> 2] | 0;
              if (d3 | 0) {
                b3[a4 + 16 >> 2] = d3;
                b3[d3 + 24 >> 2] = a4;
              }
              c3 = b3[c3 + 4 >> 2] | 0;
              if (c3) {
                b3[a4 + 20 >> 2] = c3;
                b3[c3 + 24 >> 2] = a4;
                i = h;
                c3 = g2;
              } else {
                i = h;
                c3 = g2;
              }
            } else {
              i = h;
              c3 = g2;
            }
          } else {
            i = d3;
            h = d3;
          }
        } while (0);
        if (h >>> 0 >= j >>> 0) {
          return;
        }
        a4 = j + 4 | 0;
        e3 = b3[a4 >> 2] | 0;
        if (!(e3 & 1)) {
          return;
        }
        if (!(e3 & 2)) {
          if ((b3[6987] | 0) == (j | 0)) {
            j = (b3[6984] | 0) + c3 | 0;
            b3[6984] = j;
            b3[6987] = i;
            b3[i + 4 >> 2] = j | 1;
            if ((i | 0) != (b3[6986] | 0)) {
              return;
            }
            b3[6986] = 0;
            b3[6983] = 0;
            return;
          }
          if ((b3[6986] | 0) == (j | 0)) {
            j = (b3[6983] | 0) + c3 | 0;
            b3[6983] = j;
            b3[6986] = h;
            b3[i + 4 >> 2] = j | 1;
            b3[h + j >> 2] = j;
            return;
          }
          f2 = (e3 & -8) + c3 | 0;
          d3 = e3 >>> 3;
          do {
            if (e3 >>> 0 < 256) {
              c3 = b3[j + 8 >> 2] | 0;
              a4 = b3[j + 12 >> 2] | 0;
              if ((a4 | 0) == (c3 | 0)) {
                b3[6981] = b3[6981] & ~(1 << d3);
                break;
              } else {
                b3[c3 + 12 >> 2] = a4;
                b3[a4 + 8 >> 2] = c3;
                break;
              }
            } else {
              g2 = b3[j + 24 >> 2] | 0;
              a4 = b3[j + 12 >> 2] | 0;
              do {
                if ((a4 | 0) == (j | 0)) {
                  c3 = j + 16 | 0;
                  d3 = c3 + 4 | 0;
                  a4 = b3[d3 >> 2] | 0;
                  if (!a4) {
                    a4 = b3[c3 >> 2] | 0;
                    if (!a4) {
                      d3 = 0;
                      break;
                    }
                  } else {
                    c3 = d3;
                  }
                  while (1) {
                    e3 = a4 + 20 | 0;
                    d3 = b3[e3 >> 2] | 0;
                    if (!d3) {
                      e3 = a4 + 16 | 0;
                      d3 = b3[e3 >> 2] | 0;
                      if (!d3) {
                        break;
                      } else {
                        a4 = d3;
                        c3 = e3;
                      }
                    } else {
                      a4 = d3;
                      c3 = e3;
                    }
                  }
                  b3[c3 >> 2] = 0;
                  d3 = a4;
                } else {
                  d3 = b3[j + 8 >> 2] | 0;
                  b3[d3 + 12 >> 2] = a4;
                  b3[a4 + 8 >> 2] = d3;
                  d3 = a4;
                }
              } while (0);
              if (g2 | 0) {
                a4 = b3[j + 28 >> 2] | 0;
                c3 = 28228 + (a4 << 2) | 0;
                if ((b3[c3 >> 2] | 0) == (j | 0)) {
                  b3[c3 >> 2] = d3;
                  if (!d3) {
                    b3[6982] = b3[6982] & ~(1 << a4);
                    break;
                  }
                } else {
                  e3 = g2 + 16 | 0;
                  b3[((b3[e3 >> 2] | 0) == (j | 0) ? e3 : g2 + 20 | 0) >> 2] = d3;
                  if (!d3) {
                    break;
                  }
                }
                b3[d3 + 24 >> 2] = g2;
                a4 = j + 16 | 0;
                c3 = b3[a4 >> 2] | 0;
                if (c3 | 0) {
                  b3[d3 + 16 >> 2] = c3;
                  b3[c3 + 24 >> 2] = d3;
                }
                a4 = b3[a4 + 4 >> 2] | 0;
                if (a4 | 0) {
                  b3[d3 + 20 >> 2] = a4;
                  b3[a4 + 24 >> 2] = d3;
                }
              }
            }
          } while (0);
          b3[i + 4 >> 2] = f2 | 1;
          b3[h + f2 >> 2] = f2;
          if ((i | 0) == (b3[6986] | 0)) {
            b3[6983] = f2;
            return;
          }
        } else {
          b3[a4 >> 2] = e3 & -2;
          b3[i + 4 >> 2] = c3 | 1;
          b3[h + c3 >> 2] = c3;
          f2 = c3;
        }
        a4 = f2 >>> 3;
        if (f2 >>> 0 < 256) {
          d3 = 27964 + (a4 << 1 << 2) | 0;
          c3 = b3[6981] | 0;
          a4 = 1 << a4;
          if (!(c3 & a4)) {
            b3[6981] = c3 | a4;
            a4 = d3;
            c3 = d3 + 8 | 0;
          } else {
            c3 = d3 + 8 | 0;
            a4 = b3[c3 >> 2] | 0;
          }
          b3[c3 >> 2] = i;
          b3[a4 + 12 >> 2] = i;
          b3[i + 8 >> 2] = a4;
          b3[i + 12 >> 2] = d3;
          return;
        }
        a4 = f2 >>> 8;
        if (a4) {
          if (f2 >>> 0 > 16777215) {
            e3 = 31;
          } else {
            h = (a4 + 1048320 | 0) >>> 16 & 8;
            j = a4 << h;
            g2 = (j + 520192 | 0) >>> 16 & 4;
            j = j << g2;
            e3 = (j + 245760 | 0) >>> 16 & 2;
            e3 = 14 - (g2 | h | e3) + (j << e3 >>> 15) | 0;
            e3 = f2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
          }
        } else {
          e3 = 0;
        }
        a4 = 28228 + (e3 << 2) | 0;
        b3[i + 28 >> 2] = e3;
        b3[i + 20 >> 2] = 0;
        b3[i + 16 >> 2] = 0;
        c3 = b3[6982] | 0;
        d3 = 1 << e3;
        a: do {
          if (!(c3 & d3)) {
            b3[6982] = c3 | d3;
            b3[a4 >> 2] = i;
            b3[i + 24 >> 2] = a4;
            b3[i + 12 >> 2] = i;
            b3[i + 8 >> 2] = i;
          } else {
            a4 = b3[a4 >> 2] | 0;
            b: do {
              if ((b3[a4 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                e3 = f2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                while (1) {
                  d3 = a4 + 16 + (e3 >>> 31 << 2) | 0;
                  c3 = b3[d3 >> 2] | 0;
                  if (!c3) {
                    break;
                  }
                  if ((b3[c3 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                    a4 = c3;
                    break b;
                  } else {
                    e3 = e3 << 1;
                    a4 = c3;
                  }
                }
                b3[d3 >> 2] = i;
                b3[i + 24 >> 2] = a4;
                b3[i + 12 >> 2] = i;
                b3[i + 8 >> 2] = i;
                break a;
              }
            } while (0);
            h = a4 + 8 | 0;
            j = b3[h >> 2] | 0;
            b3[j + 12 >> 2] = i;
            b3[h >> 2] = i;
            b3[i + 8 >> 2] = j;
            b3[i + 12 >> 2] = a4;
            b3[i + 24 >> 2] = 0;
          }
        } while (0);
        j = (b3[6989] | 0) + -1 | 0;
        b3[6989] = j;
        if (j | 0) {
          return;
        }
        a4 = 28380;
        while (1) {
          a4 = b3[a4 >> 2] | 0;
          if (!a4) {
            break;
          } else {
            a4 = a4 + 8 | 0;
          }
        }
        b3[6989] = -1;
        return;
      }
      function Id(a4, c3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        var d3 = 0;
        if (a4) {
          d3 = B2(c3, a4) | 0;
          if ((c3 | a4) >>> 0 > 65535) {
            d3 = ((d3 >>> 0) / (a4 >>> 0) | 0 | 0) == (c3 | 0) ? d3 : -1;
          }
        } else {
          d3 = 0;
        }
        a4 = Gd(d3) | 0;
        if (!a4) {
          return a4 | 0;
        }
        if (!(b3[a4 + -4 >> 2] & 3)) {
          return a4 | 0;
        }
        _d(a4 | 0, 0, d3 | 0) | 0;
        return a4 | 0;
      }
      function Jd(a4, b4, c3, d3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        c3 = a4 + c3 >>> 0;
        return (G2(b4 + d3 + (c3 >>> 0 < a4 >>> 0 | 0) >>> 0 | 0), c3 | 0) | 0;
      }
      function Kd(a4, b4, c3, d3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        d3 = b4 - d3 - (c3 >>> 0 > a4 >>> 0 | 0) >>> 0;
        return (G2(d3 | 0), a4 - c3 >>> 0 | 0) | 0;
      }
      function Ld(a4) {
        a4 = a4 | 0;
        return (a4 ? 31 - (E2(a4 ^ a4 - 1) | 0) | 0 : 32) | 0;
      }
      function Md(a4, c3, d3, e3, f2) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        l = a4;
        j = c3;
        k = j;
        h = d3;
        n = e3;
        i = n;
        if (!k) {
          g2 = (f2 | 0) != 0;
          if (!i) {
            if (g2) {
              b3[f2 >> 2] = (l >>> 0) % (h >>> 0);
              b3[f2 + 4 >> 2] = 0;
            }
            n = 0;
            f2 = (l >>> 0) / (h >>> 0) >>> 0;
            return (G2(n | 0), f2) | 0;
          } else {
            if (!g2) {
              n = 0;
              f2 = 0;
              return (G2(n | 0), f2) | 0;
            }
            b3[f2 >> 2] = a4 | 0;
            b3[f2 + 4 >> 2] = c3 & 0;
            n = 0;
            f2 = 0;
            return (G2(n | 0), f2) | 0;
          }
        }
        g2 = (i | 0) == 0;
        do {
          if (h) {
            if (!g2) {
              g2 = (E2(i | 0) | 0) - (E2(k | 0) | 0) | 0;
              if (g2 >>> 0 <= 31) {
                m = g2 + 1 | 0;
                i = 31 - g2 | 0;
                c3 = g2 - 31 >> 31;
                h = m;
                a4 = l >>> (m >>> 0) & c3 | k << i;
                c3 = k >>> (m >>> 0) & c3;
                g2 = 0;
                i = l << i;
                break;
              }
              if (!f2) {
                n = 0;
                f2 = 0;
                return (G2(n | 0), f2) | 0;
              }
              b3[f2 >> 2] = a4 | 0;
              b3[f2 + 4 >> 2] = j | c3 & 0;
              n = 0;
              f2 = 0;
              return (G2(n | 0), f2) | 0;
            }
            g2 = h - 1 | 0;
            if (g2 & h | 0) {
              i = (E2(h | 0) | 0) + 33 - (E2(k | 0) | 0) | 0;
              p2 = 64 - i | 0;
              m = 32 - i | 0;
              j = m >> 31;
              o = i - 32 | 0;
              c3 = o >> 31;
              h = i;
              a4 = m - 1 >> 31 & k >>> (o >>> 0) | (k << m | l >>> (i >>> 0)) & c3;
              c3 = c3 & k >>> (i >>> 0);
              g2 = l << p2 & j;
              i = (k << p2 | l >>> (o >>> 0)) & j | l << m & i - 33 >> 31;
              break;
            }
            if (f2 | 0) {
              b3[f2 >> 2] = g2 & l;
              b3[f2 + 4 >> 2] = 0;
            }
            if ((h | 0) == 1) {
              o = j | c3 & 0;
              p2 = a4 | 0 | 0;
              return (G2(o | 0), p2) | 0;
            } else {
              p2 = Ld(h | 0) | 0;
              o = k >>> (p2 >>> 0) | 0;
              p2 = k << 32 - p2 | l >>> (p2 >>> 0) | 0;
              return (G2(o | 0), p2) | 0;
            }
          } else {
            if (g2) {
              if (f2 | 0) {
                b3[f2 >> 2] = (k >>> 0) % (h >>> 0);
                b3[f2 + 4 >> 2] = 0;
              }
              o = 0;
              p2 = (k >>> 0) / (h >>> 0) >>> 0;
              return (G2(o | 0), p2) | 0;
            }
            if (!l) {
              if (f2 | 0) {
                b3[f2 >> 2] = 0;
                b3[f2 + 4 >> 2] = (k >>> 0) % (i >>> 0);
              }
              o = 0;
              p2 = (k >>> 0) / (i >>> 0) >>> 0;
              return (G2(o | 0), p2) | 0;
            }
            g2 = i - 1 | 0;
            if (!(g2 & i)) {
              if (f2 | 0) {
                b3[f2 >> 2] = a4 | 0;
                b3[f2 + 4 >> 2] = g2 & k | c3 & 0;
              }
              o = 0;
              p2 = k >>> ((Ld(i | 0) | 0) >>> 0);
              return (G2(o | 0), p2) | 0;
            }
            g2 = (E2(i | 0) | 0) - (E2(k | 0) | 0) | 0;
            if (g2 >>> 0 <= 30) {
              c3 = g2 + 1 | 0;
              i = 31 - g2 | 0;
              h = c3;
              a4 = k << i | l >>> (c3 >>> 0);
              c3 = k >>> (c3 >>> 0);
              g2 = 0;
              i = l << i;
              break;
            }
            if (!f2) {
              o = 0;
              p2 = 0;
              return (G2(o | 0), p2) | 0;
            }
            b3[f2 >> 2] = a4 | 0;
            b3[f2 + 4 >> 2] = j | c3 & 0;
            o = 0;
            p2 = 0;
            return (G2(o | 0), p2) | 0;
          }
        } while (0);
        if (!h) {
          k = i;
          j = 0;
          i = 0;
        } else {
          m = d3 | 0 | 0;
          l = n | e3 & 0;
          k = Jd(m | 0, l | 0, -1, -1) | 0;
          d3 = H() | 0;
          j = i;
          i = 0;
          do {
            e3 = j;
            j = g2 >>> 31 | j << 1;
            g2 = i | g2 << 1;
            e3 = a4 << 1 | e3 >>> 31 | 0;
            n = a4 >>> 31 | c3 << 1 | 0;
            Kd(k | 0, d3 | 0, e3 | 0, n | 0) | 0;
            p2 = H() | 0;
            o = p2 >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1;
            i = o & 1;
            a4 = Kd(e3 | 0, n | 0, o & m | 0, (((p2 | 0) < 0 ? -1 : 0) >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1) & l | 0) | 0;
            c3 = H() | 0;
            h = h - 1 | 0;
          } while ((h | 0) != 0);
          k = j;
          j = 0;
        }
        h = 0;
        if (f2 | 0) {
          b3[f2 >> 2] = a4;
          b3[f2 + 4 >> 2] = c3;
        }
        o = (g2 | 0) >>> 31 | (k | h) << 1 | (h << 1 | g2 >>> 31) & 0 | j;
        p2 = (g2 << 1 | 0 >>> 31) & -2 | i;
        return (G2(o | 0), p2) | 0;
      }
      function Nd(a4, b4, c3, d3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = b4 >> 31 | ((b4 | 0) < 0 ? -1 : 0) << 1;
        i = ((b4 | 0) < 0 ? -1 : 0) >> 31 | ((b4 | 0) < 0 ? -1 : 0) << 1;
        f2 = d3 >> 31 | ((d3 | 0) < 0 ? -1 : 0) << 1;
        e3 = ((d3 | 0) < 0 ? -1 : 0) >> 31 | ((d3 | 0) < 0 ? -1 : 0) << 1;
        h = Kd(j ^ a4 | 0, i ^ b4 | 0, j | 0, i | 0) | 0;
        g2 = H() | 0;
        a4 = f2 ^ j;
        b4 = e3 ^ i;
        return Kd((Md(h, g2, Kd(f2 ^ c3 | 0, e3 ^ d3 | 0, f2 | 0, e3 | 0) | 0, H() | 0, 0) | 0) ^ a4 | 0, (H() | 0) ^ b4 | 0, a4 | 0, b4 | 0) | 0;
      }
      function Od(a4, b4) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        var c3 = 0, d3 = 0, e3 = 0, f2 = 0;
        f2 = a4 & 65535;
        e3 = b4 & 65535;
        c3 = B2(e3, f2) | 0;
        d3 = a4 >>> 16;
        a4 = (c3 >>> 16) + (B2(e3, d3) | 0) | 0;
        e3 = b4 >>> 16;
        b4 = B2(e3, f2) | 0;
        return (G2((a4 >>> 16) + (B2(e3, d3) | 0) + (((a4 & 65535) + b4 | 0) >>> 16) | 0), a4 + b4 << 16 | c3 & 65535 | 0) | 0;
      }
      function Pd(a4, b4, c3, d3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        var e3 = 0, f2 = 0;
        e3 = a4;
        f2 = c3;
        c3 = Od(e3, f2) | 0;
        a4 = H() | 0;
        return (G2((B2(b4, f2) | 0) + (B2(d3, e3) | 0) + a4 | a4 & 0 | 0), c3 | 0 | 0) | 0;
      }
      function Qd(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        f2 = T;
        T = T + 16 | 0;
        i = f2 | 0;
        h = c3 >> 31 | ((c3 | 0) < 0 ? -1 : 0) << 1;
        g2 = ((c3 | 0) < 0 ? -1 : 0) >> 31 | ((c3 | 0) < 0 ? -1 : 0) << 1;
        k = e3 >> 31 | ((e3 | 0) < 0 ? -1 : 0) << 1;
        j = ((e3 | 0) < 0 ? -1 : 0) >> 31 | ((e3 | 0) < 0 ? -1 : 0) << 1;
        a4 = Kd(h ^ a4 | 0, g2 ^ c3 | 0, h | 0, g2 | 0) | 0;
        c3 = H() | 0;
        Md(a4, c3, Kd(k ^ d3 | 0, j ^ e3 | 0, k | 0, j | 0) | 0, H() | 0, i) | 0;
        e3 = Kd(b3[i >> 2] ^ h | 0, b3[i + 4 >> 2] ^ g2 | 0, h | 0, g2 | 0) | 0;
        d3 = H() | 0;
        T = f2;
        return (G2(d3 | 0), e3) | 0;
      }
      function Rd(a4, c3, d3, e3) {
        a4 = a4 | 0;
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        g2 = T;
        T = T + 16 | 0;
        f2 = g2 | 0;
        Md(a4, c3, d3, e3, f2) | 0;
        T = g2;
        return (G2(b3[f2 + 4 >> 2] | 0), b3[f2 >> 2] | 0) | 0;
      }
      function Sd(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          G2(b4 >> c3 | 0);
          return a4 >>> c3 | (b4 & (1 << c3) - 1) << 32 - c3;
        }
        G2(((b4 | 0) < 0 ? -1 : 0) | 0);
        return b4 >> c3 - 32 | 0;
      }
      function Td(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          G2(b4 >>> c3 | 0);
          return a4 >>> c3 | (b4 & (1 << c3) - 1) << 32 - c3;
        }
        G2(0);
        return b4 >>> c3 - 32 | 0;
      }
      function Ud(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        if ((c3 | 0) < 32) {
          G2(b4 << c3 | (a4 & (1 << c3) - 1 << 32 - c3) >>> 32 - c3 | 0);
          return a4 << c3;
        }
        G2(a4 << c3 - 32 | 0);
        return 0;
      }
      function Vd(a4, b4, c3) {
        a4 = a4 | 0;
        b4 = b4 | 0;
        c3 = c3 | 0;
        b4 = E2(b4) | 0;
        if ((b4 | 0) == 32) {
          b4 = b4 + (E2(a4) | 0) | 0;
        }
        G2(0);
        return b4 | 0;
      }
      function Wd(a4, b4) {
        a4 = +a4;
        b4 = +b4;
        if (a4 != a4) {
          return +b4;
        }
        if (b4 != b4) {
          return +a4;
        }
        return +D2(+a4, +b4);
      }
      function Xd(a4, b4) {
        a4 = +a4;
        b4 = +b4;
        if (a4 != a4) {
          return +b4;
        }
        if (b4 != b4) {
          return +a4;
        }
        return +C2(+a4, +b4);
      }
      function Yd(a4) {
        a4 = +a4;
        return a4 >= 0 ? +p(a4 + 0.5) : +A2(a4 - 0.5);
      }
      function Zd(c3, d3, e3) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        if ((e3 | 0) >= 8192) {
          L2(c3 | 0, d3 | 0, e3 | 0) | 0;
          return c3 | 0;
        }
        h = c3 | 0;
        g2 = c3 + e3 | 0;
        if ((c3 & 3) == (d3 & 3)) {
          while (c3 & 3) {
            if (!e3) {
              return h | 0;
            }
            a3[c3 >> 0] = a3[d3 >> 0] | 0;
            c3 = c3 + 1 | 0;
            d3 = d3 + 1 | 0;
            e3 = e3 - 1 | 0;
          }
          e3 = g2 & -4 | 0;
          f2 = e3 - 64 | 0;
          while ((c3 | 0) <= (f2 | 0)) {
            b3[c3 >> 2] = b3[d3 >> 2];
            b3[c3 + 4 >> 2] = b3[d3 + 4 >> 2];
            b3[c3 + 8 >> 2] = b3[d3 + 8 >> 2];
            b3[c3 + 12 >> 2] = b3[d3 + 12 >> 2];
            b3[c3 + 16 >> 2] = b3[d3 + 16 >> 2];
            b3[c3 + 20 >> 2] = b3[d3 + 20 >> 2];
            b3[c3 + 24 >> 2] = b3[d3 + 24 >> 2];
            b3[c3 + 28 >> 2] = b3[d3 + 28 >> 2];
            b3[c3 + 32 >> 2] = b3[d3 + 32 >> 2];
            b3[c3 + 36 >> 2] = b3[d3 + 36 >> 2];
            b3[c3 + 40 >> 2] = b3[d3 + 40 >> 2];
            b3[c3 + 44 >> 2] = b3[d3 + 44 >> 2];
            b3[c3 + 48 >> 2] = b3[d3 + 48 >> 2];
            b3[c3 + 52 >> 2] = b3[d3 + 52 >> 2];
            b3[c3 + 56 >> 2] = b3[d3 + 56 >> 2];
            b3[c3 + 60 >> 2] = b3[d3 + 60 >> 2];
            c3 = c3 + 64 | 0;
            d3 = d3 + 64 | 0;
          }
          while ((c3 | 0) < (e3 | 0)) {
            b3[c3 >> 2] = b3[d3 >> 2];
            c3 = c3 + 4 | 0;
            d3 = d3 + 4 | 0;
          }
        } else {
          e3 = g2 - 4 | 0;
          while ((c3 | 0) < (e3 | 0)) {
            a3[c3 >> 0] = a3[d3 >> 0] | 0;
            a3[c3 + 1 >> 0] = a3[d3 + 1 >> 0] | 0;
            a3[c3 + 2 >> 0] = a3[d3 + 2 >> 0] | 0;
            a3[c3 + 3 >> 0] = a3[d3 + 3 >> 0] | 0;
            c3 = c3 + 4 | 0;
            d3 = d3 + 4 | 0;
          }
        }
        while ((c3 | 0) < (g2 | 0)) {
          a3[c3 >> 0] = a3[d3 >> 0] | 0;
          c3 = c3 + 1 | 0;
          d3 = d3 + 1 | 0;
        }
        return h | 0;
      }
      function _d(c3, d3, e3) {
        c3 = c3 | 0;
        d3 = d3 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        h = c3 + e3 | 0;
        d3 = d3 & 255;
        if ((e3 | 0) >= 67) {
          while (c3 & 3) {
            a3[c3 >> 0] = d3;
            c3 = c3 + 1 | 0;
          }
          f2 = h & -4 | 0;
          i = d3 | d3 << 8 | d3 << 16 | d3 << 24;
          g2 = f2 - 64 | 0;
          while ((c3 | 0) <= (g2 | 0)) {
            b3[c3 >> 2] = i;
            b3[c3 + 4 >> 2] = i;
            b3[c3 + 8 >> 2] = i;
            b3[c3 + 12 >> 2] = i;
            b3[c3 + 16 >> 2] = i;
            b3[c3 + 20 >> 2] = i;
            b3[c3 + 24 >> 2] = i;
            b3[c3 + 28 >> 2] = i;
            b3[c3 + 32 >> 2] = i;
            b3[c3 + 36 >> 2] = i;
            b3[c3 + 40 >> 2] = i;
            b3[c3 + 44 >> 2] = i;
            b3[c3 + 48 >> 2] = i;
            b3[c3 + 52 >> 2] = i;
            b3[c3 + 56 >> 2] = i;
            b3[c3 + 60 >> 2] = i;
            c3 = c3 + 64 | 0;
          }
          while ((c3 | 0) < (f2 | 0)) {
            b3[c3 >> 2] = i;
            c3 = c3 + 4 | 0;
          }
        }
        while ((c3 | 0) < (h | 0)) {
          a3[c3 >> 0] = d3;
          c3 = c3 + 1 | 0;
        }
        return h - e3 | 0;
      }
      function $d(a4) {
        a4 = +a4;
        return a4 >= 0 ? +p(a4 + 0.5) : +A2(a4 - 0.5);
      }
      function ae(a4) {
        a4 = a4 | 0;
        var c3 = 0, d3 = 0, e3 = 0;
        e3 = K() | 0;
        d3 = b3[g >> 2] | 0;
        c3 = d3 + a4 | 0;
        if ((a4 | 0) > 0 & (c3 | 0) < (d3 | 0) | (c3 | 0) < 0) {
          N(c3 | 0) | 0;
          J(12);
          return -1;
        }
        if ((c3 | 0) > (e3 | 0)) {
          if (!(M(c3 | 0) | 0)) {
            J(12);
            return -1;
          }
        }
        b3[g >> 2] = c3;
        return d3 | 0;
      }
      return {
        ___divdi3: Nd,
        ___muldi3: Pd,
        ___remdi3: Qd,
        ___uremdi3: Rd,
        _areNeighborCells: ib,
        _bitshift64Ashr: Sd,
        _bitshift64Lshr: Td,
        _bitshift64Shl: Ud,
        _calloc: Id,
        _cellAreaKm2: Ac,
        _cellAreaM2: Bc,
        _cellAreaRads2: zc,
        _cellToBoundary: bc,
        _cellToCenterChild: Nb,
        _cellToChildPos: gc,
        _cellToChildren: Lb,
        _cellToChildrenSize: Jb,
        _cellToLatLng: ac,
        _cellToLocalIj: Mc,
        _cellToParent: Ib,
        _cellToVertex: td,
        _cellToVertexes: ud,
        _cellsToDirectedEdge: jb,
        _cellsToLinkedMultiPolygon: na,
        _childPosToCell: hc,
        _compactCells: Ob,
        _constructCell: Eb,
        _destroyLinkedMultiPolygon: Hc,
        _directedEdgeToBoundary: pb,
        _directedEdgeToCells: nb,
        _edgeLengthKm: Dc,
        _edgeLengthM: Ec,
        _edgeLengthRads: Cc,
        _emscripten_replace_memory: W2,
        _free: Hd,
        _getBaseCellNumber: Cb,
        _getDirectedEdgeDestination: lb,
        _getDirectedEdgeOrigin: kb,
        _getHexagonAreaAvgKm2: tc,
        _getHexagonAreaAvgM2: uc,
        _getHexagonEdgeLengthAvgKm: vc,
        _getHexagonEdgeLengthAvgM: wc,
        _getIcosahedronFaces: dc,
        _getIndexDigit: Db,
        _getNumCells: xc,
        _getPentagons: fc,
        _getRes0Cells: ya,
        _getResolution: Bb,
        _greatCircleDistanceKm: pc,
        _greatCircleDistanceM: qc,
        _greatCircleDistanceRads: oc,
        _gridDisk: aa,
        _gridDiskDistances: ba,
        _gridDistance: Oc,
        _gridPathCells: Qc,
        _gridPathCellsSize: Pc,
        _gridRing: fa,
        _gridRingUnsafe: ga,
        _i64Add: Jd,
        _i64Subtract: Kd,
        _isPentagon: Kb,
        _isResClassIII: Rb,
        _isValidCell: Fb,
        _isValidDirectedEdge: mb,
        _isValidIndex: Gb,
        _isValidVertex: wd,
        _latLngToCell: Zb,
        _llvm_ctlz_i64: Vd,
        _llvm_maxnum_f64: Wd,
        _llvm_minnum_f64: Xd,
        _llvm_round_f64: Yd,
        _localIjToCell: Nc,
        _malloc: Gd,
        _maxFaceCount: cc,
        _maxGridDiskSize: $,
        _maxPolygonToCellsSize: ja,
        _maxPolygonToCellsSizeExperimental: Xc,
        _memcpy: Zd,
        _memset: _d,
        _originToDirectedEdges: ob,
        _pentagonCount: ec,
        _polygonToCells: la,
        _polygonToCellsExperimental: Wc,
        _readInt64AsDoubleFromPointer: ld,
        _res0CellCount: xa,
        _round: $d,
        _sbrk: ae,
        _sizeOfCellBoundary: gd,
        _sizeOfCoordIJ: kd,
        _sizeOfGeoLoop: hd,
        _sizeOfGeoPolygon: id,
        _sizeOfH3Index: ed,
        _sizeOfLatLng: fd,
        _sizeOfLinkedGeoPolygon: jd,
        _uncompactCells: Pb,
        _uncompactCellsSize: Qb,
        _vertexToLatLng: vd,
        establishStackSpace: _,
        stackAlloc: X,
        stackRestore: Z,
        stackSave: Y
      };
    }(asmGlobalArg, asmLibraryArg, buffer)
  );
  var ___divdi3 = Module["___divdi3"] = asm["___divdi3"];
  var ___muldi3 = Module["___muldi3"] = asm["___muldi3"];
  var ___remdi3 = Module["___remdi3"] = asm["___remdi3"];
  var ___uremdi3 = Module["___uremdi3"] = asm["___uremdi3"];
  var _areNeighborCells = Module["_areNeighborCells"] = asm["_areNeighborCells"];
  var _bitshift64Ashr = Module["_bitshift64Ashr"] = asm["_bitshift64Ashr"];
  var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
  var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
  var _calloc = Module["_calloc"] = asm["_calloc"];
  var _cellAreaKm2 = Module["_cellAreaKm2"] = asm["_cellAreaKm2"];
  var _cellAreaM2 = Module["_cellAreaM2"] = asm["_cellAreaM2"];
  var _cellAreaRads2 = Module["_cellAreaRads2"] = asm["_cellAreaRads2"];
  var _cellToBoundary = Module["_cellToBoundary"] = asm["_cellToBoundary"];
  var _cellToCenterChild = Module["_cellToCenterChild"] = asm["_cellToCenterChild"];
  var _cellToChildPos = Module["_cellToChildPos"] = asm["_cellToChildPos"];
  var _cellToChildren = Module["_cellToChildren"] = asm["_cellToChildren"];
  var _cellToChildrenSize = Module["_cellToChildrenSize"] = asm["_cellToChildrenSize"];
  var _cellToLatLng = Module["_cellToLatLng"] = asm["_cellToLatLng"];
  var _cellToLocalIj = Module["_cellToLocalIj"] = asm["_cellToLocalIj"];
  var _cellToParent = Module["_cellToParent"] = asm["_cellToParent"];
  var _cellToVertex = Module["_cellToVertex"] = asm["_cellToVertex"];
  var _cellToVertexes = Module["_cellToVertexes"] = asm["_cellToVertexes"];
  var _cellsToDirectedEdge = Module["_cellsToDirectedEdge"] = asm["_cellsToDirectedEdge"];
  var _cellsToLinkedMultiPolygon = Module["_cellsToLinkedMultiPolygon"] = asm["_cellsToLinkedMultiPolygon"];
  var _childPosToCell = Module["_childPosToCell"] = asm["_childPosToCell"];
  var _compactCells = Module["_compactCells"] = asm["_compactCells"];
  var _constructCell = Module["_constructCell"] = asm["_constructCell"];
  var _destroyLinkedMultiPolygon = Module["_destroyLinkedMultiPolygon"] = asm["_destroyLinkedMultiPolygon"];
  var _directedEdgeToBoundary = Module["_directedEdgeToBoundary"] = asm["_directedEdgeToBoundary"];
  var _directedEdgeToCells = Module["_directedEdgeToCells"] = asm["_directedEdgeToCells"];
  var _edgeLengthKm = Module["_edgeLengthKm"] = asm["_edgeLengthKm"];
  var _edgeLengthM = Module["_edgeLengthM"] = asm["_edgeLengthM"];
  var _edgeLengthRads = Module["_edgeLengthRads"] = asm["_edgeLengthRads"];
  var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = asm["_emscripten_replace_memory"];
  var _free = Module["_free"] = asm["_free"];
  var _getBaseCellNumber = Module["_getBaseCellNumber"] = asm["_getBaseCellNumber"];
  var _getDirectedEdgeDestination = Module["_getDirectedEdgeDestination"] = asm["_getDirectedEdgeDestination"];
  var _getDirectedEdgeOrigin = Module["_getDirectedEdgeOrigin"] = asm["_getDirectedEdgeOrigin"];
  var _getHexagonAreaAvgKm2 = Module["_getHexagonAreaAvgKm2"] = asm["_getHexagonAreaAvgKm2"];
  var _getHexagonAreaAvgM2 = Module["_getHexagonAreaAvgM2"] = asm["_getHexagonAreaAvgM2"];
  var _getHexagonEdgeLengthAvgKm = Module["_getHexagonEdgeLengthAvgKm"] = asm["_getHexagonEdgeLengthAvgKm"];
  var _getHexagonEdgeLengthAvgM = Module["_getHexagonEdgeLengthAvgM"] = asm["_getHexagonEdgeLengthAvgM"];
  var _getIcosahedronFaces = Module["_getIcosahedronFaces"] = asm["_getIcosahedronFaces"];
  var _getIndexDigit = Module["_getIndexDigit"] = asm["_getIndexDigit"];
  var _getNumCells = Module["_getNumCells"] = asm["_getNumCells"];
  var _getPentagons = Module["_getPentagons"] = asm["_getPentagons"];
  var _getRes0Cells = Module["_getRes0Cells"] = asm["_getRes0Cells"];
  var _getResolution = Module["_getResolution"] = asm["_getResolution"];
  var _greatCircleDistanceKm = Module["_greatCircleDistanceKm"] = asm["_greatCircleDistanceKm"];
  var _greatCircleDistanceM = Module["_greatCircleDistanceM"] = asm["_greatCircleDistanceM"];
  var _greatCircleDistanceRads = Module["_greatCircleDistanceRads"] = asm["_greatCircleDistanceRads"];
  var _gridDisk = Module["_gridDisk"] = asm["_gridDisk"];
  var _gridDiskDistances = Module["_gridDiskDistances"] = asm["_gridDiskDistances"];
  var _gridDistance = Module["_gridDistance"] = asm["_gridDistance"];
  var _gridPathCells = Module["_gridPathCells"] = asm["_gridPathCells"];
  var _gridPathCellsSize = Module["_gridPathCellsSize"] = asm["_gridPathCellsSize"];
  var _gridRing = Module["_gridRing"] = asm["_gridRing"];
  var _gridRingUnsafe = Module["_gridRingUnsafe"] = asm["_gridRingUnsafe"];
  var _i64Add = Module["_i64Add"] = asm["_i64Add"];
  var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
  var _isPentagon = Module["_isPentagon"] = asm["_isPentagon"];
  var _isResClassIII = Module["_isResClassIII"] = asm["_isResClassIII"];
  var _isValidCell = Module["_isValidCell"] = asm["_isValidCell"];
  var _isValidDirectedEdge = Module["_isValidDirectedEdge"] = asm["_isValidDirectedEdge"];
  var _isValidIndex = Module["_isValidIndex"] = asm["_isValidIndex"];
  var _isValidVertex = Module["_isValidVertex"] = asm["_isValidVertex"];
  var _latLngToCell = Module["_latLngToCell"] = asm["_latLngToCell"];
  var _llvm_ctlz_i64 = Module["_llvm_ctlz_i64"] = asm["_llvm_ctlz_i64"];
  var _llvm_maxnum_f64 = Module["_llvm_maxnum_f64"] = asm["_llvm_maxnum_f64"];
  var _llvm_minnum_f64 = Module["_llvm_minnum_f64"] = asm["_llvm_minnum_f64"];
  var _llvm_round_f64 = Module["_llvm_round_f64"] = asm["_llvm_round_f64"];
  var _localIjToCell = Module["_localIjToCell"] = asm["_localIjToCell"];
  var _malloc = Module["_malloc"] = asm["_malloc"];
  var _maxFaceCount = Module["_maxFaceCount"] = asm["_maxFaceCount"];
  var _maxGridDiskSize = Module["_maxGridDiskSize"] = asm["_maxGridDiskSize"];
  var _maxPolygonToCellsSize = Module["_maxPolygonToCellsSize"] = asm["_maxPolygonToCellsSize"];
  var _maxPolygonToCellsSizeExperimental = Module["_maxPolygonToCellsSizeExperimental"] = asm["_maxPolygonToCellsSizeExperimental"];
  var _memcpy = Module["_memcpy"] = asm["_memcpy"];
  var _memset = Module["_memset"] = asm["_memset"];
  var _originToDirectedEdges = Module["_originToDirectedEdges"] = asm["_originToDirectedEdges"];
  var _pentagonCount = Module["_pentagonCount"] = asm["_pentagonCount"];
  var _polygonToCells = Module["_polygonToCells"] = asm["_polygonToCells"];
  var _polygonToCellsExperimental = Module["_polygonToCellsExperimental"] = asm["_polygonToCellsExperimental"];
  var _readInt64AsDoubleFromPointer = Module["_readInt64AsDoubleFromPointer"] = asm["_readInt64AsDoubleFromPointer"];
  var _res0CellCount = Module["_res0CellCount"] = asm["_res0CellCount"];
  var _round = Module["_round"] = asm["_round"];
  var _sbrk = Module["_sbrk"] = asm["_sbrk"];
  var _sizeOfCellBoundary = Module["_sizeOfCellBoundary"] = asm["_sizeOfCellBoundary"];
  var _sizeOfCoordIJ = Module["_sizeOfCoordIJ"] = asm["_sizeOfCoordIJ"];
  var _sizeOfGeoLoop = Module["_sizeOfGeoLoop"] = asm["_sizeOfGeoLoop"];
  var _sizeOfGeoPolygon = Module["_sizeOfGeoPolygon"] = asm["_sizeOfGeoPolygon"];
  var _sizeOfH3Index = Module["_sizeOfH3Index"] = asm["_sizeOfH3Index"];
  var _sizeOfLatLng = Module["_sizeOfLatLng"] = asm["_sizeOfLatLng"];
  var _sizeOfLinkedGeoPolygon = Module["_sizeOfLinkedGeoPolygon"] = asm["_sizeOfLinkedGeoPolygon"];
  var _uncompactCells = Module["_uncompactCells"] = asm["_uncompactCells"];
  var _uncompactCellsSize = Module["_uncompactCellsSize"] = asm["_uncompactCellsSize"];
  var _vertexToLatLng = Module["_vertexToLatLng"] = asm["_vertexToLatLng"];
  var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
  var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
  var stackRestore = Module["stackRestore"] = asm["stackRestore"];
  var stackSave = Module["stackSave"] = asm["stackSave"];
  Module["asm"] = asm;
  Module["cwrap"] = cwrap;
  Module["setValue"] = setValue;
  Module["getValue"] = getValue;
  if (memoryInitializer) {
    if (!isDataURI(memoryInitializer)) {
      memoryInitializer = locateFile(memoryInitializer);
    }
    {
      addRunDependency("memory initializer");
      var applyMemoryInitializer = function(data) {
        if (data.byteLength) {
          data = new Uint8Array(data);
        }
        HEAPU8.set(data, GLOBAL_BASE);
        if (Module["memoryInitializerRequest"]) {
          delete Module["memoryInitializerRequest"].response;
        }
        removeRunDependency("memory initializer");
      };
      var doBrowserLoad = function() {
        readAsync(memoryInitializer, applyMemoryInitializer, function() {
          throw "could not load memory initializer " + memoryInitializer;
        });
      };
      var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);
      if (memoryInitializerBytes) {
        applyMemoryInitializer(memoryInitializerBytes.buffer);
      } else if (Module["memoryInitializerRequest"]) {
        var useRequest = function() {
          var request = Module["memoryInitializerRequest"];
          var response = request.response;
          if (request.status !== 200 && request.status !== 0) {
            var data = tryParseAsDataURI(Module["memoryInitializerRequestURL"]);
            if (data) {
              response = data.buffer;
            } else {
              console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
              doBrowserLoad();
              return;
            }
          }
          applyMemoryInitializer(response);
        };
        if (Module["memoryInitializerRequest"].response) {
          setTimeout(useRequest, 0);
        } else {
          Module["memoryInitializerRequest"].addEventListener("load", useRequest);
        }
      } else {
        doBrowserLoad();
      }
    }
  }
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun) {
      run();
    }
    if (!calledRun) {
      dependenciesFulfilled = runCaller;
    }
  };
  function run(args) {
    args = args || arguments_;
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun) {
        return;
      }
      calledRun = true;
      if (ABORT) {
        return;
      }
      initRuntime();
      preMain();
      if (Module["onRuntimeInitialized"]) {
        Module["onRuntimeInitialized"]();
      }
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  Module["run"] = run;
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what += "";
    out(what);
    err(what);
    ABORT = true;
    throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
  }
  Module["abort"] = abort;
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function") {
      Module["preInit"] = [Module["preInit"]];
    }
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  return libh32;
}(typeof libh3 === "object" ? libh3 : {});
var NUMBER = "number";
var H3_ERROR = NUMBER;
var BOOLEAN = NUMBER;
var H3_LOWER = NUMBER;
var H3_UPPER = NUMBER;
var RESOLUTION = NUMBER;
var POINTER = NUMBER;
var BINDINGS = [
  // The size functions are inserted via build/sizes.h
  ["sizeOfH3Index", NUMBER],
  ["sizeOfLatLng", NUMBER],
  ["sizeOfCellBoundary", NUMBER],
  ["sizeOfGeoLoop", NUMBER],
  ["sizeOfGeoPolygon", NUMBER],
  ["sizeOfLinkedGeoPolygon", NUMBER],
  ["sizeOfCoordIJ", NUMBER],
  ["readInt64AsDoubleFromPointer", NUMBER],
  // The remaining functions are defined in the core lib in h3Api.h
  ["isValidCell", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["isValidIndex", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["latLngToCell", H3_ERROR, [NUMBER, NUMBER, RESOLUTION, POINTER]],
  ["cellToLatLng", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellToBoundary", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["maxGridDiskSize", H3_ERROR, [NUMBER, POINTER]],
  ["gridDisk", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["gridDiskDistances", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER, POINTER]],
  ["gridRing", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["gridRingUnsafe", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["maxPolygonToCellsSize", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["polygonToCells", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["maxPolygonToCellsSizeExperimental", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["polygonToCellsExperimental", H3_ERROR, [POINTER, RESOLUTION, NUMBER, NUMBER, NUMBER, POINTER]],
  ["cellsToLinkedMultiPolygon", H3_ERROR, [POINTER, NUMBER, POINTER]],
  ["destroyLinkedMultiPolygon", null, [POINTER]],
  ["compactCells", H3_ERROR, [POINTER, POINTER, NUMBER, NUMBER]],
  ["uncompactCells", H3_ERROR, [POINTER, NUMBER, NUMBER, POINTER, NUMBER, RESOLUTION]],
  ["uncompactCellsSize", H3_ERROR, [POINTER, NUMBER, NUMBER, RESOLUTION, POINTER]],
  ["isPentagon", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["isResClassIII", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["getBaseCellNumber", NUMBER, [H3_LOWER, H3_UPPER]],
  ["getResolution", NUMBER, [H3_LOWER, H3_UPPER]],
  ["getIndexDigit", NUMBER, [H3_LOWER, H3_UPPER, NUMBER]],
  ["constructCell", H3_ERROR, [NUMBER, NUMBER, POINTER, POINTER]],
  ["maxFaceCount", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getIcosahedronFaces", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellToParent", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildren", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToCenterChild", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildrenSize", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildPos", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["childPosToCell", H3_ERROR, [NUMBER, NUMBER, H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["areNeighborCells", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["cellsToDirectedEdge", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["getDirectedEdgeOrigin", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getDirectedEdgeDestination", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["isValidDirectedEdge", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["directedEdgeToCells", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["originToDirectedEdges", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["directedEdgeToBoundary", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["gridDistance", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["gridPathCells", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["gridPathCellsSize", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["cellToLocalIj", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["localIjToCell", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER, NUMBER, POINTER]],
  ["getHexagonAreaAvgM2", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonAreaAvgKm2", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonEdgeLengthAvgM", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonEdgeLengthAvgKm", H3_ERROR, [RESOLUTION, POINTER]],
  ["greatCircleDistanceM", NUMBER, [POINTER, POINTER]],
  ["greatCircleDistanceKm", NUMBER, [POINTER, POINTER]],
  ["greatCircleDistanceRads", NUMBER, [POINTER, POINTER]],
  ["cellAreaM2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellAreaKm2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellAreaRads2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthM", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthKm", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthRads", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getNumCells", H3_ERROR, [RESOLUTION, POINTER]],
  ["getRes0Cells", H3_ERROR, [POINTER]],
  ["res0CellCount", NUMBER],
  ["getPentagons", H3_ERROR, [NUMBER, POINTER]],
  ["pentagonCount", NUMBER],
  ["cellToVertex", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["cellToVertexes", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["vertexToLatLng", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["isValidVertex", BOOLEAN, [H3_LOWER, H3_UPPER]]
];
var E_SUCCESS = 0;
var E_FAILED = 1;
var E_DOMAIN = 2;
var E_LATLNG_DOMAIN = 3;
var E_RES_DOMAIN = 4;
var E_CELL_INVALID = 5;
var E_DIR_EDGE_INVALID = 6;
var E_UNDIR_EDGE_INVALID = 7;
var E_VERTEX_INVALID = 8;
var E_PENTAGON = 9;
var E_DUPLICATE_INPUT = 10;
var E_NOT_NEIGHBORS = 11;
var E_RES_MISMATCH = 12;
var E_MEMORY_ALLOC = 13;
var E_MEMORY_BOUNDS = 14;
var E_OPTION_INVALID = 15;
var E_INDEX_INVALID = 16;
var E_BASE_CELL_DOMAIN = 17;
var E_DIGIT_DOMAIN = 18;
var E_DELETED_DIGIT = 19;
var H3_ERROR_MSGS = {};
H3_ERROR_MSGS[E_SUCCESS] = "Success";
H3_ERROR_MSGS[E_FAILED] = "The operation failed but a more specific error is not available";
H3_ERROR_MSGS[E_DOMAIN] = "Argument was outside of acceptable range";
H3_ERROR_MSGS[E_LATLNG_DOMAIN] = "Latitude or longitude arguments were outside of acceptable range";
H3_ERROR_MSGS[E_RES_DOMAIN] = "Resolution argument was outside of acceptable range";
H3_ERROR_MSGS[E_CELL_INVALID] = "Cell argument was not valid";
H3_ERROR_MSGS[E_DIR_EDGE_INVALID] = "Directed edge argument was not valid";
H3_ERROR_MSGS[E_UNDIR_EDGE_INVALID] = "Undirected edge argument was not valid";
H3_ERROR_MSGS[E_VERTEX_INVALID] = "Vertex argument was not valid";
H3_ERROR_MSGS[E_PENTAGON] = "Pentagon distortion was encountered";
H3_ERROR_MSGS[E_DUPLICATE_INPUT] = "Duplicate input";
H3_ERROR_MSGS[E_NOT_NEIGHBORS] = "Cell arguments were not neighbors";
H3_ERROR_MSGS[E_RES_MISMATCH] = "Cell arguments had incompatible resolutions";
H3_ERROR_MSGS[E_MEMORY_ALLOC] = "Memory allocation failed";
H3_ERROR_MSGS[E_MEMORY_BOUNDS] = "Bounds of provided memory were insufficient";
H3_ERROR_MSGS[E_OPTION_INVALID] = "Mode or flags argument was not valid";
H3_ERROR_MSGS[E_INDEX_INVALID] = "Index argument was not valid";
H3_ERROR_MSGS[E_BASE_CELL_DOMAIN] = "Base cell number was outside of acceptable range";
H3_ERROR_MSGS[E_DIGIT_DOMAIN] = "Child indexing digits invalid";
H3_ERROR_MSGS[E_DELETED_DIGIT] = "Child indexing digits refer to a deleted subsequence";
var E_UNKNOWN_UNIT = 1e3;
var E_ARRAY_LENGTH = 1001;
var E_NULL_INDEX = 1002;
var JS_ERROR_MESSAGES = {};
JS_ERROR_MESSAGES[E_UNKNOWN_UNIT] = "Unknown unit";
JS_ERROR_MESSAGES[E_ARRAY_LENGTH] = "Array length out of bounds";
JS_ERROR_MESSAGES[E_NULL_INDEX] = "Got unexpected null value for H3 index";
var UNKNOWN_ERROR_MSG = "Unknown error";
function createError(messages, errCode, meta) {
  var hasValue = meta && "value" in meta;
  var err = new Error((messages[errCode] || UNKNOWN_ERROR_MSG) + " (code: " + errCode + (hasValue ? ", value: " + meta.value : "") + ")");
  err.code = errCode;
  return err;
}
function H3LibraryError(errCode, value) {
  var meta = arguments.length === 2 ? {
    value
  } : {};
  return createError(H3_ERROR_MSGS, errCode, meta);
}
function JSBindingError(errCode, value) {
  var meta = arguments.length === 2 ? {
    value
  } : {};
  return createError(JS_ERROR_MESSAGES, errCode, meta);
}
function throwIfError(errCode) {
  if (errCode !== 0) {
    throw H3LibraryError(errCode);
  }
}
var H3 = {};
BINDINGS.forEach(function bind(def) {
  H3[def[0]] = libh3.cwrap.apply(libh3, def);
});
var BASE_16 = 16;
var SZ_INT = 4;
var SZ_PTR = 4;
var SZ_DBL = 8;
var SZ_INT64 = 8;
var SZ_H3INDEX = H3.sizeOfH3Index();
var SZ_LATLNG = H3.sizeOfLatLng();
var SZ_CELLBOUNDARY = H3.sizeOfCellBoundary();
var SZ_GEOPOLYGON = H3.sizeOfGeoPolygon();
var SZ_GEOLOOP = H3.sizeOfGeoLoop();
var SZ_LINKED_GEOPOLYGON = H3.sizeOfLinkedGeoPolygon();
var SZ_COORDIJ = H3.sizeOfCoordIJ();
var UNITS = {
  m: "m",
  m2: "m2",
  km: "km",
  km2: "km2",
  rads: "rads",
  rads2: "rads2"
};
function validateRes(res) {
  if (typeof res !== "number" || res < 0 || res > 15 || Math.floor(res) !== res) {
    throw H3LibraryError(E_RES_DOMAIN, res);
  }
  return res;
}
function validateH3Index(h3Index) {
  if (!h3Index) {
    throw JSBindingError(E_NULL_INDEX);
  }
  return h3Index;
}
var MAX_JS_ARRAY_LENGTH = Math.pow(2, 32) - 1;
var INVALID_HEXIDECIMAL_CHAR = /[^0-9a-fA-F]/;
function h3IndexToSplitLong(h3Index) {
  if (Array.isArray(h3Index) && h3Index.length === 2 && Number.isInteger(h3Index[0]) && Number.isInteger(h3Index[1])) {
    return h3Index;
  }
  if (typeof h3Index !== "string" || INVALID_HEXIDECIMAL_CHAR.test(h3Index)) {
    return [0, 0];
  }
  var upper = parseInt(h3Index.substring(0, h3Index.length - 8), BASE_16);
  var lower = parseInt(h3Index.substring(h3Index.length - 8), BASE_16);
  return [lower, upper];
}
function hexFrom32Bit(num) {
  if (num >= 0) {
    return num.toString(BASE_16);
  }
  num = num & 2147483647;
  var tempStr = zeroPad(8, num.toString(BASE_16));
  var topNum = (parseInt(tempStr[0], BASE_16) + 8).toString(BASE_16);
  tempStr = topNum + tempStr.substring(1);
  return tempStr;
}
function splitLongToH3Index(lower, upper) {
  return hexFrom32Bit(upper) + zeroPad(8, hexFrom32Bit(lower));
}
function zeroPad(fullLen, numStr) {
  var numZeroes = fullLen - numStr.length;
  var outStr = "";
  for (var i = 0; i < numZeroes; i++) {
    outStr += "0";
  }
  outStr = outStr + numStr;
  return outStr;
}
var UPPER_BIT_DIVISOR = Math.pow(2, 32);
function readH3IndexFromPointer(cAddress, offset) {
  if (offset === void 0) offset = 0;
  var lower = libh3.getValue(cAddress + SZ_H3INDEX * offset, "i32");
  var upper = libh3.getValue(cAddress + SZ_H3INDEX * offset + SZ_INT, "i32");
  return upper ? splitLongToH3Index(lower, upper) : null;
}
function readDoubleFromPointer(cAddress, offset) {
  if (offset === void 0) offset = 0;
  return libh3.getValue(cAddress + SZ_DBL * offset, "double");
}
function readInt64AsDoubleFromPointer(cAddress) {
  return H3.readInt64AsDoubleFromPointer(cAddress);
}
function storeH3Index(h3Index, cAddress, offset) {
  libh3.HEAPU32.set(h3IndexToSplitLong(h3Index), cAddress / SZ_INT + 2 * offset);
}
function storeArrayOfH3Indexes(cAddress, hexagons) {
  var count = hexagons.length;
  for (var i = 0; i < count; i++) {
    storeH3Index(hexagons[i], cAddress, i);
  }
}
function readSingleCoord(cAddress) {
  return radsToDegs(libh3.getValue(cAddress, "double"));
}
function readLatLng(cAddress) {
  return [readSingleCoord(cAddress), readSingleCoord(cAddress + SZ_DBL)];
}
function readLatLngGeoJson(cAddress) {
  return [readSingleCoord(cAddress + SZ_DBL), readSingleCoord(cAddress)];
}
function readCellBoundary(cellBoundary, geoJsonCoords, closedLoop) {
  var numVerts = libh3.getValue(cellBoundary, "i32");
  var vertsPos = cellBoundary + SZ_DBL;
  var out = [];
  var readCoord = geoJsonCoords ? readLatLngGeoJson : readLatLng;
  for (var i = 0; i < numVerts * 2; i += 2) {
    out.push(readCoord(vertsPos + SZ_DBL * i));
  }
  if (closedLoop) {
    out.push(out[0]);
  }
  return out;
}
function readMultiPolygon(polygon, formatAsGeoJson) {
  var output = [];
  var readCoord = formatAsGeoJson ? readLatLngGeoJson : readLatLng;
  var loops;
  var loop;
  var coords;
  var coord;
  while (polygon) {
    output.push(loops = []);
    loop = libh3.getValue(polygon, "i8*");
    while (loop) {
      loops.push(coords = []);
      coord = libh3.getValue(loop, "i8*");
      while (coord) {
        coords.push(readCoord(coord));
        coord = libh3.getValue(coord + SZ_DBL * 2, "i8*");
      }
      if (formatAsGeoJson) {
        coords.push(coords[0]);
      }
      loop = libh3.getValue(loop + SZ_PTR * 2, "i8*");
    }
    polygon = libh3.getValue(polygon + SZ_PTR * 2, "i8*");
  }
  return output;
}
function isPentagon(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  return Boolean(H3.isPentagon(lower, upper));
}
function getResolution2(h3Index) {
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  if (!H3.isValidCell(lower, upper)) {
    return -1;
  }
  return H3.getResolution(lower, upper);
}
function latLngToCell(lat, lng, res) {
  var latLng = libh3._malloc(SZ_LATLNG);
  libh3.HEAPF64.set([lat, lng].map(degsToRads), latLng / SZ_DBL);
  var h3Index = libh3._malloc(SZ_H3INDEX);
  try {
    throwIfError(H3.latLngToCell(latLng, res, h3Index));
    return validateH3Index(readH3IndexFromPointer(h3Index));
  } finally {
    libh3._free(h3Index);
    libh3._free(latLng);
  }
}
function cellToLatLng(h3Index) {
  var latLng = libh3._malloc(SZ_LATLNG);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  try {
    throwIfError(H3.cellToLatLng(lower, upper, latLng));
    return readLatLng(latLng);
  } finally {
    libh3._free(latLng);
  }
}
function cellToBoundary2(h3Index, formatAsGeoJson) {
  var cellBoundary = libh3._malloc(SZ_CELLBOUNDARY);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  try {
    throwIfError(H3.cellToBoundary(lower, upper, cellBoundary));
    return readCellBoundary(cellBoundary, formatAsGeoJson, formatAsGeoJson);
  } finally {
    libh3._free(cellBoundary);
  }
}
function cellsToMultiPolygon(h3Indexes, formatAsGeoJson) {
  if (!h3Indexes || !h3Indexes.length) {
    return [];
  }
  var indexCount = h3Indexes.length;
  var set6 = libh3._calloc(indexCount, SZ_H3INDEX);
  storeArrayOfH3Indexes(set6, h3Indexes);
  var polygon = libh3._calloc(SZ_LINKED_GEOPOLYGON);
  try {
    throwIfError(H3.cellsToLinkedMultiPolygon(set6, indexCount, polygon));
    return readMultiPolygon(polygon, formatAsGeoJson);
  } finally {
    H3.destroyLinkedMultiPolygon(polygon);
    libh3._free(polygon);
    libh3._free(set6);
  }
}
function gridDistance(origin, destination) {
  var ref = h3IndexToSplitLong(origin);
  var oLower = ref[0];
  var oUpper = ref[1];
  var ref$1 = h3IndexToSplitLong(destination);
  var dLower = ref$1[0];
  var dUpper = ref$1[1];
  var countPtr = libh3._malloc(SZ_INT64);
  try {
    throwIfError(H3.gridDistance(oLower, oUpper, dLower, dUpper, countPtr));
    return readInt64AsDoubleFromPointer(countPtr);
  } finally {
    libh3._free(countPtr);
  }
}
function getHexagonEdgeLengthAvg(res, unit) {
  validateRes(res);
  var out = libh3._malloc(SZ_DBL);
  try {
    switch (unit) {
      case UNITS.m:
        throwIfError(H3.getHexagonEdgeLengthAvgM(res, out));
        break;
      case UNITS.km:
        throwIfError(H3.getHexagonEdgeLengthAvgKm(res, out));
        break;
      default:
        throw JSBindingError(E_UNKNOWN_UNIT, unit);
    }
    return readDoubleFromPointer(out);
  } finally {
    libh3._free(out);
  }
}
function degsToRads(deg) {
  return deg * Math.PI / 180;
}
function radsToDegs(rad) {
  return rad * 180 / Math.PI;
}

// node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-utils.js
function normalizeLongitudes2(vertices, refLng) {
  refLng = refLng === void 0 ? vertices[0][0] : refLng;
  for (const pt of vertices) {
    const deltaLng = pt[0] - refLng;
    if (deltaLng > 180) {
      pt[0] -= 360;
    } else if (deltaLng < -180) {
      pt[0] += 360;
    }
  }
}
function scalePolygon(hexId, vertices, factor) {
  const [lat, lng] = cellToLatLng(hexId);
  const actualCount = vertices.length;
  normalizeLongitudes2(vertices, lng);
  const vertexCount = vertices[0] === vertices[actualCount - 1] ? actualCount - 1 : actualCount;
  for (let i = 0; i < vertexCount; i++) {
    vertices[i][0] = lerp(lng, vertices[i][0], factor);
    vertices[i][1] = lerp(lat, vertices[i][1], factor);
  }
}
function getHexagonCentroid(getHexagon, object, objectInfo) {
  const hexagonId = getHexagon(object, objectInfo);
  const [lat, lng] = cellToLatLng(hexagonId);
  return [lng, lat];
}
function h3ToPolygon(hexId, coverage = 1) {
  const vertices = cellToBoundary2(hexId, true);
  if (coverage !== 1) {
    scalePolygon(hexId, vertices, coverage);
  } else {
    normalizeLongitudes2(vertices);
  }
  return vertices;
}
function flattenPolygon(vertices) {
  const positions = new Float64Array(vertices.length * 2);
  let i = 0;
  for (const pt of vertices) {
    positions[i++] = pt[0];
    positions[i++] = pt[1];
  }
  return positions;
}

// node_modules/@deck.gl/geo-layers/dist/a5-layer/a5-layer.js
var defaultProps2 = {
  getPentagon: { type: "accessor", value: (d2) => d2.pentagon }
};
var A5Layer = class extends GeoCellLayer_default {
  indexToBounds() {
    const { data, getPentagon } = this.props;
    return {
      data,
      _normalize: false,
      _windingOrder: "CCW",
      positionFormat: "XY",
      getPolygon: (x, objectInfo) => {
        const pentagon = getPentagon(x, objectInfo);
        const boundary = cellToBoundary(typeof pentagon === "string" ? hexToU64(pentagon) : pentagon, { closedRing: true, segments: "auto" });
        return flattenPolygon(boundary);
      }
    };
  }
};
A5Layer.layerName = "A5Layer";
A5Layer.defaultProps = defaultProps2;
var a5_layer_default = A5Layer;

// node_modules/@loaders.gl/xml/dist/sax-ts/sax.js
var DEFAULT_SAX_EVENTS = {
  ontext: () => {
  },
  onprocessinginstruction: () => {
  },
  onsgmldeclaration: () => {
  },
  ondoctype: () => {
  },
  oncomment: () => {
  },
  onopentagstart: () => {
  },
  onattribute: () => {
  },
  onopentag: () => {
  },
  onclosetag: () => {
  },
  onopencdata: () => {
  },
  oncdata: () => {
  },
  onclosecdata: () => {
  },
  onerror: () => {
  },
  onend: () => {
  },
  onready: () => {
  },
  onscript: () => {
  },
  onopennamespace: () => {
  },
  onclosenamespace: () => {
  }
};
var DEFAULT_SAX_PARSER_OPTIONS = {
  ...DEFAULT_SAX_EVENTS,
  strict: false,
  MAX_BUFFER_LENGTH: 64 * 1024,
  lowercase: false,
  lowercasetags: false,
  noscript: false,
  strictEntities: false,
  xmlns: void 0,
  position: void 0,
  trim: void 0,
  normalize: void 0
};
var ENTITIES = {
  amp: "&",
  gt: ">",
  lt: "<",
  quot: '"',
  apos: "'",
  AElig: 198,
  Aacute: 193,
  Acirc: 194,
  Agrave: 192,
  Aring: 197,
  Atilde: 195,
  Auml: 196,
  Ccedil: 199,
  ETH: 208,
  Eacute: 201,
  Ecirc: 202,
  Egrave: 200,
  Euml: 203,
  Iacute: 205,
  Icirc: 206,
  Igrave: 204,
  Iuml: 207,
  Ntilde: 209,
  Oacute: 211,
  Ocirc: 212,
  Ograve: 210,
  Oslash: 216,
  Otilde: 213,
  Ouml: 214,
  THORN: 222,
  Uacute: 218,
  Ucirc: 219,
  Ugrave: 217,
  Uuml: 220,
  Yacute: 221,
  aacute: 225,
  acirc: 226,
  aelig: 230,
  agrave: 224,
  aring: 229,
  atilde: 227,
  auml: 228,
  ccedil: 231,
  eacute: 233,
  ecirc: 234,
  egrave: 232,
  eth: 240,
  euml: 235,
  iacute: 237,
  icirc: 238,
  igrave: 236,
  iuml: 239,
  ntilde: 241,
  oacute: 243,
  ocirc: 244,
  ograve: 242,
  oslash: 248,
  otilde: 245,
  ouml: 246,
  szlig: 223,
  thorn: 254,
  uacute: 250,
  ucirc: 251,
  ugrave: 249,
  uuml: 252,
  yacute: 253,
  yuml: 255,
  copy: 169,
  reg: 174,
  nbsp: 160,
  iexcl: 161,
  cent: 162,
  pound: 163,
  curren: 164,
  yen: 165,
  brvbar: 166,
  sect: 167,
  uml: 168,
  ordf: 170,
  laquo: 171,
  not: 172,
  shy: 173,
  macr: 175,
  deg: 176,
  plusmn: 177,
  sup1: 185,
  sup2: 178,
  sup3: 179,
  acute: 180,
  micro: 181,
  para: 182,
  middot: 183,
  cedil: 184,
  ordm: 186,
  raquo: 187,
  frac14: 188,
  frac12: 189,
  frac34: 190,
  iquest: 191,
  times: 215,
  divide: 247,
  OElig: 338,
  oelig: 339,
  Scaron: 352,
  scaron: 353,
  Yuml: 376,
  fnof: 402,
  circ: 710,
  tilde: 732,
  Alpha: 913,
  Beta: 914,
  Gamma: 915,
  Delta: 916,
  Epsilon: 917,
  Zeta: 918,
  Eta: 919,
  Theta: 920,
  Iota: 921,
  Kappa: 922,
  Lambda: 923,
  Mu: 924,
  Nu: 925,
  Xi: 926,
  Omicron: 927,
  Pi: 928,
  Rho: 929,
  Sigma: 931,
  Tau: 932,
  Upsilon: 933,
  Phi: 934,
  Chi: 935,
  Psi: 936,
  Omega: 937,
  alpha: 945,
  beta: 946,
  gamma: 947,
  delta: 948,
  epsilon: 949,
  zeta: 950,
  eta: 951,
  theta: 952,
  iota: 953,
  kappa: 954,
  lambda: 955,
  mu: 956,
  nu: 957,
  xi: 958,
  omicron: 959,
  pi: 960,
  rho: 961,
  sigmaf: 962,
  sigma: 963,
  tau: 964,
  upsilon: 965,
  phi: 966,
  chi: 967,
  psi: 968,
  omega: 969,
  thetasym: 977,
  upsih: 978,
  piv: 982,
  ensp: 8194,
  emsp: 8195,
  thinsp: 8201,
  zwnj: 8204,
  zwj: 8205,
  lrm: 8206,
  rlm: 8207,
  ndash: 8211,
  mdash: 8212,
  lsquo: 8216,
  rsquo: 8217,
  sbquo: 8218,
  ldquo: 8220,
  rdquo: 8221,
  bdquo: 8222,
  dagger: 8224,
  Dagger: 8225,
  bull: 8226,
  hellip: 8230,
  permil: 8240,
  prime: 8242,
  Prime: 8243,
  lsaquo: 8249,
  rsaquo: 8250,
  oline: 8254,
  frasl: 8260,
  euro: 8364,
  image: 8465,
  weierp: 8472,
  real: 8476,
  trade: 8482,
  alefsym: 8501,
  larr: 8592,
  uarr: 8593,
  rarr: 8594,
  darr: 8595,
  harr: 8596,
  crarr: 8629,
  lArr: 8656,
  uArr: 8657,
  rArr: 8658,
  dArr: 8659,
  hArr: 8660,
  forall: 8704,
  part: 8706,
  exist: 8707,
  empty: 8709,
  nabla: 8711,
  isin: 8712,
  notin: 8713,
  ni: 8715,
  prod: 8719,
  sum: 8721,
  minus: 8722,
  lowast: 8727,
  radic: 8730,
  prop: 8733,
  infin: 8734,
  ang: 8736,
  and: 8743,
  or: 8744,
  cap: 8745,
  cup: 8746,
  int: 8747,
  there4: 8756,
  sim: 8764,
  cong: 8773,
  asymp: 8776,
  ne: 8800,
  equiv: 8801,
  le: 8804,
  ge: 8805,
  sub: 8834,
  sup: 8835,
  nsub: 8836,
  sube: 8838,
  supe: 8839,
  oplus: 8853,
  otimes: 8855,
  perp: 8869,
  sdot: 8901,
  lceil: 8968,
  rceil: 8969,
  lfloor: 8970,
  rfloor: 8971,
  lang: 9001,
  rang: 9002,
  loz: 9674,
  spades: 9824,
  clubs: 9827,
  hearts: 9829,
  diams: 9830
};
Object.keys(ENTITIES).forEach((key) => {
  const e2 = ENTITIES[key];
  ENTITIES[key] = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
});

// node_modules/@loaders.gl/xml/dist/lib/xml-utils/uncapitalize.js
function uncapitalize(str5) {
  return typeof str5 === "string" ? str5.charAt(0).toLowerCase() + str5.slice(1) : str5;
}
function uncapitalizeKeys(object) {
  if (Array.isArray(object)) {
    return object.map((element) => uncapitalizeKeys(element));
  }
  if (object && typeof object === "object") {
    const newObject = {};
    for (const [key, value] of Object.entries(object)) {
      newObject[uncapitalize(key)] = uncapitalizeKeys(value);
    }
    return newObject;
  }
  return object;
}

// node_modules/@loaders.gl/xml/dist/lib/parsers/parse-xml.js
var import_fast_xml_parser = __toESM(require_fxp(), 1);
function parseXMLSync(text, options) {
  if ((options == null ? void 0 : options._parser) && options._parser !== "fast-xml-parser") {
    throw new Error(options == null ? void 0 : options._parser);
  }
  const fastXMLOptions = {
    // Default FastXML options
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#allowbooleanattributes
    allowBooleanAttributes: true,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#ignoredeclaration
    ignoreDeclaration: true,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#removensprefix
    removeNSPrefix: options == null ? void 0 : options.removeNSPrefix,
    // https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/docs/v4/2.XMLparseOptions.md#textnodename
    textNodeName: options == null ? void 0 : options.textNodeName,
    // Let's application specify keys that are always arrays
    isArray: (name12, jpath, isLeafNode, isAttribute) => {
      var _a;
      const array = Boolean((_a = options == null ? void 0 : options.arrayPaths) == null ? void 0 : _a.some((path) => jpath === path));
      return array;
    },
    // Application overrides
    ...options == null ? void 0 : options._fastXML
  };
  const xml = fastParseXML(text, fastXMLOptions);
  return (options == null ? void 0 : options.uncapitalizeKeys) ? uncapitalizeKeys(xml) : xml;
}
function fastParseXML(text, options) {
  const parser = new import_fast_xml_parser.XMLParser({
    ignoreAttributes: false,
    attributeNamePrefix: "",
    ...options
  });
  const parsedXML = parser.parse(text);
  return parsedXML;
}

// node_modules/@loaders.gl/xml/dist/xml-loader.js
var VERSION = true ? "4.3.3" : "latest";
var XMLLoader = {
  dataType: null,
  batchType: null,
  name: "XML",
  id: "xml",
  module: "xml",
  version: VERSION,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/xml", "text/xml"],
  testText: testXMLFile,
  options: {
    xml: {
      _parser: "fast-xml-parser",
      uncapitalizeKeys: false,
      removeNSPrefix: false,
      textNodeName: "value",
      arrayPaths: []
    }
  },
  parse: async (arrayBuffer, options) => parseXMLSync(new TextDecoder().decode(arrayBuffer), {
    ...XMLLoader.options.xml,
    ...options == null ? void 0 : options.xml
  }),
  parseTextSync: (text, options) => parseXMLSync(text, { ...XMLLoader.options.xml, ...options == null ? void 0 : options.xml })
};
function testXMLFile(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/xml/dist/html-loader.js
var HTMLLoader = {
  ...XMLLoader,
  name: "HTML",
  id: "html",
  extensions: ["html", "htm"],
  mimeTypes: ["text/html"],
  testText: testHTMLFile,
  parse: async (arrayBuffer, options) => parseTextSync(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync(text, options)
};
function testHTMLFile(text) {
  return text.startsWith("<html");
}
function parseTextSync(text, options) {
  var _a, _b;
  options = mergeLoaderOptions(options, {
    xml: {
      _parser: "fast-xml-parser",
      _fastXML: {
        htmlEntities: true
      }
    }
  });
  return (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-error.js
function parseWMSError(text, options) {
  var _a, _b, _c, _d;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  const serviceExceptionXML = ((_c = parsedXML == null ? void 0 : parsedXML.ServiceExceptionReport) == null ? void 0 : _c.ServiceException) || ((_d = parsedXML == null ? void 0 : parsedXML["ogc:ServiceExceptionReport"]) == null ? void 0 : _d["ogc:ServiceException"]);
  const message = typeof serviceExceptionXML === "string" ? serviceExceptionXML : serviceExceptionXML.value || serviceExceptionXML.code || "Unknown error";
  return message;
}

// node_modules/@loaders.gl/wms/dist/wms-error-loader.js
var VERSION2 = true ? "4.3.3" : "latest";
var WMSErrorLoader = {
  dataType: null,
  batchType: null,
  id: "wms-error",
  name: "WMS Error",
  module: "wms",
  version: VERSION2,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.se_xml", "application/xml", "text/xml"],
  testText: testXMLFile2,
  options: {
    wms: {
      throwOnError: false
    }
  },
  parse: async (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
  parseSync: (arrayBuffer, options) => parseTextSync2(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseTextSync2(text, options)
};
function testXMLFile2(text) {
  return text.startsWith("<?xml");
}
function parseTextSync2(text, options) {
  const wmsOptions = { ...WMSErrorLoader.options.wms, ...options == null ? void 0 : options.wms };
  const error = parseWMSError(text, wmsOptions);
  const message = wmsOptions.minimalErrors ? error : `WMS Service error: ${error}`;
  if (wmsOptions.throwOnError) {
    throw new Error(message);
  }
  return message;
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/xml/parse-xml-helpers.js
function getXMLArray(xmlValue) {
  if (Array.isArray(xmlValue)) {
    return xmlValue;
  }
  if (xmlValue) {
    return [xmlValue];
  }
  return [];
}
function getXMLStringArray(xmlValue) {
  const xmlArray = getXMLArray(xmlValue);
  if (xmlArray.length > 0 && xmlArray.every((_) => typeof _ === "string")) {
    return xmlArray;
  }
  return [];
}
function getXMLFloat(xmlValue, defaultValue2 = void 0) {
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseFloat(xmlValue);
    default:
      return void 0;
  }
}
function getXMLInteger(xmlValue, defaultValue2 = void 0) {
  switch (typeof xmlValue) {
    case "number":
      return xmlValue;
    case "string":
      return parseInt(xmlValue, 10);
    default:
      return void 0;
  }
}
function getXMLBoolean(xmlValue) {
  switch (xmlValue) {
    case "true":
      return true;
    case "false":
      return false;
    case "1":
      return true;
    case "0":
      return false;
    default:
      return false;
  }
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-capabilities.js
function parseWMSCapabilities(xmlText, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, xmlText, options);
  const xmlCapabilities = parsedXML.WMT_MS_Capabilities || parsedXML.WMS_Capabilities || parsedXML;
  const capabilities = extractCapabilities(xmlCapabilities);
  if (options == null ? void 0 : options.inheritedLayerProps) {
    for (const layer of capabilities.layers) {
      addInheritedLayerProps(layer, null);
    }
  }
  if (options == null ? void 0 : options.includeRawJSON) {
    capabilities.json = xmlCapabilities;
  }
  if (options == null ? void 0 : options.includeXMLText) {
    capabilities.xml = xmlText;
  }
  return capabilities;
}
function extractCapabilities(xml) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const capabilities = {
    version: String(xml.version || ""),
    name: String(((_a = xml.Service) == null ? void 0 : _a.Name) || "unnamed"),
    title: ((_b = xml.Service) == null ? void 0 : _b.Title) ? String((_c = xml.Service) == null ? void 0 : _c.Title) : void 0,
    abstract: ((_d = xml.Service) == null ? void 0 : _d.Abstract) ? String((_e = xml.Service) == null ? void 0 : _e.Abstract) : void 0,
    keywords: getXMLStringArray((_g = (_f = xml.Service) == null ? void 0 : _f.KeywordList) == null ? void 0 : _g.Keyword),
    fees: ((_h = xml.Service) == null ? void 0 : _h.Fees) ? JSON.stringify((_i = xml.Service) == null ? void 0 : _i.Fees) : void 0,
    accessConstraints: ((_j = xml.Service) == null ? void 0 : _j.AccessConstraints) ? JSON.stringify((_k = xml.Service) == null ? void 0 : _k.AccessConstraints) : void 0,
    layerLimit: getXMLInteger((_l = xml.Service) == null ? void 0 : _l.LayerLimit),
    maxWidth: getXMLInteger((_m = xml.Service) == null ? void 0 : _m.maxWidth),
    maxHeight: getXMLInteger((_n = xml.Service) == null ? void 0 : _n.maxHeight),
    layers: [],
    requests: extractRequests((_o = xml.Capability) == null ? void 0 : _o.Request),
    exceptions: extractExceptions(xml.Exception)
    // contact field is a mess of largely irrelevant information, put it last
    // contact: xml.Service?.Contact ? JSON.stringify(xml.Service?.Contact) : undefined,
  };
  const xmlLayers = getXMLArray((_p = xml.Capability) == null ? void 0 : _p.Layer);
  for (const xmlSubLayer of xmlLayers) {
    capabilities.layers.push(extractLayer(xmlSubLayer));
  }
  for (const [key, value] of Object.entries(capabilities)) {
    if (value === void 0) {
      delete capabilities[key];
    }
  }
  return capabilities;
}
function extractRequests(xmlRequests) {
  const requests = {};
  for (const [name12, xmlRequest] of Object.entries(xmlRequests || {})) {
    const mimeTypes = getXMLStringArray(xmlRequest == null ? void 0 : xmlRequest.Format);
    requests[name12] = { mimeTypes };
  }
  return requests;
}
function extractExceptions(xmlException) {
  const xmlExceptionFormats = getXMLArray(xmlException == null ? void 0 : xmlException.Format);
  if (xmlExceptionFormats.length > 0) {
    return {
      mimeTypes: getXMLStringArray(xmlException)
    };
  }
  return void 0;
}
function extractLayer(xmlLayer) {
  var _a;
  const layer = {
    // All layers must have a title
    title: String((xmlLayer == null ? void 0 : xmlLayer.Title) || ""),
    // Name is required only if renderable
    name: (xmlLayer == null ? void 0 : xmlLayer.Name) && String(xmlLayer == null ? void 0 : xmlLayer.Name),
    abstract: (xmlLayer == null ? void 0 : xmlLayer.Name) && String(xmlLayer == null ? void 0 : xmlLayer.Abstract),
    keywords: getXMLStringArray((_a = xmlLayer.KeywordList) == null ? void 0 : _a.Keyword)
  };
  const crs2 = (xmlLayer == null ? void 0 : xmlLayer.CRS) || (xmlLayer == null ? void 0 : xmlLayer.SRS);
  if (crs2 && Array.isArray(crs2) && crs2.every((_) => typeof _ === "string")) {
    layer.crs = crs2;
  }
  let geographicBoundingBox = (xmlLayer == null ? void 0 : xmlLayer.EX_GeographicBoundingBox) && extractEXBoundingBox(xmlLayer == null ? void 0 : xmlLayer.EX_GeographicBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  geographicBoundingBox = (xmlLayer == null ? void 0 : xmlLayer.LatLonBoundingBox) && extractLatLonBoundingBox(xmlLayer == null ? void 0 : xmlLayer.LatLonBoundingBox);
  if (geographicBoundingBox) {
    layer.geographicBoundingBox = geographicBoundingBox;
  }
  const boundingBoxes = (xmlLayer == null ? void 0 : xmlLayer.BoundingBox) && extractWMSBoundingBoxes(xmlLayer == null ? void 0 : xmlLayer.BoundingBox);
  if (boundingBoxes && boundingBoxes.length > 0) {
    layer.boundingBoxes = boundingBoxes;
  }
  const xmlDimensions = getXMLArray(xmlLayer == null ? void 0 : xmlLayer.Dimension);
  const dimensions = xmlDimensions.map((xml) => extractDimension(xml));
  if (dimensions.length) {
    layer.dimensions = dimensions;
  }
  if (xmlLayer == null ? void 0 : xmlLayer.opaque) {
    layer.opaque = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.opaque);
  }
  if (xmlLayer == null ? void 0 : xmlLayer.cascaded) {
    layer.cascaded = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.cascaded);
  }
  if (xmlLayer == null ? void 0 : xmlLayer.queryable) {
    layer.queryable = getXMLBoolean(xmlLayer == null ? void 0 : xmlLayer.queryable);
  }
  const xmlLayers = getXMLArray(xmlLayer == null ? void 0 : xmlLayer.Layer);
  const layers = [];
  for (const xmlSubLayer of xmlLayers) {
    layers.push(extractLayer(xmlSubLayer));
  }
  if (layers.length > 0) {
    layer.layers = layers;
  }
  for (const [key, value] of Object.entries(layer)) {
    if (value === void 0) {
      delete layer[key];
    }
  }
  return layer;
}
function extractEXBoundingBox(xmlBoundingBox) {
  const { westBoundLongitude: w2, northBoundLatitude: n, eastBoundLongitude: e2, southBoundLatitude: s } = xmlBoundingBox;
  return [
    [w2, s],
    [e2, n]
  ];
}
function extractLatLonBoundingBox(xmlBoundingBox) {
  const { minx, miny, maxx, maxy } = xmlBoundingBox;
  return [
    [minx, miny],
    [maxx, maxy]
  ];
}
function extractWMSBoundingBoxes(xmlBoundingBoxes) {
  const xmlBoxes = getXMLArray(xmlBoundingBoxes);
  return xmlBoxes.map((xmlBox) => extractWMSBoundingBox(xmlBox));
}
function extractWMSBoundingBox(xmlBoundingBox) {
  const { CRS: CRS2, SRS, minx, miny, maxx, maxy, resx, resy } = xmlBoundingBox;
  const boundingBox = {
    // CRS in 1.3.0, SRS in 1.1.1
    crs: CRS2 || SRS,
    boundingBox: [
      [getXMLFloat(minx), getXMLFloat(miny)],
      [getXMLFloat(maxx), getXMLFloat(maxy)]
    ]
  };
  if (resx) {
    boundingBox.xResolution = resx;
  }
  if (resy) {
    boundingBox.yResolution = resy;
  }
  return boundingBox;
}
function extractDimension(xmlDimension) {
  const { name: name12, units, value: extent } = xmlDimension;
  const dimension = { name: name12, units, extent };
  if (xmlDimension.unitSymbol) {
    dimension.unitSymbol = xmlDimension.unitSymbol;
  }
  if (xmlDimension.default) {
    dimension.defaultValue = xmlDimension.default;
  }
  if (xmlDimension.multipleValues) {
    dimension.multipleValues = getXMLBoolean(xmlDimension.multipleValues);
  }
  if (xmlDimension.nearestValue) {
    dimension.nearestValue = getXMLBoolean(xmlDimension.nearestValue);
  }
  if (xmlDimension.current) {
    dimension.current = getXMLBoolean(xmlDimension.current);
  }
  return dimension;
}
function addInheritedLayerProps(layer, parent) {
  if ((parent == null ? void 0 : parent.geographicBoundingBox) && !layer.geographicBoundingBox) {
    layer.geographicBoundingBox = [...parent.geographicBoundingBox];
  }
  if ((parent == null ? void 0 : parent.crs) && !layer.crs) {
    layer.crs = [...parent.crs];
  }
  if ((parent == null ? void 0 : parent.boundingBoxes) && !layer.boundingBoxes) {
    layer.boundingBoxes = [...parent.boundingBoxes];
  }
  if ((parent == null ? void 0 : parent.dimensions) && !layer.dimensions) {
    layer.dimensions = [...parent.dimensions];
  }
  for (const subLayer of layer.layers || []) {
    addInheritedLayerProps(subLayer, layer);
  }
}

// node_modules/@loaders.gl/wms/dist/wms-capabilities-loader.js
var VERSION3 = true ? "4.3.3" : "latest";
var WMSCapabilitiesLoader = {
  dataType: null,
  batchType: null,
  id: "wms-capabilities",
  name: "WMS Capabilities",
  module: "wms",
  version: VERSION3,
  worker: false,
  extensions: ["xml"],
  mimeTypes: ["application/vnd.ogc.wms_xml", "application/xml", "text/xml"],
  testText: testXMLFile3,
  options: {
    wms: {}
  },
  parse: async (arrayBuffer, options) => (
    // TODO pass in XML options
    parseWMSCapabilities(new TextDecoder().decode(arrayBuffer), options == null ? void 0 : options.wms)
  ),
  parseTextSync: (text, options) => (
    // TODO pass in XML options
    parseWMSCapabilities(text, options == null ? void 0 : options.wms)
  )
};
function testXMLFile3(text) {
  return text.startsWith("<?xml");
}

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-features.js
function parseWMSFeatureInfo(text, options) {
  var _a, _b, _c;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  const xmlFeatureInfo = ((_c = parsedXML.FeatureInfoResponse) == null ? void 0 : _c.FIELDS) || [];
  const xmlFeatures = Array.isArray(xmlFeatureInfo) ? xmlFeatureInfo : [xmlFeatureInfo];
  return {
    features: xmlFeatures.map((xmlFeature) => extractFeature(xmlFeature))
  };
}
function extractFeature(xmlFeature) {
  const xmlFields = xmlFeature || {};
  return {
    attributes: xmlFields,
    type: "",
    bounds: { bottom: 0, top: 0, left: 0, right: 0 }
  };
}

// node_modules/@loaders.gl/wms/dist/wip/wms-feature-info-loader.js
var WMSFeatureInfoLoader = {
  ...WMSCapabilitiesLoader,
  dataType: null,
  id: "wms-feature-info",
  name: "WMS FeatureInfo",
  parse: async (arrayBuffer, options) => parseWMSFeatureInfo(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSFeatureInfo(text, options)
};

// node_modules/@loaders.gl/wms/dist/lib/parsers/wms/parse-wms-layer-description.js
function parseWMSLayerDescription(text, options) {
  var _a, _b;
  const parsedXML = (_b = (_a = XMLLoader).parseTextSync) == null ? void 0 : _b.call(_a, text, options);
  return parsedXML;
}

// node_modules/@loaders.gl/wms/dist/wip/wms-layer-description-loader.js
var WMSLayerDescriptionLoader = {
  ...WMSCapabilitiesLoader,
  dataType: null,
  id: "wms-layer-description",
  name: "WMS DescribeLayer",
  parse: async (arrayBuffer, options) => parseWMSLayerDescription(new TextDecoder().decode(arrayBuffer), options),
  parseTextSync: (text, options) => parseWMSLayerDescription(text, options)
};

// node_modules/@loaders.gl/wms/dist/lib/parsers/gml/deep-strict-equal.js
var pSlice = Array.prototype.slice;

// node_modules/@turf/helpers/main.es.js
var earthRadius = 63710088e-1;
var factors = {
  meters: earthRadius,
  metres: earthRadius,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  miles: earthRadius / 1609.344,
  nauticalmiles: earthRadius / 1852,
  inches: earthRadius * 39.37,
  yards: earthRadius / 1.0936,
  feet: earthRadius * 3.28084,
  radians: 1,
  degrees: earthRadius / 111325
};
var unitsFactors = {
  meters: 1,
  metres: 1,
  millimeters: 1e3,
  millimetres: 1e3,
  centimeters: 100,
  centimetres: 100,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  miles: 1 / 1609.344,
  nauticalmiles: 1 / 1852,
  inches: 39.37,
  yards: 1 / 1.0936,
  feet: 3.28084,
  radians: 1 / earthRadius,
  degrees: 1 / 111325
};

// node_modules/@loaders.gl/wms/dist/services/ogc/wms-service.js
var WMSSource = {
  name: "Web Map Service (OGC WMS)",
  id: "wms",
  module: "wms",
  version: "0.0.0",
  extensions: [],
  mimeTypes: [],
  options: {
    wms: {
      // TODO - add options here
    }
  },
  type: "wms",
  fromUrl: true,
  fromBlob: false,
  testURL: (url) => url.toLowerCase().includes("wms"),
  createDataSource: (url, props) => new WMSImageSource(url, props)
};
var WMSImageSource = class extends ImageSource {
  /** Create a WMSImageSource */
  constructor(url, props) {
    var _a, _b, _c;
    super(props);
    /** Base URL to the service */
    __publicField(this, "url");
    __publicField(this, "data");
    /** In WMS 1.3.0, replaces references to EPSG:4326 with CRS:84. But not always supported. Default: false */
    __publicField(this, "substituteCRS84");
    /** In WMS 1.3.0, flips x,y (lng, lat) coordinates for the supplied coordinate systems. Default: ['ESPG:4326'] */
    __publicField(this, "flipCRS");
    /** Default static WMS parameters */
    __publicField(this, "wmsParameters");
    /** Default static vendor parameters */
    __publicField(this, "vendorParameters");
    __publicField(this, "capabilities", null);
    this.url = url;
    this.data = url;
    this.substituteCRS84 = ((_a = props.wms) == null ? void 0 : _a.substituteCRS84) ?? props.substituteCRS84 ?? false;
    this.flipCRS = ["EPSG:4326"];
    this.wmsParameters = {
      layers: void 0,
      query_layers: void 0,
      styles: void 0,
      version: "1.3.0",
      crs: "EPSG:4326",
      format: "image/png",
      info_format: "text/plain",
      transparent: void 0,
      time: void 0,
      elevation: void 0,
      ...props.wmsParameters,
      // deprecated
      ...(_b = props.wms) == null ? void 0 : _b.wmsParameters
    };
    this.vendorParameters = ((_c = props.wms) == null ? void 0 : _c.vendorParameters) || props.vendorParameters || {};
  }
  // ImageSource implementation
  async getMetadata() {
    const capabilities = await this.getCapabilities();
    return this.normalizeMetadata(capabilities);
  }
  async getImage(parameters2) {
    const { boundingBox, bbox, ...rest } = parameters2;
    const wmsParameters = {
      bbox: boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox,
      ...rest
    };
    return await this.getMap(wmsParameters);
  }
  normalizeMetadata(capabilities) {
    return capabilities;
  }
  // WMS Service API Stubs
  /** Get Capabilities */
  async getCapabilities(wmsParameters, vendorParameters) {
    const url = this.getCapabilitiesURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    const capabilities = await WMSCapabilitiesLoader.parse(arrayBuffer, this.loadOptions);
    this.capabilities = capabilities;
    return capabilities;
  }
  /** Get a map image */
  async getMap(wmsParameters, vendorParameters) {
    const url = this.getMapURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfo(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSFeatureInfoLoader.parse(arrayBuffer, this.loadOptions);
  }
  /** Get Feature Info for a coordinate */
  async getFeatureInfoText(wmsParameters, vendorParameters) {
    const url = this.getFeatureInfoURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return new TextDecoder().decode(arrayBuffer);
  }
  /** Get more information about a layer */
  async describeLayer(wmsParameters, vendorParameters) {
    const url = this.describeLayerURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return await WMSLayerDescriptionLoader.parse(arrayBuffer, this.loadOptions);
  }
  /** Get an image with a semantic legend */
  async getLegendGraphic(wmsParameters, vendorParameters) {
    const url = this.getLegendGraphicURL(wmsParameters, vendorParameters);
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    try {
      return await ImageLoader.parse(arrayBuffer, this.loadOptions);
    } catch {
      throw this._parseError(arrayBuffer);
    }
  }
  // Typed URL creators
  // For applications that want full control of fetching and parsing
  /** Generate a URL for the GetCapabilities request */
  getCapabilitiesURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("GetCapabilities", options, vendorParameters);
  }
  /** Generate a URL for the GetMap request */
  getMapURL(wmsParameters, vendorParameters) {
    wmsParameters = this._getWMS130Parameters(wmsParameters);
    const options = {
      version: this.wmsParameters.version,
      format: this.wmsParameters.format,
      transparent: this.wmsParameters.transparent,
      time: this.wmsParameters.time,
      elevation: this.wmsParameters.elevation,
      layers: this.wmsParameters.layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      ...wmsParameters
    };
    return this._getWMSUrl("GetMap", options, vendorParameters);
  }
  /** Generate a URL for the GetFeatureInfo request */
  getFeatureInfoURL(wmsParameters, vendorParameters) {
    wmsParameters = this._getWMS130Parameters(wmsParameters);
    const { boundingBox, bbox } = wmsParameters;
    wmsParameters.bbox = boundingBox ? [...boundingBox[0], ...boundingBox[1]] : bbox;
    const options = {
      version: this.wmsParameters.version,
      // query_layers: [],
      // format: this.wmsParameters.format,
      info_format: this.wmsParameters.info_format,
      layers: this.wmsParameters.layers,
      query_layers: this.wmsParameters.query_layers,
      styles: this.wmsParameters.styles,
      crs: this.wmsParameters.crs,
      // bbox: [-77.87304, 40.78975, -77.85828, 40.80228],
      // width: 1200,
      // height: 900,
      // x: undefined!,
      // y: undefined!,
      ...wmsParameters
    };
    return this._getWMSUrl("GetFeatureInfo", options, vendorParameters);
  }
  /** Generate a URL for the GetFeatureInfo request */
  describeLayerURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      ...wmsParameters
    };
    return this._getWMSUrl("DescribeLayer", options, vendorParameters);
  }
  getLegendGraphicURL(wmsParameters, vendorParameters) {
    const options = {
      version: this.wmsParameters.version,
      // format?
      ...wmsParameters
    };
    return this._getWMSUrl("GetLegendGraphic", options, vendorParameters);
  }
  // INTERNAL METHODS
  _parseWMSUrl(url) {
    const [baseUrl, search] = url.split("?");
    const searchParams = search.split("&");
    const parameters2 = {};
    for (const parameter of searchParams) {
      const [key, value] = parameter.split("=");
      parameters2[key] = value;
    }
    return { url: baseUrl, parameters: parameters2 };
  }
  /**
   * Generate a URL with parameters
   * @note case _getWMSUrl may need to be overridden to handle certain backends?
   * @note at the moment, only URLs with parameters are supported (no XML payloads)
   * */
  _getWMSUrl(request, wmsParameters, vendorParameters) {
    let url = this.url;
    let first = true;
    const allParameters = {
      service: "WMS",
      version: wmsParameters.version,
      request,
      ...wmsParameters,
      ...this.vendorParameters,
      ...vendorParameters
    };
    const IGNORE_EMPTY_KEYS = ["transparent", "time", "elevation"];
    for (const [key, value] of Object.entries(allParameters)) {
      if (!IGNORE_EMPTY_KEYS.includes(key) || value) {
        url += first ? "?" : "&";
        first = false;
        url += this._getURLParameter(key, value, wmsParameters);
      }
    }
    return encodeURI(url);
  }
  _getWMS130Parameters(wmsParameters) {
    const newParameters = { ...wmsParameters };
    if (newParameters.srs) {
      newParameters.crs = newParameters.crs || newParameters.srs;
      delete newParameters.srs;
    }
    return newParameters;
  }
  // eslint-disable-next-line complexity
  _getURLParameter(key, value, wmsParameters) {
    switch (key) {
      case "crs":
        if (wmsParameters.version !== "1.3.0") {
          key = "srs";
        } else if (this.substituteCRS84 && value === "EPSG:4326") {
          value = "CRS:84";
        }
        break;
      case "srs":
        if (wmsParameters.version === "1.3.0") {
          key = "crs";
        }
        break;
      case "bbox":
        const bbox = this._flipBoundingBox(value, wmsParameters);
        if (bbox) {
          value = bbox;
        }
        break;
      case "x":
        if (wmsParameters.version === "1.3.0") {
          key = "i";
        }
        break;
      case "y":
        if (wmsParameters.version === "1.3.0") {
          key = "j";
        }
        break;
      default:
    }
    key = key.toUpperCase();
    return Array.isArray(value) ? `${key}=${value.join(",")}` : `${key}=${value ? String(value) : ""}`;
  }
  /** Coordinate order is flipped for certain CRS in WMS 1.3.0 */
  _flipBoundingBox(bboxValue, wmsParameters) {
    if (!Array.isArray(bboxValue) || bboxValue.length !== 4) {
      return null;
    }
    const flipCoordinates = (
      // Only affects WMS 1.3.0
      wmsParameters.version === "1.3.0" && // Flip if we are dealing with a CRS that was flipped in 1.3.0
      this.flipCRS.includes(wmsParameters.crs || "") && // Don't flip if we are substituting EPSG:4326 with CRS:84
      !(this.substituteCRS84 && wmsParameters.crs === "EPSG:4326")
    );
    const bbox = bboxValue;
    return flipCoordinates ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
  }
  /** Fetches an array buffer and checks the response (boilerplate reduction) */
  async _fetchArrayBuffer(url) {
    const response = await this.fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    this._checkResponse(response, arrayBuffer);
    return arrayBuffer;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  _checkResponse(response, arrayBuffer) {
    var _a, _b;
    const contentType = response.headers["content-type"];
    if (!response.ok || WMSErrorLoader.mimeTypes.includes(contentType)) {
      const loadOptions = mergeLoaderOptions(this.loadOptions, {
        wms: { throwOnError: true }
      });
      const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, loadOptions);
      throw new Error(error);
    }
  }
  /** Error situation detected */
  _parseError(arrayBuffer) {
    var _a, _b;
    const error = (_b = (_a = WMSErrorLoader).parseSync) == null ? void 0 : _b.call(_a, arrayBuffer, this.loadOptions);
    return new Error(error);
  }
};

// node_modules/@loaders.gl/wms/dist/services/arcgis/arcgis-image-server.js
var ArcGISImageServerSource = {
  name: "ArcGISImageServer",
  id: "arcgis-image-server",
  module: "wms",
  version: "0.0.0",
  extensions: [],
  mimeTypes: [],
  options: {
    "arcgis-image-server": {
      // TODO - add options here
    }
  },
  type: "arcgis-image-server",
  fromUrl: true,
  fromBlob: false,
  testURL: (url) => url.toLowerCase().includes("ImageServer"),
  createDataSource: (url, props) => new ArcGISImageSource(url, props)
};
var ArcGISImageSource = class extends ImageSource {
  constructor(url, props) {
    super(props);
    __publicField(this, "url");
    __publicField(this, "data");
    this.url = url;
    this.data = url;
  }
  // ImageSource (normalized endpoints)
  async getMetadata() {
    return await this.metadata();
  }
  async getImage(parameters2) {
    throw new Error("not implemented");
  }
  // ImageServer endpoints
  async metadata() {
    throw new Error("not implemented");
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&compressionQuality=&bandIds=&mosaicRule=&renderingRule=&f=image`,
   */
  exportImage(options) {
    throw new Error("not implemented");
  }
  // URL creators
  metadataURL(options) {
    return `${this.url}?f=pjson`;
  }
  /**
   * Form a URL to an ESRI ImageServer
   // https://sampleserver6.arcgisonline.com/arcgis/rest/services/NLCDLandCover2001/ImageServer/exportImage?
   //   bbox=${bounds[0]},${bounds[1]},${bounds[2]},${bounds[3]}&bboxSR=4326&
   //   size=${width},${height}&imageSR=102100&time=&format=jpgpng&pixelType=U8&
   //   noData=&noDataInterpretation=esriNoDataMatchAny&interpolation=+RSP_NearestNeighbor&compression=&
   //   compressionQuality=&bandIds=&mosaicRule=&renderingRule=&
   //   f=image
   */
  exportImageURL(options) {
    const bbox = `bbox=${options.bbox[0]},${options.bbox[1]},${options.bbox[2]},${options.bbox[3]}`;
    const size = `size=${options.width},${options.height}`;
    const arcgisOptions = { ...options, bbox, size };
    delete arcgisOptions.width;
    delete arcgisOptions.height;
    return this.getUrl("exportImage", arcgisOptions);
  }
  // INTERNAL METHODS
  /**
   * @note protected, since perhaps getWMSUrl may need to be overridden to handle certain backends?
   * @note if override is common, maybe add a callback prop?
   * */
  getUrl(path, options, extra) {
    let url = `${this.url}/${path}`;
    let first = true;
    for (const [key, value] of Object.entries(options)) {
      url += first ? "?" : "&";
      first = false;
      if (Array.isArray(value)) {
        url += `${key.toUpperCase()}=${value.join(",")}`;
      } else {
        url += `${key.toUpperCase()}=${value ? String(value) : ""}`;
      }
    }
    return url;
  }
  /** Checks for and parses a WMS XML formatted ServiceError and throws an exception */
  async checkResponse(response) {
    if (!response.ok) {
      throw new Error("error");
    }
  }
};

// node_modules/@loaders.gl/wms/dist/lib/deprecated/create-image-source.js
var SOURCES = [WMSSource, ArcGISImageServerSource];
function createImageSource(props, sources = SOURCES) {
  const { type = "auto" } = props;
  const source = type === "auto" ? guessSourceType(props.url, sources) : getSourceOfType(type, sources);
  if (!source) {
    throw new Error("Not a valid image source type");
  }
  return source.createDataSource(props.url, props);
}
function getSourceOfType(type, sources) {
  for (const source of sources) {
    if (source.type === type) {
      return source;
    }
  }
  return null;
}
function guessSourceType(url, sources) {
  for (const source of sources) {
    if (source.testURL && source.testURL(url)) {
      return source;
    }
  }
  return null;
}

// node_modules/@deck.gl/geo-layers/dist/wms-layer/utils.js
var HALF_EARTH_CIRCUMFERENCE = 6378137 * Math.PI;
function WGS84ToPseudoMercator(coord) {
  const mercator = lngLatToWorld(coord);
  mercator[0] = (mercator[0] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  mercator[1] = (mercator[1] / 256 - 1) * HALF_EARTH_CIRCUMFERENCE;
  return mercator;
}

// node_modules/@deck.gl/geo-layers/dist/wms-layer/wms-layer.js
var defaultProps3 = {
  id: "imagery-layer",
  data: "",
  serviceType: "auto",
  srs: "auto",
  layers: { type: "array", compare: true, value: [] },
  onMetadataLoad: { type: "function", value: () => {
  } },
  // eslint-disable-next-line
  onMetadataLoadError: { type: "function", value: console.error },
  onImageLoadStart: { type: "function", value: () => {
  } },
  onImageLoad: { type: "function", value: () => {
  } },
  onImageLoadError: {
    type: "function",
    compare: false,
    // eslint-disable-next-line
    value: (requestId, error) => console.error(error, requestId)
  }
};
var WMSLayer = class extends composite_layer_default {
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    var _a;
    return ((_a = this.state) == null ? void 0 : _a.loadCounter) === 0 && super.isLoaded;
  }
  /** Lets deck.gl know that we want viewport change events */
  shouldUpdateState() {
    return true;
  }
  initializeState() {
    this.state._nextRequestId = 0;
    this.state.lastRequestId = -1;
    this.state.loadCounter = 0;
  }
  updateState({ changeFlags, props, oldProps }) {
    const { viewport } = this.context;
    if (changeFlags.dataChanged || props.serviceType !== oldProps.serviceType) {
      this.state.imageSource = this._createImageSource(props);
      this._loadMetadata();
      this.debounce(() => this.loadImage(viewport, "image source changed"), 0);
    } else if (!deepEqual(props.layers, oldProps.layers, 1)) {
      this.debounce(() => this.loadImage(viewport, "layers changed"), 0);
    } else if (changeFlags.viewportChanged) {
      this.debounce(() => this.loadImage(viewport, "viewport changed"));
    }
  }
  finalizeState() {
  }
  renderLayers() {
    const { bounds, image, lastRequestParameters } = this.state;
    return image && new bitmap_layer_default({
      ...this.getSubLayerProps({ id: "bitmap" }),
      _imageCoordinateSystem: lastRequestParameters.srs === "EPSG:4326" ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN,
      bounds,
      image
    });
  }
  async getFeatureInfoText(x, y) {
    var _a, _b;
    const { lastRequestParameters } = this.state;
    if (lastRequestParameters) {
      const featureInfo = await ((_b = (_a = this.state.imageSource).getFeatureInfoText) == null ? void 0 : _b.call(_a, {
        ...lastRequestParameters,
        query_layers: lastRequestParameters.layers,
        x,
        y,
        info_format: "application/vnd.ogc.gml"
      }));
      return featureInfo;
    }
    return "";
  }
  _createImageSource(props) {
    if (props.data instanceof ImageSource) {
      return props.data;
    }
    if (typeof props.data === "string") {
      return createImageSource({
        url: props.data,
        loadOptions: props.loadOptions,
        type: props.serviceType
      });
    }
    throw new Error("invalid image source in props.data");
  }
  /** Run a getMetadata on the image service */
  async _loadMetadata() {
    var _a, _b;
    const { imageSource } = this.state;
    try {
      this.state.loadCounter++;
      const metadata = await imageSource.getMetadata();
      if (this.state.imageSource === imageSource) {
        (_a = this.getCurrentLayer()) == null ? void 0 : _a.props.onMetadataLoad(metadata);
      }
    } catch (error) {
      (_b = this.getCurrentLayer()) == null ? void 0 : _b.props.onMetadataLoadError(error);
    } finally {
      this.state.loadCounter--;
    }
  }
  /** Load an image */
  async loadImage(viewport, reason) {
    var _a, _b;
    const { layers, serviceType } = this.props;
    if (serviceType === "wms" && layers.length === 0) {
      return;
    }
    const bounds = viewport.getBounds();
    const { width, height } = viewport;
    const requestId = this.getRequestId();
    let { srs } = this.props;
    if (srs === "auto") {
      srs = viewport.resolution ? "EPSG:4326" : "EPSG:3857";
    }
    const requestParams = {
      width,
      height,
      boundingBox: [
        [bounds[0], bounds[1]],
        [bounds[2], bounds[3]]
      ],
      layers,
      crs: srs
    };
    if (srs === "EPSG:3857") {
      const min3 = WGS84ToPseudoMercator([bounds[0], bounds[1]]);
      const max3 = WGS84ToPseudoMercator([bounds[2], bounds[3]]);
      requestParams.boundingBox = [min3, max3];
    }
    try {
      this.state.loadCounter++;
      this.props.onImageLoadStart(requestId);
      const image = await this.state.imageSource.getImage(requestParams);
      if (this.state.lastRequestId < requestId) {
        (_a = this.getCurrentLayer()) == null ? void 0 : _a.props.onImageLoad(requestId);
        this.setState({
          image,
          bounds,
          lastRequestParameters: requestParams,
          lastRequestId: requestId
        });
      }
    } catch (error) {
      this.raiseError(error, "Load image");
      (_b = this.getCurrentLayer()) == null ? void 0 : _b.props.onImageLoadError(requestId, error);
    } finally {
      this.state.loadCounter--;
    }
  }
  // HELPERS
  /** Global counter for issuing unique request ids */
  getRequestId() {
    return this.state._nextRequestId++;
  }
  /** Runs an action in the future, cancels it if the new action is issued before it executes */
  debounce(fn, ms = 500) {
    clearTimeout(this.state._timeoutId);
    this.state._timeoutId = setTimeout(() => fn(), ms);
  }
};
WMSLayer.layerName = "WMSLayer";
WMSLayer.defaultProps = defaultProps3;

// node_modules/@deck.gl/geo-layers/dist/great-circle-layer/great-circle-layer.js
var defaultProps4 = {
  getHeight: { type: "accessor", value: 0 },
  greatCircle: true
};
var GreatCircleLayer = class extends arc_layer_default {
};
GreatCircleLayer.layerName = "GreatCircleLayer";
GreatCircleLayer.defaultProps = defaultProps4;
var great_circle_layer_default = GreatCircleLayer;

// node_modules/@deck.gl/geo-layers/dist/s2-layer/s2-geometry.js
var import_long = __toESM(require_long(), 1);
var FACE_BITS = 3;
var MAX_LEVEL = 30;
var POS_BITS = 2 * MAX_LEVEL + 1;
var RADIAN_TO_DEGREE = 180 / Math.PI;
function IJToST(ij, order, offsets) {
  const maxSize = 1 << order;
  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
}
function singleSTtoUV(st) {
  if (st >= 0.5) {
    return 1 / 3 * (4 * st * st - 1);
  }
  return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
}
function STToUV(st) {
  return [singleSTtoUV(st[0]), singleSTtoUV(st[1])];
}
function FaceUVToXYZ(face, [u2, v2]) {
  switch (face) {
    case 0:
      return [1, u2, v2];
    case 1:
      return [-u2, 1, v2];
    case 2:
      return [-u2, -v2, 1];
    case 3:
      return [-1, -v2, -u2];
    case 4:
      return [v2, -1, -u2];
    case 5:
      return [v2, u2, -1];
    default:
      throw new Error("Invalid face");
  }
}
function XYZToLngLat([x, y, z]) {
  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
  const lng = Math.atan2(y, x);
  return [lng * RADIAN_TO_DEGREE, lat * RADIAN_TO_DEGREE];
}
function toHilbertQuadkey(idS) {
  let bin = import_long.default.fromString(idS, true, 10).toString(2);
  while (bin.length < FACE_BITS + POS_BITS) {
    bin = "0" + bin;
  }
  const lsbIndex = bin.lastIndexOf("1");
  const faceB = bin.substring(0, 3);
  const posB = bin.substring(3, lsbIndex);
  const levelN = posB.length / 2;
  const faceS = import_long.default.fromString(faceB, true, 2).toString(10);
  let posS = import_long.default.fromString(posB, true, 2).toString(4);
  while (posS.length < levelN) {
    posS = "0" + posS;
  }
  return `${faceS}/${posS}`;
}
function rotateAndFlipQuadrant(n, point2, rx, ry) {
  if (ry === 0) {
    if (rx === 1) {
      point2[0] = n - 1 - point2[0];
      point2[1] = n - 1 - point2[1];
    }
    const x = point2[0];
    point2[0] = point2[1];
    point2[1] = x;
  }
}
function FromHilbertQuadKey(hilbertQuadkey) {
  const parts = hilbertQuadkey.split("/");
  const face = parseInt(parts[0], 10);
  const position = parts[1];
  const maxLevel = position.length;
  const point2 = [0, 0];
  let level;
  for (let i = maxLevel - 1; i >= 0; i--) {
    level = maxLevel - i;
    const bit = position[i];
    let rx = 0;
    let ry = 0;
    if (bit === "1") {
      ry = 1;
    } else if (bit === "2") {
      rx = 1;
      ry = 1;
    } else if (bit === "3") {
      rx = 1;
    }
    const val = Math.pow(2, level - 1);
    rotateAndFlipQuadrant(val, point2, rx, ry);
    point2[0] += val * rx;
    point2[1] += val * ry;
  }
  if (face % 2 === 1) {
    const t = point2[0];
    point2[0] = point2[1];
    point2[1] = t;
  }
  return { face, ij: point2, level };
}

// node_modules/@deck.gl/geo-layers/dist/s2-layer/s2-utils.js
var import_long2 = __toESM(require_long(), 1);
function getIdFromToken(token) {
  const paddedToken = token.padEnd(16, "0");
  return import_long2.default.fromString(paddedToken, 16);
}
var MAX_RESOLUTION2 = 100;
function getGeoBounds({ face, ij, level }) {
  const offsets = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION2 * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;
  for (let i = 0; i < 4; i++) {
    const offset = offsets[i].slice(0);
    const nextOffset = offsets[i + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;
    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = IJToST(ij, level, offset);
      const uv = STToUV(st);
      const xyz = FaceUVToXYZ(face, uv);
      const lngLat = XYZToLngLat(xyz);
      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }
      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }
  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}
function getS2QuadKey(token) {
  if (typeof token === "string") {
    if (token.indexOf("/") > 0) {
      return token;
    }
    token = getIdFromToken(token);
  }
  return toHilbertQuadkey(token.toString());
}
function getS2Polygon(token) {
  const key = getS2QuadKey(token);
  const s2cell = FromHilbertQuadKey(key);
  return getGeoBounds(s2cell);
}

// node_modules/@deck.gl/geo-layers/dist/s2-layer/s2-layer.js
var defaultProps5 = {
  getS2Token: { type: "accessor", value: (d2) => d2.token }
};
var S2Layer = class extends GeoCellLayer_default {
  indexToBounds() {
    const { data, getS2Token } = this.props;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x, objectInfo) => getS2Polygon(getS2Token(x, objectInfo))
    };
  }
};
S2Layer.layerName = "S2Layer";
S2Layer.defaultProps = defaultProps5;
var s2_layer_default = S2Layer;

// node_modules/@deck.gl/geo-layers/dist/quadkey-layer/quadkey-utils.js
var TILE_SIZE = 512;
function quadkeyToWorldBounds(quadkey, coverage) {
  let x = 0;
  let y = 0;
  let mask = 1 << quadkey.length;
  const scale7 = mask / TILE_SIZE;
  for (let i = 0; i < quadkey.length; i++) {
    mask >>= 1;
    const q = parseInt(quadkey[i]);
    if (q % 2)
      x |= mask;
    if (q > 1)
      y |= mask;
  }
  return [
    [x / scale7, TILE_SIZE - y / scale7],
    [(x + coverage) / scale7, TILE_SIZE - (y + coverage) / scale7]
  ];
}
function getQuadkeyPolygon(quadkey, coverage = 1) {
  const [topLeft, bottomRight] = quadkeyToWorldBounds(quadkey, coverage);
  const [w2, n] = worldToLngLat(topLeft);
  const [e2, s] = worldToLngLat(bottomRight);
  return [e2, n, e2, s, w2, s, w2, n, e2, n];
}

// node_modules/@deck.gl/geo-layers/dist/quadkey-layer/quadkey-layer.js
var defaultProps6 = {
  getQuadkey: { type: "accessor", value: (d2) => d2.quadkey }
};
var QuadkeyLayer = class extends GeoCellLayer_default {
  indexToBounds() {
    const { data, extruded, getQuadkey } = this.props;
    const coverage = extruded ? 0.99 : 1;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x, objectInfo) => getQuadkeyPolygon(getQuadkey(x, objectInfo), coverage),
      updateTriggers: { getPolygon: coverage }
    };
  }
};
QuadkeyLayer.layerName = "QuadkeyLayer";
QuadkeyLayer.defaultProps = defaultProps6;
var quadkey_layer_default = QuadkeyLayer;

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-header.js
var Tile2DHeader = class {
  constructor(index) {
    this.index = index;
    this.isVisible = false;
    this.isSelected = false;
    this.parent = null;
    this.children = [];
    this.content = null;
    this._loader = void 0;
    this._abortController = null;
    this._loaderId = 0;
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
  }
  /** @deprecated use `boundingBox` instead */
  get bbox() {
    return this._bbox;
  }
  // TODO - remove in v9
  set bbox(value) {
    if (this._bbox)
      return;
    this._bbox = value;
    if ("west" in value) {
      this.boundingBox = [
        [value.west, value.south],
        [value.east, value.north]
      ];
    } else {
      this.boundingBox = [
        [value.left, value.top],
        [value.right, value.bottom]
      ];
    }
  }
  get data() {
    return this.isLoading && this._loader ? this._loader.then(() => this.data) : this.content;
  }
  get isLoaded() {
    return this._isLoaded && !this._needsReload;
  }
  get isLoading() {
    return Boolean(this._loader) && !this._isCancelled;
  }
  get needsReload() {
    return this._needsReload || this._isCancelled;
  }
  get byteLength() {
    const result = this.content ? this.content.byteLength : 0;
    if (!Number.isFinite(result)) {
      console.error("byteLength not defined in tile data");
    }
    return result;
  }
  /* eslint-disable max-statements */
  async _loadData({ getData, requestScheduler, onLoad, onError }) {
    const { index, id, bbox, userData, zoom } = this;
    const loaderId = this._loaderId;
    this._abortController = new AbortController();
    const { signal } = this._abortController;
    const requestToken = await requestScheduler.scheduleRequest(this, (tile) => {
      return tile.isSelected ? 1 : -1;
    });
    if (!requestToken) {
      this._isCancelled = true;
      return;
    }
    if (this._isCancelled) {
      requestToken.done();
      return;
    }
    let tileData = null;
    let error;
    try {
      tileData = await getData({ index, id, bbox, userData, zoom, signal });
    } catch (err) {
      error = err || true;
    } finally {
      requestToken.done();
    }
    if (loaderId !== this._loaderId) {
      return;
    }
    this._loader = void 0;
    this.content = tileData;
    if (this._isCancelled && !tileData) {
      this._isLoaded = false;
      return;
    }
    this._isLoaded = true;
    this._isCancelled = false;
    if (error) {
      onError(error, this);
    } else {
      onLoad(this);
    }
  }
  loadData(opts) {
    this._isLoaded = false;
    this._isCancelled = false;
    this._needsReload = false;
    this._loaderId++;
    this._loader = this._loadData(opts);
    return this._loader;
  }
  setNeedsReload() {
    if (this.isLoading) {
      this.abort();
      this._loader = void 0;
    }
    this._needsReload = true;
  }
  abort() {
    var _a;
    if (this.isLoaded) {
      return;
    }
    this._isCancelled = true;
    (_a = this._abortController) == null ? void 0 : _a.abort();
  }
};

// node_modules/@math.gl/culling/dist/constants.js
var INTERSECTION = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
};

// node_modules/@math.gl/culling/dist/lib/bounding-volumes/axis-aligned-bounding-box.js
var scratchVector = new Vector3();
var scratchNormal = new Vector3();
var AxisAlignedBoundingBox = class _AxisAlignedBoundingBox {
  /**
   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.
   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.
   * @param center The center of the box; automatically computed if not supplied.
   */
  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center2) {
    center2 = center2 || scratchVector.copy(minimum).add(maximum).scale(0.5);
    this.center = new Vector3(center2);
    this.halfDiagonal = new Vector3(maximum).subtract(this.center);
    this.minimum = new Vector3(minimum);
    this.maximum = new Vector3(maximum);
  }
  /**
   * Duplicates a AxisAlignedBoundingBox instance.
   *
   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.
   */
  clone() {
    return new _AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
  }
  /**
   * Compares the provided AxisAlignedBoundingBox componentwise and returns
   * <code>true</code> if they are equal, <code>false</code> otherwise.
   *
   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.
   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
   */
  equals(right) {
    return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(transform2) {
    this.center.transformAsPoint(transform2);
    this.halfDiagonal.transform(transform2);
    this.minimum.transform(transform2);
    this.maximum.transform(transform2);
    return this;
  }
  /**
   * Determines which side of a plane a box is located.
   */
  intersectPlane(plane) {
    const { halfDiagonal } = this;
    const normal = scratchNormal.from(plane.normal);
    const e2 = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
    const s = this.center.dot(normal) + plane.distance;
    if (s - e2 > 0) {
      return INTERSECTION.INSIDE;
    }
    if (s + e2 < 0) {
      return INTERSECTION.OUTSIDE;
    }
    return INTERSECTION.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(point2) {
    return Math.sqrt(this.distanceSquaredTo(point2));
  }
  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */
  distanceSquaredTo(point2) {
    const offset = scratchVector.from(point2).subtract(this.center);
    const { halfDiagonal } = this;
    let distanceSquared = 0;
    let d2;
    d2 = Math.abs(offset.x) - halfDiagonal.x;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    d2 = Math.abs(offset.y) - halfDiagonal.y;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    d2 = Math.abs(offset.z) - halfDiagonal.z;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    return distanceSquared;
  }
};

// node_modules/@math.gl/culling/dist/lib/bounding-volumes/bounding-sphere.js
var scratchVector2 = new Vector3();
var scratchVector22 = new Vector3();
var BoundingSphere = class _BoundingSphere {
  /** Creates a bounding sphere */
  constructor(center2 = [0, 0, 0], radius = 0) {
    this.radius = -0;
    this.center = new Vector3();
    this.fromCenterRadius(center2, radius);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(center2, radius) {
    this.center.from(center2);
    this.radius = radius;
    return this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(corner, oppositeCorner) {
    oppositeCorner = scratchVector2.from(oppositeCorner);
    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);
    this.radius = this.center.distance(oppositeCorner);
    return this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(right) {
    return this === right || Boolean(right) && this.center.equals(right.center) && this.radius === right.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new _BoundingSphere(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(boundingSphere) {
    const leftCenter = this.center;
    const leftRadius = this.radius;
    const rightCenter = boundingSphere.center;
    const rightRadius = boundingSphere.radius;
    const toRightCenter = scratchVector2.copy(rightCenter).subtract(leftCenter);
    const centerSeparation = toRightCenter.magnitude();
    if (leftRadius >= centerSeparation + rightRadius) {
      return this.clone();
    }
    if (rightRadius >= centerSeparation + leftRadius) {
      return boundingSphere.clone();
    }
    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;
    scratchVector22.copy(toRightCenter).scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation).add(leftCenter);
    this.center.copy(scratchVector22);
    this.radius = halfDistanceBetweenTangentPoints;
    return this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(point2) {
    const scratchPoint2 = scratchVector2.from(point2);
    const radius = scratchPoint2.subtract(this.center).magnitude();
    if (radius > this.radius) {
      this.radius = radius;
    }
    return this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(transform2) {
    this.center.transform(transform2);
    const scale7 = mat4_exports.getScaling(scratchVector2, transform2);
    this.radius = Math.max(scale7[0], Math.max(scale7[1], scale7[2])) * this.radius;
    return this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(point2) {
    const d2 = this.distanceTo(point2);
    return d2 * d2;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(point2) {
    const scratchPoint2 = scratchVector2.from(point2);
    const delta = scratchPoint2.subtract(this.center);
    return Math.max(0, delta.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(plane) {
    const center2 = this.center;
    const radius = this.radius;
    const normal = plane.normal;
    const distanceToPlane = normal.dot(center2) + plane.distance;
    if (distanceToPlane < -radius) {
      return INTERSECTION.OUTSIDE;
    }
    if (distanceToPlane < radius) {
      return INTERSECTION.INTERSECTING;
    }
    return INTERSECTION.INSIDE;
  }
};

// node_modules/@math.gl/culling/dist/lib/bounding-volumes/oriented-bounding-box.js
var scratchVector3 = new Vector3();
var scratchOffset = new Vector3();
var scratchVectorU = new Vector3();
var scratchVectorV = new Vector3();
var scratchVectorW = new Vector3();
var scratchCorner = new Vector3();
var scratchToCenter = new Vector3();
var MATRIX3 = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
var OrientedBoundingBox = class _OrientedBoundingBox {
  constructor(center2 = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {
    this.center = new Vector3().from(center2);
    this.halfAxes = new Matrix3(halfAxes);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const xAxis = this.halfAxes.getColumn(0);
    const yAxis = this.halfAxes.getColumn(1);
    const zAxis = this.halfAxes.getColumn(2);
    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const xAxis = this.halfAxes.getColumn(0);
    const yAxis = this.halfAxes.getColumn(1);
    const zAxis = this.halfAxes.getColumn(2);
    const normXAxis = new Vector3(xAxis).normalize();
    const normYAxis = new Vector3(yAxis).normalize();
    const normZAxis = new Vector3(zAxis).normalize();
    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(center2, halfSize, quaternion) {
    const quaternionObject = new Quaternion(quaternion);
    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);
    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];
    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];
    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];
    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];
    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];
    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];
    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];
    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];
    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];
    this.center = new Vector3().from(center2);
    this.halfAxes = directionsMatrix;
    return this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new _OrientedBoundingBox(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(right) {
    return this === right || Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere(result = new BoundingSphere()) {
    const halfAxes = this.halfAxes;
    const u2 = halfAxes.getColumn(0, scratchVectorU);
    const v2 = halfAxes.getColumn(1, scratchVectorV);
    const w2 = halfAxes.getColumn(2, scratchVectorW);
    const cornerVector = scratchVector3.copy(u2).add(v2).add(w2);
    result.center.copy(this.center);
    result.radius = cornerVector.magnitude();
    return result;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(plane) {
    const center2 = this.center;
    const normal = plane.normal;
    const halfAxes = this.halfAxes;
    const normalX = normal.x;
    const normalY = normal.y;
    const normalZ = normal.z;
    const radEffective = Math.abs(normalX * halfAxes[MATRIX3.COLUMN0ROW0] + normalY * halfAxes[MATRIX3.COLUMN0ROW1] + normalZ * halfAxes[MATRIX3.COLUMN0ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN1ROW0] + normalY * halfAxes[MATRIX3.COLUMN1ROW1] + normalZ * halfAxes[MATRIX3.COLUMN1ROW2]) + Math.abs(normalX * halfAxes[MATRIX3.COLUMN2ROW0] + normalY * halfAxes[MATRIX3.COLUMN2ROW1] + normalZ * halfAxes[MATRIX3.COLUMN2ROW2]);
    const distanceToPlane = normal.dot(center2) + plane.distance;
    if (distanceToPlane <= -radEffective) {
      return INTERSECTION.OUTSIDE;
    } else if (distanceToPlane >= radEffective) {
      return INTERSECTION.INSIDE;
    }
    return INTERSECTION.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(point2) {
    return Math.sqrt(this.distanceSquaredTo(point2));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(point2) {
    const offset = scratchOffset.from(point2).subtract(this.center);
    const halfAxes = this.halfAxes;
    const u2 = halfAxes.getColumn(0, scratchVectorU);
    const v2 = halfAxes.getColumn(1, scratchVectorV);
    const w2 = halfAxes.getColumn(2, scratchVectorW);
    const uHalf = u2.magnitude();
    const vHalf = v2.magnitude();
    const wHalf = w2.magnitude();
    u2.normalize();
    v2.normalize();
    w2.normalize();
    let distanceSquared = 0;
    let d2;
    d2 = Math.abs(offset.dot(u2)) - uHalf;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    d2 = Math.abs(offset.dot(v2)) - vHalf;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    d2 = Math.abs(offset.dot(w2)) - wHalf;
    if (d2 > 0) {
      distanceSquared += d2 * d2;
    }
    return distanceSquared;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(position, direction, result = [-0, -0]) {
    let minDist = Number.POSITIVE_INFINITY;
    let maxDist = Number.NEGATIVE_INFINITY;
    const center2 = this.center;
    const halfAxes = this.halfAxes;
    const u2 = halfAxes.getColumn(0, scratchVectorU);
    const v2 = halfAxes.getColumn(1, scratchVectorV);
    const w2 = halfAxes.getColumn(2, scratchVectorW);
    const corner = scratchCorner.copy(u2).add(v2).add(w2).add(center2);
    const toCenter = scratchToCenter.copy(corner).subtract(position);
    let mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    corner.copy(center2).add(u2).add(v2).subtract(w2);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    corner.copy(center2).add(u2).subtract(v2).add(w2);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    corner.copy(center2).add(u2).subtract(v2).subtract(w2);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center2.copy(corner).subtract(u2).add(v2).add(w2);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center2.copy(corner).subtract(u2).add(v2).subtract(w2);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center2.copy(corner).subtract(u2).subtract(v2).add(w2);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    center2.copy(corner).subtract(u2).subtract(v2).subtract(w2);
    toCenter.copy(corner).subtract(position);
    mag = direction.dot(toCenter);
    minDist = Math.min(mag, minDist);
    maxDist = Math.max(mag, maxDist);
    result[0] = minDist;
    result[1] = maxDist;
    return result;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(transformation) {
    this.center.transformAsPoint(transformation);
    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);
    xAxis.transformAsPoint(transformation);
    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);
    yAxis.transformAsPoint(transformation);
    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);
    zAxis.transformAsPoint(transformation);
    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);
    return this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
};

// node_modules/@math.gl/culling/dist/lib/plane.js
var scratchPosition = new Vector3();
var scratchNormal2 = new Vector3();
var Plane = class _Plane {
  constructor(normal = [0, 0, 1], distance3 = 0) {
    this.normal = new Vector3();
    this.distance = -0;
    this.fromNormalDistance(normal, distance3);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(normal, distance3) {
    assert3(Number.isFinite(distance3));
    this.normal.from(normal).normalize();
    this.distance = distance3;
    return this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(point2, normal) {
    point2 = scratchPosition.from(point2);
    this.normal.from(normal).normalize();
    const distance3 = -this.normal.dot(point2);
    this.distance = distance3;
    return this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(a3, b3, c2, d2) {
    this.normal.set(a3, b3, c2);
    assert3(equals(this.normal.len(), 1));
    this.distance = d2;
    return this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new _Plane(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(right) {
    return equals(this.distance, right.distance) && equals(this.normal, right.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(point2) {
    return this.normal.dot(point2) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(matrix4) {
    const normal = scratchNormal2.copy(this.normal).transformAsVector(matrix4).normalize();
    const point2 = this.normal.scale(-this.distance).transform(matrix4);
    return this.fromPointNormal(point2, normal);
  }
  projectPointOntoPlane(point2, result = [0, 0, 0]) {
    const scratchPoint2 = scratchPosition.from(point2);
    const pointDistance = this.getPointDistance(scratchPoint2);
    const scaledNormal = scratchNormal2.copy(this.normal).scale(pointDistance);
    return scratchPoint2.subtract(scaledNormal).to(result);
  }
};

// node_modules/@math.gl/culling/dist/lib/culling-volume.js
var faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];
var scratchPlaneCenter = new Vector3();
var scratchPlaneNormal = new Vector3();
var CullingVolume = class _CullingVolume {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor(planes = []) {
    this.planes = planes;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(boundingSphere) {
    this.planes.length = 2 * faces.length;
    const center2 = boundingSphere.center;
    const radius = boundingSphere.radius;
    let planeIndex = 0;
    for (const faceNormal of faces) {
      let plane0 = this.planes[planeIndex];
      let plane1 = this.planes[planeIndex + 1];
      if (!plane0) {
        plane0 = this.planes[planeIndex] = new Plane();
      }
      if (!plane1) {
        plane1 = this.planes[planeIndex + 1] = new Plane();
      }
      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center2);
      plane0.fromPointNormal(plane0Center, faceNormal);
      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center2);
      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();
      plane1.fromPointNormal(plane1Center, negatedFaceNormal);
      planeIndex += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(boundingVolume) {
    let intersect2 = INTERSECTION.INSIDE;
    for (const plane of this.planes) {
      const result = boundingVolume.intersectPlane(plane);
      switch (result) {
        case INTERSECTION.OUTSIDE:
          return INTERSECTION.OUTSIDE;
        case INTERSECTION.INTERSECTING:
          intersect2 = INTERSECTION.INTERSECTING;
          break;
        default:
      }
    }
    return intersect2;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(boundingVolume, parentPlaneMask) {
    assert3(Number.isFinite(parentPlaneMask), "parentPlaneMask is required.");
    if (parentPlaneMask === _CullingVolume.MASK_OUTSIDE || parentPlaneMask === _CullingVolume.MASK_INSIDE) {
      return parentPlaneMask;
    }
    let mask = _CullingVolume.MASK_INSIDE;
    const planes = this.planes;
    for (let k = 0; k < this.planes.length; ++k) {
      const flag = k < 31 ? 1 << k : 0;
      if (k < 31 && (parentPlaneMask & flag) === 0) {
        continue;
      }
      const plane = planes[k];
      const result = boundingVolume.intersectPlane(plane);
      if (result === INTERSECTION.OUTSIDE) {
        return _CullingVolume.MASK_OUTSIDE;
      } else if (result === INTERSECTION.INTERSECTING) {
        mask |= flag;
      }
    }
    return mask;
  }
};
CullingVolume.MASK_OUTSIDE = 4294967295;
CullingVolume.MASK_INSIDE = 0;
CullingVolume.MASK_INDETERMINATE = 2147483647;

// node_modules/@math.gl/culling/dist/lib/perspective-off-center-frustum.js
var scratchPlaneUpVector = new Vector3();
var scratchPlaneRightVector = new Vector3();
var scratchPlaneNearCenter = new Vector3();
var scratchPlaneFarCenter = new Vector3();
var scratchPlaneNormal2 = new Vector3();

// node_modules/@math.gl/culling/dist/lib/algorithms/bounding-sphere-from-points.js
var fromPointsXMin = new Vector3();
var fromPointsYMin = new Vector3();
var fromPointsZMin = new Vector3();
var fromPointsXMax = new Vector3();
var fromPointsYMax = new Vector3();
var fromPointsZMax = new Vector3();
var fromPointsCurrentPos = new Vector3();
var fromPointsScratch = new Vector3();
var fromPointsRitterCenter = new Vector3();
var fromPointsMinBoxPt = new Vector3();
var fromPointsMaxBoxPt = new Vector3();
var fromPointsNaiveCenterScratch = new Vector3();

// node_modules/@math.gl/culling/dist/lib/algorithms/compute-eigen-decomposition.js
var scratchMatrix = new Matrix3();
var scratchUnitary = new Matrix3();
var scratchDiagonal = new Matrix3();
var jMatrix = new Matrix3();
var jMatrixTranspose = new Matrix3();
function computeEigenDecomposition(matrix, result = {}) {
  const EIGEN_TOLERANCE = math_utils_exports.EPSILON20;
  const EIGEN_MAX_SWEEPS = 10;
  let count = 0;
  let sweep = 0;
  const unitaryMatrix = scratchUnitary;
  const diagonalMatrix = scratchDiagonal;
  unitaryMatrix.identity();
  diagonalMatrix.copy(matrix);
  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);
  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
    shurDecomposition(diagonalMatrix, jMatrix);
    jMatrixTranspose.copy(jMatrix).transpose();
    diagonalMatrix.multiplyRight(jMatrix);
    diagonalMatrix.multiplyLeft(jMatrixTranspose);
    unitaryMatrix.multiplyRight(jMatrix);
    if (++count > 2) {
      ++sweep;
      count = 0;
    }
  }
  result.unitary = unitaryMatrix.toTarget(result.unitary);
  result.diagonal = diagonalMatrix.toTarget(result.diagonal);
  return result;
}
function computeFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i = 0; i < 9; ++i) {
    const temp = matrix[i];
    norm += temp * temp;
  }
  return Math.sqrt(norm);
}
var rowVal = [1, 0, 0];
var colVal = [2, 2, 1];
function offDiagonalFrobeniusNorm(matrix) {
  let norm = 0;
  for (let i = 0; i < 3; ++i) {
    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];
    norm += 2 * temp * temp;
  }
  return Math.sqrt(norm);
}
function shurDecomposition(matrix, result) {
  const tolerance = math_utils_exports.EPSILON15;
  let maxDiagonal = 0;
  let rotAxis = 1;
  for (let i = 0; i < 3; ++i) {
    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);
    if (temp > maxDiagonal) {
      rotAxis = i;
      maxDiagonal = temp;
    }
  }
  const p = rowVal[rotAxis];
  const q = colVal[rotAxis];
  let c2 = 1;
  let s = 0;
  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {
    const qq = matrix[scratchMatrix.getElementIndex(q, q)];
    const pp = matrix[scratchMatrix.getElementIndex(p, p)];
    const qp = matrix[scratchMatrix.getElementIndex(q, p)];
    const tau = (qq - pp) / 2 / qp;
    let t;
    if (tau < 0) {
      t = -1 / (-tau + Math.sqrt(1 + tau * tau));
    } else {
      t = 1 / (tau + Math.sqrt(1 + tau * tau));
    }
    c2 = 1 / Math.sqrt(1 + t * t);
    s = t * c2;
  }
  Matrix3.IDENTITY.to(result);
  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c2;
  result[scratchMatrix.getElementIndex(q, p)] = s;
  result[scratchMatrix.getElementIndex(p, q)] = -s;
  return result;
}

// node_modules/@math.gl/culling/dist/lib/algorithms/bounding-box-from-points.js
var scratchVector23 = new Vector3();
var scratchVector32 = new Vector3();
var scratchVector4 = new Vector3();
var scratchVector5 = new Vector3();
var scratchVector6 = new Vector3();
var scratchCovarianceResult = new Matrix3();
var scratchEigenResult = {
  diagonal: new Matrix3(),
  unitary: new Matrix3()
};
function makeOrientedBoundingBoxFromPoints(positions, result = new OrientedBoundingBox()) {
  if (!positions || positions.length === 0) {
    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);
    result.center = new Vector3();
    return result;
  }
  const length5 = positions.length;
  const meanPoint = new Vector3(0, 0, 0);
  for (const position of positions) {
    meanPoint.add(position);
  }
  const invLength = 1 / length5;
  meanPoint.multiplyByScalar(invLength);
  let exx = 0;
  let exy = 0;
  let exz = 0;
  let eyy = 0;
  let eyz = 0;
  let ezz = 0;
  for (const position of positions) {
    const p = scratchVector23.copy(position).subtract(meanPoint);
    exx += p.x * p.x;
    exy += p.x * p.y;
    exz += p.x * p.z;
    eyy += p.y * p.y;
    eyz += p.y * p.z;
    ezz += p.z * p.z;
  }
  exx *= invLength;
  exy *= invLength;
  exz *= invLength;
  eyy *= invLength;
  eyz *= invLength;
  ezz *= invLength;
  const covarianceMatrix = scratchCovarianceResult;
  covarianceMatrix[0] = exx;
  covarianceMatrix[1] = exy;
  covarianceMatrix[2] = exz;
  covarianceMatrix[3] = exy;
  covarianceMatrix[4] = eyy;
  covarianceMatrix[5] = eyz;
  covarianceMatrix[6] = exz;
  covarianceMatrix[7] = eyz;
  covarianceMatrix[8] = ezz;
  const { unitary } = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);
  const rotation2 = result.halfAxes.copy(unitary);
  let v1 = rotation2.getColumn(0, scratchVector4);
  let v2 = rotation2.getColumn(1, scratchVector5);
  let v3 = rotation2.getColumn(2, scratchVector6);
  let u1 = -Number.MAX_VALUE;
  let u2 = -Number.MAX_VALUE;
  let u3 = -Number.MAX_VALUE;
  let l1 = Number.MAX_VALUE;
  let l2 = Number.MAX_VALUE;
  let l3 = Number.MAX_VALUE;
  for (const position of positions) {
    scratchVector23.copy(position);
    u1 = Math.max(scratchVector23.dot(v1), u1);
    u2 = Math.max(scratchVector23.dot(v2), u2);
    u3 = Math.max(scratchVector23.dot(v3), u3);
    l1 = Math.min(scratchVector23.dot(v1), l1);
    l2 = Math.min(scratchVector23.dot(v2), l2);
    l3 = Math.min(scratchVector23.dot(v3), l3);
  }
  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));
  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));
  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));
  result.center.copy(v1).add(v2).add(v3);
  const scale7 = scratchVector32.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);
  const scaleMatrix = new Matrix3([scale7[0], 0, 0, 0, scale7[1], 0, 0, 0, scale7[2]]);
  result.halfAxes.multiplyRight(scaleMatrix);
  return result;
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tile-2d-traversal.js
var TILE_SIZE2 = 512;
var MAX_MAPS = 3;
var REF_POINTS_5 = [
  [0.5, 0.5],
  [0, 0],
  [0, 1],
  [1, 0],
  [1, 1]
];
var REF_POINTS_9 = REF_POINTS_5.concat([
  [0, 0.5],
  [0.5, 0],
  [1, 0.5],
  [0.5, 1]
]);
var REF_POINTS_11 = REF_POINTS_9.concat([
  [0.25, 0.5],
  [0.75, 0.5]
]);
var OSMNode = class _OSMNode {
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  get children() {
    if (!this._children) {
      const x = this.x * 2;
      const y = this.y * 2;
      const z = this.z + 1;
      this._children = [
        new _OSMNode(x, y, z),
        new _OSMNode(x, y + 1, z),
        new _OSMNode(x + 1, y, z),
        new _OSMNode(x + 1, y + 1, z)
      ];
    }
    return this._children;
  }
  // eslint-disable-next-line complexity
  update(params) {
    const { viewport, cullingVolume: cullingVolume2, elevationBounds, minZ, maxZ, bounds, offset, project } = params;
    const boundingVolume = this.getBoundingVolume(elevationBounds, offset, project);
    if (bounds && !this.insideBounds(bounds)) {
      return false;
    }
    const isInside = cullingVolume2.computeVisibility(boundingVolume);
    if (isInside < 0) {
      return false;
    }
    if (!this.childVisible) {
      let { z } = this;
      if (z < maxZ && z >= minZ) {
        const distance3 = boundingVolume.distanceTo(viewport.cameraPosition) * viewport.scale / viewport.height;
        z += Math.floor(Math.log2(distance3));
      }
      if (z >= maxZ) {
        this.selected = true;
        return true;
      }
    }
    this.selected = false;
    this.childVisible = true;
    for (const child of this.children) {
      child.update(params);
    }
    return true;
  }
  getSelected(result = []) {
    if (this.selected) {
      result.push(this);
    }
    if (this._children) {
      for (const node of this._children) {
        node.getSelected(result);
      }
    }
    return result;
  }
  insideBounds([minX, minY, maxX, maxY]) {
    const scale7 = Math.pow(2, this.z);
    const extent = TILE_SIZE2 / scale7;
    return this.x * extent < maxX && this.y * extent < maxY && (this.x + 1) * extent > minX && (this.y + 1) * extent > minY;
  }
  getBoundingVolume(zRange, worldOffset, project) {
    if (project) {
      const refPoints = this.z < 1 ? REF_POINTS_11 : this.z < 2 ? REF_POINTS_9 : REF_POINTS_5;
      const refPointPositions = [];
      for (const p of refPoints) {
        const lngLat = osmTile2lngLat(this.x + p[0], this.y + p[1], this.z);
        lngLat[2] = zRange[0];
        refPointPositions.push(project(lngLat));
        if (zRange[0] !== zRange[1]) {
          lngLat[2] = zRange[1];
          refPointPositions.push(project(lngLat));
        }
      }
      return makeOrientedBoundingBoxFromPoints(refPointPositions);
    }
    const scale7 = Math.pow(2, this.z);
    const extent = TILE_SIZE2 / scale7;
    const originX = this.x * extent + worldOffset * TILE_SIZE2;
    const originY = TILE_SIZE2 - (this.y + 1) * extent;
    return new AxisAlignedBoundingBox([originX, originY, zRange[0]], [originX + extent, originY + extent, zRange[1]]);
  }
};
function getOSMTileIndices(viewport, maxZ, zRange, bounds) {
  const project = viewport instanceof globe_viewport_default && viewport.resolution ? (
    // eslint-disable-next-line @typescript-eslint/unbound-method
    viewport.projectPosition
  ) : null;
  const planes = Object.values(viewport.getFrustumPlanes()).map(({ normal, distance: distance3 }) => new Plane(normal.clone().negate(), distance3));
  const cullingVolume2 = new CullingVolume(planes);
  const unitsPerMeter = viewport.distanceScales.unitsPerMeter[2];
  const elevationMin = zRange && zRange[0] * unitsPerMeter || 0;
  const elevationMax = zRange && zRange[1] * unitsPerMeter || 0;
  const minZ = viewport instanceof web_mercator_viewport_default && viewport.pitch <= 60 ? maxZ : 0;
  if (bounds) {
    const [minLng, minLat, maxLng, maxLat] = bounds;
    const topLeft = lngLatToWorld([minLng, maxLat]);
    const bottomRight = lngLatToWorld([maxLng, minLat]);
    bounds = [topLeft[0], TILE_SIZE2 - topLeft[1], bottomRight[0], TILE_SIZE2 - bottomRight[1]];
  }
  const root = new OSMNode(0, 0, 0);
  const traversalParams = {
    viewport,
    project,
    cullingVolume: cullingVolume2,
    elevationBounds: [elevationMin, elevationMax],
    minZ,
    maxZ,
    bounds,
    // num. of worlds from the center. For repeated maps
    offset: 0
  };
  root.update(traversalParams);
  if (viewport instanceof web_mercator_viewport_default && viewport.subViewports && viewport.subViewports.length > 1) {
    traversalParams.offset = -1;
    while (root.update(traversalParams)) {
      if (--traversalParams.offset < -MAX_MAPS) {
        break;
      }
    }
    traversalParams.offset = 1;
    while (root.update(traversalParams)) {
      if (++traversalParams.offset > MAX_MAPS) {
        break;
      }
    }
  }
  return root.getSelected();
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/utils.js
var TILE_SIZE3 = 512;
var DEFAULT_EXTENT = [-Infinity, -Infinity, Infinity, Infinity];
var urlType = {
  type: "object",
  value: null,
  validate: (value, propType) => propType.optional && value === null || typeof value === "string" || Array.isArray(value) && value.every((url) => typeof url === "string"),
  equal: (value1, value2) => {
    if (value1 === value2) {
      return true;
    }
    if (!Array.isArray(value1) || !Array.isArray(value2)) {
      return false;
    }
    const len4 = value1.length;
    if (len4 !== value2.length) {
      return false;
    }
    for (let i = 0; i < len4; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }
    return true;
  }
};
function transformBox(bbox, modelMatrix2) {
  const transformedCoords = [
    // top-left
    modelMatrix2.transformAsPoint([bbox[0], bbox[1]]),
    // top-right
    modelMatrix2.transformAsPoint([bbox[2], bbox[1]]),
    // bottom-left
    modelMatrix2.transformAsPoint([bbox[0], bbox[3]]),
    // bottom-right
    modelMatrix2.transformAsPoint([bbox[2], bbox[3]])
  ];
  const transformedBox = [
    // Minimum x coord
    Math.min(...transformedCoords.map((i) => i[0])),
    // Minimum y coord
    Math.min(...transformedCoords.map((i) => i[1])),
    // Max x coord
    Math.max(...transformedCoords.map((i) => i[0])),
    // Max y coord
    Math.max(...transformedCoords.map((i) => i[1]))
  ];
  return transformedBox;
}
function stringHash(s) {
  return Math.abs(s.split("").reduce((a3, b3) => (a3 << 5) - a3 + b3.charCodeAt(0) | 0, 0));
}
function getURLFromTemplate(template, tile) {
  if (!template || !template.length) {
    return null;
  }
  const { index, id } = tile;
  if (Array.isArray(template)) {
    const i = stringHash(id) % template.length;
    template = template[i];
  }
  let url = template;
  for (const key of Object.keys(index)) {
    const regex = new RegExp(`{${key}}`, "g");
    url = url.replace(regex, String(index[key]));
  }
  if (Number.isInteger(index.y) && Number.isInteger(index.z)) {
    url = url.replace(/\{-y\}/g, String(Math.pow(2, index.z) - index.y - 1));
  }
  return url;
}
function getBoundingBox(viewport, zRange, extent) {
  let bounds;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({ z: minZ });
    const bounds1 = viewport.getBounds({ z: maxZ });
    bounds = [
      Math.min(bounds0[0], bounds1[0]),
      Math.min(bounds0[1], bounds1[1]),
      Math.max(bounds0[2], bounds1[2]),
      Math.max(bounds0[3], bounds1[3])
    ];
  } else {
    bounds = viewport.getBounds();
  }
  if (!viewport.isGeospatial) {
    return [
      // Top corner should not be more then bottom corner in either direction
      Math.max(Math.min(bounds[0], extent[2]), extent[0]),
      Math.max(Math.min(bounds[1], extent[3]), extent[1]),
      // Bottom corner should not be less then top corner in either direction
      Math.min(Math.max(bounds[2], extent[0]), extent[2]),
      Math.min(Math.max(bounds[3], extent[1]), extent[3])
    ];
  }
  return [
    Math.max(bounds[0], extent[0]),
    Math.max(bounds[1], extent[1]),
    Math.min(bounds[2], extent[2]),
    Math.min(bounds[3], extent[3])
  ];
}
function getCullBounds({ viewport, z, cullRect }) {
  const subViewports = viewport.subViewports || [viewport];
  return subViewports.map((v2) => getCullBoundsInViewport(v2, z || 0, cullRect));
}
function getCullBoundsInViewport(viewport, z, cullRect) {
  if (!Array.isArray(z)) {
    const x = cullRect.x - viewport.x;
    const y = cullRect.y - viewport.y;
    const { width, height } = cullRect;
    const unprojectOption = { targetZ: z };
    const topLeft = viewport.unproject([x, y], unprojectOption);
    const topRight = viewport.unproject([x + width, y], unprojectOption);
    const bottomLeft = viewport.unproject([x, y + height], unprojectOption);
    const bottomRight = viewport.unproject([x + width, y + height], unprojectOption);
    return [
      Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]),
      Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]),
      Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])
    ];
  }
  const bounds0 = getCullBoundsInViewport(viewport, z[0], cullRect);
  const bounds1 = getCullBoundsInViewport(viewport, z[1], cullRect);
  return [
    Math.min(bounds0[0], bounds1[0]),
    Math.min(bounds0[1], bounds1[1]),
    Math.max(bounds0[2], bounds1[2]),
    Math.max(bounds0[3], bounds1[3])
  ];
}
function getIndexingCoords(bbox, scale7, modelMatrixInverse) {
  if (modelMatrixInverse) {
    const transformedTileIndex = transformBox(bbox, modelMatrixInverse).map((i) => i * scale7 / TILE_SIZE3);
    return transformedTileIndex;
  }
  return bbox.map((i) => i * scale7 / TILE_SIZE3);
}
function getScale(z, tileSize) {
  return Math.pow(2, z) * TILE_SIZE3 / tileSize;
}
function osmTile2lngLat(x, y, z) {
  const scale7 = getScale(z, TILE_SIZE3);
  const lng = x / scale7 * 360 - 180;
  const n = Math.PI - 2 * Math.PI * y / scale7;
  const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  return [lng, lat];
}
function tile2XY(x, y, z, tileSize) {
  const scale7 = getScale(z, tileSize);
  return [x / scale7 * TILE_SIZE3, y / scale7 * TILE_SIZE3];
}
function tileToBoundingBox(viewport, x, y, z, tileSize = TILE_SIZE3) {
  if (viewport.isGeospatial) {
    const [west, north] = osmTile2lngLat(x, y, z);
    const [east, south] = osmTile2lngLat(x + 1, y + 1, z);
    return { west, north, east, south };
  }
  const [left, top] = tile2XY(x, y, z, tileSize);
  const [right, bottom] = tile2XY(x + 1, y + 1, z, tileSize);
  return { left, top, right, bottom };
}
function getIdentityTileIndices(viewport, z, tileSize, extent, modelMatrixInverse) {
  const bbox = getBoundingBox(viewport, null, extent);
  const scale7 = getScale(z, tileSize);
  const [minX, minY, maxX, maxY] = getIndexingCoords(bbox, scale7, modelMatrixInverse);
  const indices = [];
  for (let x = Math.floor(minX); x < maxX; x++) {
    for (let y = Math.floor(minY); y < maxY; y++) {
      indices.push({ x, y, z });
    }
  }
  return indices;
}
function getTileIndices({ viewport, maxZoom, minZoom, zRange, extent, tileSize = TILE_SIZE3, modelMatrix: modelMatrix2, modelMatrixInverse, zoomOffset = 0 }) {
  let z = viewport.isGeospatial ? Math.round(viewport.zoom + Math.log2(TILE_SIZE3 / tileSize)) + zoomOffset : Math.ceil(viewport.zoom) + zoomOffset;
  if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
    if (!extent) {
      return [];
    }
    z = minZoom;
  }
  if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
    z = maxZoom;
  }
  let transformedExtent = extent;
  if (modelMatrix2 && modelMatrixInverse && extent && !viewport.isGeospatial) {
    transformedExtent = transformBox(extent, modelMatrix2);
  }
  return viewport.isGeospatial ? getOSMTileIndices(viewport, z, zRange, extent) : getIdentityTileIndices(viewport, z, tileSize, transformedExtent || DEFAULT_EXTENT, modelMatrixInverse);
}
function isURLTemplate(s) {
  return /(?=.*{z})(?=.*{x})(?=.*({y}|{-y}))/.test(s);
}
function isGeoBoundingBox(v2) {
  return Number.isFinite(v2.west) && Number.isFinite(v2.north) && Number.isFinite(v2.east) && Number.isFinite(v2.south);
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/memoize.js
function memoize2(compute) {
  let cachedArgs = {};
  let cachedResult;
  return (args) => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }
    return cachedResult;
  };
}
function isEqual(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (Array.isArray(a3)) {
    const len4 = a3.length;
    if (!b3 || b3.length !== len4) {
      return false;
    }
    for (let i = 0; i < len4; i++) {
      if (a3[i] !== b3[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@deck.gl/geo-layers/dist/tileset-2d/tileset-2d.js
var TILE_STATE_VISITED = 1;
var TILE_STATE_VISIBLE = 2;
var STRATEGY_NEVER = "never";
var STRATEGY_REPLACE = "no-overlap";
var STRATEGY_DEFAULT = "best-available";
var DEFAULT_CACHE_SCALE = 5;
var STRATEGIES = {
  [STRATEGY_DEFAULT]: updateTileStateDefault,
  [STRATEGY_REPLACE]: updateTileStateReplace,
  [STRATEGY_NEVER]: () => {
  }
};
var DEFAULT_TILESET2D_PROPS = {
  extent: null,
  tileSize: 512,
  maxZoom: null,
  minZoom: null,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: "best-available",
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0,
  // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */
  // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  }
};
var Tileset2D = class {
  /**
   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.
   * Cache size defaults to 5 * number of tiles in the current viewport
   */
  constructor(opts) {
    this._getCullBounds = memoize2(getCullBounds);
    this.opts = { ...DEFAULT_TILESET2D_PROPS, ...opts };
    this.setOptions(this.opts);
    this.onTileLoad = (tile) => {
      var _a, _b;
      (_b = (_a = this.opts).onTileLoad) == null ? void 0 : _b.call(_a, tile);
      if (this.opts.maxCacheByteSize !== null) {
        this._cacheByteSize += tile.byteLength;
        this._resizeCache();
      }
    };
    this._requestScheduler = new RequestScheduler({
      throttleRequests: this.opts.maxRequests > 0 || this.opts.debounceTime > 0,
      maxRequests: this.opts.maxRequests,
      debounceTime: this.opts.debounceTime
    });
    this._cache = /* @__PURE__ */ new Map();
    this._tiles = [];
    this._dirty = false;
    this._cacheByteSize = 0;
    this._viewport = null;
    this._zRange = null;
    this._selectedTiles = null;
    this._frameNumber = 0;
    this._modelMatrix = new Matrix4();
    this._modelMatrixInverse = new Matrix4();
  }
  /* Public API */
  get tiles() {
    return this._tiles;
  }
  get selectedTiles() {
    return this._selectedTiles;
  }
  get isLoaded() {
    return this._selectedTiles !== null && this._selectedTiles.every((tile) => tile.isLoaded);
  }
  get needsReload() {
    return this._selectedTiles !== null && this._selectedTiles.some((tile) => tile.needsReload);
  }
  setOptions(opts) {
    Object.assign(this.opts, opts);
    if (Number.isFinite(opts.maxZoom)) {
      this._maxZoom = Math.floor(opts.maxZoom);
    }
    if (Number.isFinite(opts.minZoom)) {
      this._minZoom = Math.ceil(opts.minZoom);
    }
  }
  // Clean up any outstanding tile requests.
  finalize() {
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        tile.abort();
      }
    }
    this._cache.clear();
    this._tiles = [];
    this._selectedTiles = null;
  }
  reloadAll() {
    for (const id of this._cache.keys()) {
      const tile = this._cache.get(id);
      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {
        this._cache.delete(id);
      } else {
        tile.setNeedsReload();
      }
    }
  }
  /**
   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.
   */
  update(viewport, { zRange, modelMatrix: modelMatrix2 } = {
    zRange: null,
    modelMatrix: null
  }) {
    const modelMatrixAsMatrix4 = modelMatrix2 ? new Matrix4(modelMatrix2) : new Matrix4();
    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);
    if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {
      if (isModelMatrixNew) {
        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();
        this._modelMatrix = modelMatrixAsMatrix4;
      }
      this._viewport = viewport;
      this._zRange = zRange;
      const tileIndices = this.getTileIndices({
        viewport,
        maxZoom: this._maxZoom,
        minZoom: this._minZoom,
        zRange,
        modelMatrix: this._modelMatrix,
        modelMatrixInverse: this._modelMatrixInverse
      });
      this._selectedTiles = tileIndices.map((index) => this._getTile(index, true));
      if (this._dirty) {
        this._rebuildTree();
      }
    } else if (this.needsReload) {
      this._selectedTiles = this._selectedTiles.map((tile) => this._getTile(tile.index, true));
    }
    const changed = this.updateTileStates();
    this._pruneRequests();
    if (this._dirty) {
      this._resizeCache();
    }
    if (changed) {
      this._frameNumber++;
    }
    return this._frameNumber;
  }
  // eslint-disable-next-line complexity
  isTileVisible(tile, cullRect, modelMatrix2) {
    if (!tile.isVisible) {
      return false;
    }
    if (cullRect && this._viewport) {
      const boundsArr = this._getCullBounds({
        viewport: this._viewport,
        z: this._zRange,
        cullRect
      });
      let { bbox } = tile;
      for (const [minX, minY, maxX, maxY] of boundsArr) {
        let overlaps;
        if ("west" in bbox) {
          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;
        } else {
          if (modelMatrix2 && !Matrix4.IDENTITY.equals(modelMatrix2)) {
            const [left, top, right, bottom] = transformBox([bbox.left, bbox.top, bbox.right, bbox.bottom], modelMatrix2);
            bbox = { left, top, right, bottom };
          }
          const y0 = Math.min(bbox.top, bbox.bottom);
          const y1 = Math.max(bbox.top, bbox.bottom);
          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;
        }
        if (overlaps) {
          return true;
        }
      }
      return false;
    }
    return true;
  }
  /* Public interface for subclassing */
  /** Returns array of tile indices in the current viewport */
  getTileIndices({ viewport, maxZoom, minZoom, zRange, modelMatrix: modelMatrix2, modelMatrixInverse }) {
    const { tileSize, extent, zoomOffset } = this.opts;
    return getTileIndices({
      viewport,
      maxZoom,
      minZoom,
      zRange,
      tileSize,
      extent,
      modelMatrix: modelMatrix2,
      modelMatrixInverse,
      zoomOffset
    });
  }
  /** Returns unique string key for a tile index */
  getTileId(index) {
    return `${index.x}-${index.y}-${index.z}`;
  }
  /** Returns a zoom level for a tile index */
  getTileZoom(index) {
    return index.z;
  }
  /** Returns additional metadata to add to tile, bbox by default */
  getTileMetadata(index) {
    const { tileSize } = this.opts;
    return { bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize) };
  }
  /** Returns index of the parent tile */
  getParentIndex(index) {
    const x = Math.floor(index.x / 2);
    const y = Math.floor(index.y / 2);
    const z = index.z - 1;
    return { x, y, z };
  }
  // Returns true if any tile's visibility changed
  updateTileStates() {
    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;
    const visibilities = new Array(this._cache.size);
    let i = 0;
    for (const tile of this._cache.values()) {
      visibilities[i++] = tile.isVisible;
      tile.isSelected = false;
      tile.isVisible = false;
    }
    for (const tile of this._selectedTiles) {
      tile.isSelected = true;
      tile.isVisible = true;
    }
    (typeof refinementStrategy === "function" ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));
    i = 0;
    for (const tile of this._cache.values()) {
      if (visibilities[i++] !== tile.isVisible) {
        return true;
      }
    }
    return false;
  }
  _pruneRequests() {
    const { maxRequests = 0 } = this.opts;
    const abortCandidates = [];
    let ongoingRequestCount = 0;
    for (const tile of this._cache.values()) {
      if (tile.isLoading) {
        ongoingRequestCount++;
        if (!tile.isSelected && !tile.isVisible) {
          abortCandidates.push(tile);
        }
      }
    }
    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {
      const tile = abortCandidates.shift();
      tile.abort();
      ongoingRequestCount--;
    }
  }
  // This needs to be called every time some tiles have been added/removed from cache
  _rebuildTree() {
    const { _cache } = this;
    for (const tile of _cache.values()) {
      tile.parent = null;
      if (tile.children) {
        tile.children.length = 0;
      }
    }
    for (const tile of _cache.values()) {
      const parent = this._getNearestAncestor(tile);
      tile.parent = parent;
      if (parent == null ? void 0 : parent.children) {
        parent.children.push(tile);
      }
    }
  }
  /**
   * Clear tiles that are not visible when the cache is full
   */
  /* eslint-disable complexity */
  _resizeCache() {
    var _a, _b;
    const { _cache, opts } = this;
    const maxCacheSize = opts.maxCacheSize ?? // @ts-expect-error called only when selectedTiles is initialized
    (opts.maxCacheByteSize !== null ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);
    const maxCacheByteSize = opts.maxCacheByteSize ?? Infinity;
    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;
    if (overflown) {
      for (const [id, tile] of _cache) {
        if (!tile.isVisible && !tile.isSelected) {
          this._cacheByteSize -= opts.maxCacheByteSize !== null ? tile.byteLength : 0;
          _cache.delete(id);
          (_b = (_a = this.opts).onTileUnload) == null ? void 0 : _b.call(_a, tile);
        }
        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {
          break;
        }
      }
      this._rebuildTree();
      this._dirty = true;
    }
    if (this._dirty) {
      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);
      this._dirty = false;
    }
  }
  _getTile(index, create7) {
    const id = this.getTileId(index);
    let tile = this._cache.get(id);
    let needsReload = false;
    if (!tile && create7) {
      tile = new Tile2DHeader(index);
      Object.assign(tile, this.getTileMetadata(tile.index));
      Object.assign(tile, { id, zoom: this.getTileZoom(tile.index) });
      needsReload = true;
      this._cache.set(id, tile);
      this._dirty = true;
    } else if (tile && tile.needsReload) {
      needsReload = true;
    }
    if (tile && needsReload) {
      tile.loadData({
        getData: this.opts.getTileData,
        requestScheduler: this._requestScheduler,
        onLoad: this.onTileLoad,
        onError: this.opts.onTileError
      });
    }
    return tile;
  }
  _getNearestAncestor(tile) {
    const { _minZoom = 0 } = this;
    let index = tile.index;
    while (this.getTileZoom(index) > _minZoom) {
      index = this.getParentIndex(index);
      const parent = this._getTile(index);
      if (parent) {
        return parent;
      }
    }
    return null;
  }
};
function updateTileStateDefault(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {
      getPlaceholderInChildren(tile);
    }
  }
  for (const tile of allTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
  }
}
function updateTileStateReplace(allTiles) {
  for (const tile of allTiles) {
    tile.state = 0;
  }
  for (const tile of allTiles) {
    if (tile.isSelected) {
      getPlaceholderInAncestors(tile);
    }
  }
  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);
  for (const tile of sortedTiles) {
    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);
    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {
      for (const child of tile.children) {
        child.state = TILE_STATE_VISITED;
      }
    } else if (tile.isSelected) {
      getPlaceholderInChildren(tile);
    }
  }
}
function getPlaceholderInAncestors(startTile) {
  let tile = startTile;
  while (tile) {
    if (tile.isLoaded || tile.content) {
      tile.state |= TILE_STATE_VISIBLE;
      return true;
    }
    tile = tile.parent;
  }
  return false;
}
function getPlaceholderInChildren(tile) {
  for (const child of tile.children) {
    if (child.isLoaded || child.content) {
      child.state |= TILE_STATE_VISIBLE;
    } else {
      getPlaceholderInChildren(child);
    }
  }
}

// node_modules/@deck.gl/geo-layers/dist/tile-layer/tile-layer.js
var defaultProps7 = {
  TilesetClass: Tileset2D,
  data: { type: "data", value: [] },
  dataComparator: urlType.equal,
  renderSubLayers: { type: "function", value: (props) => new geojson_layer_default(props) },
  getTileData: { type: "function", optional: true, value: null },
  // TODO - change to onViewportLoad to align with Tile3DLayer
  onViewportLoad: { type: "function", optional: true, value: null },
  onTileLoad: { type: "function", value: (tile) => {
  } },
  onTileUnload: { type: "function", value: (tile) => {
  } },
  // eslint-disable-next-line
  onTileError: { type: "function", value: (err) => console.error(err) },
  extent: { type: "array", optional: true, value: null, compare: true },
  tileSize: 512,
  maxZoom: null,
  minZoom: 0,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: STRATEGY_DEFAULT,
  zRange: null,
  maxRequests: 6,
  debounceTime: 0,
  zoomOffset: 0
};
var TileLayer = class extends composite_layer_default {
  initializeState() {
    this.state = {
      tileset: null,
      isLoaded: false
    };
  }
  finalizeState() {
    var _a, _b;
    (_b = (_a = this.state) == null ? void 0 : _a.tileset) == null ? void 0 : _b.finalize();
  }
  get isLoaded() {
    var _a, _b, _c;
    return Boolean((_c = (_b = (_a = this.state) == null ? void 0 : _a.tileset) == null ? void 0 : _b.selectedTiles) == null ? void 0 : _c.every((tile) => tile.isLoaded && tile.layers && tile.layers.every((layer) => layer.isLoaded)));
  }
  shouldUpdateState({ changeFlags }) {
    return changeFlags.somethingChanged;
  }
  updateState({ changeFlags }) {
    let { tileset } = this.state;
    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;
    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);
    if (!tileset) {
      tileset = new this.props.TilesetClass(this._getTilesetOptions());
      this.setState({ tileset });
    } else if (propsChanged) {
      tileset.setOptions(this._getTilesetOptions());
      if (dataChanged) {
        tileset.reloadAll();
      } else {
        tileset.tiles.forEach((tile) => {
          tile.layers = null;
        });
      }
    }
    this._updateTileset();
  }
  _getTilesetOptions() {
    const { tileSize, maxCacheSize, maxCacheByteSize, refinementStrategy, extent, maxZoom, minZoom, maxRequests, debounceTime, zoomOffset } = this.props;
    return {
      maxCacheSize,
      maxCacheByteSize,
      maxZoom,
      minZoom,
      tileSize,
      refinementStrategy,
      extent,
      maxRequests,
      debounceTime,
      zoomOffset,
      getTileData: this.getTileData.bind(this),
      onTileLoad: this._onTileLoad.bind(this),
      onTileError: this._onTileError.bind(this),
      onTileUnload: this._onTileUnload.bind(this)
    };
  }
  _updateTileset() {
    const tileset = this.state.tileset;
    const { zRange, modelMatrix: modelMatrix2 } = this.props;
    const frameNumber = tileset.update(this.context.viewport, { zRange, modelMatrix: modelMatrix2 });
    const { isLoaded } = tileset;
    const loadingStateChanged = this.state.isLoaded !== isLoaded;
    const tilesetChanged = this.state.frameNumber !== frameNumber;
    if (isLoaded && (loadingStateChanged || tilesetChanged)) {
      this._onViewportLoad();
    }
    if (tilesetChanged) {
      this.setState({ frameNumber });
    }
    this.state.isLoaded = isLoaded;
  }
  _onViewportLoad() {
    const { tileset } = this.state;
    const { onViewportLoad } = this.props;
    if (onViewportLoad) {
      onViewportLoad(tileset.selectedTiles);
    }
  }
  _onTileLoad(tile) {
    this.props.onTileLoad(tile);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileError(error, tile) {
    this.props.onTileError(error);
    tile.layers = null;
    this.setNeedsUpdate();
  }
  _onTileUnload(tile) {
    this.props.onTileUnload(tile);
  }
  // Methods for subclass to override
  getTileData(tile) {
    const { data, getTileData, fetch: fetch2 } = this.props;
    const { signal } = tile;
    tile.url = typeof data === "string" || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;
    if (getTileData) {
      return getTileData(tile);
    }
    if (fetch2 && tile.url) {
      return fetch2(tile.url, { propName: "data", layer: this, signal });
    }
    return null;
  }
  renderSubLayers(props) {
    return this.props.renderSubLayers(props);
  }
  getSubLayerPropsByTile(tile) {
    return null;
  }
  getPickingInfo(params) {
    const sourceLayer = params.sourceLayer;
    const sourceTile = sourceLayer.props.tile;
    const info = params.info;
    if (info.picked) {
      info.tile = sourceTile;
    }
    info.sourceTile = sourceTile;
    info.sourceTileSubLayer = sourceLayer;
    return info;
  }
  _updateAutoHighlight(info) {
    info.sourceTileSubLayer.updateAutoHighlight(info);
  }
  renderLayers() {
    return this.state.tileset.tiles.map((tile) => {
      const subLayerProps = this.getSubLayerPropsByTile(tile);
      if (!tile.isLoaded && !tile.content) {
      } else if (!tile.layers) {
        const layers = this.renderSubLayers({
          ...this.props,
          ...this.getSubLayerProps({
            id: tile.id,
            updateTriggers: this.props.updateTriggers
          }),
          data: tile.content,
          _offset: 0,
          tile
        });
        tile.layers = flatten(layers, Boolean).map((layer) => layer.clone({
          tile,
          ...subLayerProps
        }));
      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some((propName) => tile.layers[0].props[propName] !== subLayerProps[propName])) {
        tile.layers = tile.layers.map((layer) => layer.clone(subLayerProps));
      }
      return tile.layers;
    });
  }
  filterSubLayer({ layer, cullRect }) {
    const { tile } = layer.props;
    const { modelMatrix: modelMatrix2 } = this.props;
    return this.state.tileset.isTileVisible(tile, cullRect, modelMatrix2 ? new Matrix4(modelMatrix2) : null);
  }
};
TileLayer.defaultProps = defaultProps7;
TileLayer.layerName = "TileLayer";
var tile_layer_default = TileLayer;

// node_modules/@deck.gl/geo-layers/dist/trips-layer/trips-layer-uniforms.js
var uniformBlock = `uniform tripsUniforms {
  bool fadeTrail;
  float trailLength;
  float currentTime;
} trips;
`;
var tripsUniforms = {
  name: "trips",
  vs: uniformBlock,
  fs: uniformBlock,
  uniformTypes: {
    fadeTrail: "f32",
    trailLength: "f32",
    currentTime: "f32"
  }
};

// node_modules/@deck.gl/geo-layers/dist/trips-layer/trips-layer.js
var defaultProps8 = {
  fadeTrail: true,
  trailLength: { type: "number", value: 120, min: 0 },
  currentTime: { type: "number", value: 0, min: 0 },
  getTimestamps: { type: "accessor", value: (d2) => d2.timestamps }
};
var TripsLayer = class extends path_layer_default {
  getShaders() {
    const shaders = super.getShaders();
    shaders.inject = {
      "vs:#decl": `in float instanceTimestamps;
in float instanceNextTimestamps;
out float vTime;
`,
      // Timestamp of the vertex
      "vs:#main-end": `vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;
`,
      "fs:#decl": `in float vTime;
`,
      // Drop the segments outside of the time window
      "fs:#main-start": `if(vTime > trips.currentTime || (trips.fadeTrail && (vTime < trips.currentTime - trips.trailLength))) {
  discard;
}
`,
      // Fade the color (currentTime - 100%, end of trail - 0%)
      "fs:DECKGL_FILTER_COLOR": `if(trips.fadeTrail) {
  color.a *= 1.0 - (trips.currentTime - vTime) / trips.trailLength;
}
`
    };
    shaders.modules = [...shaders.modules, tripsUniforms];
    return shaders;
  }
  initializeState() {
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      timestamps: {
        size: 1,
        accessor: "getTimestamps",
        shaderAttributes: {
          instanceTimestamps: {
            vertexOffset: 0
          },
          instanceNextTimestamps: {
            vertexOffset: 1
          }
        }
      }
    });
  }
  draw(params) {
    const { fadeTrail, trailLength, currentTime } = this.props;
    const tripsProps = { fadeTrail, trailLength, currentTime };
    const model = this.state.model;
    model.shaderInputs.setProps({ trips: tripsProps });
    super.draw(params);
  }
};
TripsLayer.layerName = "TripsLayer";
TripsLayer.defaultProps = defaultProps8;
var trips_layer_default = TripsLayer;

// node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-hexagon-layer.js
var UPDATE_THRESHOLD_KM = 10;
function mergeTriggers(getHexagon, coverage) {
  let trigger;
  if (getHexagon === void 0 || getHexagon === null) {
    trigger = coverage;
  } else if (typeof getHexagon === "object") {
    trigger = { ...getHexagon, coverage };
  } else {
    trigger = { getHexagon, coverage };
  }
  return trigger;
}
var defaultProps9 = {
  ...polygon_layer_default.defaultProps,
  highPrecision: "auto",
  coverage: { type: "number", min: 0, max: 1, value: 1 },
  centerHexagon: null,
  getHexagon: { type: "accessor", value: (x) => x.hexagon },
  extruded: true
};
var H3HexagonLayer = class _H3HexagonLayer extends composite_layer_default {
  initializeState() {
    _H3HexagonLayer._checkH3Lib();
    this.state = {
      edgeLengthKM: 0,
      resolution: -1
    };
  }
  shouldUpdateState({ changeFlags }) {
    return this._shouldUseHighPrecision() ? changeFlags.propsOrDataChanged : changeFlags.somethingChanged;
  }
  updateState({ props, changeFlags }) {
    if (props.highPrecision !== true && (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagon)) {
      const dataProps = this._calculateH3DataProps();
      this.setState(dataProps);
    }
    this._updateVertices(this.context.viewport);
  }
  _calculateH3DataProps() {
    let resolution = -1;
    let hasPentagon = false;
    let hasMultipleRes = false;
    const { iterable, objectInfo } = createIterable(this.props.data);
    for (const object of iterable) {
      objectInfo.index++;
      const hexId = this.props.getHexagon(object, objectInfo);
      const hexResolution = getResolution2(hexId);
      if (resolution < 0) {
        resolution = hexResolution;
        if (!this.props.highPrecision)
          break;
      } else if (resolution !== hexResolution) {
        hasMultipleRes = true;
        break;
      }
      if (isPentagon(hexId)) {
        hasPentagon = true;
        break;
      }
    }
    return {
      resolution,
      edgeLengthKM: resolution >= 0 ? getHexagonEdgeLengthAvg(resolution, "km") : 0,
      hasMultipleRes,
      hasPentagon
    };
  }
  _shouldUseHighPrecision() {
    if (this.props.highPrecision === "auto") {
      const { resolution, hasPentagon, hasMultipleRes } = this.state;
      const { viewport } = this.context;
      return Boolean(viewport == null ? void 0 : viewport.resolution) || hasMultipleRes || hasPentagon || resolution >= 0 && resolution <= 5;
    }
    return this.props.highPrecision;
  }
  _updateVertices(viewport) {
    if (this._shouldUseHighPrecision()) {
      return;
    }
    const { resolution, edgeLengthKM, centerHex } = this.state;
    if (resolution < 0) {
      return;
    }
    const hex = this.props.centerHexagon || latLngToCell(viewport.latitude, viewport.longitude, resolution);
    if (centerHex === hex) {
      return;
    }
    if (centerHex) {
      try {
        const distance3 = gridDistance(centerHex, hex);
        if (distance3 * edgeLengthKM < UPDATE_THRESHOLD_KM) {
          return;
        }
      } catch {
      }
    }
    const { unitsPerMeter } = viewport.distanceScales;
    let vertices = h3ToPolygon(hex);
    const [centerLat, centerLng] = cellToLatLng(hex);
    const [centerX, centerY] = viewport.projectFlat([centerLng, centerLat]);
    vertices = vertices.map((p) => {
      const worldPosition = viewport.projectFlat(p);
      return [
        (worldPosition[0] - centerX) / unitsPerMeter[0],
        (worldPosition[1] - centerY) / unitsPerMeter[1]
      ];
    });
    this.setState({ centerHex: hex, vertices });
  }
  renderLayers() {
    return this._shouldUseHighPrecision() ? this._renderPolygonLayer() : this._renderColumnLayer();
  }
  _getForwardProps() {
    const { elevationScale, material, coverage, extruded, wireframe, stroked, filled, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, getFillColor, getElevation, getLineColor, getLineWidth, transitions, updateTriggers } = this.props;
    return {
      elevationScale,
      extruded,
      coverage,
      wireframe,
      stroked,
      filled,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      material,
      getElevation,
      getFillColor,
      getLineColor,
      getLineWidth,
      transitions,
      updateTriggers: {
        getFillColor: updateTriggers.getFillColor,
        getElevation: updateTriggers.getElevation,
        getLineColor: updateTriggers.getLineColor,
        getLineWidth: updateTriggers.getLineWidth
      }
    };
  }
  _renderPolygonLayer() {
    const { data, getHexagon, updateTriggers, coverage } = this.props;
    const SubLayerClass = this.getSubLayerClass("hexagon-cell-hifi", polygon_layer_default);
    const forwardProps = this._getForwardProps();
    forwardProps.updateTriggers.getPolygon = mergeTriggers(updateTriggers.getHexagon, coverage);
    return new SubLayerClass(forwardProps, this.getSubLayerProps({
      id: "hexagon-cell-hifi",
      updateTriggers: forwardProps.updateTriggers
    }), {
      data,
      _normalize: false,
      _windingOrder: "CCW",
      positionFormat: "XY",
      getPolygon: (object, objectInfo) => {
        const hexagonId = getHexagon(object, objectInfo);
        return flattenPolygon(h3ToPolygon(hexagonId, coverage));
      }
    });
  }
  _renderColumnLayer() {
    const { data, getHexagon, updateTriggers } = this.props;
    const SubLayerClass = this.getSubLayerClass("hexagon-cell", column_layer_default);
    const forwardProps = this._getForwardProps();
    forwardProps.updateTriggers.getPosition = updateTriggers.getHexagon;
    return new SubLayerClass(forwardProps, this.getSubLayerProps({
      id: "hexagon-cell",
      flatShading: true,
      updateTriggers: forwardProps.updateTriggers
    }), {
      data,
      diskResolution: 6,
      // generate an extruded hexagon as the base geometry
      radius: 1,
      vertices: this.state.vertices,
      getPosition: getHexagonCentroid.bind(null, getHexagon)
    });
  }
};
H3HexagonLayer.defaultProps = defaultProps9;
H3HexagonLayer.layerName = "H3HexagonLayer";
H3HexagonLayer._checkH3Lib = () => {
};
var h3_hexagon_layer_default = H3HexagonLayer;

// node_modules/@deck.gl/geo-layers/dist/h3-layers/h3-cluster-layer.js
var defaultProps10 = {
  getHexagons: { type: "accessor", value: (d2) => d2.hexagons }
};
var H3ClusterLayer = class extends GeoCellLayer_default {
  initializeState() {
    h3_hexagon_layer_default._checkH3Lib();
  }
  updateState({ props, changeFlags }) {
    if (changeFlags.dataChanged || changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getHexagons) {
      const { data, getHexagons } = props;
      const polygons = [];
      const { iterable, objectInfo } = createIterable(data);
      for (const object of iterable) {
        objectInfo.index++;
        const hexagons = getHexagons(object, objectInfo);
        const multiPolygon = cellsToMultiPolygon(hexagons, true);
        for (const polygon of multiPolygon) {
          for (const ring of polygon) {
            normalizeLongitudes2(ring);
          }
          polygons.push(this.getSubLayerRow({ polygon }, object, objectInfo.index));
        }
      }
      this.setState({ polygons });
    }
  }
  indexToBounds() {
    const { getElevation, getFillColor, getLineColor, getLineWidth } = this.props;
    return {
      data: this.state.polygons,
      getPolygon: (d2) => d2.polygon,
      getElevation: this.getSubLayerAccessor(getElevation),
      getFillColor: this.getSubLayerAccessor(getFillColor),
      getLineColor: this.getSubLayerAccessor(getLineColor),
      getLineWidth: this.getSubLayerAccessor(getLineWidth)
    };
  }
};
H3ClusterLayer.layerName = "H3ClusterLayer";
H3ClusterLayer.defaultProps = defaultProps10;
var h3_cluster_layer_default = H3ClusterLayer;

// node_modules/@deck.gl/mesh-layers/dist/utils/matrix.js
var RADIAN_PER_DEGREE = Math.PI / 180;
var modelMatrix = new Float32Array(16);
var valueArray = new Float32Array(12);
function calculateTransformMatrix(targetMatrix, orientation, scale7) {
  const pitch = orientation[0] * RADIAN_PER_DEGREE;
  const yaw = orientation[1] * RADIAN_PER_DEGREE;
  const roll = orientation[2] * RADIAN_PER_DEGREE;
  const sr = Math.sin(roll);
  const sp = Math.sin(pitch);
  const sw = Math.sin(yaw);
  const cr = Math.cos(roll);
  const cp = Math.cos(pitch);
  const cw = Math.cos(yaw);
  const scx = scale7[0];
  const scy = scale7[1];
  const scz = scale7[2];
  targetMatrix[0] = scx * cw * cp;
  targetMatrix[1] = scx * sw * cp;
  targetMatrix[2] = scx * -sp;
  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr);
  targetMatrix[4] = scy * (cw * cr + sw * sp * sr);
  targetMatrix[5] = scy * cp * sr;
  targetMatrix[6] = scz * (sw * sr + cw * sp * cr);
  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr);
  targetMatrix[8] = scz * cp * cr;
}
function getExtendedMat3FromMat4(mat4) {
  mat4[0] = mat4[0];
  mat4[1] = mat4[1];
  mat4[2] = mat4[2];
  mat4[3] = mat4[4];
  mat4[4] = mat4[5];
  mat4[5] = mat4[6];
  mat4[6] = mat4[8];
  mat4[7] = mat4[9];
  mat4[8] = mat4[10];
  mat4[9] = mat4[12];
  mat4[10] = mat4[13];
  mat4[11] = mat4[14];
  return mat4.subarray(0, 12);
}
var MATRIX_ATTRIBUTES = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(attribute, { startRow, endRow }) {
    const { data, getOrientation, getScale: getScale2, getTranslation, getTransformMatrix } = this.props;
    const arrayMatrix = Array.isArray(getTransformMatrix);
    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;
    const constantScale = Array.isArray(getScale2);
    const constantOrientation = Array.isArray(getOrientation);
    const constantTranslation = Array.isArray(getTranslation);
    const hasMatrix = constantMatrix || !arrayMatrix && Boolean(getTransformMatrix(data[0]));
    if (hasMatrix) {
      attribute.constant = constantMatrix;
    } else {
      attribute.constant = constantOrientation && constantScale && constantTranslation;
    }
    const instanceModelMatrixData = attribute.value;
    if (attribute.constant) {
      let matrix;
      if (hasMatrix) {
        modelMatrix.set(getTransformMatrix);
        matrix = getExtendedMat3FromMat4(modelMatrix);
      } else {
        matrix = valueArray;
        const orientation = getOrientation;
        const scale7 = getScale2;
        calculateTransformMatrix(matrix, orientation, scale7);
        matrix.set(getTranslation, 9);
      }
      attribute.value = new Float32Array(matrix);
    } else {
      let i = startRow * attribute.size;
      const { iterable, objectInfo } = createIterable(data, startRow, endRow);
      for (const object of iterable) {
        objectInfo.index++;
        let matrix;
        if (hasMatrix) {
          modelMatrix.set(constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo));
          matrix = getExtendedMat3FromMat4(modelMatrix);
        } else {
          matrix = valueArray;
          const orientation = constantOrientation ? getOrientation : getOrientation(object, objectInfo);
          const scale7 = constantScale ? getScale2 : getScale2(object, objectInfo);
          calculateTransformMatrix(matrix, orientation, scale7);
          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);
        }
        instanceModelMatrixData[i++] = matrix[0];
        instanceModelMatrixData[i++] = matrix[1];
        instanceModelMatrixData[i++] = matrix[2];
        instanceModelMatrixData[i++] = matrix[3];
        instanceModelMatrixData[i++] = matrix[4];
        instanceModelMatrixData[i++] = matrix[5];
        instanceModelMatrixData[i++] = matrix[6];
        instanceModelMatrixData[i++] = matrix[7];
        instanceModelMatrixData[i++] = matrix[8];
        instanceModelMatrixData[i++] = matrix[9];
        instanceModelMatrixData[i++] = matrix[10];
        instanceModelMatrixData[i++] = matrix[11];
      }
    }
  }
};
function shouldComposeModelMatrix(viewport, coordinateSystem) {
  return coordinateSystem === COORDINATE_SYSTEM.CARTESIAN || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial;
}

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer-uniforms.js
var uniformBlock2 = `uniform simpleMeshUniforms {
  float sizeScale;
  bool composeModelMatrix;
  bool hasTexture;
  bool flatShading;
} simpleMesh;
`;
var simpleMeshUniforms = {
  name: "simpleMesh",
  vs: uniformBlock2,
  fs: uniformBlock2,
  uniformTypes: {
    sizeScale: "f32",
    composeModelMatrix: "f32",
    hasTexture: "f32",
    flatShading: "f32"
  }
};

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer-vertex.glsl.js
var simple_mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;
if (simpleMesh.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer-fragment.glsl.js
var simple_mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/simple-mesh-layer/simple-mesh-layer.js
function normalizeGeometryAttributes(attributes) {
  const positionAttribute = attributes.positions || attributes.POSITION;
  log_default.assert(positionAttribute, 'no "postions" or "POSITION" attribute in mesh');
  const vertexCount = positionAttribute.value.length / positionAttribute.size;
  let colorAttribute = attributes.COLOR_0 || attributes.colors;
  if (!colorAttribute) {
    colorAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(1) };
  }
  let normalAttribute = attributes.NORMAL || attributes.normals;
  if (!normalAttribute) {
    normalAttribute = { size: 3, value: new Float32Array(vertexCount * 3).fill(0) };
  }
  let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;
  if (!texCoordAttribute) {
    texCoordAttribute = { size: 2, value: new Float32Array(vertexCount * 2).fill(0) };
  }
  return {
    positions: positionAttribute,
    colors: colorAttribute,
    normals: normalAttribute,
    texCoords: texCoordAttribute
  };
}
function getGeometry(data) {
  if (data instanceof Geometry) {
    data.attributes = normalizeGeometryAttributes(data.attributes);
    return data;
  } else if (data.attributes) {
    return new Geometry({
      ...data,
      topology: "triangle-list",
      attributes: normalizeGeometryAttributes(data.attributes)
    });
  } else {
    return new Geometry({
      topology: "triangle-list",
      attributes: normalizeGeometryAttributes(data)
    });
  }
}
var DEFAULT_COLOR = [0, 0, 0, 255];
var defaultProps11 = {
  mesh: { type: "object", value: null, async: true },
  texture: { type: "image", value: null, async: true },
  sizeScale: { type: "number", value: 1, min: 0 },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: true,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: false,
  // Optional material for 'lighting' shader module
  material: true,
  getPosition: { type: "accessor", value: (x) => x.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  textureParameters: { type: "object", ignore: true, value: null }
};
var SimpleMeshLayer = class extends layer_default {
  getShaders() {
    return super.getShaders({
      vs: simple_mesh_layer_vertex_glsl_default,
      fs: simple_mesh_layer_fragment_glsl_default,
      modules: [project32_default, phongMaterial, picking_default, simpleMeshUniforms]
    });
  }
  getBounds() {
    var _a;
    if (this.props._instanced) {
      return super.getBounds();
    }
    let result = this.state.positionBounds;
    if (result) {
      return result;
    }
    const { mesh } = this.props;
    if (!mesh) {
      return null;
    }
    result = (_a = mesh.header) == null ? void 0 : _a.boundingBox;
    if (!result) {
      const { attributes } = getGeometry(mesh);
      attributes.POSITION = attributes.POSITION || attributes.positions;
      result = getMeshBoundingBox(attributes);
    }
    this.state.positionBounds = result;
    return result;
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        transition: true,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: true,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
    this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(params) {
    var _a;
    super.updateState(params);
    const { props, oldProps, changeFlags } = params;
    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {
      this.state.positionBounds = null;
      (_a = this.state.model) == null ? void 0 : _a.destroy();
      if (props.mesh) {
        this.state.model = this.getModel(props.mesh);
        const attributes = props.mesh.attributes || props.mesh;
        this.setState({
          hasNormals: Boolean(attributes.NORMAL || attributes.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    if (props.texture !== oldProps.texture && props.texture instanceof Texture) {
      this.setTexture(props.texture);
    }
    if (this.state.model) {
      this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
    }
  }
  finalizeState(context) {
    super.finalizeState(context);
    this.state.emptyTexture.delete();
  }
  draw({ uniforms }) {
    const { model } = this.state;
    if (!model) {
      return;
    }
    const { viewport, renderPass } = this.context;
    const { sizeScale, coordinateSystem, _instanced } = this.props;
    const simpleMeshProps = {
      sizeScale,
      composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),
      flatShading: !this.state.hasNormals
    };
    model.shaderInputs.setProps({ simpleMesh: simpleMeshProps });
    model.draw(renderPass);
  }
  get isLoaded() {
    var _a;
    return Boolean(((_a = this.state) == null ? void 0 : _a.model) && super.isLoaded);
  }
  getModel(mesh) {
    const model = new Model(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: getGeometry(mesh),
      isInstanced: true
    });
    const { texture } = this.props;
    const { emptyTexture } = this.state;
    const simpleMeshProps = {
      sampler: texture || emptyTexture,
      hasTexture: Boolean(texture)
    };
    model.shaderInputs.setProps({ simpleMesh: simpleMeshProps });
    return model;
  }
  setTexture(texture) {
    const { emptyTexture, model } = this.state;
    if (model) {
      const simpleMeshProps = {
        sampler: texture || emptyTexture,
        hasTexture: Boolean(texture)
      };
      model.shaderInputs.setProps({ simpleMesh: simpleMeshProps });
    }
  }
};
SimpleMeshLayer.defaultProps = defaultProps11;
SimpleMeshLayer.layerName = "SimpleMeshLayer";
var simple_mesh_layer_default = SimpleMeshLayer;

// node_modules/@loaders.gl/textures/dist/lib/utils/version.js
var VERSION4 = true ? "4.3.3" : "latest";

// node_modules/@loaders.gl/textures/dist/lib/parsers/basis-module-loader.js
var BASIS_EXTERNAL_LIBRARIES = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
var loadBasisTranscoderPromise;
async function loadBasisTranscoderModule(options) {
  registerJSModules(options.modules);
  const basis = getJSModuleOrNull("basis");
  if (basis) {
    return basis;
  }
  loadBasisTranscoderPromise || (loadBasisTranscoderPromise = loadBasisTranscoder(options));
  return await loadBasisTranscoderPromise;
}
async function loadBasisTranscoder(options) {
  let BASIS2 = null;
  let wasmBinary = null;
  [BASIS2, wasmBinary] = await Promise.all([
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER, "textures", options),
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.TRANSCODER_WASM, "textures", options)
  ]);
  BASIS2 = BASIS2 || globalThis.BASIS;
  return await initializeBasisTranscoderModule(BASIS2, wasmBinary);
}
function initializeBasisTranscoderModule(BasisModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    BasisModule(options).then((module) => {
      const { BasisFile, initializeBasis } = module;
      initializeBasis();
      resolve({ BasisFile });
    });
  });
}
var loadBasisEncoderPromise;
async function loadBasisEncoderModule(options) {
  const modules = options.modules || {};
  if (modules.basisEncoder) {
    return modules.basisEncoder;
  }
  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);
  return await loadBasisEncoderPromise;
}
async function loadBasisEncoder(options) {
  let BASIS_ENCODER = null;
  let wasmBinary = null;
  [BASIS_ENCODER, wasmBinary] = await Promise.all([
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER, "textures", options),
    await loadLibrary(BASIS_EXTERNAL_LIBRARIES.ENCODER_WASM, "textures", options)
  ]);
  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;
  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);
}
function initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    BasisEncoderModule(options).then((module) => {
      const { BasisFile, KTX2File, initializeBasis, BasisEncoder } = module;
      initializeBasis();
      resolve({ BasisFile, KTX2File, BasisEncoder });
    });
  });
}

// node_modules/@loaders.gl/textures/dist/lib/gl-extensions.js
var GL_EXTENSIONS_CONSTANTS = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_es3
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_RGBA8_ETC2_EAC: 37493,
  COMPRESSED_SRGB8_ETC2: 37494,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_atc
  COMPRESSED_RGB_ATC_WEBGL: 35986,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
  // EXT_texture_compression_rgtc
  COMPRESSED_RED_RGTC1_EXT: 36283,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
  // WEBGL_compressed_texture_s3tc_srgb
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
};

// node_modules/@loaders.gl/textures/dist/lib/utils/texture-formats.js
var BROWSER_PREFIXES = ["", "WEBKIT_", "MOZ_"];
var WEBGL_EXTENSIONS = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
var formats = null;
function getSupportedGPUTextureFormats(gl) {
  if (!formats) {
    gl = gl || getWebGLContext() || void 0;
    formats = /* @__PURE__ */ new Set();
    for (const prefix of BROWSER_PREFIXES) {
      for (const extension in WEBGL_EXTENSIONS) {
        if (gl && gl.getExtension(`${prefix}${extension}`)) {
          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];
          formats.add(gpuTextureFormat);
        }
      }
    }
  }
  return formats;
}
function getWebGLContext() {
  try {
    const canvas = document.createElement("canvas");
    return canvas.getContext("webgl");
  } catch (error) {
    return null;
  }
}

// node_modules/ktx-parse/dist/ktx-parse.modern.js
var KHR_SUPERCOMPRESSION_NONE = 0;
var KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0;
var KHR_DF_VENDORID_KHRONOS = 0;
var KHR_DF_VERSION = 2;
var KHR_DF_MODEL_UNSPECIFIED = 0;
var KHR_DF_FLAG_ALPHA_STRAIGHT = 0;
var KHR_DF_TRANSFER_SRGB = 2;
var KHR_DF_PRIMARIES_BT709 = 1;
var KHR_DF_SAMPLE_DATATYPE_SIGNED = 64;
var VK_FORMAT_UNDEFINED = 0;
var KTX2Container = class {
  constructor() {
    this.vkFormat = VK_FORMAT_UNDEFINED;
    this.typeSize = 1;
    this.pixelWidth = 0;
    this.pixelHeight = 0;
    this.pixelDepth = 0;
    this.layerCount = 0;
    this.faceCount = 1;
    this.supercompressionScheme = KHR_SUPERCOMPRESSION_NONE;
    this.levels = [];
    this.dataFormatDescriptor = [{
      vendorId: KHR_DF_VENDORID_KHRONOS,
      descriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,
      descriptorBlockSize: 0,
      versionNumber: KHR_DF_VERSION,
      colorModel: KHR_DF_MODEL_UNSPECIFIED,
      colorPrimaries: KHR_DF_PRIMARIES_BT709,
      transferFunction: KHR_DF_TRANSFER_SRGB,
      flags: KHR_DF_FLAG_ALPHA_STRAIGHT,
      texelBlockDimension: [0, 0, 0, 0],
      bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
      samples: []
    }];
    this.keyValue = {};
    this.globalData = null;
  }
};
var BufferReader = class {
  constructor(data, byteOffset, byteLength, littleEndian) {
    this._dataView = void 0;
    this._littleEndian = void 0;
    this._offset = void 0;
    this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);
    this._littleEndian = littleEndian;
    this._offset = 0;
  }
  _nextUint8() {
    const value = this._dataView.getUint8(this._offset);
    this._offset += 1;
    return value;
  }
  _nextUint16() {
    const value = this._dataView.getUint16(this._offset, this._littleEndian);
    this._offset += 2;
    return value;
  }
  _nextUint32() {
    const value = this._dataView.getUint32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  }
  _nextUint64() {
    const left = this._dataView.getUint32(this._offset, this._littleEndian);
    const right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
    const value = left + 2 ** 32 * right;
    this._offset += 8;
    return value;
  }
  _nextInt32() {
    const value = this._dataView.getInt32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  }
  _nextUint8Array(len4) {
    const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, len4);
    this._offset += len4;
    return value;
  }
  _skip(bytes) {
    this._offset += bytes;
    return this;
  }
  _scan(maxByteLength, term = 0) {
    const byteOffset = this._offset;
    let byteLength = 0;
    while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {
      byteLength++;
      this._offset++;
    }
    if (byteLength < maxByteLength) this._offset++;
    return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
  }
};
var NUL = new Uint8Array([0]);
var KTX2_ID = [
  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function decodeText(buffer) {
  return new TextDecoder().decode(buffer);
}
function read(data) {
  const id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);
  if (id[0] !== KTX2_ID[0] || // '´'
  id[1] !== KTX2_ID[1] || // 'K'
  id[2] !== KTX2_ID[2] || // 'T'
  id[3] !== KTX2_ID[3] || // 'X'
  id[4] !== KTX2_ID[4] || // ' '
  id[5] !== KTX2_ID[5] || // '2'
  id[6] !== KTX2_ID[6] || // '0'
  id[7] !== KTX2_ID[7] || // 'ª'
  id[8] !== KTX2_ID[8] || // '\r'
  id[9] !== KTX2_ID[9] || // '\n'
  id[10] !== KTX2_ID[10] || // '\x1A'
  id[11] !== KTX2_ID[11]) {
    throw new Error("Missing KTX 2.0 identifier.");
  }
  const container = new KTX2Container();
  const headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;
  const headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);
  container.vkFormat = headerReader._nextUint32();
  container.typeSize = headerReader._nextUint32();
  container.pixelWidth = headerReader._nextUint32();
  container.pixelHeight = headerReader._nextUint32();
  container.pixelDepth = headerReader._nextUint32();
  container.layerCount = headerReader._nextUint32();
  container.faceCount = headerReader._nextUint32();
  const levelCount = headerReader._nextUint32();
  container.supercompressionScheme = headerReader._nextUint32();
  const dfdByteOffset = headerReader._nextUint32();
  const dfdByteLength = headerReader._nextUint32();
  const kvdByteOffset = headerReader._nextUint32();
  const kvdByteLength = headerReader._nextUint32();
  const sgdByteOffset = headerReader._nextUint64();
  const sgdByteLength = headerReader._nextUint64();
  const levelByteLength = levelCount * 3 * 8;
  const levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);
  for (let i = 0; i < levelCount; i++) {
    container.levels.push({
      levelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),
      uncompressedByteLength: levelReader._nextUint64()
    });
  }
  const dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);
  const dfd = {
    vendorId: dfdReader._skip(
      4
      /* totalSize */
    )._nextUint16(),
    descriptorType: dfdReader._nextUint16(),
    versionNumber: dfdReader._nextUint16(),
    descriptorBlockSize: dfdReader._nextUint16(),
    colorModel: dfdReader._nextUint8(),
    colorPrimaries: dfdReader._nextUint8(),
    transferFunction: dfdReader._nextUint8(),
    flags: dfdReader._nextUint8(),
    texelBlockDimension: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
    bytesPlane: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
    samples: []
  };
  const sampleStart = 6;
  const sampleWords = 4;
  const numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;
  for (let i = 0; i < numSamples; i++) {
    const sample = {
      bitOffset: dfdReader._nextUint16(),
      bitLength: dfdReader._nextUint8(),
      channelType: dfdReader._nextUint8(),
      samplePosition: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
      sampleLower: -Infinity,
      sampleUpper: Infinity
    };
    if (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {
      sample.sampleLower = dfdReader._nextInt32();
      sample.sampleUpper = dfdReader._nextInt32();
    } else {
      sample.sampleLower = dfdReader._nextUint32();
      sample.sampleUpper = dfdReader._nextUint32();
    }
    dfd.samples[i] = sample;
  }
  container.dataFormatDescriptor.length = 0;
  container.dataFormatDescriptor.push(dfd);
  const kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);
  while (kvdReader._offset < kvdByteLength) {
    const keyValueByteLength = kvdReader._nextUint32();
    const keyData = kvdReader._scan(keyValueByteLength);
    const key = decodeText(keyData);
    container.keyValue[key] = kvdReader._nextUint8Array(keyValueByteLength - keyData.byteLength - 1);
    if (key.match(/^ktx/i)) {
      const text = decodeText(container.keyValue[key]);
      container.keyValue[key] = text.substring(0, text.lastIndexOf("\0"));
    }
    const kvPadding = keyValueByteLength % 4 ? 4 - keyValueByteLength % 4 : 0;
    kvdReader._skip(kvPadding);
  }
  if (sgdByteLength <= 0) return container;
  const sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);
  const endpointCount = sgdReader._nextUint16();
  const selectorCount = sgdReader._nextUint16();
  const endpointsByteLength = sgdReader._nextUint32();
  const selectorsByteLength = sgdReader._nextUint32();
  const tablesByteLength = sgdReader._nextUint32();
  const extendedByteLength = sgdReader._nextUint32();
  const imageDescs = [];
  for (let i = 0; i < levelCount; i++) {
    imageDescs.push({
      imageFlags: sgdReader._nextUint32(),
      rgbSliceByteOffset: sgdReader._nextUint32(),
      rgbSliceByteLength: sgdReader._nextUint32(),
      alphaSliceByteOffset: sgdReader._nextUint32(),
      alphaSliceByteLength: sgdReader._nextUint32()
    });
  }
  const endpointsByteOffset = sgdByteOffset + sgdReader._offset;
  const selectorsByteOffset = endpointsByteOffset + endpointsByteLength;
  const tablesByteOffset = selectorsByteOffset + selectorsByteLength;
  const extendedByteOffset = tablesByteOffset + tablesByteLength;
  const endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);
  const selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);
  const tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);
  const extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);
  container.globalData = {
    endpointCount,
    selectorCount,
    imageDescs,
    endpointsData,
    selectorsData,
    tablesData,
    extendedData
  };
  return container;
}

// node_modules/@loaders.gl/textures/dist/lib/utils/extract-mipmap-images.js
function extractMipmapImages(data, options) {
  const images = new Array(options.mipMapLevels);
  let levelWidth = options.width;
  let levelHeight = options.height;
  let offset = 0;
  for (let i = 0; i < options.mipMapLevels; ++i) {
    const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i);
    const levelData = getLevelData(data, i, offset, levelSize);
    images[i] = {
      compressed: true,
      format: options.internalFormat,
      data: levelData,
      width: levelWidth,
      height: levelHeight,
      levelSize
    };
    levelWidth = Math.max(1, levelWidth >> 1);
    levelHeight = Math.max(1, levelHeight >> 1);
    offset += levelSize;
  }
  return images;
}
function getLevelData(data, index, offset, levelSize) {
  if (!Array.isArray(data)) {
    return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);
  }
  return data[index].levelData;
}
function getLevelSize(options, levelWidth, levelHeight, data, index) {
  if (!Array.isArray(data)) {
    return options.sizeFunction(levelWidth, levelHeight);
  }
  return options.sizeFunction(data[index]);
}

// node_modules/@loaders.gl/textures/dist/lib/utils/ktx-format-helper.js
var VULKAN_TO_WEBGL_FORMAT_MAP = {
  131: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,
  132: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_S3TC_DXT1_EXT,
  133: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT1_EXT,
  134: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
  135: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  136: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
  137: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  138: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
  139: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_RGTC1_EXT,
  140: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_RGTC1_EXT,
  141: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_GREEN_RGTC2_EXT,
  142: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
  147: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2,
  148: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ETC2,
  149: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
  150: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
  151: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC,
  152: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
  153: GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC,
  154: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_R11_EAC,
  155: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC,
  156: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RG11_EAC,
  // @ts-ignore
  157: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,
  // @ts-ignore
  158: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
  // @ts-ignore
  159: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,
  // @ts-ignore
  160: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,
  // @ts-ignore
  161: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,
  // @ts-ignore
  162: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
  // @ts-ignore
  163: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,
  // @ts-ignore
  164: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
  // @ts-ignore
  165: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,
  // @ts-ignore
  166: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
  // @ts-ignore
  167: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,
  // @ts-ignore
  168: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
  // @ts-ignore
  169: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,
  // @ts-ignore
  170: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
  // @ts-ignore
  171: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,
  // @ts-ignore
  172: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
  // @ts-ignore
  173: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,
  // @ts-ignore
  174: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
  // @ts-ignore
  175: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,
  // @ts-ignore
  176: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
  // @ts-ignore
  177: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,
  // @ts-ignore
  178: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
  // @ts-ignore
  179: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,
  // @ts-ignore
  180: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
  // @ts-ignore
  181: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,
  // @ts-ignore
  182: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
  // @ts-ignore
  183: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR,
  // @ts-ignore
  184: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
  1000054e3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
  1000054001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
  // @ts-ignore
  1000066e3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,
  // @ts-ignore
  1000066001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,
  // @ts-ignore
  1000066002: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,
  // @ts-ignore
  1000066003: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,
  // @ts-ignore
  1000066004: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,
  // @ts-ignore
  1000066005: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,
  // @ts-ignore
  1000066006: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,
  // @ts-ignore
  1000066007: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,
  // @ts-ignore
  1000066008: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,
  // @ts-ignore
  1000066009: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,
  // @ts-ignore
  1000066010: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,
  // @ts-ignore
  1000066011: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,
  // @ts-ignore
  1000066012: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,
  // @ts-ignore
  1000066013: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR
};
function mapVkFormatToWebGL(vkFormat) {
  return VULKAN_TO_WEBGL_FORMAT_MAP[vkFormat];
}

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-ktx.js
var KTX2_ID2 = [
  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function isKTX(data) {
  const id = new Uint8Array(data);
  const notKTX = id.byteLength < KTX2_ID2.length || id[0] !== KTX2_ID2[0] || // '´'
  id[1] !== KTX2_ID2[1] || // 'K'
  id[2] !== KTX2_ID2[2] || // 'T'
  id[3] !== KTX2_ID2[3] || // 'X'
  id[4] !== KTX2_ID2[4] || // ' '
  id[5] !== KTX2_ID2[5] || // '2'
  id[6] !== KTX2_ID2[6] || // '0'
  id[7] !== KTX2_ID2[7] || // 'ª'
  id[8] !== KTX2_ID2[8] || // '\r'
  id[9] !== KTX2_ID2[9] || // '\n'
  id[10] !== KTX2_ID2[10] || // '\x1A'
  id[11] !== KTX2_ID2[11];
  return !notKTX;
}
function parseKTX(arrayBuffer) {
  const uint8Array = new Uint8Array(arrayBuffer);
  const ktx = read(uint8Array);
  const mipMapLevels = Math.max(1, ktx.levels.length);
  const width = ktx.pixelWidth;
  const height = ktx.pixelHeight;
  const internalFormat = mapVkFormatToWebGL(ktx.vkFormat);
  return extractMipmapImages(ktx.levels, {
    mipMapLevels,
    width,
    height,
    sizeFunction: (level) => level.uncompressedByteLength,
    internalFormat
  });
}

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-basis.js
var OutputFormat = {
  etc1: {
    basisFormat: 0,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: { basisFormat: 1, compressed: true },
  bc1: {
    basisFormat: 2,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: { basisFormat: 4, compressed: true },
  bc5: { basisFormat: 5, compressed: true },
  "bc7-m6-opaque-only": { basisFormat: 6, compressed: true },
  "bc7-m5": { basisFormat: 7, compressed: true },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: true,
    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": { basisFormat: 11, compressed: true },
  "atc-rgba-interpolated-alpha": { basisFormat: 12, compressed: true },
  rgba32: { basisFormat: 13, compressed: false },
  rgb565: { basisFormat: 14, compressed: false },
  bgr565: { basisFormat: 15, compressed: false },
  rgba4444: { basisFormat: 16, compressed: false }
};
async function parseBasis(data, options) {
  if (options.basis.containerFormat === "auto") {
    if (isKTX(data)) {
      const fileConstructors = await loadBasisEncoderModule(options);
      return parseKTX2File(fileConstructors.KTX2File, data, options);
    }
    const { BasisFile } = await loadBasisTranscoderModule(options);
    return parseBasisFile(BasisFile, data, options);
  }
  switch (options.basis.module) {
    case "encoder":
      const fileConstructors = await loadBasisEncoderModule(options);
      switch (options.basis.containerFormat) {
        case "ktx2":
          return parseKTX2File(fileConstructors.KTX2File, data, options);
        case "basis":
        default:
          return parseBasisFile(fileConstructors.BasisFile, data, options);
      }
    case "transcoder":
    default:
      const { BasisFile } = await loadBasisTranscoderModule(options);
      return parseBasisFile(BasisFile, data, options);
  }
}
function parseBasisFile(BasisFile, data, options) {
  const basisFile = new BasisFile(new Uint8Array(data));
  try {
    if (!basisFile.startTranscoding()) {
      throw new Error("Failed to start basis transcoding");
    }
    const imageCount = basisFile.getNumImages();
    const images = [];
    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {
      const levelsCount = basisFile.getNumLevels(imageIndex);
      const levels = [];
      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));
      }
      images.push(levels);
    }
    return images;
  } finally {
    basisFile.close();
    basisFile.delete();
  }
}
function transcodeImage(basisFile, imageIndex, levelIndex, options) {
  const width = basisFile.getImageWidth(imageIndex, levelIndex);
  const height = basisFile.getImageHeight(imageIndex, levelIndex);
  const hasAlpha = basisFile.getHasAlpha(
    /* imageIndex, levelIndex */
  );
  const { compressed, format: format2, basisFormat } = getBasisOptions(options, hasAlpha);
  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {
    throw new Error("failed to start Basis transcoding");
  }
  return {
    // standard loaders.gl image category payload
    width,
    height,
    data: decodedData,
    compressed,
    format: format2,
    // Additional fields
    // Add levelSize field.
    hasAlpha
  };
}
function parseKTX2File(KTX2File, data, options) {
  const ktx2File = new KTX2File(new Uint8Array(data));
  try {
    if (!ktx2File.startTranscoding()) {
      throw new Error("failed to start KTX2 transcoding");
    }
    const levelsCount = ktx2File.getLevels();
    const levels = [];
    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {
      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));
    }
    return [levels];
  } finally {
    ktx2File.close();
    ktx2File.delete();
  }
}
function transcodeKTX2Image(ktx2File, levelIndex, options) {
  const { alphaFlag, height, width } = ktx2File.getImageLevelInfo(levelIndex, 0, 0);
  const { compressed, format: format2, basisFormat } = getBasisOptions(options, alphaFlag);
  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(levelIndex, 0, 0, basisFormat);
  const decodedData = new Uint8Array(decodedSize);
  if (!ktx2File.transcodeImage(
    decodedData,
    levelIndex,
    0,
    0,
    basisFormat,
    0,
    -1,
    -1
    /* channel1 */
  )) {
    throw new Error("Failed to transcode KTX2 image");
  }
  return {
    // standard loaders.gl image category payload
    width,
    height,
    data: decodedData,
    compressed,
    // Additional fields
    levelSize: decodedSize,
    hasAlpha: alphaFlag,
    format: format2
  };
}
function getBasisOptions(options, hasAlpha) {
  let format2 = options && options.basis && options.basis.format;
  if (format2 === "auto") {
    format2 = selectSupportedBasisFormat();
  }
  if (typeof format2 === "object") {
    format2 = hasAlpha ? format2.alpha : format2.noAlpha;
  }
  format2 = format2.toLowerCase();
  return OutputFormat[format2];
}
function selectSupportedBasisFormat() {
  const supportedFormats = getSupportedGPUTextureFormats();
  if (supportedFormats.has("astc")) {
    return "astc-4x4";
  } else if (supportedFormats.has("dxt")) {
    return {
      alpha: "bc3",
      noAlpha: "bc1"
    };
  } else if (supportedFormats.has("pvrtc")) {
    return {
      alpha: "pvrtc1-4-rgba",
      noAlpha: "pvrtc1-4-rgb"
    };
  } else if (supportedFormats.has("etc1")) {
    return "etc1";
  } else if (supportedFormats.has("etc2")) {
    return "etc2";
  }
  return "rgb565";
}

// node_modules/@loaders.gl/textures/dist/basis-loader.js
var BasisWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: VERSION4,
  worker: true,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: true,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
};
var BasisLoader = {
  ...BasisWorkerLoader,
  parse: parseBasis
};

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-dds.js
var DDS_CONSTANTS = {
  MAGIC_NUMBER: 542327876,
  HEADER_LENGTH: 31,
  MAGIC_NUMBER_INDEX: 0,
  HEADER_SIZE_INDEX: 1,
  HEADER_FLAGS_INDEX: 2,
  HEADER_HEIGHT_INDEX: 3,
  HEADER_WIDTH_INDEX: 4,
  MIPMAPCOUNT_INDEX: 7,
  HEADER_PF_FLAGS_INDEX: 20,
  HEADER_PF_FOURCC_INDEX: 21,
  DDSD_MIPMAPCOUNT: 131072,
  DDPF_FOURCC: 4
};
var DDS_PIXEL_FORMATS = {
  DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,
  DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,
  DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,
  "ATC ": GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,
  ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
  ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
};
var getATCLevelSize = getDxt1LevelSize;
var getATCALevelSize = getDxtXLevelSize;
var getATCILevelSize = getDxtXLevelSize;
var DDS_SIZE_FUNCTIONS = {
  DXT1: getDxt1LevelSize,
  DXT3: getDxtXLevelSize,
  DXT5: getDxtXLevelSize,
  "ATC ": getATCLevelSize,
  ATCA: getATCALevelSize,
  ATCI: getATCILevelSize
};
function isDDS(data) {
  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);
  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];
  return magic === DDS_CONSTANTS.MAGIC_NUMBER;
}
function parseDDS(data) {
  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);
  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];
  assert2(Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC), "DDS: Unsupported format, must contain a FourCC code");
  const fourCC = int32ToFourCC(pixelFormatNumber);
  const internalFormat = DDS_PIXEL_FORMATS[fourCC];
  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];
  assert2(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);
  let mipMapLevels = 1;
  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {
    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);
  }
  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];
  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];
  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;
  const image = new Uint8Array(data, dataOffset);
  return extractMipmapImages(image, {
    mipMapLevels,
    width,
    height,
    sizeFunction,
    internalFormat
  });
}
function getDxt1LevelSize(width, height) {
  return (width + 3 >> 2) * (height + 3 >> 2) * 8;
}
function getDxtXLevelSize(width, height) {
  return (width + 3 >> 2) * (height + 3 >> 2) * 16;
}
function int32ToFourCC(value) {
  return String.fromCharCode(value & 255, value >> 8 & 255, value >> 16 & 255, value >> 24 & 255);
}

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-pvr.js
var PVR_CONSTANTS = {
  MAGIC_NUMBER: 55727696,
  MAGIC_NUMBER_EXTRA: 1347834371,
  HEADER_LENGTH: 13,
  HEADER_SIZE: 52,
  MAGIC_NUMBER_INDEX: 0,
  PIXEL_FORMAT_INDEX: 2,
  COLOUR_SPACE_INDEX: 4,
  HEIGHT_INDEX: 6,
  WIDTH_INDEX: 7,
  MIPMAPCOUNT_INDEX: 11,
  METADATA_SIZE_INDEX: 12
};
var PVR_PIXEL_FORMATS = {
  0: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG],
  1: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG],
  2: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG],
  3: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG],
  6: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL],
  7: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT],
  9: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT],
  11: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT],
  22: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2],
  23: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC],
  24: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2],
  25: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC],
  26: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC],
  27: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR
  ],
  28: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X4_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR
  ],
  29: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR
  ],
  30: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR
  ],
  31: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X6_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR
  ],
  32: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR
  ],
  33: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X6_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR
  ],
  34: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X8_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR
  ],
  35: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X5_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR
  ],
  36: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X6_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR
  ],
  37: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X8_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR
  ],
  38: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X10_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR
  ],
  39: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X10_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR
  ],
  40: [
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X12_KHR,
    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR
  ]
};
var PVR_SIZE_FUNCTIONS = {
  0: pvrtc2bppSize,
  1: pvrtc2bppSize,
  2: pvrtc4bppSize,
  3: pvrtc4bppSize,
  6: dxtEtcSmallSize,
  7: dxtEtcSmallSize,
  9: dxtEtcAstcBigSize,
  11: dxtEtcAstcBigSize,
  22: dxtEtcSmallSize,
  23: dxtEtcAstcBigSize,
  24: dxtEtcSmallSize,
  25: dxtEtcSmallSize,
  26: dxtEtcAstcBigSize,
  27: dxtEtcAstcBigSize,
  28: atc5x4Size,
  29: atc5x5Size,
  30: atc6x5Size,
  31: atc6x6Size,
  32: atc8x5Size,
  33: atc8x6Size,
  34: atc8x8Size,
  35: atc10x5Size,
  36: atc10x6Size,
  37: atc10x8Size,
  38: atc10x10Size,
  39: atc12x10Size,
  40: atc12x12Size
};
function isPVR(data) {
  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);
  const version = header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX];
  return version === PVR_CONSTANTS.MAGIC_NUMBER || version === PVR_CONSTANTS.MAGIC_NUMBER_EXTRA;
}
function parsePVR(data) {
  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);
  const pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX];
  const colourSpace = header[PVR_CONSTANTS.COLOUR_SPACE_INDEX];
  const pixelFormats = PVR_PIXEL_FORMATS[pvrFormat] || [];
  const internalFormat = pixelFormats.length > 1 && colourSpace ? pixelFormats[1] : pixelFormats[0];
  const sizeFunction = PVR_SIZE_FUNCTIONS[pvrFormat];
  const mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];
  const width = header[PVR_CONSTANTS.WIDTH_INDEX];
  const height = header[PVR_CONSTANTS.HEIGHT_INDEX];
  const dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];
  const image = new Uint8Array(data, dataOffset);
  return extractMipmapImages(image, {
    mipMapLevels,
    width,
    height,
    sizeFunction,
    internalFormat
  });
}
function pvrtc2bppSize(width, height) {
  width = Math.max(width, 16);
  height = Math.max(height, 8);
  return width * height / 4;
}
function pvrtc4bppSize(width, height) {
  width = Math.max(width, 8);
  height = Math.max(height, 8);
  return width * height / 2;
}
function dxtEtcSmallSize(width, height) {
  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
}
function dxtEtcAstcBigSize(width, height) {
  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
}
function atc5x4Size(width, height) {
  return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
}
function atc5x5Size(width, height) {
  return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
}
function atc6x5Size(width, height) {
  return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
}
function atc6x6Size(width, height) {
  return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
}
function atc8x5Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
}
function atc8x6Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
}
function atc8x8Size(width, height) {
  return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
}
function atc10x5Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
}
function atc10x6Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
}
function atc10x8Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
}
function atc10x10Size(width, height) {
  return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
}
function atc12x10Size(width, height) {
  return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
}
function atc12x12Size(width, height) {
  return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
}

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-compressed-texture.js
function parseCompressedTexture(data) {
  if (isKTX(data)) {
    return parseKTX(data);
  }
  if (isDDS(data)) {
    return parseDDS(data);
  }
  if (isPVR(data)) {
    return parsePVR(data);
  }
  throw new Error("Texture container format not recognized");
}

// node_modules/@loaders.gl/textures/dist/compressed-texture-loader.js
var CompressedTextureWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Texture Containers",
  id: "compressed-texture",
  module: "textures",
  version: VERSION4,
  worker: true,
  extensions: [
    "ktx",
    "ktx2",
    "dds",
    // WEBGL_compressed_texture_s3tc, WEBGL_compressed_texture_atc
    "pvr"
    // WEBGL_compressed_texture_pvrtc
  ],
  mimeTypes: [
    "image/ktx2",
    "image/ktx",
    "image/vnd-ms.dds",
    "image/x-dds",
    "application/octet-stream"
  ],
  binary: true,
  options: {
    "compressed-texture": {
      libraryPath: "libs/",
      useBasis: false
    }
  }
};
var CompressedTextureLoader = {
  ...CompressedTextureWorkerLoader,
  parse: async (arrayBuffer, options) => {
    var _a;
    if ((_a = options == null ? void 0 : options["compressed-texture"]) == null ? void 0 : _a.useBasis) {
      options.basis = {
        format: {
          alpha: "BC3",
          noAlpha: "BC1"
        },
        // @ts-expect-error TODO not allowed to modify inputs
        ...options.basis,
        containerFormat: "ktx2",
        module: "encoder"
      };
      const result = await parseBasis(arrayBuffer, options);
      return result[0];
    }
    return parseCompressedTexture(arrayBuffer);
  }
};

// node_modules/@loaders.gl/textures/dist/lib/parsers/parse-npy.js
var a2 = new Uint32Array([305419896]);
var b2 = new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength);
var isLittleEndian = !(b2[0] === 18);
var LITTLE_ENDIAN_OS = isLittleEndian;
var DTYPES = {
  u1: Uint8Array,
  i1: Int8Array,
  u2: Uint16Array,
  i2: Int16Array,
  u4: Uint32Array,
  i4: Int32Array,
  f4: Float32Array,
  f8: Float64Array
};
function parseNPY(arrayBuffer, options) {
  var _a;
  const view = new DataView(arrayBuffer);
  const { header, headerEndOffset } = parseHeader(view);
  const numpyType = header.descr;
  const ArrayType = DTYPES[numpyType.slice(1, 3)];
  if (!ArrayType) {
    throw new Error(`Unimplemented type ${numpyType}`);
  }
  const nArrayElements = (_a = header.shape) == null ? void 0 : _a.reduce((a3, b3) => a3 * b3);
  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;
  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {
    throw new Error("Buffer overflow");
  }
  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));
  if (numpyType[0] === ">" && LITTLE_ENDIAN_OS || numpyType[0] === "<" && !LITTLE_ENDIAN_OS) {
    throw new Error("Incorrect endianness");
  }
  return {
    data,
    header
  };
}
function parseHeader(view) {
  const majorVersion = view.getUint8(6);
  let offset = 8;
  let headerLength;
  if (majorVersion >= 2) {
    headerLength = view.getUint32(offset, true);
    offset += 4;
  } else {
    headerLength = view.getUint16(offset, true);
    offset += 2;
  }
  const encoding = majorVersion <= 2 ? "latin1" : "utf-8";
  const decoder = new TextDecoder(encoding);
  const headerArray = new Uint8Array(view.buffer, offset, headerLength);
  const headerText = decoder.decode(headerArray);
  offset += headerLength;
  const header = JSON.parse(headerText.replace(/'/g, '"').replace("False", "false").replace("(", "[").replace(/,*\),*/g, "]"));
  return { header, headerEndOffset: offset };
}

// node_modules/@loaders.gl/textures/dist/npy-loader.js
var NPY_MAGIC_NUMBER = new Uint8Array([147, 78, 85, 77, 80, 89]);
var NPYWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "NPY",
  id: "npy",
  module: "textures",
  version: VERSION4,
  worker: true,
  extensions: ["npy"],
  mimeTypes: [],
  tests: [NPY_MAGIC_NUMBER.buffer],
  options: {
    npy: {}
  }
};
var NPYLoader = {
  ...NPYWorkerLoader,
  parseSync: parseNPY,
  parse: async (arrayBuffer, options) => parseNPY(arrayBuffer, options)
};

// node_modules/@luma.gl/gltf/dist/webgl-to-webgpu/convert-webgl-sampler.js
function convertSampler(gltfSampler) {
  return {
    addressModeU: convertSamplerWrapMode(gltfSampler.wrapS),
    addressModeV: convertSamplerWrapMode(gltfSampler.wrapT),
    magFilter: convertSamplerMagFilter(gltfSampler.magFilter),
    ...convertSamplerMinFilter(gltfSampler.minFilter)
  };
}
function convertSamplerWrapMode(mode) {
  switch (mode) {
    case 33071:
      return "clamp-to-edge";
    case 10497:
      return "repeat";
    case 33648:
      return "mirror-repeat";
    default:
      return void 0;
  }
}
function convertSamplerMagFilter(mode) {
  switch (mode) {
    case 9728:
      return "nearest";
    case 9729:
      return "linear";
    default:
      return void 0;
  }
}
function convertSamplerMinFilter(mode) {
  switch (mode) {
    case 9728:
      return { minFilter: "nearest" };
    case 9729:
      return { minFilter: "linear" };
    case 9984:
      return { minFilter: "nearest", mipmapFilter: "nearest" };
    case 9985:
      return { minFilter: "linear", mipmapFilter: "nearest" };
    case 9986:
      return { minFilter: "nearest", mipmapFilter: "linear" };
    case 9987:
      return { minFilter: "linear", mipmapFilter: "linear" };
    default:
      return {};
  }
}

// node_modules/@luma.gl/gltf/dist/parsers/parse-pbr-material.js
function parsePBRMaterial(device, material, attributes, options) {
  const parsedMaterial = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: true,
      SRGB_FAST_APPROXIMATION: true
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      camera: [0, 0, 0],
      // Model should override
      metallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  parsedMaterial.defines["USE_TEX_LOD"] = true;
  const { imageBasedLightingEnvironment } = options;
  if (imageBasedLightingEnvironment) {
    parsedMaterial.bindings.pbr_diffuseEnvSampler = imageBasedLightingEnvironment.diffuseEnvSampler.texture;
    parsedMaterial.bindings.pbr_specularEnvSampler = imageBasedLightingEnvironment.specularEnvSampler.texture;
    parsedMaterial.bindings.pbr_BrdfLUT = imageBasedLightingEnvironment.brdfLutTexture.texture;
    parsedMaterial.uniforms.scaleIBLAmbient = [1, 1];
  }
  if (options == null ? void 0 : options.pbrDebug) {
    parsedMaterial.defines["PBR_DEBUG"] = true;
    parsedMaterial.uniforms.scaleDiffBaseMR = [0, 0, 0, 0];
    parsedMaterial.uniforms.scaleFGDSpec = [0, 0, 0, 0];
  }
  if (attributes["NORMAL"])
    parsedMaterial.defines["HAS_NORMALS"] = true;
  if (attributes["TANGENT"] && (options == null ? void 0 : options.useTangents))
    parsedMaterial.defines["HAS_TANGENTS"] = true;
  if (attributes["TEXCOORD_0"])
    parsedMaterial.defines["HAS_UV"] = true;
  if (options == null ? void 0 : options.imageBasedLightingEnvironment)
    parsedMaterial.defines["USE_IBL"] = true;
  if (options == null ? void 0 : options.lights)
    parsedMaterial.defines["USE_LIGHTS"] = true;
  if (material) {
    parseMaterial(device, material, parsedMaterial);
  }
  return parsedMaterial;
}
function parseMaterial(device, material, parsedMaterial) {
  parsedMaterial.uniforms.unlit = Boolean(material.unlit);
  if (material.pbrMetallicRoughness) {
    parsePbrMetallicRoughness(device, material.pbrMetallicRoughness, parsedMaterial);
  }
  if (material.normalTexture) {
    addTexture(device, material.normalTexture, "pbr_normalSampler", "HAS_NORMALMAP", parsedMaterial);
    const { scale: scale7 = 1 } = material.normalTexture;
    parsedMaterial.uniforms.normalScale = scale7;
  }
  if (material.occlusionTexture) {
    addTexture(device, material.occlusionTexture, "pbr_occlusionSampler", "HAS_OCCLUSIONMAP", parsedMaterial);
    const { strength = 1 } = material.occlusionTexture;
    parsedMaterial.uniforms.occlusionStrength = strength;
  }
  if (material.emissiveTexture) {
    addTexture(device, material.emissiveTexture, "pbr_emissiveSampler", "HAS_EMISSIVEMAP", parsedMaterial);
    parsedMaterial.uniforms.emissiveFactor = material.emissiveFactor || [0, 0, 0];
  }
  switch (material.alphaMode || "MASK") {
    case "MASK":
      const { alphaCutoff = 0.5 } = material;
      parsedMaterial.defines["ALPHA_CUTOFF"] = true;
      parsedMaterial.uniforms.alphaCutoff = alphaCutoff;
      break;
    case "BLEND":
      log2.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")();
      parsedMaterial.parameters.blend = true;
      parsedMaterial.parameters.blendColorOperation = "add";
      parsedMaterial.parameters.blendColorSrcFactor = "src-alpha";
      parsedMaterial.parameters.blendColorDstFactor = "one-minus-src-alpha";
      parsedMaterial.parameters.blendAlphaOperation = "add";
      parsedMaterial.parameters.blendAlphaSrcFactor = "one";
      parsedMaterial.parameters.blendAlphaDstFactor = "one-minus-src-alpha";
      parsedMaterial.glParameters["blend"] = true;
      parsedMaterial.glParameters["blendEquation"] = 32774;
      parsedMaterial.glParameters["blendFunc"] = [
        770,
        771,
        1,
        771
      ];
      break;
  }
}
function parsePbrMetallicRoughness(device, pbrMetallicRoughness, parsedMaterial) {
  if (pbrMetallicRoughness.baseColorTexture) {
    addTexture(device, pbrMetallicRoughness.baseColorTexture, "pbr_baseColorSampler", "HAS_BASECOLORMAP", parsedMaterial);
  }
  parsedMaterial.uniforms.baseColorFactor = pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1];
  if (pbrMetallicRoughness.metallicRoughnessTexture) {
    addTexture(device, pbrMetallicRoughness.metallicRoughnessTexture, "pbr_metallicRoughnessSampler", "HAS_METALROUGHNESSMAP", parsedMaterial);
  }
  const { metallicFactor = 1, roughnessFactor = 1 } = pbrMetallicRoughness;
  parsedMaterial.uniforms.metallicRoughnessValues = [metallicFactor, roughnessFactor];
}
function addTexture(device, gltfTexture, uniformName, define2, parsedMaterial) {
  var _a;
  const image = gltfTexture.texture.source.image;
  let textureOptions;
  if (image.compressed) {
    textureOptions = image;
  } else {
    textureOptions = { data: image };
  }
  const gltfSampler = {
    wrapS: 10497,
    // default REPEAT S (U) wrapping mode.
    wrapT: 10497,
    // default REPEAT T (V) wrapping mode.
    ...(_a = gltfTexture == null ? void 0 : gltfTexture.texture) == null ? void 0 : _a.sampler
  };
  const texture = device.createTexture({
    id: gltfTexture.uniformName || gltfTexture.id,
    sampler: convertSampler(gltfSampler),
    ...textureOptions
  });
  parsedMaterial.bindings[uniformName] = texture;
  if (define2)
    parsedMaterial.defines[define2] = true;
  parsedMaterial.generatedTextures.push(texture);
}

// node_modules/@luma.gl/gltf/dist/webgl-to-webgpu/convert-webgl-topology.js
var GLEnum2;
(function(GLEnum3) {
  GLEnum3[GLEnum3["POINTS"] = 0] = "POINTS";
  GLEnum3[GLEnum3["LINES"] = 1] = "LINES";
  GLEnum3[GLEnum3["LINE_LOOP"] = 2] = "LINE_LOOP";
  GLEnum3[GLEnum3["LINE_STRIP"] = 3] = "LINE_STRIP";
  GLEnum3[GLEnum3["TRIANGLES"] = 4] = "TRIANGLES";
  GLEnum3[GLEnum3["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
  GLEnum3[GLEnum3["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
})(GLEnum2 || (GLEnum2 = {}));
function convertGLDrawModeToTopology(drawMode) {
  switch (drawMode) {
    case GLEnum2.POINTS:
      return "point-list";
    case GLEnum2.LINES:
      return "line-list";
    case GLEnum2.LINE_STRIP:
      return "line-strip";
    case GLEnum2.TRIANGLES:
      return "triangle-list";
    case GLEnum2.TRIANGLE_STRIP:
      return "triangle-strip";
    default:
      throw new Error(String(drawMode));
  }
}

// node_modules/@luma.gl/gltf/dist/gltf/create-gltf-model.js
var SHADER = (
  /* WGSL */
  `
layout(0) positions: vec4; // in vec4 POSITION;

  #ifdef HAS_NORMALS
    in vec4 normals; // in vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

@vertex
  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }

@fragment
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
);
var vs = (
  /* glsl */
  `#version 300 es

  // in vec4 POSITION;
  in vec4 positions;

  #ifdef HAS_NORMALS
    // in vec4 NORMAL;
    in vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;
  }
`
);
var fs = (
  /* glsl */
  `#version 300 es
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
);
function createGLTFModel(device, options) {
  const { id, geometry, parsedPPBRMaterial, vertexCount, modelOptions = {} } = options;
  log2.info(4, "createGLTFModel defines: ", parsedPPBRMaterial.defines)();
  const managedResources = [];
  const parameters2 = {
    depthWriteEnabled: true,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  };
  const modelProps = {
    id,
    source: SHADER,
    vs,
    fs,
    geometry,
    topology: geometry.topology,
    vertexCount,
    modules: [pbrMaterial],
    ...modelOptions,
    defines: { ...parsedPPBRMaterial.defines, ...modelOptions.defines },
    parameters: { ...parameters2, ...parsedPPBRMaterial.parameters, ...modelOptions.parameters }
  };
  const model = new Model(device, modelProps);
  const { camera, ...pbrMaterialProps } = {
    ...parsedPPBRMaterial.uniforms,
    ...modelOptions.uniforms,
    ...parsedPPBRMaterial.bindings,
    ...modelOptions.bindings
  };
  model.shaderInputs.setProps({ pbrMaterial: pbrMaterialProps, pbrProjection: { camera } });
  return new ModelNode({ managedResources, model });
}

// node_modules/@luma.gl/gltf/dist/parsers/parse-gltf.js
var defaultOptions = {
  modelOptions: {},
  pbrDebug: false,
  imageBasedLightingEnvironment: void 0,
  lights: true,
  useTangents: false
};
function parseGLTF(device, gltf, options_ = {}) {
  const options = { ...defaultOptions, ...options_ };
  const sceneNodes = gltf.scenes.map((gltfScene) => createScene(device, gltfScene, gltf.nodes, options));
  return sceneNodes;
}
function createScene(device, gltfScene, gltfNodes, options) {
  const gltfSceneNodes = gltfScene.nodes || [];
  const nodes = gltfSceneNodes.map((node) => createNode(device, node, gltfNodes, options));
  const sceneNode = new GroupNode({
    id: gltfScene.name || gltfScene.id,
    children: nodes
  });
  return sceneNode;
}
function createNode(device, gltfNode, gltfNodes, options) {
  if (!gltfNode._node) {
    const gltfChildren = gltfNode.children || [];
    const children = gltfChildren.map((child) => createNode(device, child, gltfNodes, options));
    if (gltfNode.mesh) {
      children.push(createMesh(device, gltfNode.mesh, options));
    }
    const node = new GroupNode({
      id: gltfNode.name || gltfNode.id,
      children
    });
    if (gltfNode.matrix) {
      node.setMatrix(gltfNode.matrix);
    } else {
      node.matrix.identity();
      if (gltfNode.translation) {
        node.matrix.translate(gltfNode.translation);
      }
      if (gltfNode.rotation) {
        const rotationMatrix = new Matrix4().fromQuaternion(gltfNode.rotation);
        node.matrix.multiplyRight(rotationMatrix);
      }
      if (gltfNode.scale) {
        node.matrix.scale(gltfNode.scale);
      }
    }
    gltfNode._node = node;
  }
  const topLevelNode = gltfNodes.find((node) => node.id === gltfNode.id);
  topLevelNode._node = gltfNode._node;
  return gltfNode._node;
}
function createMesh(device, gltfMesh, options) {
  if (!gltfMesh._mesh) {
    const gltfPrimitives = gltfMesh.primitives || [];
    const primitives = gltfPrimitives.map((gltfPrimitive, i) => createPrimitive(device, gltfPrimitive, i, gltfMesh, options));
    const mesh = new GroupNode({
      id: gltfMesh.name || gltfMesh.id,
      children: primitives
    });
    gltfMesh._mesh = mesh;
  }
  return gltfMesh._mesh;
}
function createPrimitive(device, gltfPrimitive, i, gltfMesh, options) {
  const id = gltfPrimitive.name || `${gltfMesh.name || gltfMesh.id}-primitive-${i}`;
  const topology = convertGLDrawModeToTopology(gltfPrimitive.mode || 4);
  const vertexCount = gltfPrimitive.indices ? gltfPrimitive.indices.count : getVertexCount(gltfPrimitive.attributes);
  const geometry = createGeometry(id, gltfPrimitive, topology);
  const parsedPPBRMaterial = parsePBRMaterial(device, gltfPrimitive.material, geometry.attributes, options);
  const modelNode = createGLTFModel(device, {
    id,
    geometry: createGeometry(id, gltfPrimitive, topology),
    parsedPPBRMaterial,
    modelOptions: options.modelOptions,
    vertexCount
  });
  modelNode.bounds = [gltfPrimitive.attributes.POSITION.min, gltfPrimitive.attributes.POSITION.max];
  return modelNode;
}
function getVertexCount(attributes) {
  throw new Error("getVertexCount not implemented");
}
function createGeometry(id, gltfPrimitive, topology) {
  const attributes = {};
  for (const [attributeName, attribute] of Object.entries(gltfPrimitive.attributes)) {
    const { components, size, value } = attribute;
    attributes[attributeName] = { size: size ?? components, value };
  }
  return new Geometry({
    id,
    topology,
    indices: gltfPrimitive.indices.value,
    attributes
  });
}

// node_modules/@luma.gl/gltf/dist/gltf/animations/interpolate.js
var scratchQuaternion = new Quaternion();
function interpolate(time, { input, interpolation, output }, target, path) {
  const maxTime = input[input.length - 1];
  const animationTime = time % maxTime;
  const nextIndex = input.findIndex((t) => t >= animationTime);
  const previousIndex = Math.max(0, nextIndex - 1);
  if (!Array.isArray(target[path])) {
    switch (path) {
      case "translation":
        target[path] = [0, 0, 0];
        break;
      case "rotation":
        target[path] = [0, 0, 0, 1];
        break;
      case "scale":
        target[path] = [1, 1, 1];
        break;
      default:
        log2.warn(`Bad animation path ${path}`)();
    }
  }
  const previousTime = input[previousIndex];
  const nextTime = input[nextIndex];
  switch (interpolation) {
    case "STEP":
      stepInterpolate(target, path, output[previousIndex]);
      break;
    case "LINEAR":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        linearInterpolate(target, path, output[previousIndex], output[nextIndex], ratio);
      }
      break;
    case "CUBICSPLINE":
      if (nextTime > previousTime) {
        const ratio = (animationTime - previousTime) / (nextTime - previousTime);
        const tDiff = nextTime - previousTime;
        const p0 = output[3 * previousIndex + 1];
        const outTangent0 = output[3 * previousIndex + 2];
        const inTangent1 = output[3 * nextIndex + 0];
        const p1 = output[3 * nextIndex + 1];
        cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio });
      }
      break;
    default:
      log2.warn(`Interpolation ${interpolation} not supported`)();
      break;
  }
}
function linearInterpolate(target, path, start, stop, ratio) {
  if (!target[path]) {
    throw new Error();
  }
  if (path === "rotation") {
    scratchQuaternion.slerp({ start, target: stop, ratio });
    for (let i = 0; i < scratchQuaternion.length; i++) {
      target[path][i] = scratchQuaternion[i];
    }
  } else {
    for (let i = 0; i < start.length; i++) {
      target[path][i] = ratio * stop[i] + (1 - ratio) * start[i];
    }
  }
}
function cubicsplineInterpolate(target, path, { p0, outTangent0, inTangent1, p1, tDiff, ratio: t }) {
  if (!target[path]) {
    throw new Error();
  }
  for (let i = 0; i < target[path].length; i++) {
    const m0 = outTangent0[i] * tDiff;
    const m1 = inTangent1[i] * tDiff;
    target[path][i] = (2 * Math.pow(t, 3) - 3 * Math.pow(t, 2) + 1) * p0[i] + (Math.pow(t, 3) - 2 * Math.pow(t, 2) + t) * m0 + (-2 * Math.pow(t, 3) + 3 * Math.pow(t, 2)) * p1[i] + (Math.pow(t, 3) - Math.pow(t, 2)) * m1;
  }
}
function stepInterpolate(target, path, value) {
  if (!target[path]) {
    throw new Error();
  }
  for (let i = 0; i < value.length; i++) {
    target[path][i] = value[i];
  }
}

// node_modules/@luma.gl/gltf/dist/gltf/gltf-animator.js
var GLTFSingleAnimator = class {
  constructor(props) {
    __publicField(this, "animation");
    __publicField(this, "startTime", 0);
    __publicField(this, "playing", true);
    __publicField(this, "speed", 1);
    var _a;
    this.animation = props.animation;
    (_a = this.animation).name || (_a.name = "unnamed");
    Object.assign(this, props);
  }
  setTime(timeMs) {
    if (!this.playing) {
      return;
    }
    const absTime = timeMs / 1e3;
    const time = (absTime - this.startTime) * this.speed;
    this.animation.channels.forEach(({ sampler, target, path }) => {
      interpolate(time, sampler, target, path);
      applyTranslationRotationScale(target, target._node);
    });
  }
};
var GLTFAnimator = class {
  constructor(props) {
    __publicField(this, "animations");
    this.animations = props.animations.map((animation, index) => {
      const name12 = animation.name || `Animation-${index}`;
      return new GLTFSingleAnimator({
        animation: { name: name12, channels: animation.channels }
      });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(time) {
    log2.warn("GLTFAnimator#animate is deprecated. Use GLTFAnimator#setTime instead")();
    this.setTime(time);
  }
  setTime(time) {
    this.animations.forEach((animation) => animation.setTime(time));
  }
  getAnimations() {
    return this.animations;
  }
};
var scratchMatrix2 = new Matrix4();
function applyTranslationRotationScale(gltfNode, node) {
  node.matrix.identity();
  if (gltfNode.translation) {
    node.matrix.translate(gltfNode.translation);
  }
  if (gltfNode.rotation) {
    const rotationMatrix = scratchMatrix2.fromQuaternion(gltfNode.rotation);
    node.matrix.multiplyRight(rotationMatrix);
  }
  if (gltfNode.scale) {
    node.matrix.scale(gltfNode.scale);
  }
}

// node_modules/@luma.gl/gltf/dist/webgl-to-webgpu/convert-webgl-attribute.js
var ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function accessorToTypedArray(accessor) {
  var _a;
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
  const length5 = components * accessor.count;
  const { buffer, byteOffset = 0 } = ((_a = accessor.bufferView) == null ? void 0 : _a.data) ?? {};
  const typedArray = new ArrayType(buffer, byteOffset + (accessor.byteOffset || 0), length5);
  return { typedArray, components };
}

// node_modules/@luma.gl/gltf/dist/parsers/parse-gltf-animations.js
function parseGLTFAnimations(gltf) {
  const gltfAnimations = gltf.animations || [];
  return gltfAnimations.map((animation, index) => {
    const name12 = animation.name || `Animation-${index}`;
    const samplers = animation.samplers.map(({ input, interpolation = "LINEAR", output }) => ({
      input: accessorToJsArray(gltf.accessors[input]),
      interpolation,
      output: accessorToJsArray(gltf.accessors[output])
    }));
    const channels = animation.channels.map(({ sampler, target }) => ({
      sampler: samplers[sampler],
      target: gltf.nodes[target.node ?? 0],
      path: target.path
    }));
    return { name: name12, channels };
  });
}
function accessorToJsArray(accessor) {
  if (!accessor._animation) {
    const { typedArray: array, components } = accessorToTypedArray(accessor);
    if (components === 1) {
      accessor._animation = Array.from(array);
    } else {
      const slicedArray = [];
      for (let i = 0; i < array.length; i += components) {
        slicedArray.push(Array.from(array.slice(i, i + components)));
      }
      accessor._animation = slicedArray;
    }
  }
  return accessor._animation;
}

// node_modules/@luma.gl/gltf/dist/utils/deep-copy.js
function deepCopy(object) {
  if (ArrayBuffer.isView(object) || object instanceof ArrayBuffer || object instanceof ImageBitmap) {
    return object;
  }
  if (Array.isArray(object)) {
    return object.map(deepCopy);
  }
  if (object && typeof object === "object") {
    const result = {};
    for (const key in object) {
      result[key] = deepCopy(object[key]);
    }
    return result;
  }
  return object;
}

// node_modules/@luma.gl/gltf/dist/gltf/create-scenegraph-from-gltf.js
function createScenegraphsFromGLTF(device, gltf, options) {
  gltf = deepCopy(gltf);
  const scenes = parseGLTF(device, gltf, options);
  const animations = parseGLTFAnimations(gltf);
  const animator = new GLTFAnimator({ animations });
  return { scenes, animator };
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
var EXT_mesh_features_exports = {};
__export(EXT_mesh_features_exports, {
  createExtMeshFeatures: () => createExtMeshFeatures,
  decode: () => decode,
  encode: () => encode,
  name: () => name
});

// node_modules/@loaders.gl/gltf/dist/lib/utils/assert.js
function assert4(condition, message) {
  if (!condition) {
    throw new Error(message || "assert failed: gltf");
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-constants.js
var COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
};

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-utils.js
var MIPMAP_FACTOR = 1.33;
var TYPES = ["SCALAR", "VEC2", "VEC3", "VEC4"];
var ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT = [
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126],
  [Float64Array, 5130]
];
var ARRAY_TO_COMPONENT_TYPE = new Map(ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT);
var ATTRIBUTE_TYPE_TO_COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2 = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function getAccessorTypeFromSize(size) {
  const type = TYPES[size - 1];
  return type || TYPES[0];
}
function getComponentTypeFromArray(typedArray) {
  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
  if (!componentType) {
    throw new Error("Illegal typed array");
  }
  return componentType;
}
function getAccessorArrayTypeAndLength(accessor, bufferView) {
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY2[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS2[accessor.type];
  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
  const length5 = accessor.count * components;
  const byteLength = accessor.count * components * bytesPerComponent;
  assert4(byteLength >= 0 && byteLength <= bufferView.byteLength);
  const componentByteSize = BYTES[accessor.componentType];
  const numberOfComponentsInElement = COMPONENTS[accessor.type];
  return { ArrayType, length: length5, byteLength, componentByteSize, numberOfComponentsInElement };
}
function getMemoryUsageGLTF(gltf) {
  let { images, bufferViews } = gltf;
  images = images || [];
  bufferViews = bufferViews || [];
  const imageBufferViews = images.map((i) => i.bufferView);
  bufferViews = bufferViews.filter((view) => !imageBufferViews.includes(view));
  const bufferMemory = bufferViews.reduce((acc, view) => acc + view.byteLength, 0);
  const pixelCount = images.reduce((acc, image) => {
    const { width, height } = image.image;
    return acc + width * height;
  }, 0);
  return bufferMemory + Math.ceil(4 * pixelCount * MIPMAP_FACTOR);
}

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/get-typed-array.js
function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
  const bufferView = json.bufferViews[bufferViewIndex];
  assert4(bufferView);
  const bufferIndex = bufferView.buffer;
  const binChunk = buffers[bufferIndex];
  assert4(binChunk);
  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
}
function getTypedArrayForAccessor(json, buffers, accessor) {
  var _a, _b;
  const gltfAccessor = typeof accessor === "number" ? (_a = json.accessors) == null ? void 0 : _a[accessor] : accessor;
  if (!gltfAccessor) {
    throw new Error(`No gltf accessor ${JSON.stringify(accessor)}`);
  }
  const bufferView = (_b = json.bufferViews) == null ? void 0 : _b[gltfAccessor.bufferView || 0];
  if (!bufferView) {
    throw new Error(`No gltf buffer view for accessor ${bufferView}`);
  }
  const { arrayBuffer, byteOffset: bufferByteOffset } = buffers[bufferView.buffer];
  const byteOffset = (bufferByteOffset || 0) + (gltfAccessor.byteOffset || 0) + (bufferView.byteOffset || 0);
  const { ArrayType, length: length5, componentByteSize, numberOfComponentsInElement } = getAccessorArrayTypeAndLength(gltfAccessor, bufferView);
  const elementByteSize = componentByteSize * numberOfComponentsInElement;
  const elementAddressScale = bufferView.byteStride || elementByteSize;
  if (typeof bufferView.byteStride === "undefined" || bufferView.byteStride === elementByteSize) {
    const result2 = new ArrayType(arrayBuffer, byteOffset, length5);
    return result2;
  }
  const result = new ArrayType(length5);
  for (let i = 0; i < gltfAccessor.count; i++) {
    const values = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, numberOfComponentsInElement);
    result.set(values, i * numberOfComponentsInElement);
  }
  return result;
}

// node_modules/@loaders.gl/gltf/dist/lib/api/gltf-scenegraph.js
function makeDefaultGLTFJson() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
var GLTFScenegraph = class {
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(gltf) {
    // internal
    __publicField(this, "gltf");
    __publicField(this, "sourceBuffers");
    __publicField(this, "byteLength");
    this.gltf = {
      json: (gltf == null ? void 0 : gltf.json) || makeDefaultGLTFJson(),
      buffers: (gltf == null ? void 0 : gltf.buffers) || [],
      images: (gltf == null ? void 0 : gltf.images) || []
    };
    this.sourceBuffers = [];
    this.byteLength = 0;
    if (this.gltf.buffers && this.gltf.buffers[0]) {
      this.byteLength = this.gltf.buffers[0].byteLength;
      this.sourceBuffers = [this.gltf.buffers[0]];
    }
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(key) {
    const data = this.json[key];
    return data;
  }
  getExtraData(key) {
    const extras = this.json.extras || {};
    return extras[key];
  }
  hasExtension(extensionName) {
    const isUsedExtension = this.getUsedExtensions().find((name12) => name12 === extensionName);
    const isRequiredExtension = this.getRequiredExtensions().find((name12) => name12 === extensionName);
    return typeof isUsedExtension === "string" || typeof isRequiredExtension === "string";
  }
  getExtension(extensionName) {
    const isExtension = this.getUsedExtensions().find((name12) => name12 === extensionName);
    const extensions = this.json.extensions || {};
    return isExtension ? extensions[extensionName] : null;
  }
  getRequiredExtension(extensionName) {
    const isRequired = this.getRequiredExtensions().find((name12) => name12 === extensionName);
    return isRequired ? this.getExtension(extensionName) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(object, extensionName) {
    const extensions = object.extensions || {};
    return extensions[extensionName];
  }
  getScene(index) {
    return this.getObject("scenes", index);
  }
  getNode(index) {
    return this.getObject("nodes", index);
  }
  getSkin(index) {
    return this.getObject("skins", index);
  }
  getMesh(index) {
    return this.getObject("meshes", index);
  }
  getMaterial(index) {
    return this.getObject("materials", index);
  }
  getAccessor(index) {
    return this.getObject("accessors", index);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(index) {
    return this.getObject("textures", index);
  }
  getSampler(index) {
    return this.getObject("samplers", index);
  }
  getImage(index) {
    return this.getObject("images", index);
  }
  getBufferView(index) {
    return this.getObject("bufferViews", index);
  }
  getBuffer(index) {
    return this.getObject("buffers", index);
  }
  getObject(array, index) {
    if (typeof index === "object") {
      return index;
    }
    const object = this.json[array] && this.json[array][index];
    if (!object) {
      throw new Error(`glTF file error: Could not find ${array}[${index}]`);
    }
    return object;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(bufferView) {
    bufferView = this.getBufferView(bufferView);
    const bufferIndex = bufferView.buffer;
    const binChunk = this.gltf.buffers[bufferIndex];
    assert4(binChunk);
    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(accessor) {
    const gltfAccessor = this.getAccessor(accessor);
    return getTypedArrayForAccessor(this.gltf.json, this.gltf.buffers, gltfAccessor);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(image) {
    image = this.getAccessor(image);
    const bufferView = this.getBufferView(image.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;
    const byteOffset = bufferView.byteOffset || 0;
    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(key, data) {
    this.json[key] = data;
    return this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(key, data) {
    this.json.extras = this.json.extras || {};
    this.json.extras[key] = data;
    return this;
  }
  addObjectExtension(object, extensionName, data) {
    object.extensions = object.extensions || {};
    object.extensions[extensionName] = data;
    this.registerUsedExtension(extensionName);
    return this;
  }
  setObjectExtension(object, extensionName, data) {
    const extensions = object.extensions || {};
    extensions[extensionName] = data;
  }
  removeObjectExtension(object, extensionName) {
    const extensions = (object == null ? void 0 : object.extensions) || {};
    if (extensions[extensionName]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    delete extensions[extensionName];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(extensionName, extensionData = {}) {
    assert4(extensionData);
    this.json.extensions = this.json.extensions || {};
    this.json.extensions[extensionName] = extensionData;
    this.registerUsedExtension(extensionName);
    return extensionData;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(extensionName, extensionData = {}) {
    assert4(extensionData);
    this.addExtension(extensionName, extensionData);
    this.registerRequiredExtension(extensionName);
    return extensionData;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(extensionName) {
    this.json.extensionsUsed = this.json.extensionsUsed || [];
    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {
      this.json.extensionsUsed.push(extensionName);
    }
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(extensionName) {
    this.registerUsedExtension(extensionName);
    this.json.extensionsRequired = this.json.extensionsRequired || [];
    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {
      this.json.extensionsRequired.push(extensionName);
    }
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(extensionName) {
    var _a;
    if ((_a = this.json.extensions) == null ? void 0 : _a[extensionName]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const extensionsRemoved = this.json.extensionsRemoved;
      if (!extensionsRemoved.includes(extensionName)) {
        extensionsRemoved.push(extensionName);
      }
    }
    if (this.json.extensions) {
      delete this.json.extensions[extensionName];
    }
    if (this.json.extensionsRequired) {
      this._removeStringFromArray(this.json.extensionsRequired, extensionName);
    }
    if (this.json.extensionsUsed) {
      this._removeStringFromArray(this.json.extensionsUsed, extensionName);
    }
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(sceneIndex) {
    this.json.scene = sceneIndex;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(scene) {
    const { nodeIndices } = scene;
    this.json.scenes = this.json.scenes || [];
    this.json.scenes.push({ nodes: nodeIndices });
    return this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(node) {
    const { meshIndex, matrix } = node;
    this.json.nodes = this.json.nodes || [];
    const nodeData = { mesh: meshIndex };
    if (matrix) {
      nodeData.matrix = matrix;
    }
    this.json.nodes.push(nodeData);
    return this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(mesh) {
    const { attributes, indices, material, mode = 4 } = mesh;
    const accessors = this._addAttributes(attributes);
    const glTFMesh = {
      primitives: [
        {
          attributes: accessors,
          mode
        }
      ]
    };
    if (indices) {
      const indicesAccessor = this._addIndices(indices);
      glTFMesh.primitives[0].indices = indicesAccessor;
    }
    if (Number.isFinite(material)) {
      glTFMesh.primitives[0].material = material;
    }
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }
  addPointCloud(attributes) {
    const accessorIndices = this._addAttributes(attributes);
    const glTFMesh = {
      primitives: [
        {
          attributes: accessorIndices,
          mode: 0
          // GL.POINTS
        }
      ]
    };
    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(imageData, mimeTypeOpt) {
    const metadata = getBinaryImageMetadata(imageData);
    const mimeType = mimeTypeOpt || (metadata == null ? void 0 : metadata.mimeType);
    const bufferViewIndex = this.addBufferView(imageData);
    const glTFImage = {
      bufferView: bufferViewIndex,
      mimeType
    };
    this.json.images = this.json.images || [];
    this.json.images.push(glTFImage);
    return this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(buffer, bufferIndex = 0, byteOffset = this.byteLength) {
    const byteLength = buffer.byteLength;
    assert4(Number.isFinite(byteLength));
    this.sourceBuffers = this.sourceBuffers || [];
    this.sourceBuffers.push(buffer);
    const glTFBufferView = {
      buffer: bufferIndex,
      // Write offset from the start of the binary body
      byteOffset,
      byteLength
    };
    this.byteLength += padToNBytes(byteLength, 4);
    this.json.bufferViews = this.json.bufferViews || [];
    this.json.bufferViews.push(glTFBufferView);
    return this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(bufferViewIndex, accessor) {
    const glTFAccessor = {
      bufferView: bufferViewIndex,
      // @ts-ignore
      type: getAccessorTypeFromSize(accessor.size),
      // @ts-ignore
      componentType: accessor.componentType,
      // @ts-ignore
      count: accessor.count,
      // @ts-ignore
      max: accessor.max,
      // @ts-ignore
      min: accessor.min
    };
    this.json.accessors = this.json.accessors || [];
    this.json.accessors.push(glTFAccessor);
    return this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(sourceBuffer, accessor = { size: 3 }) {
    const bufferViewIndex = this.addBufferView(sourceBuffer);
    let minMax = { min: accessor.min, max: accessor.max };
    if (!minMax.min || !minMax.max) {
      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);
    }
    const accessorDefaults = {
      // @ts-ignore
      size: accessor.size,
      componentType: getComponentTypeFromArray(sourceBuffer),
      // @ts-ignore
      count: Math.round(sourceBuffer.length / accessor.size),
      min: minMax.min,
      max: minMax.max
    };
    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(texture) {
    const { imageIndex } = texture;
    const glTFTexture = {
      source: imageIndex
    };
    this.json.textures = this.json.textures || [];
    this.json.textures.push(glTFTexture);
    return this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(pbrMaterialInfo) {
    this.json.materials = this.json.materials || [];
    this.json.materials.push(pbrMaterialInfo);
    return this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    var _a, _b;
    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);
    let dstByteOffset = 0;
    for (const sourceBuffer of this.sourceBuffers || []) {
      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);
    }
    if ((_b = (_a = this.json) == null ? void 0 : _a.buffers) == null ? void 0 : _b[0]) {
      this.json.buffers[0].byteLength = totalByteLength;
    } else {
      this.json.buffers = [{ byteLength: totalByteLength }];
    }
    this.gltf.binary = arrayBuffer;
    this.sourceBuffers = [arrayBuffer];
    this.gltf.buffers = [{ arrayBuffer, byteOffset: 0, byteLength: arrayBuffer.byteLength }];
  }
  // PRIVATE
  _removeStringFromArray(array, string) {
    let found = true;
    while (found) {
      const index = array.indexOf(string);
      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes(attributes = {}) {
    const result = {};
    for (const attributeKey in attributes) {
      const attributeData = attributes[attributeKey];
      const attrName = this._getGltfAttributeName(attributeKey);
      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);
      result[attrName] = accessor;
    }
    return result;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(indices) {
    return this.addBinaryBuffer(indices, { size: 1 });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(attributeName) {
    switch (attributeName.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return attributeName;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(buffer, size) {
    const result = { min: null, max: null };
    if (buffer.length < size) {
      return result;
    }
    result.min = [];
    result.max = [];
    const initValues = buffer.subarray(0, size);
    for (const value of initValues) {
      result.min.push(value);
      result.max.push(value);
    }
    for (let index = size; index < buffer.length; index += size) {
      for (let componentIndex = 0; componentIndex < size; componentIndex++) {
        result.min[0 + componentIndex] = Math.min(
          // @ts-ignore
          result.min[0 + componentIndex],
          buffer[index + componentIndex]
        );
        result.max[0 + componentIndex] = Math.max(
          // @ts-ignore
          result.max[0 + componentIndex],
          buffer[index + componentIndex]
        );
      }
    }
    return result;
  }
};

// node_modules/@loaders.gl/gltf/dist/lib/extensions/utils/3d-tiles-utils.js
function emod(n) {
  return (n % 1 + 1) % 1;
}
var ATTRIBUTE_TYPE_TO_COMPONENTS3 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
};
var ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY3 = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
var ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2 = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function getArrayElementByteSize(attributeType, componentType) {
  return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType] * ATTRIBUTE_TYPE_TO_COMPONENTS3[attributeType];
}
function getOffsetsForProperty(scenegraph, bufferViewIndex, offsetType, numberOfElements) {
  if (offsetType !== "UINT8" && offsetType !== "UINT16" && offsetType !== "UINT32" && offsetType !== "UINT64") {
    return null;
  }
  const arrayOffsetsBytes = scenegraph.getTypedArrayForBufferView(bufferViewIndex);
  const arrayOffsets = convertRawBufferToMetadataArray(
    arrayOffsetsBytes,
    "SCALAR",
    // offsets consist of ONE component
    offsetType,
    numberOfElements + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  if (arrayOffsets instanceof BigInt64Array || arrayOffsets instanceof BigUint64Array) {
    return null;
  }
  return arrayOffsets;
}
function convertRawBufferToMetadataArray(data, attributeType, componentType, elementCount = 1) {
  const numberOfComponents = ATTRIBUTE_TYPE_TO_COMPONENTS3[attributeType];
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY3[componentType];
  const size = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE2[componentType];
  const length5 = elementCount * numberOfComponents;
  const byteLength = length5 * size;
  let buffer = data.buffer;
  let offset = data.byteOffset;
  if (offset % size !== 0) {
    const bufferArray = new Uint8Array(buffer);
    buffer = bufferArray.slice(offset, offset + byteLength).buffer;
    offset = 0;
  }
  return new ArrayType(buffer, offset, length5);
}
function getPrimitiveTextureData(scenegraph, textureInfo, primitive) {
  var _a, _b, _c, _d, _e;
  const texCoordAccessorKey = `TEXCOORD_${textureInfo.texCoord || 0}`;
  const texCoordAccessorIndex = primitive.attributes[texCoordAccessorKey];
  const textureCoordinates = scenegraph.getTypedArrayForAccessor(texCoordAccessorIndex);
  const json = scenegraph.gltf.json;
  const textureIndex = textureInfo.index;
  const imageIndex = (_b = (_a = json.textures) == null ? void 0 : _a[textureIndex]) == null ? void 0 : _b.source;
  if (typeof imageIndex !== "undefined") {
    const mimeType = (_d = (_c = json.images) == null ? void 0 : _c[imageIndex]) == null ? void 0 : _d.mimeType;
    const parsedImage = (_e = scenegraph.gltf.images) == null ? void 0 : _e[imageIndex];
    if (parsedImage && typeof parsedImage.width !== "undefined") {
      const textureData = [];
      for (let index = 0; index < textureCoordinates.length; index += 2) {
        const value = getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, textureInfo.channels);
        textureData.push(value);
      }
      return textureData;
    }
  }
  return [];
}
function primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTable, primitive) {
  if (!(propertyData == null ? void 0 : propertyData.length)) {
    return;
  }
  const featureIndices = [];
  for (const texelData of propertyData) {
    let index = featureTable.findIndex((item) => item === texelData);
    if (index === -1) {
      index = featureTable.push(texelData) - 1;
    }
    featureIndices.push(index);
  }
  const typedArray = new Uint32Array(featureIndices);
  const bufferIndex = scenegraph.gltf.buffers.push({
    arrayBuffer: typedArray.buffer,
    byteOffset: typedArray.byteOffset,
    byteLength: typedArray.byteLength
  }) - 1;
  const bufferViewIndex = scenegraph.addBufferView(typedArray, bufferIndex, 0);
  const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {
    size: 1,
    componentType: getComponentTypeFromArray(typedArray),
    count: typedArray.length
  });
  primitive.attributes[attributeName] = accessorIndex;
}
function getImageValueByCoordinates(parsedImage, mimeType, textureCoordinates, index, channels = [0]) {
  const CHANNELS_MAP = {
    r: { offset: 0, shift: 0 },
    g: { offset: 1, shift: 8 },
    b: { offset: 2, shift: 16 },
    a: { offset: 3, shift: 24 }
  };
  const u2 = textureCoordinates[index];
  const v2 = textureCoordinates[index + 1];
  let components = 1;
  if (mimeType && (mimeType.indexOf("image/jpeg") !== -1 || mimeType.indexOf("image/png") !== -1))
    components = 4;
  const offset = coordinatesToOffset(u2, v2, parsedImage, components);
  let value = 0;
  for (const c2 of channels) {
    const map = typeof c2 === "number" ? Object.values(CHANNELS_MAP)[c2] : CHANNELS_MAP[c2];
    const imageOffset = offset + map.offset;
    const imageData = getImageData(parsedImage);
    if (imageData.data.length <= imageOffset) {
      throw new Error(`${imageData.data.length} <= ${imageOffset}`);
    }
    const imageValue = imageData.data[imageOffset];
    value |= imageValue << map.shift;
  }
  return value;
}
function coordinatesToOffset(u2, v2, parsedImage, componentsCount = 1) {
  const w2 = parsedImage.width;
  const iX = emod(u2) * (w2 - 1);
  const indX = Math.round(iX);
  const h = parsedImage.height;
  const iY = emod(v2) * (h - 1);
  const indY = Math.round(iY);
  const components = parsedImage.components ? parsedImage.components : componentsCount;
  const offset = (indY * w2 + indX) * components;
  return offset;
}
function parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, valueSize) {
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const arrayOffset = arrayOffsets[index];
    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
      break;
    }
    const typedArrayOffset = arrayOffset / valueSize;
    const elementCount = arrayByteSize / valueSize;
    attributeValueArray.push(valuesData.slice(typedArrayOffset, typedArrayOffset + elementCount));
  }
  return attributeValueArray;
}
function parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount) {
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const elementOffset = index * arrayCount;
    attributeValueArray.push(valuesData.slice(elementOffset, elementOffset + arrayCount));
  }
  return attributeValueArray;
}
function getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets) {
  if (arrayOffsets) {
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  }
  if (stringOffsets) {
    const stringsArray = [];
    const textDecoder = new TextDecoder("utf8");
    let stringOffset = 0;
    for (let index = 0; index < numberOfElements; index++) {
      const stringByteSize = stringOffsets[index + 1] - stringOffsets[index];
      if (stringByteSize + stringOffset <= valuesDataBytes.length) {
        const stringData = valuesDataBytes.subarray(stringOffset, stringByteSize + stringOffset);
        const stringAttribute = textDecoder.decode(stringData);
        stringsArray.push(stringAttribute);
        stringOffset += stringByteSize;
      }
    }
    return stringsArray;
  }
  return [];
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_mesh_features.js
var EXT_MESH_FEATURES_NAME = "EXT_mesh_features";
var name = EXT_MESH_FEATURES_NAME;
async function decode(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtMeshFeatures(scenegraph, options);
}
function encode(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  encodeExtMeshFeatures(scenegraph, options);
  scenegraph.createBinaryChunk();
  return scenegraph.gltf;
}
function decodeExtMeshFeatures(scenegraph, options) {
  const json = scenegraph.gltf.json;
  if (!json.meshes) {
    return;
  }
  for (const mesh of json.meshes) {
    for (const primitive of mesh.primitives) {
      processMeshPrimitiveFeatures(scenegraph, primitive, options);
    }
  }
}
function processMeshPrimitiveFeatures(scenegraph, primitive, options) {
  var _a, _b, _c;
  if (!((_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.loadBuffers)) {
    return;
  }
  const extension = (_b = primitive.extensions) == null ? void 0 : _b[EXT_MESH_FEATURES_NAME];
  const featureIds = extension == null ? void 0 : extension.featureIds;
  if (!featureIds) {
    return;
  }
  for (const featureId of featureIds) {
    let featureIdData;
    if (typeof featureId.attribute !== "undefined") {
      const accessorKey = `_FEATURE_ID_${featureId.attribute}`;
      const accessorIndex = primitive.attributes[accessorKey];
      featureIdData = scenegraph.getTypedArrayForAccessor(accessorIndex);
    } else if (typeof featureId.texture !== "undefined" && ((_c = options == null ? void 0 : options.gltf) == null ? void 0 : _c.loadImages)) {
      featureIdData = getPrimitiveTextureData(scenegraph, featureId.texture, primitive);
    } else {
      featureIdData = [];
    }
    featureId.data = featureIdData;
  }
}
function encodeExtMeshFeatures(scenegraph, options) {
  const meshes = scenegraph.gltf.json.meshes;
  if (!meshes) {
    return;
  }
  for (const mesh of meshes) {
    for (const primitive of mesh.primitives) {
      encodeExtMeshFeaturesForPrimitive(scenegraph, primitive);
    }
  }
}
function createExtMeshFeatures(scenegraph, primitive, featureIdArray, propertyTableIndex) {
  if (!primitive.extensions) {
    primitive.extensions = {};
  }
  let extension = primitive.extensions[EXT_MESH_FEATURES_NAME];
  if (!extension) {
    extension = { featureIds: [] };
    primitive.extensions[EXT_MESH_FEATURES_NAME] = extension;
  }
  const { featureIds } = extension;
  const featureId = {
    featureCount: featureIdArray.length,
    propertyTable: propertyTableIndex,
    data: featureIdArray
  };
  featureIds.push(featureId);
  scenegraph.addObjectExtension(primitive, EXT_MESH_FEATURES_NAME, extension);
}
function encodeExtMeshFeaturesForPrimitive(scenegraph, primitive) {
  var _a;
  const extension = (_a = primitive.extensions) == null ? void 0 : _a[EXT_MESH_FEATURES_NAME];
  if (!extension) {
    return;
  }
  const featureIds = extension.featureIds;
  featureIds.forEach((featureId, elementIndex) => {
    if (featureId.data) {
      const { accessorKey, index } = createAccessorKey(primitive.attributes);
      const typedArray = new Uint32Array(featureId.data);
      featureIds[elementIndex] = {
        featureCount: typedArray.length,
        propertyTable: featureId.propertyTable,
        attribute: index
      };
      scenegraph.gltf.buffers.push({
        arrayBuffer: typedArray.buffer,
        byteOffset: typedArray.byteOffset,
        byteLength: typedArray.byteLength
      });
      const bufferViewIndex = scenegraph.addBufferView(typedArray);
      const accessorIndex = scenegraph.addAccessor(bufferViewIndex, {
        size: 1,
        componentType: getComponentTypeFromArray(typedArray),
        count: typedArray.length
      });
      primitive.attributes[accessorKey] = accessorIndex;
    }
  });
}
function createAccessorKey(attributes) {
  const prefix = "_FEATURE_ID_";
  const attrs = Object.keys(attributes).filter((item) => item.indexOf(prefix) === 0);
  let max3 = -1;
  for (const a3 of attrs) {
    const n = Number(a3.substring(prefix.length));
    if (n > max3) {
      max3 = n;
    }
  }
  max3++;
  const accessorKey = `${prefix}${max3}`;
  return { accessorKey, index: max3 };
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_structural_metadata.js
var EXT_structural_metadata_exports = {};
__export(EXT_structural_metadata_exports, {
  createExtStructuralMetadata: () => createExtStructuralMetadata,
  decode: () => decode2,
  encode: () => encode2,
  name: () => name2
});
var EXT_STRUCTURAL_METADATA_NAME = "EXT_structural_metadata";
var name2 = EXT_STRUCTURAL_METADATA_NAME;
async function decode2(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtStructuralMetadata(scenegraph, options);
}
function encode2(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  encodeExtStructuralMetadata(scenegraph, options);
  scenegraph.createBinaryChunk();
  return scenegraph.gltf;
}
function decodeExtStructuralMetadata(scenegraph, options) {
  var _a, _b;
  if (!((_a = options.gltf) == null ? void 0 : _a.loadBuffers)) {
    return;
  }
  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    return;
  }
  if ((_b = options.gltf) == null ? void 0 : _b.loadImages) {
    decodePropertyTextures(scenegraph, extension);
  }
  decodePropertyTables(scenegraph, extension);
}
function decodePropertyTextures(scenegraph, extension) {
  const propertyTextures = extension.propertyTextures;
  const json = scenegraph.gltf.json;
  if (propertyTextures && json.meshes) {
    for (const mesh of json.meshes) {
      for (const primitive of mesh.primitives) {
        processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension);
      }
    }
  }
}
function decodePropertyTables(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const propertyTables = extension.propertyTables;
  if (schemaClasses && propertyTables) {
    for (const schemaName in schemaClasses) {
      const propertyTable = findPropertyTableByClass(propertyTables, schemaName);
      if (propertyTable) {
        processPropertyTable(scenegraph, schema, propertyTable);
      }
    }
  }
}
function findPropertyTableByClass(propertyTables, schemaClassName) {
  for (const propertyTable of propertyTables) {
    if (propertyTable.class === schemaClassName) {
      return propertyTable;
    }
  }
  return null;
}
function processPrimitivePropertyTextures(scenegraph, propertyTextures, primitive, extension) {
  var _a;
  if (!propertyTextures) {
    return;
  }
  const primitiveExtension = (_a = primitive.extensions) == null ? void 0 : _a[EXT_STRUCTURAL_METADATA_NAME];
  const primitivePropertyTextureIndices = primitiveExtension == null ? void 0 : primitiveExtension.propertyTextures;
  if (!primitivePropertyTextureIndices) {
    return;
  }
  for (const primitivePropertyTextureIndex of primitivePropertyTextureIndices) {
    const propertyTexture = propertyTextures[primitivePropertyTextureIndex];
    processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension);
  }
}
function processPrimitivePropertyTexture(scenegraph, propertyTexture, primitive, extension) {
  var _a;
  if (!propertyTexture.properties) {
    return;
  }
  if (!extension.dataAttributeNames) {
    extension.dataAttributeNames = [];
  }
  const className = propertyTexture.class;
  for (const propertyName in propertyTexture.properties) {
    const attributeName = `${className}_${propertyName}`;
    const textureInfoTopLevel = (_a = propertyTexture.properties) == null ? void 0 : _a[propertyName];
    if (!textureInfoTopLevel) {
      continue;
    }
    if (!textureInfoTopLevel.data) {
      textureInfoTopLevel.data = [];
    }
    const featureTextureTable = textureInfoTopLevel.data;
    const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
    if (propertyData === null) {
      continue;
    }
    primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
    textureInfoTopLevel.data = featureTextureTable;
    extension.dataAttributeNames.push(attributeName);
  }
}
function processPropertyTable(scenegraph, schema, propertyTable) {
  var _a, _b;
  const schemaClass = (_a = schema.classes) == null ? void 0 : _a[propertyTable.class];
  if (!schemaClass) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
  }
  const numberOfElements = propertyTable.count;
  for (const propertyName in schemaClass.properties) {
    const classProperty = schemaClass.properties[propertyName];
    const propertyTableProperty = (_b = propertyTable.properties) == null ? void 0 : _b[propertyName];
    if (propertyTableProperty) {
      const data = getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
      propertyTableProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty) {
  let data = [];
  const valuesBufferView = propertyTableProperty.values;
  const valuesDataBytes = scenegraph.getTypedArrayForBufferView(valuesBufferView);
  const arrayOffsets = getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements);
  const stringOffsets = getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements);
  switch (classProperty.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      data = getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
      break;
    }
    case "BOOLEAN": {
      throw new Error(`Not implemented - classProperty.type=${classProperty.type}`);
    }
    case "STRING": {
      data = getPropertyDataString(numberOfElements, valuesDataBytes, arrayOffsets, stringOffsets);
      break;
    }
    case "ENUM": {
      data = getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${classProperty.type}`);
  }
  return data;
}
function getArrayOffsetsForProperty(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (classProperty.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof classProperty.count === "undefined" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof propertyTableProperty.arrayOffsets !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.arrayOffsets, propertyTableProperty.arrayOffsetType || "UINT32", numberOfElements);
  }
  return null;
}
function getStringOffsetsForProperty(scenegraph, propertyTableProperty, numberOfElements) {
  if (typeof propertyTableProperty.stringOffsets !== "undefined") {
    return getOffsetsForProperty(scenegraph, propertyTableProperty.stringOffsets, propertyTableProperty.stringOffsetType || "UINT32", numberOfElements);
  }
  return null;
}
function getPropertyDataNumeric(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const isArray = classProperty.array;
  const arrayCount = classProperty.count;
  const elementSize = getArrayElementByteSize(classProperty.type, classProperty.componentType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  let valuesData;
  if (classProperty.componentType) {
    valuesData = convertRawBufferToMetadataArray(
      valuesDataBytes,
      classProperty.type,
      // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
      classProperty.componentType,
      elementCount
    );
  } else {
    valuesData = valuesDataBytes;
  }
  if (isArray) {
    if (arrayOffsets) {
      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
    }
    if (arrayCount) {
      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
    }
    return [];
  }
  return valuesData;
}
function getPropertyDataENUM(schema, classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  var _a;
  const enumType = classProperty.enumType;
  if (!enumType) {
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  }
  const enumEntry = (_a = schema.enums) == null ? void 0 : _a[enumType];
  if (!enumEntry) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${enumType}`);
  }
  const enumValueType = enumEntry.valueType || "UINT16";
  const elementSize = getArrayElementByteSize(classProperty.type, enumValueType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  let valuesData = convertRawBufferToMetadataArray(valuesDataBytes, classProperty.type, enumValueType, elementCount);
  if (!valuesData) {
    valuesData = valuesDataBytes;
  }
  if (classProperty.array) {
    if (arrayOffsets) {
      return parseVariableLengthArrayENUM({
        valuesData,
        numberOfElements,
        arrayOffsets,
        valuesDataBytesLength: valuesDataBytes.length,
        elementSize,
        enumEntry
      });
    }
    const arrayCount = classProperty.count;
    if (arrayCount) {
      return parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry);
    }
    return [];
  }
  return getEnumsArray(valuesData, 0, numberOfElements, enumEntry);
}
function parseVariableLengthArrayENUM(params) {
  const { valuesData, numberOfElements, arrayOffsets, valuesDataBytesLength, elementSize, enumEntry } = params;
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const arrayOffset = arrayOffsets[index];
    const arrayByteSize = arrayOffsets[index + 1] - arrayOffsets[index];
    if (arrayByteSize + arrayOffset > valuesDataBytesLength) {
      break;
    }
    const typedArrayOffset = arrayOffset / elementSize;
    const elementCount = arrayByteSize / elementSize;
    const array = getEnumsArray(valuesData, typedArrayOffset, elementCount, enumEntry);
    attributeValueArray.push(array);
  }
  return attributeValueArray;
}
function parseFixedLengthArrayENUM(valuesData, numberOfElements, arrayCount, enumEntry) {
  const attributeValueArray = [];
  for (let index = 0; index < numberOfElements; index++) {
    const elementOffset = arrayCount * index;
    const array = getEnumsArray(valuesData, elementOffset, arrayCount, enumEntry);
    attributeValueArray.push(array);
  }
  return attributeValueArray;
}
function getEnumsArray(valuesData, offset, count, enumEntry) {
  const array = [];
  for (let i = 0; i < count; i++) {
    if (valuesData instanceof BigInt64Array || valuesData instanceof BigUint64Array) {
      array.push("");
    } else {
      const value = valuesData[offset + i];
      const enumObject = getEnumByValue(enumEntry, value);
      if (enumObject) {
        array.push(enumObject.name);
      } else {
        array.push("");
      }
    }
  }
  return array;
}
function getEnumByValue(enumEntry, value) {
  for (const enumValue of enumEntry.values) {
    if (enumValue.value === value) {
      return enumValue;
    }
  }
  return null;
}
var SCHEMA_CLASS_ID_DEFAULT = "schemaClassId";
function encodeExtStructuralMetadata(scenegraph, options) {
  var _a, _b;
  const extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    return;
  }
  if (extension.propertyTables) {
    for (const table of extension.propertyTables) {
      const classId = table.class;
      const schemaClass = (_b = (_a = extension.schema) == null ? void 0 : _a.classes) == null ? void 0 : _b[classId];
      if (table.properties && schemaClass) {
        encodeProperties(table, schemaClass, scenegraph);
      }
    }
  }
}
function encodeProperties(table, schemaClass, scenegraph) {
  for (const propertyName in table.properties) {
    const data = table.properties[propertyName].data;
    if (data) {
      const classProperty = schemaClass.properties[propertyName];
      if (classProperty) {
        const tableProperty = createPropertyTableProperty(data, classProperty, scenegraph);
        table.properties[propertyName] = tableProperty;
      }
    }
  }
}
function createExtStructuralMetadata(scenegraph, propertyAttributes, classId = SCHEMA_CLASS_ID_DEFAULT) {
  let extension = scenegraph.getExtension(EXT_STRUCTURAL_METADATA_NAME);
  if (!extension) {
    extension = scenegraph.addExtension(EXT_STRUCTURAL_METADATA_NAME);
  }
  extension.schema = createSchema(propertyAttributes, classId, extension.schema);
  const table = createPropertyTable(propertyAttributes, classId, extension.schema);
  if (!extension.propertyTables) {
    extension.propertyTables = [];
  }
  return extension.propertyTables.push(table) - 1;
}
function createSchema(propertyAttributes, classId, schemaToUpdate) {
  const schema = schemaToUpdate ?? {
    id: "schema_id"
  };
  const schemaClass = {
    properties: {}
  };
  for (const attribute of propertyAttributes) {
    const classProperty = {
      type: attribute.elementType,
      componentType: attribute.componentType
    };
    schemaClass.properties[attribute.name] = classProperty;
  }
  schema.classes = {};
  schema.classes[classId] = schemaClass;
  return schema;
}
function createPropertyTable(propertyAttributes, classId, schema) {
  var _a;
  const table = {
    class: classId,
    count: 0
  };
  let count = 0;
  const schemaClass = (_a = schema.classes) == null ? void 0 : _a[classId];
  for (const attribute of propertyAttributes) {
    if (count === 0) {
      count = attribute.values.length;
    }
    if (count !== attribute.values.length && attribute.values.length) {
      throw new Error("Illegal values in attributes");
    }
    const classProperty = schemaClass == null ? void 0 : schemaClass.properties[attribute.name];
    if (classProperty) {
      if (!table.properties) {
        table.properties = {};
      }
      table.properties[attribute.name] = { values: 0, data: attribute.values };
    }
  }
  table.count = count;
  return table;
}
function createPropertyTableProperty(values, classProperty, scenegraph) {
  const prop = { values: 0 };
  if (classProperty.type === "STRING") {
    const { stringData, stringOffsets } = createPropertyDataString(values);
    prop.stringOffsets = createBufferView(stringOffsets, scenegraph);
    prop.values = createBufferView(stringData, scenegraph);
  } else if (classProperty.type === "SCALAR" && classProperty.componentType) {
    const data = createPropertyDataScalar(values, classProperty.componentType);
    prop.values = createBufferView(data, scenegraph);
  }
  return prop;
}
var COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function createPropertyDataScalar(array, componentType) {
  const numberArray = [];
  for (const value of array) {
    numberArray.push(Number(value));
  }
  const Construct = COMPONENT_TYPE_TO_ARRAY_CONSTRUCTOR[componentType];
  if (!Construct) {
    throw new Error("Illegal component type");
  }
  return new Construct(numberArray);
}
function createPropertyDataString(strings) {
  const utf8Encode = new TextEncoder();
  const arr = [];
  let len4 = 0;
  for (const str5 of strings) {
    const uint8Array = utf8Encode.encode(str5);
    len4 += uint8Array.length;
    arr.push(uint8Array);
  }
  const strArray = new Uint8Array(len4);
  const strOffsets = [];
  let offset = 0;
  for (const str5 of arr) {
    strArray.set(str5, offset);
    strOffsets.push(offset);
    offset += str5.length;
  }
  strOffsets.push(offset);
  const stringOffsetsTypedArray = new Uint32Array(strOffsets);
  return { stringData: strArray, stringOffsets: stringOffsetsTypedArray };
}
function createBufferView(typedArray, scenegraph) {
  scenegraph.gltf.buffers.push({
    arrayBuffer: typedArray.buffer,
    byteOffset: typedArray.byteOffset,
    byteLength: typedArray.byteLength
  });
  return scenegraph.addBufferView(typedArray);
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/EXT_feature_metadata.js
var EXT_feature_metadata_exports = {};
__export(EXT_feature_metadata_exports, {
  decode: () => decode3,
  name: () => name3
});
var EXT_FEATURE_METADATA_NAME = "EXT_feature_metadata";
var name3 = EXT_FEATURE_METADATA_NAME;
async function decode3(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  decodeExtFeatureMetadata(scenegraph, options);
}
function decodeExtFeatureMetadata(scenegraph, options) {
  var _a, _b;
  if (!((_a = options.gltf) == null ? void 0 : _a.loadBuffers)) {
    return;
  }
  const extension = scenegraph.getExtension(EXT_FEATURE_METADATA_NAME);
  if (!extension) {
    return;
  }
  if ((_b = options.gltf) == null ? void 0 : _b.loadImages) {
    decodePropertyTextures2(scenegraph, extension);
  }
  decodePropertyTables2(scenegraph, extension);
}
function decodePropertyTextures2(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const { featureTextures } = extension;
  if (schemaClasses && featureTextures) {
    for (const schemaName in schemaClasses) {
      const schemaClass = schemaClasses[schemaName];
      const featureTexture = findFeatureTextureByClass(featureTextures, schemaName);
      if (featureTexture) {
        handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass);
      }
    }
  }
}
function decodePropertyTables2(scenegraph, extension) {
  const schema = extension.schema;
  if (!schema) {
    return;
  }
  const schemaClasses = schema.classes;
  const propertyTables = extension.featureTables;
  if (schemaClasses && propertyTables) {
    for (const schemaName in schemaClasses) {
      const propertyTable = findPropertyTableByClass2(propertyTables, schemaName);
      if (propertyTable) {
        processPropertyTable2(scenegraph, schema, propertyTable);
      }
    }
  }
}
function findPropertyTableByClass2(propertyTables, schemaClassName) {
  for (const propertyTableName in propertyTables) {
    const propertyTable = propertyTables[propertyTableName];
    if (propertyTable.class === schemaClassName) {
      return propertyTable;
    }
  }
  return null;
}
function findFeatureTextureByClass(featureTextures, schemaClassName) {
  for (const featureTexturesName in featureTextures) {
    const featureTable = featureTextures[featureTexturesName];
    if (featureTable.class === schemaClassName) {
      return featureTable;
    }
  }
  return null;
}
function processPropertyTable2(scenegraph, schema, propertyTable) {
  var _a, _b;
  if (!propertyTable.class) {
    return;
  }
  const schemaClass = (_a = schema.classes) == null ? void 0 : _a[propertyTable.class];
  if (!schemaClass) {
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${propertyTable.class}`);
  }
  const numberOfElements = propertyTable.count;
  for (const propertyName in schemaClass.properties) {
    const classProperty = schemaClass.properties[propertyName];
    const propertyTableProperty = (_b = propertyTable.properties) == null ? void 0 : _b[propertyName];
    if (propertyTableProperty) {
      const data = getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfElements, propertyTableProperty);
      propertyTableProperty.data = data;
    }
  }
}
function handleFeatureTextureProperties(scenegraph, featureTexture, schemaClass) {
  var _a;
  const attributeName = featureTexture.class;
  for (const propertyName in schemaClass.properties) {
    const featureTextureProperty = (_a = featureTexture == null ? void 0 : featureTexture.properties) == null ? void 0 : _a[propertyName];
    if (featureTextureProperty) {
      const data = getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName);
      featureTextureProperty.data = data;
    }
  }
}
function getPropertyDataFromBinarySource2(scenegraph, schema, classProperty, numberOfFeatures, featureTableProperty) {
  let data = [];
  const bufferView = featureTableProperty.bufferView;
  const dataArray = scenegraph.getTypedArrayForBufferView(bufferView);
  const arrayOffsets = getArrayOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
  const stringOffsets = getStringOffsetsForProperty2(scenegraph, classProperty, featureTableProperty, numberOfFeatures);
  if (classProperty.type === "STRING" || classProperty.componentType === "STRING") {
    data = getPropertyDataString(numberOfFeatures, dataArray, arrayOffsets, stringOffsets);
  } else if (isNumericProperty(classProperty)) {
    data = getPropertyDataNumeric2(classProperty, numberOfFeatures, dataArray, arrayOffsets);
  }
  return data;
}
function getArrayOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (classProperty.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof classProperty.componentCount === "undefined" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof propertyTableProperty.arrayOffsetBufferView !== "undefined") {
    return getOffsetsForProperty(
      scenegraph,
      propertyTableProperty.arrayOffsetBufferView,
      propertyTableProperty.offsetType || "UINT32",
      // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
      numberOfElements
    );
  }
  return null;
}
function getStringOffsetsForProperty2(scenegraph, classProperty, propertyTableProperty, numberOfElements) {
  if (typeof propertyTableProperty.stringOffsetBufferView !== "undefined") {
    return getOffsetsForProperty(
      scenegraph,
      propertyTableProperty.stringOffsetBufferView,
      propertyTableProperty.offsetType || "UINT32",
      // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
      numberOfElements
    );
  }
  return null;
}
function isNumericProperty(schemaProperty) {
  const types = [
    "UINT8",
    "INT16",
    "UINT16",
    "INT32",
    "UINT32",
    "INT64",
    "UINT64",
    "FLOAT32",
    "FLOAT64"
  ];
  return types.includes(schemaProperty.type) || typeof schemaProperty.componentType !== "undefined" && types.includes(schemaProperty.componentType);
}
function getPropertyDataNumeric2(classProperty, numberOfElements, valuesDataBytes, arrayOffsets) {
  const isArray = classProperty.type === "ARRAY";
  const arrayCount = classProperty.componentCount;
  const attributeType = "SCALAR";
  const componentType = classProperty.componentType || classProperty.type;
  const elementSize = getArrayElementByteSize(attributeType, componentType);
  const elementCount = valuesDataBytes.byteLength / elementSize;
  const valuesData = convertRawBufferToMetadataArray(valuesDataBytes, attributeType, componentType, elementCount);
  if (isArray) {
    if (arrayOffsets) {
      return parseVariableLengthArrayNumeric(valuesData, numberOfElements, arrayOffsets, valuesDataBytes.length, elementSize);
    }
    if (arrayCount) {
      return parseFixedLengthArrayNumeric(valuesData, numberOfElements, arrayCount);
    }
    return [];
  }
  return valuesData;
}
function getPropertyDataFromTexture(scenegraph, featureTextureProperty, attributeName) {
  const json = scenegraph.gltf.json;
  if (!json.meshes) {
    return [];
  }
  const featureTextureTable = [];
  for (const mesh of json.meshes) {
    for (const primitive of mesh.primitives) {
      processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive);
    }
  }
  return featureTextureTable;
}
function processPrimitiveTextures(scenegraph, attributeName, featureTextureProperty, featureTextureTable, primitive) {
  const textureInfoTopLevel = {
    channels: featureTextureProperty.channels,
    ...featureTextureProperty.texture
  };
  const propertyData = getPrimitiveTextureData(scenegraph, textureInfoTopLevel, primitive);
  if (!propertyData) {
    return;
  }
  primitivePropertyDataToAttributes(scenegraph, attributeName, propertyData, featureTextureTable, primitive);
}

// node_modules/@loaders.gl/gltf/dist/lib/utils/version.js
var VERSION5 = true ? "4.3.3" : "latest";

// node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-glb.js
var LITTLE_ENDIAN = true;
var MAGIC_glTF = 1735152710;
var GLB_FILE_HEADER_SIZE = 12;
var GLB_CHUNK_HEADER_SIZE = 8;
var GLB_CHUNK_TYPE_JSON = 1313821514;
var GLB_CHUNK_TYPE_BIN = 5130562;
var GLB_V1_CONTENT_FORMAT_JSON = 0;
var GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0;
var GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1;
function getMagicString(dataView, byteOffset = 0) {
  return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}
function isGLB(arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const { magic = MAGIC_glTF } = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}
function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const type = getMagicString(dataView, byteOffset + 0);
  const version = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
  const byteLength = dataView.getUint32(byteOffset + 8, LITTLE_ENDIAN);
  Object.assign(glb, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset,
      // Byte offset into the initial arrayBuffer
      byteLength,
      hasBinChunk: false
    },
    type,
    version,
    json: {},
    binChunks: []
  });
  byteOffset += GLB_FILE_HEADER_SIZE;
  switch (glb.version) {
    case 1:
      return parseGLBV1(glb, dataView, byteOffset);
    case 2:
      return parseGLBV2(glb, dataView, byteOffset, options = {});
    default:
      throw new Error(`Invalid GLB version ${glb.version}. Only supports version 1 and 2.`);
  }
}
function parseGLBV1(glb, dataView, byteOffset) {
  assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  const contentLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN);
  const contentFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
  byteOffset += GLB_CHUNK_HEADER_SIZE;
  assert2(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);
  parseJSONChunk(glb, dataView, byteOffset, contentLength);
  byteOffset += contentLength;
  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);
  return byteOffset;
}
function parseGLBV2(glb, dataView, byteOffset, options) {
  assert2(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);
  parseGLBChunksSync(glb, dataView, byteOffset, options);
  return byteOffset + glb.header.byteLength;
}
function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LITTLE_ENDIAN);
    const chunkFormat = dataView.getUint32(byteOffset + 4, LITTLE_ENDIAN);
    byteOffset += GLB_CHUNK_HEADER_SIZE;
    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength);
        break;
      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
        if (!options.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength);
        }
        break;
      default:
        break;
    }
    byteOffset += padToNBytes(chunkLength, 4);
  }
  return byteOffset;
}
function parseJSONChunk(glb, dataView, byteOffset, chunkLength) {
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);
  const textDecoder = new TextDecoder("utf8");
  const jsonText = textDecoder.decode(jsonChunk);
  glb.json = JSON.parse(jsonText);
  return padToNBytes(chunkLength, 4);
}
function parseBINChunk(glb, dataView, byteOffset, chunkLength) {
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
    // TODO - copy, or create typed array view?
  });
  return padToNBytes(chunkLength, 4);
}

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/resolve-url.js
function resolveUrl(url, options) {
  const absolute = url.startsWith("data:") || url.startsWith("http:") || url.startsWith("https:");
  if (absolute) {
    return url;
  }
  const baseUrl = options.baseUri || options.uri;
  if (!baseUrl) {
    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);
  }
  return baseUrl.substr(0, baseUrl.lastIndexOf("/") + 1) + url;
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
var EXT_meshopt_compression_exports = {};
__export(EXT_meshopt_compression_exports, {
  decode: () => decode5,
  name: () => name4
});

// node_modules/@loaders.gl/gltf/dist/meshopt/meshopt-decoder.js
var wasm_base = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB";
var wasm_simd = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB";
var detector = new Uint8Array([
  0,
  97,
  115,
  109,
  1,
  0,
  0,
  0,
  1,
  4,
  1,
  96,
  0,
  0,
  3,
  3,
  2,
  0,
  0,
  5,
  3,
  1,
  0,
  1,
  12,
  1,
  0,
  10,
  22,
  2,
  12,
  0,
  65,
  0,
  65,
  0,
  65,
  0,
  252,
  10,
  0,
  0,
  11,
  7,
  0,
  65,
  0,
  253,
  15,
  26,
  11
]);
var wasmpack = new Uint8Array([
  32,
  0,
  65,
  253,
  3,
  1,
  2,
  34,
  4,
  106,
  6,
  5,
  11,
  8,
  7,
  20,
  13,
  33,
  12,
  16,
  128,
  9,
  116,
  64,
  19,
  113,
  127,
  15,
  10,
  21,
  22,
  14,
  255,
  66,
  24,
  54,
  136,
  107,
  18,
  23,
  192,
  26,
  114,
  118,
  132,
  17,
  77,
  101,
  130,
  144,
  27,
  87,
  131,
  44,
  45,
  74,
  156,
  154,
  70,
  167
]);
var FILTERS = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
};
var DECODERS = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function meshoptDecodeGltfBuffer(target, count, size, source, mode, filter = "NONE") {
  const instance = await loadWasmInstance();
  decode4(instance, instance.exports[DECODERS[mode]], target, count, size, source, instance.exports[FILTERS[filter || "NONE"]]);
}
var wasmPromise;
async function loadWasmInstance() {
  if (!wasmPromise) {
    wasmPromise = loadWasmModule();
  }
  return wasmPromise;
}
async function loadWasmModule() {
  let wasm3 = wasm_base;
  if (WebAssembly.validate(detector)) {
    wasm3 = wasm_simd;
    console.log("Warning: meshopt_decoder is using experimental SIMD support");
  }
  const result = await WebAssembly.instantiate(unpack(wasm3), {});
  await result.instance.exports.__wasm_call_ctors();
  return result.instance;
}
function unpack(data) {
  const result = new Uint8Array(data.length);
  for (let i = 0; i < data.length; ++i) {
    const ch = data.charCodeAt(i);
    result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;
  }
  let write = 0;
  for (let i = 0; i < data.length; ++i) {
    result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
  }
  return result.buffer.slice(0, write);
}
function decode4(instance, fun, target, count, size, source, filter) {
  const sbrk = instance.exports.sbrk;
  const count4 = count + 3 & ~3;
  const tp = sbrk(count4 * size);
  const sp = sbrk(source.length);
  const heap = new Uint8Array(instance.exports.memory.buffer);
  heap.set(source, sp);
  const res = fun(tp, count, size, sp, source.length);
  if (res === 0 && filter) {
    filter(tp, count4, size);
  }
  target.set(heap.subarray(tp, tp + count * size));
  sbrk(tp - sbrk(0));
  if (res !== 0) {
    throw new Error(`Malformed buffer data: ${res}`);
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_meshopt_compression.js
var EXT_MESHOPT_COMPRESSION = "EXT_meshopt_compression";
var name4 = EXT_MESHOPT_COMPRESSION;
async function decode5(gltfData, options) {
  var _a, _b;
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!((_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.decompressMeshes) || !((_b = options.gltf) == null ? void 0 : _b.loadBuffers)) {
    return;
  }
  const promises = [];
  for (const bufferViewIndex of gltfData.json.bufferViews || []) {
    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));
  }
  await Promise.all(promises);
  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);
}
async function decodeMeshoptBufferView(scenegraph, bufferView) {
  const meshoptExtension = scenegraph.getObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
  if (meshoptExtension) {
    const { byteOffset = 0, byteLength = 0, byteStride, count, mode, filter = "NONE", buffer: bufferIndex } = meshoptExtension;
    const buffer = scenegraph.gltf.buffers[bufferIndex];
    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);
    const result = new Uint8Array(scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer, bufferView.byteOffset, bufferView.byteLength);
    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);
    scenegraph.removeObjectExtension(bufferView, EXT_MESHOPT_COMPRESSION);
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/EXT_texture_webp.js
var EXT_texture_webp_exports = {};
__export(EXT_texture_webp_exports, {
  name: () => name5,
  preprocess: () => preprocess
});
var EXT_TEXTURE_WEBP = "EXT_texture_webp";
var name5 = EXT_TEXTURE_WEBP;
function preprocess(gltfData, options) {
  const scenegraph = new GLTFScenegraph(gltfData);
  if (!isImageFormatSupported("image/webp")) {
    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {
      throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);
    }
    return;
  }
  const { json } = scenegraph;
  for (const texture of json.textures || []) {
    const extension = scenegraph.getObjectExtension(texture, EXT_TEXTURE_WEBP);
    if (extension) {
      texture.source = extension.source;
    }
    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);
  }
  scenegraph.removeExtension(EXT_TEXTURE_WEBP);
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_basisu.js
var KHR_texture_basisu_exports = {};
__export(KHR_texture_basisu_exports, {
  name: () => name6,
  preprocess: () => preprocess2
});
var KHR_TEXTURE_BASISU = "KHR_texture_basisu";
var name6 = KHR_TEXTURE_BASISU;
function preprocess2(gltfData, options) {
  const scene = new GLTFScenegraph(gltfData);
  const { json } = scene;
  for (const texture of json.textures || []) {
    const extension = scene.getObjectExtension(texture, KHR_TEXTURE_BASISU);
    if (extension) {
      texture.source = extension.source;
      scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);
    }
  }
  scene.removeExtension(KHR_TEXTURE_BASISU);
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
var KHR_draco_mesh_compression_exports = {};
__export(KHR_draco_mesh_compression_exports, {
  decode: () => decode6,
  encode: () => encode3,
  name: () => name7,
  preprocess: () => preprocess3
});

// node_modules/@loaders.gl/draco/dist/lib/utils/version.js
var VERSION6 = true ? "4.3.3" : "latest";

// node_modules/@loaders.gl/draco/dist/draco-loader.js
var DracoLoader = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: VERSION6,
  worker: true,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: true,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly === "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};

// node_modules/@loaders.gl/draco/dist/lib/utils/get-draco-schema.js
function getDracoSchema(attributes, loaderData, indices) {
  const metadata = makeMetadata(loaderData.metadata);
  const fields = [];
  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const field = getArrowFieldFromAttribute(attributeName, attribute, namedLoaderDataAttributes[attributeName]);
    fields.push(field);
  }
  if (indices) {
    const indicesField = getArrowFieldFromAttribute("indices", indices);
    fields.push(indicesField);
  }
  return { fields, metadata };
}
function transformAttributesLoaderData(loaderData) {
  const result = {};
  for (const key in loaderData) {
    const dracoAttribute = loaderData[key];
    result[dracoAttribute.name || "undefined"] = dracoAttribute;
  }
  return result;
}
function getArrowFieldFromAttribute(attributeName, attribute, loaderData) {
  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : void 0;
  const field = deduceMeshField(attributeName, attribute, metadataMap);
  return field;
}
function makeMetadata(metadata) {
  Object.entries(metadata);
  const serializedMetadata = {};
  for (const key in metadata) {
    serializedMetadata[`${key}.string`] = JSON.stringify(metadata[key]);
  }
  return serializedMetadata;
}

// node_modules/@loaders.gl/draco/dist/lib/draco-parser.js
var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
};
var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
};
var INDEX_ITEM_SIZE = 4;
var DracoParser = class {
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(draco) {
    __publicField(this, "draco");
    __publicField(this, "decoder");
    __publicField(this, "metadataQuerier");
    this.draco = draco;
    this.decoder = new this.draco.Decoder();
    this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder);
    this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(arrayBuffer, options = {}) {
    const buffer = new this.draco.DecoderBuffer();
    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
    this._disableAttributeTransforms(options);
    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);
    const dracoGeometry = geometry_type === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let dracoStatus;
      switch (geometry_type) {
        case this.draco.TRIANGULAR_MESH:
          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry);
          break;
        case this.draco.POINT_CLOUD:
          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!dracoStatus.ok() || !dracoGeometry.ptr) {
        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;
        throw new Error(message);
      }
      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);
      const geometry = this._getMeshData(dracoGeometry, loaderData, options);
      const boundingBox = getMeshBoundingBox(geometry.attributes);
      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);
      const data = {
        loader: "draco",
        loaderData,
        header: {
          vertexCount: dracoGeometry.num_points(),
          boundingBox
        },
        ...geometry,
        schema
      };
      return data;
    } finally {
      this.draco.destroy(buffer);
      if (dracoGeometry) {
        this.draco.destroy(dracoGeometry);
      }
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(dracoGeometry, geometry_type, options) {
    const metadata = this._getTopLevelMetadata(dracoGeometry);
    const attributes = this._getDracoAttributes(dracoGeometry, options);
    return {
      geometry_type,
      num_attributes: dracoGeometry.num_attributes(),
      num_points: dracoGeometry.num_points(),
      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,
      metadata,
      attributes
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(dracoGeometry, options) {
    const dracoAttributes = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);
      dracoAttributes[dracoAttribute.unique_id()] = {
        unique_id: dracoAttribute.unique_id(),
        attribute_type: dracoAttribute.attribute_type(),
        data_type: dracoAttribute.data_type(),
        num_components: dracoAttribute.num_components(),
        byte_offset: dracoAttribute.byte_offset(),
        byte_stride: dracoAttribute.byte_stride(),
        normalized: dracoAttribute.normalized(),
        attribute_index: attributeId,
        metadata
      };
      const quantization = this._getQuantizationTransform(dracoAttribute, options);
      if (quantization) {
        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;
      }
      const octahedron = this._getOctahedronTransform(dracoAttribute, options);
      if (octahedron) {
        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;
      }
    }
    return dracoAttributes;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(dracoGeometry, loaderData, options) {
    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);
    const positionAttribute = attributes.POSITION;
    if (!positionAttribute) {
      throw new Error("DRACO: No position attribute found.");
    }
    if (dracoGeometry instanceof this.draco.Mesh) {
      switch (options.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes,
            indices: {
              value: this._getTriangleStripIndices(dracoGeometry),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes,
            indices: {
              value: this._getTriangleListIndices(dracoGeometry),
              size: 1
            }
          };
      }
    }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes
    };
  }
  _getMeshAttributes(loaderData, dracoGeometry, options) {
    const attributes = {};
    for (const loaderAttribute of Object.values(loaderData.attributes)) {
      const attributeName = this._deduceAttributeName(loaderAttribute, options);
      loaderAttribute.name = attributeName;
      const values = this._getAttributeValues(dracoGeometry, loaderAttribute);
      if (values) {
        const { value, size } = values;
        attributes[attributeName] = {
          value,
          size,
          byteOffset: loaderAttribute.byte_offset,
          byteStride: loaderAttribute.byte_stride,
          normalized: loaderAttribute.normalized
        };
      }
    }
    return attributes;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(dracoGeometry) {
    const numFaces = dracoGeometry.num_faces();
    const numIndices = numFaces * 3;
    const byteLength = numIndices * INDEX_ITEM_SIZE;
    const ptr = this.draco._malloc(byteLength);
    try {
      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();
    } finally {
      this.draco._free(ptr);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(dracoGeometry) {
    const dracoArray = new this.draco.DracoInt32Array();
    try {
      this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
      return getUint32Array(dracoArray);
    } finally {
      this.draco.destroy(dracoArray);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(dracoGeometry, attribute) {
    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];
    if (!TypedArrayCtor) {
      console.warn(`DRACO: Unsupported attribute type ${attribute.data_type}`);
      return null;
    }
    const numComponents = attribute.num_components;
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;
    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;
    const dataType = getDracoDataType(this.draco, TypedArrayCtor);
    let value;
    const ptr = this.draco._malloc(byteLength);
    try {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, dracoAttribute, dataType, byteLength, ptr);
      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();
    } finally {
      this.draco._free(ptr);
    }
    return { value, size: numComponents };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(attribute, options) {
    const uniqueId = attribute.unique_id;
    for (const [attributeName, attributeUniqueId] of Object.entries(options.extraAttributes || {})) {
      if (attributeUniqueId === uniqueId) {
        return attributeName;
      }
    }
    const thisAttributeType = attribute.attribute_type;
    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
      const attributeType = this.draco[dracoAttributeConstant];
      if (attributeType === thisAttributeType) {
        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
      }
    }
    const entryName = options.attributeNameEntry || "name";
    if (attribute.metadata[entryName]) {
      return attribute.metadata[entryName].string;
    }
    return `CUSTOM_ATTRIBUTE_${uniqueId}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(dracoGeometry) {
    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);
    return this._getDracoMetadata(dracoMetadata);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(dracoGeometry, attributeId) {
    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);
    return this._getDracoMetadata(dracoMetadata);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(dracoMetadata) {
    if (!dracoMetadata || !dracoMetadata.ptr) {
      return {};
    }
    const result = {};
    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);
    }
    return result;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(dracoMetadata, entryName) {
    const dracoArray = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);
      const intArray = getInt32Array(dracoArray);
      return {
        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
        intArray
      };
    } finally {
      this.draco.destroy(dracoArray);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(options) {
    const { quantizedAttributes = [], octahedronAttributes = [] } = options;
    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];
    for (const dracoAttributeName of skipAttributes) {
      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);
    }
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(dracoAttribute, options) {
    const { quantizedAttributes = [] } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);
    if (skip) {
      const transform2 = new this.draco.AttributeQuantizationTransform();
      try {
        if (transform2.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform2.quantization_bits(),
            range: transform2.range(),
            min_values: new Float32Array([1, 2, 3]).map((i) => transform2.min_value(i))
          };
        }
      } finally {
        this.draco.destroy(transform2);
      }
    }
    return null;
  }
  _getOctahedronTransform(dracoAttribute, options) {
    const { octahedronAttributes = [] } = options;
    const attribute_type = dracoAttribute.attribute_type();
    const octahedron = octahedronAttributes.map((type) => this.decoder[type]).includes(attribute_type);
    if (octahedron) {
      const transform2 = new this.draco.AttributeQuantizationTransform();
      try {
        if (transform2.InitFromAttribute(dracoAttribute)) {
          return {
            quantization_bits: transform2.quantization_bits()
          };
        }
      } finally {
        this.draco.destroy(transform2);
      }
    }
    return null;
  }
};
function getDracoDataType(draco, attributeType) {
  switch (attributeType) {
    case Float32Array:
      return draco.DT_FLOAT32;
    case Int8Array:
      return draco.DT_INT8;
    case Int16Array:
      return draco.DT_INT16;
    case Int32Array:
      return draco.DT_INT32;
    case Uint8Array:
      return draco.DT_UINT8;
    case Uint16Array:
      return draco.DT_UINT16;
    case Uint32Array:
      return draco.DT_UINT32;
    default:
      return draco.DT_INVALID;
  }
}
function getInt32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i = 0; i < numValues; i++) {
    intArray[i] = dracoArray.GetValue(i);
  }
  return intArray;
}
function getUint32Array(dracoArray) {
  const numValues = dracoArray.size();
  const intArray = new Int32Array(numValues);
  for (let i = 0; i < numValues; i++) {
    intArray[i] = dracoArray.GetValue(i);
  }
  return intArray;
}

// node_modules/@loaders.gl/draco/dist/lib/draco-module-loader.js
var DRACO_DECODER_VERSION = "1.5.6";
var DRACO_ENCODER_VERSION = "1.4.1";
var STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;
var DRACO_EXTERNAL_LIBRARIES = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
};
var DRACO_EXTERNAL_LIBRARY_URLS = {
  [DRACO_EXTERNAL_LIBRARIES.DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER}`,
  [DRACO_EXTERNAL_LIBRARIES.DECODER_WASM]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.DECODER_WASM}`,
  [DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER]: `${STATIC_DECODER_URL}/${DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER}`,
  [DRACO_EXTERNAL_LIBRARIES.ENCODER]: `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/${DRACO_EXTERNAL_LIBRARIES.ENCODER}`
};
var loadDecoderPromise;
async function loadDracoDecoderModule(options) {
  const modules = options.modules || {};
  if (modules.draco3d) {
    loadDecoderPromise || (loadDecoderPromise = modules.draco3d.createDecoderModule({}).then((draco) => {
      return { draco };
    }));
  } else {
    loadDecoderPromise || (loadDecoderPromise = loadDracoDecoder(options));
  }
  return await loadDecoderPromise;
}
async function loadDracoDecoder(options) {
  let DracoDecoderModule;
  let wasmBinary;
  switch (options.draco && options.draco.decoderType) {
    case "js":
      DracoDecoderModule = await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [DracoDecoderModule, wasmBinary] = await Promise.all([
        await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER),
        await loadLibrary(DRACO_EXTERNAL_LIBRARY_URLS[DRACO_EXTERNAL_LIBRARIES.DECODER_WASM], "draco", options, DRACO_EXTERNAL_LIBRARIES.DECODER_WASM)
      ]);
  }
  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;
  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
}
function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }
  return new Promise((resolve) => {
    DracoDecoderModule({
      ...options,
      onModuleLoaded: (draco) => resolve({ draco })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}

// node_modules/@loaders.gl/draco/dist/index.js
var DracoLoader2 = {
  ...DracoLoader,
  parse
};
async function parse(arrayBuffer, options) {
  const { draco } = await loadDracoDecoderModule(options);
  const dracoParser = new DracoParser(draco);
  try {
    return dracoParser.parseSync(arrayBuffer, options == null ? void 0 : options.draco);
  } finally {
    dracoParser.destroy();
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/gltf-utils/gltf-attribute-utils.js
function getGLTFAccessors(attributes) {
  const accessors = {};
  for (const name12 in attributes) {
    const attribute = attributes[name12];
    if (name12 !== "indices") {
      const glTFAccessor = getGLTFAccessor(attribute);
      accessors[name12] = glTFAccessor;
    }
  }
  return accessors;
}
function getGLTFAccessor(attribute) {
  const { buffer, size, count } = getAccessorData(attribute);
  const glTFAccessor = {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: buffer,
    size,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count,
    type: getAccessorTypeFromSize(size),
    componentType: getComponentTypeFromArray(buffer)
  };
  return glTFAccessor;
}
function getAccessorData(attribute) {
  let buffer = attribute;
  let size = 1;
  let count = 0;
  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }
  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }
    count = buffer.length / size;
  }
  return { buffer, size, count };
}
function toTypedArray(array, ArrayType, convertTypedArrays = false) {
  if (!array) {
    return null;
  }
  if (Array.isArray(array)) {
    return new ArrayType(array);
  }
  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }
  return array;
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_draco_mesh_compression.js
var KHR_DRACO_MESH_COMPRESSION = "KHR_draco_mesh_compression";
var name7 = KHR_DRACO_MESH_COMPRESSION;
function preprocess3(gltfData, options, context) {
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
    }
  }
}
async function decode6(gltfData, options, context) {
  var _a;
  if (!((_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.decompressMeshes)) {
    return;
  }
  const scenegraph = new GLTFScenegraph(gltfData);
  const promises = [];
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {
      promises.push(decompressPrimitive(scenegraph, primitive, options, context));
    }
  }
  await Promise.all(promises);
  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);
}
function encode3(gltfData, options = {}) {
  const scenegraph = new GLTFScenegraph(gltfData);
  for (const mesh of scenegraph.json.meshes || []) {
    compressMesh(mesh, options);
    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);
  }
}
async function decompressPrimitive(scenegraph, primitive, options, context) {
  const dracoExtension = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
  if (!dracoExtension) {
    return;
  }
  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);
  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset);
  const dracoOptions = { ...options };
  delete dracoOptions["3d-tiles"];
  const decodedData = await parseFromContext(bufferCopy, DracoLoader2, dracoOptions, context);
  const decodedAttributes = getGLTFAccessors(decodedData.attributes);
  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {
    if (attributeName in primitive.attributes) {
      const accessorIndex = primitive.attributes[attributeName];
      const accessor = scenegraph.getAccessor(accessorIndex);
      if ((accessor == null ? void 0 : accessor.min) && (accessor == null ? void 0 : accessor.max)) {
        decodedAttribute.min = accessor.min;
        decodedAttribute.max = accessor.max;
      }
    }
  }
  primitive.attributes = decodedAttributes;
  if (decodedData.indices) {
    primitive.indices = getGLTFAccessor(decodedData.indices);
  }
  scenegraph.removeObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);
  checkPrimitive(primitive);
}
function compressMesh(attributes, indices, mode = 4, options, context) {
  var _a;
  if (!options.DracoWriter) {
    throw new Error("options.gltf.DracoWriter not provided");
  }
  const compressedData = options.DracoWriter.encodeSync({ attributes });
  const decodedData = (_a = context == null ? void 0 : context.parseSync) == null ? void 0 : _a.call(context, { attributes });
  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);
  const bufferViewIndex = options.addBufferView(compressedData);
  const glTFMesh = {
    primitives: [
      {
        attributes: fauxAccessors,
        // TODO - verify with spec
        mode,
        // GL.POINTS
        extensions: {
          [KHR_DRACO_MESH_COMPRESSION]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors
            // TODO - verify with spec
          }
        }
      }
    ]
  };
  return glTFMesh;
}
function checkPrimitive(primitive) {
  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
  }
}
function* makeMeshPrimitiveIterator(scenegraph) {
  for (const mesh of scenegraph.json.meshes || []) {
    for (const primitive of mesh.primitives) {
      yield primitive;
    }
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_texture_transform.js
var KHR_texture_transform_exports = {};
__export(KHR_texture_transform_exports, {
  decode: () => decode7,
  name: () => name8
});
var KHR_TEXTURE_TRANSFORM = "KHR_texture_transform";
var name8 = KHR_TEXTURE_TRANSFORM;
var scratchVector7 = new Vector3();
var scratchRotationMatrix = new Matrix3();
var scratchScaleMatrix = new Matrix3();
async function decode7(gltfData, options) {
  var _a;
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const hasExtension = gltfScenegraph.hasExtension(KHR_TEXTURE_TRANSFORM);
  if (!hasExtension || !((_a = options.gltf) == null ? void 0 : _a.loadBuffers)) {
    return;
  }
  const materials = gltfData.json.materials || [];
  for (let i = 0; i < materials.length; i++) {
    transformTexCoords(i, gltfData);
  }
}
function transformTexCoords(materialIndex, gltfData) {
  var _a, _b, _c, _d;
  const material = (_a = gltfData.json.materials) == null ? void 0 : _a[materialIndex];
  const materialTextures = [
    (_b = material == null ? void 0 : material.pbrMetallicRoughness) == null ? void 0 : _b.baseColorTexture,
    material == null ? void 0 : material.emissiveTexture,
    material == null ? void 0 : material.normalTexture,
    material == null ? void 0 : material.occlusionTexture,
    (_c = material == null ? void 0 : material.pbrMetallicRoughness) == null ? void 0 : _c.metallicRoughnessTexture
  ];
  const processedTexCoords = [];
  for (const textureInfo of materialTextures) {
    if (textureInfo && ((_d = textureInfo == null ? void 0 : textureInfo.extensions) == null ? void 0 : _d[KHR_TEXTURE_TRANSFORM])) {
      transformPrimitives(gltfData, materialIndex, textureInfo, processedTexCoords);
    }
  }
}
function transformPrimitives(gltfData, materialIndex, texture, processedTexCoords) {
  const transformParameters = getTransformParameters(texture, processedTexCoords);
  if (!transformParameters) {
    return;
  }
  const meshes = gltfData.json.meshes || [];
  for (const mesh of meshes) {
    for (const primitive of mesh.primitives) {
      const material = primitive.material;
      if (Number.isFinite(material) && materialIndex === material) {
        transformPrimitive(gltfData, primitive, transformParameters);
      }
    }
  }
}
function getTransformParameters(texture, processedTexCoords) {
  var _a;
  const textureInfo = (_a = texture.extensions) == null ? void 0 : _a[KHR_TEXTURE_TRANSFORM];
  const { texCoord: originalTexCoord = 0 } = texture;
  const { texCoord = originalTexCoord } = textureInfo;
  const isProcessed = processedTexCoords.findIndex(([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord) !== -1;
  if (!isProcessed) {
    const matrix = makeTransformationMatrix(textureInfo);
    if (originalTexCoord !== texCoord) {
      texture.texCoord = texCoord;
    }
    processedTexCoords.push([originalTexCoord, texCoord]);
    return { originalTexCoord, texCoord, matrix };
  }
  return null;
}
function transformPrimitive(gltfData, primitive, transformParameters) {
  var _a, _b;
  const { originalTexCoord, texCoord, matrix } = transformParameters;
  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];
  if (Number.isFinite(texCoordAccessor)) {
    const accessor = (_a = gltfData.json.accessors) == null ? void 0 : _a[texCoordAccessor];
    if (accessor && accessor.bufferView) {
      const bufferView = (_b = gltfData.json.bufferViews) == null ? void 0 : _b[accessor.bufferView];
      if (bufferView) {
        const { arrayBuffer, byteOffset: bufferByteOffset } = gltfData.buffers[bufferView.buffer];
        const byteOffset = (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);
        const { ArrayType, length: length5 } = getAccessorArrayTypeAndLength(accessor, bufferView);
        const bytes = BYTES[accessor.componentType];
        const components = COMPONENTS[accessor.type];
        const elementAddressScale = bufferView.byteStride || bytes * components;
        const result = new Float32Array(length5);
        for (let i = 0; i < accessor.count; i++) {
          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);
          scratchVector7.set(uv[0], uv[1], 1);
          scratchVector7.transformByMatrix3(matrix);
          result.set([scratchVector7[0], scratchVector7[1]], i * components);
        }
        if (originalTexCoord === texCoord) {
          updateGltf(accessor, bufferView, gltfData.buffers, result);
        } else {
          createAttribute(texCoord, accessor, primitive, gltfData, result);
        }
      }
    }
  }
}
function updateGltf(accessor, bufferView, buffers, newTexCoordArray) {
  accessor.componentType = 5126;
  buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  bufferView.buffer = buffers.length - 1;
  bufferView.byteLength = newTexCoordArray.buffer.byteLength;
  bufferView.byteOffset = 0;
  delete bufferView.byteStride;
}
function createAttribute(newTexCoord, originalAccessor, primitive, gltfData, newTexCoordArray) {
  gltfData.buffers.push({
    arrayBuffer: newTexCoordArray.buffer,
    byteOffset: 0,
    byteLength: newTexCoordArray.buffer.byteLength
  });
  const bufferViews = gltfData.json.bufferViews;
  if (!bufferViews) {
    return;
  }
  bufferViews.push({
    buffer: gltfData.buffers.length - 1,
    byteLength: newTexCoordArray.buffer.byteLength,
    byteOffset: 0
  });
  const accessors = gltfData.json.accessors;
  if (!accessors) {
    return;
  }
  accessors.push({
    bufferView: (bufferViews == null ? void 0 : bufferViews.length) - 1,
    byteOffset: 0,
    componentType: 5126,
    count: originalAccessor.count,
    type: "VEC2"
  });
  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;
}
function makeTransformationMatrix(extensionData) {
  const { offset = [0, 0], rotation: rotation2 = 0, scale: scale7 = [1, 1] } = extensionData;
  const translationMatrix = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);
  const rotationMatrix = scratchRotationMatrix.set(Math.cos(rotation2), Math.sin(rotation2), 0, -Math.sin(rotation2), Math.cos(rotation2), 0, 0, 0, 1);
  const scaleMatrix = scratchScaleMatrix.set(scale7[0], 0, 0, 0, scale7[1], 0, 0, 0, 1);
  return translationMatrix.multiplyRight(rotationMatrix).multiplyRight(scaleMatrix);
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_lights_punctual.js
var KHR_lights_punctual_exports = {};
__export(KHR_lights_punctual_exports, {
  decode: () => decode8,
  encode: () => encode4,
  name: () => name9
});
var KHR_LIGHTS_PUNCTUAL = "KHR_lights_punctual";
var name9 = KHR_LIGHTS_PUNCTUAL;
async function decode8(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);
  if (extension) {
    gltfScenegraph.json.lights = extension.lights;
    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);
  }
  for (const node of json.nodes || []) {
    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
    if (nodeExtension) {
      node.light = nodeExtension.light;
    }
    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);
  }
}
async function encode4(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  if (json.lights) {
    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);
    assert4(!extension.lights);
    extension.lights = json.lights;
    delete json.lights;
  }
  if (gltfScenegraph.json.lights) {
    for (const light of gltfScenegraph.json.lights) {
      const node = light.node;
      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);
    }
    delete gltfScenegraph.json.lights;
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_materials_unlit.js
var KHR_materials_unlit_exports = {};
__export(KHR_materials_unlit_exports, {
  decode: () => decode9,
  encode: () => encode5,
  name: () => name10
});
var KHR_MATERIALS_UNLIT = "KHR_materials_unlit";
var name10 = KHR_MATERIALS_UNLIT;
async function decode9(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  for (const material of json.materials || []) {
    const extension = material.extensions && material.extensions.KHR_materials_unlit;
    if (extension) {
      material.unlit = true;
    }
    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);
  }
  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);
}
function encode5(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  if (gltfScenegraph.materials) {
    for (const material of json.materials || []) {
      if (material.unlit) {
        delete material.unlit;
        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});
        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);
      }
    }
  }
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/deprecated/KHR_techniques_webgl.js
var KHR_techniques_webgl_exports = {};
__export(KHR_techniques_webgl_exports, {
  decode: () => decode10,
  encode: () => encode6,
  name: () => name11
});
var KHR_TECHNIQUES_WEBGL = "KHR_techniques_webgl";
var name11 = KHR_TECHNIQUES_WEBGL;
async function decode10(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);
  if (extension) {
    const techniques = resolveTechniques(extension, gltfScenegraph);
    for (const material of json.materials || []) {
      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);
      if (materialExtension) {
        material.technique = Object.assign(
          {},
          materialExtension,
          // @ts-ignore
          techniques[materialExtension.technique]
        );
        material.technique.values = resolveValues(material.technique, gltfScenegraph);
      }
      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);
    }
    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);
  }
}
async function encode6(gltfData, options) {
}
function resolveTechniques(techniquesExtension, gltfScenegraph) {
  const { programs = [], shaders = [], techniques = [] } = techniquesExtension;
  const textDecoder = new TextDecoder();
  shaders.forEach((shader) => {
    if (Number.isFinite(shader.bufferView)) {
      shader.code = textDecoder.decode(gltfScenegraph.getTypedArrayForBufferView(shader.bufferView));
    } else {
      throw new Error("KHR_techniques_webgl: no shader code");
    }
  });
  programs.forEach((program) => {
    program.fragmentShader = shaders[program.fragmentShader];
    program.vertexShader = shaders[program.vertexShader];
  });
  techniques.forEach((technique) => {
    technique.program = programs[technique.program];
  });
  return techniques;
}
function resolveValues(technique, gltfScenegraph) {
  const values = Object.assign({}, technique.values);
  Object.keys(technique.uniforms || {}).forEach((uniform) => {
    if (technique.uniforms[uniform].value && !(uniform in values)) {
      values[uniform] = technique.uniforms[uniform].value;
    }
  });
  Object.keys(values).forEach((uniform) => {
    if (typeof values[uniform] === "object" && values[uniform].index !== void 0) {
      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
    }
  });
  return values;
}

// node_modules/@loaders.gl/gltf/dist/lib/api/gltf-extensions.js
var EXTENSIONS = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  EXT_structural_metadata_exports,
  EXT_mesh_features_exports,
  EXT_meshopt_compression_exports,
  EXT_texture_webp_exports,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  KHR_texture_basisu_exports,
  KHR_draco_mesh_compression_exports,
  KHR_lights_punctual_exports,
  KHR_materials_unlit_exports,
  KHR_techniques_webgl_exports,
  KHR_texture_transform_exports,
  EXT_feature_metadata_exports
];
function preprocessExtensions(gltf, options = {}, context) {
  var _a;
  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    (_a = extension.preprocess) == null ? void 0 : _a.call(extension, gltf, options, context);
  }
}
async function decodeExtensions(gltf, options = {}, context) {
  var _a;
  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));
  for (const extension of extensions) {
    await ((_a = extension.decode) == null ? void 0 : _a.call(extension, gltf, options, context));
  }
}
function useExtension(extensionName, options) {
  var _a;
  const excludes = ((_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.excludeExtensions) || {};
  const exclude = extensionName in excludes && !excludes[extensionName];
  return !exclude;
}

// node_modules/@loaders.gl/gltf/dist/lib/extensions/KHR_binary_gltf.js
var KHR_BINARY_GLTF = "KHR_binary_glTF";
function preprocess4(gltfData) {
  const gltfScenegraph = new GLTFScenegraph(gltfData);
  const { json } = gltfScenegraph;
  for (const image of json.images || []) {
    const extension = gltfScenegraph.getObjectExtension(image, KHR_BINARY_GLTF);
    if (extension) {
      Object.assign(image, extension);
    }
    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);
  }
  if (json.buffers && json.buffers[0]) {
    delete json.buffers[0].uri;
  }
  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);
}

// node_modules/@loaders.gl/gltf/dist/lib/api/normalize-gltf-v1.js
var GLTF_ARRAYS = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
};
var GLTF_KEYS = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
var GLTFV1Normalizer = class {
  constructor() {
    __publicField(this, "idToIndexMap", {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    });
    __publicField(this, "json");
  }
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(gltf, options) {
    this.json = gltf.json;
    const json = gltf.json;
    switch (json.asset && json.asset.version) {
      case "2.0":
        return;
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${json.asset.version}`);
        return;
    }
    if (!options.normalize) {
      throw new Error("glTF v1 is not supported.");
    }
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail.");
    this._addAsset(json);
    this._convertTopLevelObjectsToArrays(json);
    preprocess4(gltf);
    this._convertObjectIdsToArrayIndices(json);
    this._updateObjects(json);
    this._updateMaterial(json);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(json) {
    json.asset = json.asset || {};
    json.asset.version = "2.0";
    json.asset.generator = json.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertTopLevelObjectToArray(json, arrayName);
    }
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(json, mapName) {
    const objectMap = json[mapName];
    if (!objectMap || Array.isArray(objectMap)) {
      return;
    }
    json[mapName] = [];
    for (const id in objectMap) {
      const object = objectMap[id];
      object.id = object.id || id;
      const index = json[mapName].length;
      json[mapName].push(object);
      this.idToIndexMap[mapName][id] = index;
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertIdsToIndices(json, arrayName);
    }
    if ("scene" in json) {
      json.scene = this._convertIdToIndex(json.scene, "scene");
    }
    for (const texture of json.textures) {
      this._convertTextureIds(texture);
    }
    for (const mesh of json.meshes) {
      this._convertMeshIds(mesh);
    }
    for (const node of json.nodes) {
      this._convertNodeIds(node);
    }
    for (const node of json.scenes) {
      this._convertSceneIds(node);
    }
  }
  _convertTextureIds(texture) {
    if (texture.source) {
      texture.source = this._convertIdToIndex(texture.source, "image");
    }
  }
  _convertMeshIds(mesh) {
    for (const primitive of mesh.primitives) {
      const { attributes, indices, material } = primitive;
      for (const attributeName in attributes) {
        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], "accessor");
      }
      if (indices) {
        primitive.indices = this._convertIdToIndex(indices, "accessor");
      }
      if (material) {
        primitive.material = this._convertIdToIndex(material, "material");
      }
    }
  }
  _convertNodeIds(node) {
    if (node.children) {
      node.children = node.children.map((child) => this._convertIdToIndex(child, "node"));
    }
    if (node.meshes) {
      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, "mesh"));
    }
  }
  _convertSceneIds(scene) {
    if (scene.nodes) {
      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, "node"));
    }
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(json, topLevelArrayName) {
    if (!json[topLevelArrayName]) {
      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`);
      json[topLevelArrayName] = [];
    }
    for (const object of json[topLevelArrayName]) {
      for (const key in object) {
        const id = object[key];
        const index = this._convertIdToIndex(id, key);
        object[key] = index;
      }
    }
  }
  _convertIdToIndex(id, key) {
    const arrayName = GLTF_KEYS[key];
    if (arrayName in this.idToIndexMap) {
      const index = this.idToIndexMap[arrayName][id];
      if (!Number.isFinite(index)) {
        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);
      }
      return index;
    }
    return id;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(json) {
    for (const buffer of this.json.buffers) {
      delete buffer.type;
    }
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(json) {
    var _a, _b, _c;
    for (const material of json.materials) {
      material.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const textureId = ((_a = material.values) == null ? void 0 : _a.tex) || ((_b = material.values) == null ? void 0 : _b.texture2d_0) || ((_c = material.values) == null ? void 0 : _c.diffuseTex);
      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);
      if (textureIndex !== -1) {
        material.pbrMetallicRoughness.baseColorTexture = { index: textureIndex };
      }
    }
  }
};
function normalizeGLTFV1(gltf, options = {}) {
  return new GLTFV1Normalizer().normalize(gltf, options);
}

// node_modules/@loaders.gl/gltf/dist/lib/parsers/parse-gltf.js
async function parseGLTF2(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  var _a, _b, _c;
  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
  normalizeGLTFV1(gltf, { normalize: (_a = options == null ? void 0 : options.gltf) == null ? void 0 : _a.normalize });
  preprocessExtensions(gltf, options, context);
  if (((_b = options == null ? void 0 : options.gltf) == null ? void 0 : _b.loadBuffers) && gltf.json.buffers) {
    await loadBuffers(gltf, options, context);
  }
  if ((_c = options == null ? void 0 : options.gltf) == null ? void 0 : _c.loadImages) {
    await loadImages(gltf, options, context);
  }
  await decodeExtensions(gltf, options, context);
  return gltf;
}
function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  if (options.uri) {
    gltf.baseUri = options.uri;
  }
  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }
  if (typeof data === "string") {
    gltf.json = parseJSON(data);
  } else if (data instanceof ArrayBuffer) {
    const glb = {};
    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);
    assert4(glb.type === "glTF", `Invalid GLB magic string ${glb.type}`);
    gltf._glb = glb;
    gltf.json = glb.json;
  } else {
    assert4(false, "GLTF: must be ArrayBuffer or string");
  }
  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill(null);
  if (gltf._glb && gltf._glb.header.hasBinChunk) {
    const { binChunks } = gltf._glb;
    gltf.buffers[0] = {
      arrayBuffer: binChunks[0].arrayBuffer,
      byteOffset: binChunks[0].byteOffset,
      byteLength: binChunks[0].byteLength
    };
  }
  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}
async function loadBuffers(gltf, options, context) {
  var _a, _b;
  const buffers = gltf.json.buffers || [];
  for (let i = 0; i < buffers.length; ++i) {
    const buffer = buffers[i];
    if (buffer.uri) {
      const { fetch: fetch2 } = context;
      assert4(fetch2);
      const uri = resolveUrl(buffer.uri, options);
      const response = await ((_a = context == null ? void 0 : context.fetch) == null ? void 0 : _a.call(context, uri));
      const arrayBuffer = await ((_b = response == null ? void 0 : response.arrayBuffer) == null ? void 0 : _b.call(response));
      gltf.buffers[i] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };
      delete buffer.uri;
    } else if (gltf.buffers[i] === null) {
      gltf.buffers[i] = {
        arrayBuffer: new ArrayBuffer(buffer.byteLength),
        byteOffset: 0,
        byteLength: buffer.byteLength
      };
    }
  }
}
async function loadImages(gltf, options, context) {
  const imageIndices = getReferencesImageIndices(gltf);
  const images = gltf.json.images || [];
  const promises = [];
  for (const imageIndex of imageIndices) {
    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));
  }
  return await Promise.all(promises);
}
function getReferencesImageIndices(gltf) {
  const imageIndices = /* @__PURE__ */ new Set();
  const textures = gltf.json.textures || [];
  for (const texture of textures) {
    if (texture.source !== void 0) {
      imageIndices.add(texture.source);
    }
  }
  return Array.from(imageIndices).sort();
}
async function loadImage(gltf, image, index, options, context) {
  let arrayBuffer;
  if (image.uri && !image.hasOwnProperty("bufferView")) {
    const uri = resolveUrl(image.uri, options);
    const { fetch: fetch2 } = context;
    const response = await fetch2(uri);
    arrayBuffer = await response.arrayBuffer();
    image.bufferView = {
      data: arrayBuffer
    };
  }
  if (Number.isFinite(image.bufferView)) {
    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
  }
  assert4(arrayBuffer, "glTF image has no data");
  let parsedImage = await parseFromContext(arrayBuffer, [ImageLoader, BasisLoader], {
    ...options,
    mimeType: image.mimeType,
    basis: options.basis || { format: selectSupportedBasisFormat() }
  }, context);
  if (parsedImage && parsedImage[0]) {
    parsedImage = {
      compressed: true,
      // @ts-expect-error
      mipmaps: false,
      width: parsedImage[0].width,
      height: parsedImage[0].height,
      data: parsedImage[0]
    };
  }
  gltf.images = gltf.images || [];
  gltf.images[index] = parsedImage;
}

// node_modules/@loaders.gl/gltf/dist/gltf-loader.js
var GLTFLoader = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: VERSION5,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: true,
  binary: true,
  tests: ["glTF"],
  parse: parse2,
  options: {
    gltf: {
      normalize: true,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: true,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: true,
      // Create image objects
      decompressMeshes: true
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function parse2(arrayBuffer, options = {}, context) {
  options = { ...GLTFLoader.options, ...options };
  options.gltf = { ...GLTFLoader.options.gltf, ...options.gltf };
  const { byteOffset = 0 } = options;
  const gltf = {};
  return await parseGLTF2(gltf, arrayBuffer, byteOffset, options, context);
}

// node_modules/@loaders.gl/gltf/dist/lib/api/post-process-gltf.js
var COMPONENTS2 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var BYTES2 = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
};
var GL_SAMPLER = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
};
var SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};
var DEFAULT_SAMPLER_PARAMETERS = {
  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT
};
function makeDefaultSampler() {
  return {
    id: "default-sampler",
    parameters: DEFAULT_SAMPLER_PARAMETERS
  };
}
function getBytesFromComponentType(componentType) {
  return BYTES2[componentType];
}
function getSizeFromAccessorType(type) {
  return COMPONENTS2[type];
}
var GLTFPostProcessor = class {
  constructor() {
    __publicField(this, "baseUri", "");
    // @ts-expect-error
    __publicField(this, "jsonUnprocessed");
    // @ts-expect-error
    __publicField(this, "json");
    __publicField(this, "buffers", []);
    __publicField(this, "images", []);
  }
  postProcess(gltf, options = {}) {
    const { json, buffers = [], images = [] } = gltf;
    const { baseUri = "" } = gltf;
    assert4(json);
    this.baseUri = baseUri;
    this.buffers = buffers;
    this.images = images;
    this.jsonUnprocessed = json;
    this.json = this._resolveTree(gltf.json, options);
    return this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(gltf, options = {}) {
    const json = { ...gltf };
    this.json = json;
    if (gltf.bufferViews) {
      json.bufferViews = gltf.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));
    }
    if (gltf.images) {
      json.images = gltf.images.map((image, i) => this._resolveImage(image, i));
    }
    if (gltf.samplers) {
      json.samplers = gltf.samplers.map((sampler, i) => this._resolveSampler(sampler, i));
    }
    if (gltf.textures) {
      json.textures = gltf.textures.map((texture, i) => this._resolveTexture(texture, i));
    }
    if (gltf.accessors) {
      json.accessors = gltf.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));
    }
    if (gltf.materials) {
      json.materials = gltf.materials.map((material, i) => this._resolveMaterial(material, i));
    }
    if (gltf.meshes) {
      json.meshes = gltf.meshes.map((mesh, i) => this._resolveMesh(mesh, i));
    }
    if (gltf.nodes) {
      json.nodes = gltf.nodes.map((node, i) => this._resolveNode(node, i));
      json.nodes = json.nodes.map((node, i) => this._resolveNodeChildren(node));
    }
    if (gltf.skins) {
      json.skins = gltf.skins.map((skin, i) => this._resolveSkin(skin, i));
    }
    if (gltf.scenes) {
      json.scenes = gltf.scenes.map((scene, i) => this._resolveScene(scene, i));
    }
    if (typeof this.json.scene === "number" && json.scenes) {
      json.scene = json.scenes[this.json.scene];
    }
    return json;
  }
  getScene(index) {
    return this._get(this.json.scenes, index);
  }
  getNode(index) {
    return this._get(this.json.nodes, index);
  }
  getSkin(index) {
    return this._get(this.json.skins, index);
  }
  getMesh(index) {
    return this._get(this.json.meshes, index);
  }
  getMaterial(index) {
    return this._get(this.json.materials, index);
  }
  getAccessor(index) {
    return this._get(this.json.accessors, index);
  }
  getCamera(index) {
    return this._get(this.json.cameras, index);
  }
  getTexture(index) {
    return this._get(this.json.textures, index);
  }
  getSampler(index) {
    return this._get(this.json.samplers, index);
  }
  getImage(index) {
    return this._get(this.json.images, index);
  }
  getBufferView(index) {
    return this._get(this.json.bufferViews, index);
  }
  getBuffer(index) {
    return this._get(this.json.buffers, index);
  }
  _get(array, index) {
    if (typeof index === "object") {
      return index;
    }
    const object = array && array[index];
    if (!object) {
      console.warn(`glTF file error: Could not find ${array}[${index}]`);
    }
    return object;
  }
  // PARSING HELPERS
  _resolveScene(scene, index) {
    return {
      ...scene,
      // @ts-ignore
      id: scene.id || `scene-${index}`,
      nodes: (scene.nodes || []).map((node) => this.getNode(node))
    };
  }
  _resolveNode(gltfNode, index) {
    const node = {
      ...gltfNode,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: (gltfNode == null ? void 0 : gltfNode.id) || `node-${index}`
    };
    if (gltfNode.mesh !== void 0) {
      node.mesh = this.getMesh(gltfNode.mesh);
    }
    if (gltfNode.camera !== void 0) {
      node.camera = this.getCamera(gltfNode.camera);
    }
    if (gltfNode.skin !== void 0) {
      node.skin = this.getSkin(gltfNode.skin);
    }
    if (gltfNode.meshes !== void 0 && gltfNode.meshes.length) {
      node.mesh = gltfNode.meshes.reduce((accum, meshIndex) => {
        const mesh = this.getMesh(meshIndex);
        accum.id = mesh.id;
        accum.primitives = accum.primitives.concat(mesh.primitives);
        return accum;
      }, { primitives: [] });
    }
    return node;
  }
  _resolveNodeChildren(node) {
    if (node.children) {
      node.children = node.children.map((child) => this.getNode(child));
    }
    return node;
  }
  _resolveSkin(gltfSkin, index) {
    const inverseBindMatrices = typeof gltfSkin.inverseBindMatrices === "number" ? this.getAccessor(gltfSkin.inverseBindMatrices) : void 0;
    return {
      ...gltfSkin,
      id: gltfSkin.id || `skin-${index}`,
      inverseBindMatrices
    };
  }
  _resolveMesh(gltfMesh, index) {
    const mesh = {
      ...gltfMesh,
      id: gltfMesh.id || `mesh-${index}`,
      primitives: []
    };
    if (gltfMesh.primitives) {
      mesh.primitives = gltfMesh.primitives.map((gltfPrimitive) => {
        const primitive = {
          ...gltfPrimitive,
          attributes: {},
          indices: void 0,
          material: void 0
        };
        const attributes = gltfPrimitive.attributes;
        for (const attribute in attributes) {
          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
        }
        if (gltfPrimitive.indices !== void 0) {
          primitive.indices = this.getAccessor(gltfPrimitive.indices);
        }
        if (gltfPrimitive.material !== void 0) {
          primitive.material = this.getMaterial(gltfPrimitive.material);
        }
        return primitive;
      });
    }
    return mesh;
  }
  _resolveMaterial(gltfMaterial, index) {
    const material = {
      ...gltfMaterial,
      // @ts-expect-error
      id: gltfMaterial.id || `material-${index}`
    };
    if (material.normalTexture) {
      material.normalTexture = { ...material.normalTexture };
      material.normalTexture.texture = this.getTexture(material.normalTexture.index);
    }
    if (material.occlusionTexture) {
      material.occlusionTexture = { ...material.occlusionTexture };
      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
    }
    if (material.emissiveTexture) {
      material.emissiveTexture = { ...material.emissiveTexture };
      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
    }
    if (!material.emissiveFactor) {
      material.emissiveFactor = material.emissiveTexture ? [1, 1, 1] : [0, 0, 0];
    }
    if (material.pbrMetallicRoughness) {
      material.pbrMetallicRoughness = { ...material.pbrMetallicRoughness };
      const mr = material.pbrMetallicRoughness;
      if (mr.baseColorTexture) {
        mr.baseColorTexture = { ...mr.baseColorTexture };
        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
      }
      if (mr.metallicRoughnessTexture) {
        mr.metallicRoughnessTexture = { ...mr.metallicRoughnessTexture };
        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
      }
    }
    return material;
  }
  _resolveAccessor(gltfAccessor, index) {
    const bytesPerComponent = getBytesFromComponentType(gltfAccessor.componentType);
    const components = getSizeFromAccessorType(gltfAccessor.type);
    const bytesPerElement = bytesPerComponent * components;
    const accessor = {
      ...gltfAccessor,
      // @ts-expect-error
      id: gltfAccessor.id || `accessor-${index}`,
      bytesPerComponent,
      components,
      bytesPerElement,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (gltfAccessor.bufferView !== void 0) {
      accessor.bufferView = this.getBufferView(gltfAccessor.bufferView);
    }
    if (accessor.bufferView) {
      const buffer = accessor.bufferView.buffer;
      const { ArrayType, byteLength } = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);
      const byteOffset = (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;
      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);
      if (accessor.bufferView.byteStride) {
        cutBuffer = this._getValueFromInterleavedBuffer(buffer, byteOffset, accessor.bufferView.byteStride, accessor.bytesPerElement, accessor.count);
      }
      accessor.value = new ArrayType(cutBuffer);
    }
    return accessor;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {
    const result = new Uint8Array(count * bytesPerElement);
    for (let i = 0; i < count; i++) {
      const elementOffset = byteOffset + i * byteStride;
      result.set(new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)), i * bytesPerElement);
    }
    return result.buffer;
  }
  _resolveTexture(gltfTexture, index) {
    return {
      ...gltfTexture,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfTexture.id || `texture-${index}`,
      sampler: typeof gltfTexture.sampler === "number" ? this.getSampler(gltfTexture.sampler) : makeDefaultSampler(),
      source: typeof gltfTexture.source === "number" ? this.getImage(gltfTexture.source) : void 0
    };
  }
  _resolveSampler(gltfSampler, index) {
    const sampler = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfSampler.id || `sampler-${index}`,
      ...gltfSampler,
      parameters: {}
    };
    for (const key in sampler) {
      const glEnum = this._enumSamplerParameter(key);
      if (glEnum !== void 0) {
        sampler.parameters[glEnum] = sampler[key];
      }
    }
    return sampler;
  }
  _enumSamplerParameter(key) {
    return SAMPLER_PARAMETER_GLTF_TO_GL[key];
  }
  _resolveImage(gltfImage, index) {
    const image = {
      ...gltfImage,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfImage.id || `image-${index}`,
      image: null,
      bufferView: gltfImage.bufferView !== void 0 ? this.getBufferView(gltfImage.bufferView) : void 0
    };
    const preloadedImage = this.images[index];
    if (preloadedImage) {
      image.image = preloadedImage;
    }
    return image;
  }
  _resolveBufferView(gltfBufferView, index) {
    const bufferIndex = gltfBufferView.buffer;
    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;
    if (gltfBufferView.byteOffset) {
      byteOffset += gltfBufferView.byteOffset;
    }
    const bufferView = {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${index}`,
      ...gltfBufferView,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[bufferIndex],
      data: new Uint8Array(arrayBuffer, byteOffset, gltfBufferView.byteLength)
    };
    return bufferView;
  }
  _resolveCamera(gltfCamera, index) {
    const camera = {
      ...gltfCamera,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: gltfCamera.id || `camera-${index}`
    };
    if (camera.perspective) {
    }
    if (camera.orthographic) {
    }
    return camera;
  }
};
function postProcessGLTF(gltf, options) {
  return new GLTFPostProcessor().postProcess(gltf, options);
}

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/gltf-utils.js
async function waitForGLTFAssets(gltfObjects) {
  const remaining = [];
  gltfObjects.scenes.forEach((scene) => {
    scene.traverse((modelNode) => {
    });
  });
  return await waitWhileCondition(() => remaining.some((uniform) => !uniform.loaded));
}
async function waitWhileCondition(condition) {
  while (condition()) {
    await new Promise((resolve) => requestAnimationFrame(resolve));
  }
}

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer-uniforms.js
var uniformBlock3 = `uniform scenegraphUniforms {
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  mat4 sceneModelMatrix;
  bool composeModelMatrix;
} scenegraph;
`;
var scenegraphUniforms = {
  name: "scenegraph",
  vs: uniformBlock3,
  fs: uniformBlock3,
  uniformTypes: {
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    sceneModelMatrix: "mat4x4<f32>",
    composeModelMatrix: "f32"
  }
};

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer-vertex.glsl.js
var scenegraph_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef LIGHTING_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(LIGHTING_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(scenegraph.sizeScale);
float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(scenegraph.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef LIGHTING_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer-fragment.glsl.js
var scenegraph_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
in vec4 vColor;
out vec4 fragColor;
#ifndef LIGHTING_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D pbr_baseColorSampler;
#endif
#endif
void main(void) {
#ifdef LIGHTING_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= layer.opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/mesh-layers/dist/scenegraph-layer/scenegraph-layer.js
var DEFAULT_COLOR2 = [255, 255, 255, 255];
var defaultProps12 = {
  scenegraph: { type: "object", value: null, async: true },
  getScene: (gltf) => {
    if (gltf && gltf.scenes) {
      return typeof gltf.scene === "object" ? gltf.scene : gltf.scenes[gltf.scene || 0];
    }
    return gltf;
  },
  getAnimator: (scenegraph) => scenegraph && scenegraph.animator,
  _animations: null,
  sizeScale: { type: "number", value: 1, min: 0 },
  sizeMinPixels: { type: "number", min: 0, value: 0 },
  sizeMaxPixels: { type: "number", min: 0, value: Number.MAX_SAFE_INTEGER },
  getPosition: { type: "accessor", value: (x) => x.position },
  getColor: { type: "accessor", value: DEFAULT_COLOR2 },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: { type: "accessor", value: [0, 0, 0] },
  getScale: { type: "accessor", value: [1, 1, 1] },
  getTranslation: { type: "accessor", value: [0, 0, 0] },
  // 4x4 matrix
  getTransformMatrix: { type: "accessor", value: [] },
  loaders: [GLTFLoader]
};
var ScenegraphLayer = class extends layer_default {
  getShaders() {
    const defines = {};
    let pbr;
    if (this.props._lighting === "pbr") {
      pbr = pbrMaterial;
      defines.LIGHTING_PBR = 1;
    } else {
      pbr = { name: "pbrMaterial" };
    }
    const modules = [project32_default, picking_default, scenegraphUniforms, pbr];
    return super.getShaders({ defines, vs: scenegraph_layer_vertex_glsl_default, fs: scenegraph_layer_fragment_glsl_default, modules });
  }
  initializeState() {
    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: true
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: DEFAULT_COLOR2,
        transition: true
      },
      instanceModelMatrix: MATRIX_ATTRIBUTES
    });
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    if (props.scenegraph !== oldProps.scenegraph) {
      this._updateScenegraph();
    } else if (props._animations !== oldProps._animations) {
      this._applyAnimationsProp(this.state.animator, props._animations);
    }
  }
  finalizeState(context) {
    var _a;
    super.finalizeState(context);
    (_a = this.state.scenegraph) == null ? void 0 : _a.destroy();
  }
  get isLoaded() {
    var _a;
    return Boolean(((_a = this.state) == null ? void 0 : _a.scenegraph) && super.isLoaded);
  }
  _updateScenegraph() {
    var _a;
    const props = this.props;
    const { device } = this.context;
    let scenegraphData = null;
    if (props.scenegraph instanceof ScenegraphNode) {
      scenegraphData = { scenes: [props.scenegraph] };
    } else if (props.scenegraph && typeof props.scenegraph === "object") {
      const gltf = props.scenegraph;
      const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;
      const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());
      scenegraphData = { gltf: processedGLTF, ...gltfObjects };
      waitForGLTFAssets(gltfObjects).then(() => {
        this.setNeedsRedraw();
      }).catch((ex) => {
        this.raiseError(ex, "loading glTF");
      });
    }
    const options = { layer: this, device: this.context.device };
    const scenegraph = props.getScene(scenegraphData, options);
    const animator = props.getAnimator(scenegraphData, options);
    if (scenegraph instanceof GroupNode) {
      (_a = this.state.scenegraph) == null ? void 0 : _a.destroy();
      this._applyAnimationsProp(animator, props._animations);
      const models = [];
      scenegraph.traverse((node) => {
        if (node instanceof ModelNode) {
          models.push(node.model);
        }
      });
      this.setState({ scenegraph, animator, models });
      this.getAttributeManager().invalidateAll();
    } else if (scenegraph !== null) {
      log_default.warn("invalid scenegraph:", scenegraph)();
    }
  }
  _applyAnimationsProp(animator, animationsProp) {
    if (!animator || !animationsProp) {
      return;
    }
    const animations = animator.getAnimations();
    Object.keys(animationsProp).sort().forEach((key) => {
      const value = animationsProp[key];
      if (key === "*") {
        animations.forEach((animation) => {
          Object.assign(animation, value);
        });
      } else if (Number.isFinite(Number(key))) {
        const number = Number(key);
        if (number >= 0 && number < animations.length) {
          Object.assign(animations[number], value);
        } else {
          log_default.warn(`animation ${key} not found`)();
        }
      } else {
        const findResult = animations.find(({ animation }) => animation.name === key);
        if (findResult) {
          Object.assign(findResult, value);
        } else {
          log_default.warn(`animation ${key} not found`)();
        }
      }
    });
  }
  _getModelOptions() {
    const { _imageBasedLightingEnvironment } = this.props;
    let env;
    if (_imageBasedLightingEnvironment) {
      if (typeof _imageBasedLightingEnvironment === "function") {
        env = _imageBasedLightingEnvironment({ gl: this.context.gl, layer: this });
      } else {
        env = _imageBasedLightingEnvironment;
      }
    }
    return {
      imageBasedLightingEnvironment: env,
      modelOptions: {
        id: this.props.id,
        isInstanced: true,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: false
    };
  }
  draw({ context }) {
    if (!this.state.scenegraph)
      return;
    if (this.props._animations && this.state.animator) {
      this.state.animator.animate(context.timeline.getTime());
      this.setNeedsRedraw();
    }
    const { viewport, renderPass } = this.context;
    const { sizeScale, sizeMinPixels, sizeMaxPixels, coordinateSystem } = this.props;
    const pbrProjectionProps = {
      camera: viewport.cameraPosition
    };
    const numInstances = this.getNumInstances();
    this.state.scenegraph.traverse((node, { worldMatrix }) => {
      if (node instanceof ModelNode) {
        const { model } = node;
        model.setInstanceCount(numInstances);
        const scenegraphProps = {
          sizeScale,
          sizeMinPixels,
          sizeMaxPixels,
          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),
          sceneModelMatrix: worldMatrix
        };
        model.shaderInputs.setProps({
          pbrProjection: pbrProjectionProps,
          scenegraph: scenegraphProps
        });
        model.draw(renderPass);
      }
    });
  }
};
ScenegraphLayer.defaultProps = defaultProps12;
ScenegraphLayer.layerName = "ScenegraphLayer";
var scenegraph_layer_default = ScenegraphLayer;

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer-uniforms.js
var uniformBlock4 = `uniform meshUniforms {
  bool pickFeatureIds;
} mesh;
`;
var meshUniforms = {
  name: "mesh",
  vs: uniformBlock4,
  fs: uniformBlock4,
  uniformTypes: {
    pickFeatureIds: "f32"
  }
};

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer-vertex.glsl.js
var mesh_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (mesh.pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBRMATERIAL
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer-fragment.glsl.js
var mesh_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBRMATERIAL
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= layer.opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

// node_modules/@deck.gl/geo-layers/dist/mesh-layer/mesh-layer.js
function validateGeometryAttributes(attributes) {
  const positionAttribute = attributes.positions || attributes.POSITION;
  const vertexCount = positionAttribute.value.length / positionAttribute.size;
  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;
  if (!hasColorAttribute) {
    attributes.colors = {
      size: 4,
      value: new Uint8Array(vertexCount * 4).fill(255),
      normalized: true
    };
  }
}
var defaultProps13 = {
  pbrMaterial: { type: "object", value: null },
  featureIds: { type: "array", value: null, optional: true }
};
var MeshLayer = class extends simple_mesh_layer_default {
  getShaders() {
    const shaders = super.getShaders();
    const modules = shaders.modules;
    modules.push(pbrMaterial, meshUniforms);
    return { ...shaders, vs: mesh_layer_vertex_glsl_default, fs: mesh_layer_fragment_glsl_default };
  }
  initializeState() {
    const { featureIds } = this.props;
    super.initializeState();
    const attributeManager = this.getAttributeManager();
    if (featureIds) {
      attributeManager.add({
        featureIdsPickingColors: {
          type: "uint8",
          size: 3,
          noAlloc: true,
          // eslint-disable-next-line @typescript-eslint/unbound-method
          update: this.calculateFeatureIdsPickingColors
        }
      });
    }
  }
  updateState(params) {
    super.updateState(params);
    const { props, oldProps } = params;
    if (props.pbrMaterial !== oldProps.pbrMaterial) {
      this.updatePbrMaterialUniforms(props.pbrMaterial);
    }
  }
  draw(opts) {
    const { featureIds } = this.props;
    const { model } = this.state;
    if (!model) {
      return;
    }
    const meshProps = {
      pickFeatureIds: Boolean(featureIds)
    };
    const pbrProjectionProps = {
      camera: this.context.viewport.cameraPosition
    };
    model.shaderInputs.setProps({
      pbrProjection: pbrProjectionProps,
      mesh: meshProps
    });
    super.draw(opts);
  }
  getModel(mesh) {
    const { id } = this.props;
    const parsedPBRMaterial = this.parseMaterial(this.props.pbrMaterial, mesh);
    this.setState({ parsedPBRMaterial });
    const shaders = this.getShaders();
    validateGeometryAttributes(mesh.attributes);
    const model = new Model(this.context.device, {
      ...this.getShaders(),
      id,
      geometry: mesh,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...shaders.defines,
        ...parsedPBRMaterial == null ? void 0 : parsedPBRMaterial.defines,
        HAS_UV_REGIONS: mesh.attributes.uvRegions ? 1 : 0
      },
      parameters: parsedPBRMaterial == null ? void 0 : parsedPBRMaterial.parameters,
      isInstanced: true
    });
    return model;
  }
  updatePbrMaterialUniforms(material) {
    const { model } = this.state;
    if (model) {
      const { mesh } = this.props;
      const parsedPBRMaterial = this.parseMaterial(material, mesh);
      this.setState({ parsedPBRMaterial });
      const { pbr_baseColorSampler } = parsedPBRMaterial.bindings;
      const { emptyTexture } = this.state;
      const simpleMeshProps = {
        sampler: pbr_baseColorSampler || emptyTexture,
        hasTexture: Boolean(pbr_baseColorSampler)
      };
      const { camera, ...pbrMaterialProps } = {
        ...parsedPBRMaterial.bindings,
        ...parsedPBRMaterial.uniforms
      };
      model.shaderInputs.setProps({ simpleMesh: simpleMeshProps, pbrMaterial: pbrMaterialProps });
    }
  }
  parseMaterial(material, mesh) {
    const unlit = Boolean(material.pbrMetallicRoughness && material.pbrMetallicRoughness.baseColorTexture);
    return parsePBRMaterial(this.context.device, { unlit, ...material }, { NORMAL: mesh.attributes.normals, TEXCOORD_0: mesh.attributes.texCoords }, {
      pbrDebug: false,
      lights: true,
      useTangents: false
    });
  }
  calculateFeatureIdsPickingColors(attribute) {
    const featureIds = this.props.featureIds;
    const value = new Uint8ClampedArray(featureIds.length * attribute.size);
    const pickingColor = [];
    for (let index = 0; index < featureIds.length; index++) {
      this.encodePickingColor(featureIds[index], pickingColor);
      value[index * 3] = pickingColor[0];
      value[index * 3 + 1] = pickingColor[1];
      value[index * 3 + 2] = pickingColor[2];
    }
    attribute.value = value;
  }
  finalizeState(context) {
    var _a;
    super.finalizeState(context);
    (_a = this.state.parsedPBRMaterial) == null ? void 0 : _a.generatedTextures.forEach((texture) => texture.destroy());
    this.setState({ parsedPBRMaterial: null });
  }
};
MeshLayer.layerName = "MeshLayer";
MeshLayer.defaultProps = defaultProps13;
var mesh_layer_default = MeshLayer;

// node_modules/@math.gl/geospatial/dist/constants.js
var WGS84_RADIUS_X = 6378137;
var WGS84_RADIUS_Y = 6378137;
var WGS84_RADIUS_Z = 6356752314245179e-9;
var WGS84_CONSTANTS = {
  radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],
  radiiSquared: [
    WGS84_RADIUS_X * WGS84_RADIUS_X,
    WGS84_RADIUS_Y * WGS84_RADIUS_Y,
    WGS84_RADIUS_Z * WGS84_RADIUS_Z
  ],
  oneOverRadii: [1 / WGS84_RADIUS_X, 1 / WGS84_RADIUS_Y, 1 / WGS84_RADIUS_Z],
  oneOverRadiiSquared: [
    1 / (WGS84_RADIUS_X * WGS84_RADIUS_X),
    1 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y),
    1 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)
  ],
  maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),
  centerToleranceSquared: 0.1
  // EPSILON1;
};

// node_modules/@math.gl/geospatial/dist/type-utils.js
function identity3(x) {
  return x;
}
var scratchVector8 = new Vector3();
function fromCartographic(cartographic, result = [], map = identity3) {
  if ("longitude" in cartographic) {
    result[0] = map(cartographic.longitude);
    result[1] = map(cartographic.latitude);
    result[2] = cartographic.height;
  } else if ("x" in cartographic) {
    result[0] = map(cartographic.x);
    result[1] = map(cartographic.y);
    result[2] = cartographic.z;
  } else {
    result[0] = map(cartographic[0]);
    result[1] = map(cartographic[1]);
    result[2] = cartographic[2];
  }
  return result;
}
function fromCartographicToRadians(cartographic, vector = []) {
  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity3 : toRadians);
}
function toCartographic(vector, cartographic, map = identity3) {
  if ("longitude" in cartographic) {
    cartographic.longitude = map(vector[0]);
    cartographic.latitude = map(vector[1]);
    cartographic.height = vector[2];
  } else if ("x" in cartographic) {
    cartographic.x = map(vector[0]);
    cartographic.y = map(vector[1]);
    cartographic.z = vector[2];
  } else {
    cartographic[0] = map(vector[0]);
    cartographic[1] = map(vector[1]);
    cartographic[2] = vector[2];
  }
  return cartographic;
}
function toCartographicFromRadians(vector, cartographic) {
  return toCartographic(vector, cartographic, config._cartographicRadians ? identity3 : toDegrees);
}

// node_modules/@math.gl/geospatial/dist/ellipsoid/helpers/ellipsoid-transform.js
var EPSILON14 = 1e-14;
var scratchOrigin = new Vector3();
var VECTOR_PRODUCT_LOCAL_FRAME = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
};
var degeneratePositionLocalFrame = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
};
var scratchAxisVectors = {
  east: new Vector3(),
  north: new Vector3(),
  up: new Vector3(),
  west: new Vector3(),
  south: new Vector3(),
  down: new Vector3()
};
var scratchVector1 = new Vector3();
var scratchVector24 = new Vector3();
var scratchVector33 = new Vector3();
function localFrameToFixedFrame(ellipsoid, firstAxis, secondAxis, thirdAxis, cartesianOrigin, result) {
  const thirdAxisInferred = VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] && VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis];
  assert3(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));
  let firstAxisVector;
  let secondAxisVector;
  let thirdAxisVector;
  const origin = scratchOrigin.copy(cartesianOrigin);
  const atPole = equals(origin.x, 0, EPSILON14) && equals(origin.y, 0, EPSILON14);
  if (atPole) {
    const sign = Math.sign(origin.z);
    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);
    if (firstAxis !== "east" && firstAxis !== "west") {
      firstAxisVector.scale(sign);
    }
    secondAxisVector = scratchVector24.fromArray(degeneratePositionLocalFrame[secondAxis]);
    if (secondAxis !== "east" && secondAxis !== "west") {
      secondAxisVector.scale(sign);
    }
    thirdAxisVector = scratchVector33.fromArray(degeneratePositionLocalFrame[thirdAxis]);
    if (thirdAxis !== "east" && thirdAxis !== "west") {
      thirdAxisVector.scale(sign);
    }
  } else {
    const { up, east, north } = scratchAxisVectors;
    east.set(-origin.y, origin.x, 0).normalize();
    ellipsoid.geodeticSurfaceNormal(origin, up);
    north.copy(up).cross(east);
    const { down, west, south } = scratchAxisVectors;
    down.copy(up).scale(-1);
    west.copy(east).scale(-1);
    south.copy(north).scale(-1);
    firstAxisVector = scratchAxisVectors[firstAxis];
    secondAxisVector = scratchAxisVectors[secondAxis];
    thirdAxisVector = scratchAxisVectors[thirdAxis];
  }
  result[0] = firstAxisVector.x;
  result[1] = firstAxisVector.y;
  result[2] = firstAxisVector.z;
  result[3] = 0;
  result[4] = secondAxisVector.x;
  result[5] = secondAxisVector.y;
  result[6] = secondAxisVector.z;
  result[7] = 0;
  result[8] = thirdAxisVector.x;
  result[9] = thirdAxisVector.y;
  result[10] = thirdAxisVector.z;
  result[11] = 0;
  result[12] = origin.x;
  result[13] = origin.y;
  result[14] = origin.z;
  result[15] = 1;
  return result;
}

// node_modules/@math.gl/geospatial/dist/ellipsoid/helpers/scale-to-geodetic-surface.js
var scratchVector9 = new Vector3();
var scaleToGeodeticSurfaceIntersection = new Vector3();
var scaleToGeodeticSurfaceGradient = new Vector3();
function scaleToGeodeticSurface(cartesian, ellipsoid, result = []) {
  const { oneOverRadii, oneOverRadiiSquared, centerToleranceSquared } = ellipsoid;
  scratchVector9.from(cartesian);
  const positionX = scratchVector9.x;
  const positionY = scratchVector9.y;
  const positionZ = scratchVector9.z;
  const oneOverRadiiX = oneOverRadii.x;
  const oneOverRadiiY = oneOverRadii.y;
  const oneOverRadiiZ = oneOverRadii.z;
  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;
  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;
  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;
  const squaredNorm = x2 + y2 + z2;
  const ratio = Math.sqrt(1 / squaredNorm);
  if (!Number.isFinite(ratio)) {
    return void 0;
  }
  const intersection = scaleToGeodeticSurfaceIntersection;
  intersection.copy(cartesian).scale(ratio);
  if (squaredNorm < centerToleranceSquared) {
    return intersection.to(result);
  }
  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;
  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;
  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;
  const gradient = scaleToGeodeticSurfaceGradient;
  gradient.set(intersection.x * oneOverRadiiSquaredX * 2, intersection.y * oneOverRadiiSquaredY * 2, intersection.z * oneOverRadiiSquaredZ * 2);
  let lambda = (1 - ratio) * scratchVector9.len() / (0.5 * gradient.len());
  let correction = 0;
  let xMultiplier;
  let yMultiplier;
  let zMultiplier;
  let func;
  do {
    lambda -= correction;
    xMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredX);
    yMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredY);
    zMultiplier = 1 / (1 + lambda * oneOverRadiiSquaredZ);
    const xMultiplier2 = xMultiplier * xMultiplier;
    const yMultiplier2 = yMultiplier * yMultiplier;
    const zMultiplier2 = zMultiplier * zMultiplier;
    const xMultiplier3 = xMultiplier2 * xMultiplier;
    const yMultiplier3 = yMultiplier2 * yMultiplier;
    const zMultiplier3 = zMultiplier2 * zMultiplier;
    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1;
    const denominator = x2 * xMultiplier3 * oneOverRadiiSquaredX + y2 * yMultiplier3 * oneOverRadiiSquaredY + z2 * zMultiplier3 * oneOverRadiiSquaredZ;
    const derivative = -2 * denominator;
    correction = func / derivative;
  } while (Math.abs(func) > math_utils_exports.EPSILON12);
  return scratchVector9.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);
}

// node_modules/@math.gl/geospatial/dist/ellipsoid/ellipsoid.js
var scratchVector10 = new Vector3();
var scratchNormal3 = new Vector3();
var scratchK = new Vector3();
var scratchPosition2 = new Vector3();
var scratchHeight = new Vector3();
var scratchCartesian = new Vector3();
var Ellipsoid = class {
  constructor(x = 0, y = 0, z = 0) {
    this.centerToleranceSquared = math_utils_exports.EPSILON1;
    assert3(x >= 0);
    assert3(y >= 0);
    assert3(z >= 0);
    this.radii = new Vector3(x, y, z);
    this.radiiSquared = new Vector3(x * x, y * y, z * z);
    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);
    this.oneOverRadii = new Vector3(x === 0 ? 0 : 1 / x, y === 0 ? 0 : 1 / y, z === 0 ? 0 : 1 / z);
    this.oneOverRadiiSquared = new Vector3(x === 0 ? 0 : 1 / (x * x), y === 0 ? 0 : 1 / (y * y), z === 0 ? 0 : 1 / (z * z));
    this.minimumRadius = Math.min(x, y, z);
    this.maximumRadius = Math.max(x, y, z);
    if (this.radiiSquared.z !== 0) {
      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;
    }
    Object.freeze(this);
  }
  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
  equals(right) {
    return this === right || Boolean(right && this.radii.equals(right.radii));
  }
  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(cartographic, result = [0, 0, 0]) {
    const normal = scratchNormal3;
    const k = scratchK;
    const [, , height] = cartographic;
    this.geodeticSurfaceNormalCartographic(cartographic, normal);
    k.copy(this.radiiSquared).scale(normal);
    const gamma = Math.sqrt(normal.dot(k));
    k.scale(1 / gamma);
    normal.scale(height);
    k.add(normal);
    return k.to(result);
  }
  cartesianToCartographic(cartesian, result = [0, 0, 0]) {
    scratchCartesian.from(cartesian);
    const point2 = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition2);
    if (!point2) {
      return void 0;
    }
    const normal = this.geodeticSurfaceNormal(point2, scratchNormal3);
    const h = scratchHeight;
    h.copy(scratchCartesian).subtract(point2);
    const longitude = Math.atan2(normal.y, normal.x);
    const latitude = Math.asin(normal.z);
    const height = Math.sign(vec3_exports.dot(h, scratchCartesian)) * vec3_exports.length(h);
    return toCartographicFromRadians([longitude, latitude, height], result);
  }
  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {
    return localFrameToFixedFrame(this, "east", "north", "up", origin, result);
  }
  // Computes a 4x4 transformation matrix from a reference frame centered at
  // the provided origin to the ellipsoid's fixed reference frame.
  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {
    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);
  }
  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {
    return scratchVector10.from(cartesian).normalize().to(result);
  }
  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {
    const cartographicVectorRadians = fromCartographicToRadians(cartographic);
    const longitude = cartographicVectorRadians[0];
    const latitude = cartographicVectorRadians[1];
    const cosLatitude = Math.cos(latitude);
    scratchVector10.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();
    return scratchVector10.to(result);
  }
  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {
    return scratchVector10.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);
  }
  /** Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined. */
  scaleToGeodeticSurface(cartesian, result) {
    return scaleToGeodeticSurface(cartesian, this, result);
  }
  /** Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid. */
  scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {
    scratchPosition2.from(cartesian);
    const positionX = scratchPosition2.x;
    const positionY = scratchPosition2.y;
    const positionZ = scratchPosition2.z;
    const oneOverRadiiSquared = this.oneOverRadiiSquared;
    const beta = 1 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
    return scratchPosition2.multiplyScalar(beta).to(result);
  }
  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#oneOverRadii` */
  transformPositionToScaledSpace(position, result = [0, 0, 0]) {
    return scratchPosition2.from(position).scale(this.oneOverRadii).to(result);
  }
  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#radii`. */
  transformPositionFromScaledSpace(position, result = [0, 0, 0]) {
    return scratchPosition2.from(position).scale(this.radii).to(result);
  }
  /** Computes a point which is the intersection of the surface normal with the z-axis. */
  getSurfaceNormalIntersectionWithZAxis(position, buffer = 0, result = [0, 0, 0]) {
    assert3(equals(this.radii.x, this.radii.y, math_utils_exports.EPSILON15));
    assert3(this.radii.z > 0);
    scratchPosition2.from(position);
    const z = scratchPosition2.z * (1 - this.squaredXOverSquaredZ);
    if (Math.abs(z) >= this.radii.z - buffer) {
      return void 0;
    }
    return scratchPosition2.set(0, 0, z).to(result);
  }
};
Ellipsoid.WGS84 = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);

// node_modules/@loaders.gl/tiles/dist/utils/doubly-linked-list-node.js
var DoublyLinkedListNode = class {
  constructor(item, previous, next) {
    __publicField(this, "item");
    __publicField(this, "previous");
    __publicField(this, "next");
    this.item = item;
    this.previous = previous;
    this.next = next;
  }
};

// node_modules/@loaders.gl/tiles/dist/utils/doubly-linked-list.js
var DoublyLinkedList = class {
  constructor() {
    __publicField(this, "head", null);
    __publicField(this, "tail", null);
    __publicField(this, "_length", 0);
  }
  get length() {
    return this._length;
  }
  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(item) {
    const node = new DoublyLinkedListNode(item, this.tail, null);
    if (this.tail) {
      this.tail.next = node;
      this.tail = node;
    } else {
      this.head = node;
      this.tail = node;
    }
    ++this._length;
    return node;
  }
  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(node) {
    if (!node) {
      return;
    }
    if (node.previous && node.next) {
      node.previous.next = node.next;
      node.next.previous = node.previous;
    } else if (node.previous) {
      node.previous.next = null;
      this.tail = node.previous;
    } else if (node.next) {
      node.next.previous = null;
      this.head = node.next;
    } else {
      this.head = null;
      this.tail = null;
    }
    node.next = null;
    node.previous = null;
    --this._length;
  }
  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(node, nextNode) {
    if (node === nextNode) {
      return;
    }
    this.remove(nextNode);
    this._insert(node, nextNode);
  }
  _insert(node, nextNode) {
    const oldNodeNext = node.next;
    node.next = nextNode;
    if (this.tail === node) {
      this.tail = nextNode;
    } else {
      oldNodeNext.previous = nextNode;
    }
    nextNode.next = oldNodeNext;
    nextNode.previous = node;
    ++this._length;
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/tileset-cache.js
var TilesetCache = class {
  constructor() {
    __publicField(this, "_list");
    __publicField(this, "_sentinel");
    __publicField(this, "_trimTiles");
    this._list = new DoublyLinkedList();
    this._sentinel = this._list.add("sentinel");
    this._trimTiles = false;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(tile) {
    const node = tile._cacheNode;
    if (node) {
      this._list.splice(this._sentinel, node);
    }
  }
  add(tileset, tile, addCallback) {
    if (!tile._cacheNode) {
      tile._cacheNode = this._list.add(tile);
      if (addCallback) {
        addCallback(tileset, tile);
      }
    }
  }
  unloadTile(tileset, tile, unloadCallback) {
    const node = tile._cacheNode;
    if (!node) {
      return;
    }
    this._list.remove(node);
    tile._cacheNode = null;
    if (unloadCallback) {
      unloadCallback(tileset, tile);
    }
  }
  unloadTiles(tileset, unloadCallback) {
    const trimTiles = this._trimTiles;
    this._trimTiles = false;
    const list = this._list;
    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;
    const sentinel = this._sentinel;
    let node = list.head;
    while (node !== sentinel && (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)) {
      const tile = node.item;
      node = node.next;
      this.unloadTile(tileset, tile, unloadCallback);
    }
  }
  trim() {
    this._trimTiles = true;
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/transform-utils.js
function calculateTransformProps(tileHeader, tile) {
  assert2(tileHeader);
  assert2(tile);
  const { rtcCenter, gltfUpAxis } = tile;
  const { computedTransform, boundingVolume: { center: center2 } } = tileHeader;
  let modelMatrix2 = new Matrix4(computedTransform);
  if (rtcCenter) {
    modelMatrix2.translate(rtcCenter);
  }
  switch (gltfUpAxis) {
    case "Z":
      break;
    case "Y":
      const rotationY = new Matrix4().rotateX(Math.PI / 2);
      modelMatrix2 = modelMatrix2.multiplyRight(rotationY);
      break;
    case "X":
      const rotationX = new Matrix4().rotateY(-Math.PI / 2);
      modelMatrix2 = modelMatrix2.multiplyRight(rotationX);
      break;
    default:
      break;
  }
  if (tile.isQuantized) {
    modelMatrix2.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);
  }
  const cartesianOrigin = new Vector3(center2);
  tile.cartesianModelMatrix = modelMatrix2;
  tile.cartesianOrigin = cartesianOrigin;
  const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(cartesianOrigin, new Vector3());
  const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);
  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();
  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix2);
  tile.cartographicOrigin = cartographicOrigin;
  if (!tile.coordinateSystem) {
    tile.modelMatrix = tile.cartographicModelMatrix;
  }
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/frame-state.js
var scratchVector11 = new Vector3();
var scratchPosition3 = new Vector3();
var cullingVolume = new CullingVolume([
  new Plane(),
  new Plane(),
  new Plane(),
  new Plane(),
  new Plane(),
  new Plane()
]);
function getFrameState(viewport, frameNumber) {
  const { cameraDirection, cameraUp, height } = viewport;
  const { metersPerUnit } = viewport.distanceScales;
  const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);
  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);
  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
  const cameraPositionCartesian2 = Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, new Vector3());
  const cameraDirectionCartesian = new Vector3(
    // @ts-ignore
    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))
  ).normalize();
  const cameraUpCartesian = new Vector3(
    // @ts-ignore
    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))
  ).normalize();
  commonSpacePlanesToWGS84(viewport);
  const ViewportClass = viewport.constructor;
  const { longitude, latitude, width, bearing, zoom } = viewport;
  const topDownViewport = new ViewportClass({
    longitude,
    latitude,
    height,
    width,
    bearing,
    zoom,
    pitch: 0
  });
  return {
    camera: {
      position: cameraPositionCartesian2,
      direction: cameraDirectionCartesian,
      up: cameraUpCartesian
    },
    viewport,
    topDownViewport,
    height,
    cullingVolume,
    frameNumber,
    // TODO: This can be the same between updates, what number is unique for between updates?
    sseDenominator: 1.15
    // Assumes fovy = 60 degrees
  };
}
function limitSelectedTiles(tiles, frameState, maximumTilesSelected) {
  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {
    return [tiles, []];
  }
  const tuples = [];
  const { longitude: viewportLongitude, latitude: viewportLatitude } = frameState.viewport;
  for (const [index, tile] of tiles.entries()) {
    const [longitude, latitude] = tile.header.mbs;
    const deltaLon = Math.abs(viewportLongitude - longitude);
    const deltaLat = Math.abs(viewportLatitude - latitude);
    const distance3 = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);
    tuples.push([index, distance3]);
  }
  const tuplesSorted = tuples.sort((a3, b3) => a3[1] - b3[1]);
  const selectedTiles = [];
  for (let i = 0; i < maximumTilesSelected; i++) {
    selectedTiles.push(tiles[tuplesSorted[i][0]]);
  }
  const unselectedTiles = [];
  for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {
    unselectedTiles.push(tiles[tuplesSorted[i][0]]);
  }
  return [selectedTiles, unselectedTiles];
}
function commonSpacePlanesToWGS84(viewport) {
  const frustumPlanes = viewport.getFrustumPlanes();
  const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);
  const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);
  const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition3);
  let i = 0;
  cullingVolume.planes[i++].fromPointNormal(nearCenterCartesian, scratchVector11.copy(nearCenterCartesian).subtract(cameraCartesian));
  for (const dir in frustumPlanes) {
    if (dir === "near") {
      continue;
    }
    const plane = frustumPlanes[dir];
    const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition3);
    const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition3);
    cullingVolume.planes[i++].fromPointNormal(
      cartesianPos,
      // Want the normal to point into the frustum since that's what culling expects
      scratchVector11.copy(nearCenterCartesian).subtract(cartesianPos)
    );
  }
}
function closestPointOnPlane(plane, refPoint, out = new Vector3()) {
  const distanceToRef = plane.normal.dot(refPoint);
  out.copy(plane.normal).scale(plane.distance - distanceToRef).add(refPoint);
  return out;
}
function worldToCartesian(viewport, point2, out = new Vector3()) {
  const cartographicPos = viewport.unprojectPosition(point2);
  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/zoom.js
var WGS84_RADIUS_X2 = 6378137;
var WGS84_RADIUS_Y2 = 6378137;
var WGS84_RADIUS_Z2 = 6356752314245179e-9;
var scratchVector12 = new Vector3();
function getZoomFromBoundingVolume(boundingVolume, cartorgraphicCenter) {
  if (boundingVolume instanceof OrientedBoundingBox) {
    const { halfAxes } = boundingVolume;
    const obbSize = getObbSize(halfAxes);
    return Math.log2(WGS84_RADIUS_Z2 / (obbSize + cartorgraphicCenter[2]));
  } else if (boundingVolume instanceof BoundingSphere) {
    const { radius } = boundingVolume;
    return Math.log2(WGS84_RADIUS_Z2 / (radius + cartorgraphicCenter[2]));
  } else if (boundingVolume.width && boundingVolume.height) {
    const { width, height } = boundingVolume;
    const zoomX = Math.log2(WGS84_RADIUS_X2 / width);
    const zoomY = Math.log2(WGS84_RADIUS_Y2 / height);
    return (zoomX + zoomY) / 2;
  }
  return 1;
}
function getZoomFromFullExtent(fullExtent, cartorgraphicCenter, cartesianCenter) {
  Ellipsoid.WGS84.cartographicToCartesian([fullExtent.xmax, fullExtent.ymax, fullExtent.zmax], scratchVector12);
  const extentSize = Math.sqrt(Math.pow(scratchVector12[0] - cartesianCenter[0], 2) + Math.pow(scratchVector12[1] - cartesianCenter[1], 2) + Math.pow(scratchVector12[2] - cartesianCenter[2], 2));
  return Math.log2(WGS84_RADIUS_Z2 / (extentSize + cartorgraphicCenter[2]));
}
function getZoomFromExtent(extent, cartorgraphicCenter, cartesianCenter) {
  const [xmin, ymin, xmax, ymax] = extent;
  return getZoomFromFullExtent({ xmin, xmax, ymin, ymax, zmin: 0, zmax: 0 }, cartorgraphicCenter, cartesianCenter);
}
function getObbSize(halfAxes) {
  halfAxes.getColumn(0, scratchVector12);
  const axeY = halfAxes.getColumn(1);
  const axeZ = halfAxes.getColumn(2);
  const farthestVertex = scratchVector12.add(axeY).add(axeZ);
  const size = farthestVertex.len();
  return size;
}

// node_modules/@loaders.gl/tiles/dist/constants.js
var TILE_CONTENT_STATE = {
  UNLOADED: 0,
  // Has never been requested
  LOADING: 1,
  // Is waiting on a pending request
  PROCESSING: 2,
  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3,
  // Ready to render.
  EXPIRED: 4,
  // Is expired and will be unloaded once new content is loaded.
  FAILED: 5
  // Request failed.
};
var TILE_REFINEMENT;
(function(TILE_REFINEMENT2) {
  TILE_REFINEMENT2[TILE_REFINEMENT2["ADD"] = 1] = "ADD";
  TILE_REFINEMENT2[TILE_REFINEMENT2["REPLACE"] = 2] = "REPLACE";
})(TILE_REFINEMENT || (TILE_REFINEMENT = {}));
var TILE_TYPE;
(function(TILE_TYPE2) {
  TILE_TYPE2["EMPTY"] = "empty";
  TILE_TYPE2["SCENEGRAPH"] = "scenegraph";
  TILE_TYPE2["POINTCLOUD"] = "pointcloud";
  TILE_TYPE2["MESH"] = "mesh";
})(TILE_TYPE || (TILE_TYPE = {}));
var TILESET_TYPE;
(function(TILESET_TYPE2) {
  TILESET_TYPE2["I3S"] = "I3S";
  TILESET_TYPE2["TILES3D"] = "TILES3D";
})(TILESET_TYPE || (TILESET_TYPE = {}));
var LOD_METRIC_TYPE;
(function(LOD_METRIC_TYPE2) {
  LOD_METRIC_TYPE2["GEOMETRIC_ERROR"] = "geometricError";
  LOD_METRIC_TYPE2["MAX_SCREEN_THRESHOLD"] = "maxScreenThreshold";
})(LOD_METRIC_TYPE || (LOD_METRIC_TYPE = {}));
var TILE3D_OPTIMIZATION_HINT = {
  NOT_COMPUTED: -1,
  USE_OPTIMIZATION: 1,
  SKIP_OPTIMIZATION: 0
};

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/bounding-volume.js
function defined(x) {
  return x !== void 0 && x !== null;
}
var scratchPoint = new Vector3();
var scratchScale = new Vector3();
var scratchNorthWest = new Vector3();
var scratchSouthEast = new Vector3();
var scratchCenter = new Vector3();
var scratchXAxis = new Vector3();
var scratchYAxis = new Vector3();
var scratchZAxis = new Vector3();
function createBoundingVolume(boundingVolumeHeader, transform2, result) {
  assert2(boundingVolumeHeader, "3D Tile: boundingVolume must be defined");
  if (boundingVolumeHeader.box) {
    return createBox(boundingVolumeHeader.box, transform2, result);
  }
  if (boundingVolumeHeader.region) {
    return createObbFromRegion(boundingVolumeHeader.region);
  }
  if (boundingVolumeHeader.sphere) {
    return createSphere(boundingVolumeHeader.sphere, transform2, result);
  }
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function getCartographicBounds(boundingVolumeHeader, boundingVolume) {
  if (boundingVolumeHeader.box) {
    return orientedBoundingBoxToCartographicBounds(boundingVolume);
  }
  if (boundingVolumeHeader.region) {
    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;
    return [
      [degrees(west), degrees(south), minHeight],
      [degrees(east), degrees(north), maxHeight]
    ];
  }
  if (boundingVolumeHeader.sphere) {
    return boundingSphereToCartographicBounds(boundingVolume);
  }
  throw new Error("Unkown boundingVolume type");
}
function createBox(box, transform2, result) {
  const center2 = new Vector3(box[0], box[1], box[2]);
  transform2.transform(center2, center2);
  let origin = [];
  if (box.length === 10) {
    const halfSize = box.slice(3, 6);
    const quaternion = new Quaternion();
    quaternion.fromArray(box, 6);
    const x = new Vector3([1, 0, 0]);
    const y = new Vector3([0, 1, 0]);
    const z = new Vector3([0, 0, 1]);
    x.transformByQuaternion(quaternion);
    x.scale(halfSize[0]);
    y.transformByQuaternion(quaternion);
    y.scale(halfSize[1]);
    z.transformByQuaternion(quaternion);
    z.scale(halfSize[2]);
    origin = [...x.toArray(), ...y.toArray(), ...z.toArray()];
  } else {
    origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];
  }
  const xAxis = transform2.transformAsVector(origin.slice(0, 3));
  const yAxis = transform2.transformAsVector(origin.slice(3, 6));
  const zAxis = transform2.transformAsVector(origin.slice(6, 9));
  const halfAxes = new Matrix3([
    xAxis[0],
    xAxis[1],
    xAxis[2],
    yAxis[0],
    yAxis[1],
    yAxis[2],
    zAxis[0],
    zAxis[1],
    zAxis[2]
  ]);
  if (defined(result)) {
    result.center = center2;
    result.halfAxes = halfAxes;
    return result;
  }
  return new OrientedBoundingBox(center2, halfAxes);
}
function createSphere(sphere, transform2, result) {
  const center2 = new Vector3(sphere[0], sphere[1], sphere[2]);
  transform2.transform(center2, center2);
  const scale7 = transform2.getScale(scratchScale);
  const uniformScale = Math.max(Math.max(scale7[0], scale7[1]), scale7[2]);
  const radius = sphere[3] * uniformScale;
  if (defined(result)) {
    result.center = center2;
    result.radius = radius;
    return result;
  }
  return new BoundingSphere(center2, radius);
}
function createObbFromRegion(region) {
  const [west, south, east, north, minHeight, maxHeight] = region;
  const northWest = Ellipsoid.WGS84.cartographicToCartesian([degrees(west), degrees(north), minHeight], scratchNorthWest);
  const southEast = Ellipsoid.WGS84.cartographicToCartesian([degrees(east), degrees(south), maxHeight], scratchSouthEast);
  const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyByScalar(0.5);
  Ellipsoid.WGS84.cartesianToCartographic(centerInCartesian, scratchCenter);
  Ellipsoid.WGS84.cartographicToCartesian([degrees(east), scratchCenter[1], scratchCenter[2]], scratchXAxis);
  Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], degrees(north), scratchCenter[2]], scratchYAxis);
  Ellipsoid.WGS84.cartographicToCartesian([scratchCenter[0], scratchCenter[1], maxHeight], scratchZAxis);
  return createBox([
    ...centerInCartesian,
    ...scratchXAxis.subtract(centerInCartesian),
    ...scratchYAxis.subtract(centerInCartesian),
    ...scratchZAxis.subtract(centerInCartesian)
  ], new Matrix4());
}
function orientedBoundingBoxToCartographicBounds(boundingVolume) {
  const result = emptyCartographicBounds();
  const { halfAxes } = boundingVolume;
  const xAxis = new Vector3(halfAxes.getColumn(0));
  const yAxis = new Vector3(halfAxes.getColumn(1));
  const zAxis = new Vector3(halfAxes.getColumn(2));
  for (let x = 0; x < 2; x++) {
    for (let y = 0; y < 2; y++) {
      for (let z = 0; z < 2; z++) {
        scratchPoint.copy(boundingVolume.center);
        scratchPoint.add(xAxis);
        scratchPoint.add(yAxis);
        scratchPoint.add(zAxis);
        addToCartographicBounds(result, scratchPoint);
        zAxis.negate();
      }
      yAxis.negate();
    }
    xAxis.negate();
  }
  return result;
}
function boundingSphereToCartographicBounds(boundingVolume) {
  const result = emptyCartographicBounds();
  const { center: center2, radius } = boundingVolume;
  const point2 = Ellipsoid.WGS84.scaleToGeodeticSurface(center2, scratchPoint);
  let zAxis;
  if (point2) {
    zAxis = Ellipsoid.WGS84.geodeticSurfaceNormal(point2);
  } else {
    zAxis = new Vector3(0, 0, 1);
  }
  let xAxis = new Vector3(zAxis[2], -zAxis[1], 0);
  if (xAxis.len() > 0) {
    xAxis.normalize();
  } else {
    xAxis = new Vector3(0, 1, 0);
  }
  const yAxis = xAxis.clone().cross(zAxis);
  for (const axis of [xAxis, yAxis, zAxis]) {
    scratchScale.copy(axis).scale(radius);
    for (let dir = 0; dir < 2; dir++) {
      scratchPoint.copy(center2);
      scratchPoint.add(scratchScale);
      addToCartographicBounds(result, scratchPoint);
      scratchScale.negate();
    }
  }
  return result;
}
function emptyCartographicBounds() {
  return [
    [Infinity, Infinity, Infinity],
    [-Infinity, -Infinity, -Infinity]
  ];
}
function addToCartographicBounds(target, cartesian) {
  Ellipsoid.WGS84.cartesianToCartographic(cartesian, scratchPoint);
  target[0][0] = Math.min(target[0][0], scratchPoint[0]);
  target[0][1] = Math.min(target[0][1], scratchPoint[1]);
  target[0][2] = Math.min(target[0][2], scratchPoint[2]);
  target[1][0] = Math.max(target[1][0], scratchPoint[0]);
  target[1][1] = Math.max(target[1][1], scratchPoint[1]);
  target[1][2] = Math.max(target[1][2], scratchPoint[2]);
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/tiles-3d-lod.js
var scratchPositionNormal = new Vector3();
var scratchCartographic = new Vector3();
var scratchMatrix3 = new Matrix4();
var scratchCenter2 = new Vector3();
var scratchPosition4 = new Vector3();
var scratchDirection = new Vector3();
function fog(distanceToCamera, density) {
  const scalar = distanceToCamera * density;
  return 1 - Math.exp(-(scalar * scalar));
}
function getDynamicScreenSpaceError(tileset, distanceToCamera) {
  if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {
    const density = tileset.dynamicScreenSpaceErrorComputedDensity;
    const factor = tileset.dynamicScreenSpaceErrorFactor;
    const dynamicError = fog(distanceToCamera, density) * factor;
    return dynamicError;
  }
  return 0;
}
function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {
  const tileset = tile.tileset;
  const parentLodMetricValue = tile.parent && tile.parent.lodMetricValue || tile.lodMetricValue;
  const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;
  if (lodMetricValue === 0) {
    return 0;
  }
  const distance3 = Math.max(tile._distanceToCamera, 1e-7);
  const { height, sseDenominator } = frameState;
  const { viewDistanceScale } = tileset.options;
  let error = lodMetricValue * height * (viewDistanceScale || 1) / (distance3 * sseDenominator);
  error -= getDynamicScreenSpaceError(tileset, distance3);
  return error;
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/i3s-lod.js
var cameraPositionCartesian = new Vector3();
var toEye = new Vector3();
var cameraPositionEnu = new Vector3();
var extraVertexEnu = new Vector3();
var projectedOriginVector = new Vector3();
var enuToCartesianMatrix = new Matrix4();
var cartesianToEnuMatrix = new Matrix4();
function getLodStatus(tile, frameState) {
  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {
    return "DIG";
  }
  const screenSize = 2 * getProjectedRadius(tile, frameState);
  if (screenSize < 2) {
    return "OUT";
  }
  if (!tile.header.children || screenSize <= tile.lodMetricValue) {
    return "DRAW";
  } else if (tile.header.children) {
    return "DIG";
  }
  return "OUT";
}
function getProjectedRadius(tile, frameState) {
  const { topDownViewport: viewport } = frameState;
  const mbsLat = tile.header.mbs[1];
  const mbsLon = tile.header.mbs[0];
  const mbsZ = tile.header.mbs[2];
  const mbsR = tile.header.mbs[3];
  const mbsCenterCartesian = [...tile.boundingVolume.center];
  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);
  Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);
  toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();
  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);
  cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();
  cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);
  const projection = Math.sqrt(cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]);
  const extraZ = projection * projection / cameraPositionEnu[2];
  extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);
  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);
  const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();
  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);
  const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);
  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(sphereMbsBorderVertexCartesian);
  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);
  const projectedMbsBorderVertex = viewport.project(sphereMbsBorderVertexCartographic);
  const projectedRadius = projectedOriginVector.copy(projectedOrigin).subtract(projectedMbsBorderVertex).magnitude();
  return projectedRadius;
}

// node_modules/@loaders.gl/tiles/dist/tileset/helpers/3d-tiles-options.js
function get3dTilesOptions(tileset) {
  return {
    assetGltfUpAxis: tileset.asset && tileset.asset.gltfUpAxis || "Y"
  };
}

// node_modules/@loaders.gl/tiles/dist/utils/managed-array.js
var ManagedArray = class {
  constructor(length5 = 0) {
    __publicField(this, "_map", /* @__PURE__ */ new Map());
    __publicField(this, "_array");
    __publicField(this, "_length");
    this._array = new Array(length5);
    this._length = length5;
  }
  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }
  set length(length5) {
    this._length = length5;
    if (length5 > this._array.length) {
      this._array.length = length5;
    }
  }
  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }
  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(index) {
    assert2(index < this._array.length);
    return this._array[index];
  }
  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(index, element) {
    assert2(index >= 0);
    if (index >= this.length) {
      this.length = index + 1;
    }
    if (this._map.has(this._array[index])) {
      this._map.delete(this._array[index]);
    }
    this._array[index] = element;
    this._map.set(element, index);
  }
  delete(element) {
    const index = this._map.get(element);
    if (index >= 0) {
      this._array.splice(index, 1);
      this._map.delete(element);
      this.length--;
    }
  }
  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }
  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(element) {
    if (!this._map.has(element)) {
      const index = this.length++;
      this._array[index] = element;
      this._map.set(element, index);
    }
  }
  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    const element = this._array[--this.length];
    this._map.delete(element);
    return element;
  }
  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(length5) {
    assert2(length5 >= 0);
    if (length5 > this._array.length) {
      this._array.length = length5;
    }
  }
  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(length5) {
    assert2(length5 >= 0);
    this.length = length5;
  }
  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(length5) {
    if (length5 === null || length5 === void 0) {
      length5 = this.length;
    }
    this._array.length = length5;
  }
  reset() {
    this._array = [];
    this._map = /* @__PURE__ */ new Map();
    this._length = 0;
  }
  find(target) {
    return this._map.has(target);
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/tileset-traverser.js
var DEFAULT_PROPS = {
  loadSiblings: false,
  skipLevelOfDetail: false,
  updateTransforms: true,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
var TilesetTraverser = class {
  // TODO nested props
  constructor(options) {
    __publicField(this, "options");
    // fulfill in traverse call
    __publicField(this, "root", null);
    // tiles should be rendered
    __publicField(this, "selectedTiles", {});
    // tiles should be loaded from server
    __publicField(this, "requestedTiles", {});
    // tiles does not have render content
    __publicField(this, "emptyTiles", {});
    __publicField(this, "lastUpdate", (/* @__PURE__ */ new Date()).getTime());
    __publicField(this, "updateDebounceTime", 1e3);
    /** temporary storage to hold the traversed tiles during a traversal */
    __publicField(this, "_traversalStack", new ManagedArray());
    __publicField(this, "_emptyTraversalStack", new ManagedArray());
    /** set in every traverse cycle */
    __publicField(this, "_frameNumber", null);
    this.options = { ...DEFAULT_PROPS, ...options };
  }
  // RESULT
  traversalFinished(frameState) {
    return true;
  }
  // tiles should be visible
  traverse(root, frameState, options) {
    this.root = root;
    this.options = { ...this.options, ...options };
    this.reset();
    this.updateTile(root, frameState);
    this._frameNumber = frameState.frameNumber;
    this.executeTraversal(root, frameState);
  }
  reset() {
    this.requestedTiles = {};
    this.selectedTiles = {};
    this.emptyTiles = {};
    this._traversalStack.reset();
    this._emptyTraversalStack.reset();
  }
  /**
   * Execute traverse
   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
   * This is the traditional replacement refinement approach and is called the base traversal.
   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
   * and rendering children and parent tiles simultaneously.
   */
  /* eslint-disable-next-line complexity, max-statements */
  executeTraversal(root, frameState) {
    const stack2 = this._traversalStack;
    root._selectionDepth = 1;
    stack2.push(root);
    while (stack2.length > 0) {
      const tile = stack2.pop();
      let shouldRefine = false;
      if (this.canTraverse(tile, frameState)) {
        this.updateChildTiles(tile, frameState);
        shouldRefine = this.updateAndPushChildren(tile, frameState, stack2, tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth);
      }
      const parent = tile.parent;
      const parentRefines = Boolean(!parent || parent._shouldRefine);
      const stoppedRefining = !shouldRefine;
      if (!tile.hasRenderContent) {
        this.emptyTiles[tile.id] = tile;
        this.loadTile(tile, frameState);
        if (stoppedRefining) {
          this.selectTile(tile, frameState);
        }
      } else if (tile.refine === TILE_REFINEMENT.ADD) {
        this.loadTile(tile, frameState);
        this.selectTile(tile, frameState);
      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {
        this.loadTile(tile, frameState);
        if (stoppedRefining) {
          this.selectTile(tile, frameState);
        }
      }
      this.touchTile(tile, frameState);
      tile._shouldRefine = shouldRefine && parentRefines;
    }
    const newTime = (/* @__PURE__ */ new Date()).getTime();
    if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {
      this.lastUpdate = newTime;
      this.options.onTraversalEnd(frameState);
    }
  }
  updateChildTiles(tile, frameState) {
    const children = tile.children;
    for (const child of children) {
      this.updateTile(child, frameState);
    }
  }
  /* eslint-disable complexity, max-statements */
  updateAndPushChildren(tile, frameState, stack2, depth) {
    const { loadSiblings, skipLevelOfDetail } = this.options;
    const children = tile.children;
    children.sort(this.compareDistanceToCamera.bind(this));
    const checkRefines = tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;
    let hasVisibleChild = false;
    let refines = true;
    for (const child of children) {
      child._selectionDepth = depth;
      if (child.isVisibleAndInRequestVolume) {
        if (stack2.find(child)) {
          stack2.delete(child);
        }
        stack2.push(child);
        hasVisibleChild = true;
      } else if (checkRefines || loadSiblings) {
        this.loadTile(child, frameState);
        this.touchTile(child, frameState);
      }
      if (checkRefines) {
        let childRefines;
        if (!child._inRequestVolume) {
          childRefines = false;
        } else if (!child.hasRenderContent) {
          childRefines = this.executeEmptyTraversal(child, frameState);
        } else {
          childRefines = child.contentAvailable;
        }
        refines = refines && childRefines;
        if (!refines) {
          return false;
        }
      }
    }
    if (!hasVisibleChild) {
      refines = false;
    }
    return refines;
  }
  /* eslint-enable complexity, max-statements */
  updateTile(tile, frameState) {
    this.updateTileVisibility(tile, frameState);
  }
  // tile to render in the browser
  selectTile(tile, frameState) {
    if (this.shouldSelectTile(tile)) {
      tile._selectedFrame = frameState.frameNumber;
      this.selectedTiles[tile.id] = tile;
    }
  }
  // tile to load from server
  loadTile(tile, frameState) {
    if (this.shouldLoadTile(tile)) {
      tile._requestedFrame = frameState.frameNumber;
      tile._priority = tile._getPriority();
      this.requestedTiles[tile.id] = tile;
    }
  }
  // cache tile
  touchTile(tile, frameState) {
    tile.tileset._cache.touch(tile);
    tile._touchedFrame = frameState.frameNumber;
  }
  // tile should be visible
  // tile should have children
  // tile LoD (level of detail) is not sufficient under current viewport
  canTraverse(tile, frameState) {
    if (!tile.hasChildren) {
      return false;
    }
    if (tile.hasTilesetContent) {
      return !tile.contentExpired;
    }
    return this.shouldRefine(tile, frameState);
  }
  shouldLoadTile(tile) {
    return tile.hasUnloadedContent || tile.contentExpired;
  }
  shouldSelectTile(tile) {
    return tile.contentAvailable && !this.options.skipLevelOfDetail;
  }
  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
  shouldRefine(tile, frameState, useParentMetric = false) {
    let screenSpaceError = tile._screenSpaceError;
    if (useParentMetric) {
      screenSpaceError = tile.getScreenSpaceError(frameState, true);
    }
    return screenSpaceError > tile.tileset.memoryAdjustedScreenSpaceError;
  }
  updateTileVisibility(tile, frameState) {
    const viewportIds = [];
    if (this.options.viewportTraversersMap) {
      for (const key in this.options.viewportTraversersMap) {
        const value = this.options.viewportTraversersMap[key];
        if (value === frameState.viewport.id) {
          viewportIds.push(key);
        }
      }
    } else {
      viewportIds.push(frameState.viewport.id);
    }
    tile.updateVisibility(frameState, viewportIds);
  }
  // UTILITIES
  compareDistanceToCamera(b3, a3) {
    return b3._distanceToCamera - a3._distanceToCamera;
  }
  anyChildrenVisible(tile, frameState) {
    let anyVisible = false;
    for (const child of tile.children) {
      child.updateVisibility(frameState);
      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;
    }
    return anyVisible;
  }
  // Depth-first traversal that checks if all nearest descendants with content are loaded.
  // Ignores visibility.
  executeEmptyTraversal(root, frameState) {
    let allDescendantsLoaded = true;
    const stack2 = this._emptyTraversalStack;
    stack2.push(root);
    while (stack2.length > 0) {
      const tile = stack2.pop();
      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState);
      const emptyLeaf = !tile.hasRenderContent && tile.children.length === 0;
      if (!traverse && !tile.contentAvailable && !emptyLeaf) {
        allDescendantsLoaded = false;
      }
      this.updateTile(tile, frameState);
      if (!tile.isVisibleAndInRequestVolume) {
        this.loadTile(tile, frameState);
        this.touchTile(tile, frameState);
      }
      if (traverse) {
        const children = tile.children;
        for (const child of children) {
          stack2.push(child);
        }
      }
    }
    return allDescendantsLoaded;
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/tile-3d.js
var scratchVector13 = new Vector3();
function defined2(x) {
  return x !== void 0 && x !== null;
}
var Tile3D = class {
  // TODO i3s specific, needs to remove
  /**
   * @constructs
   * Create a Tile3D instance
   * @param tileset - Tileset3D instance
   * @param header - tile header - JSON loaded from a dataset
   * @param parentHeader - parent Tile3D instance
   * @param extendedId - optional ID to separate copies of a tile for different viewports.
   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
   */
  // eslint-disable-next-line max-statements
  constructor(tileset, header, parentHeader, extendedId = "") {
    __publicField(this, "tileset");
    __publicField(this, "header");
    __publicField(this, "id");
    __publicField(this, "url");
    __publicField(this, "parent");
    /* Specifies the type of refine that is used when traversing this tile for rendering. */
    __publicField(this, "refine");
    __publicField(this, "type");
    __publicField(this, "contentUrl");
    /** Different refinement algorithms used by I3S and 3D tiles */
    __publicField(this, "lodMetricType", "geometricError");
    /** The error, in meters, introduced if this tile is rendered and its children are not. */
    __publicField(this, "lodMetricValue", 0);
    /** @todo math.gl is not exporting BoundingVolume base type? */
    __publicField(this, "boundingVolume", null);
    /**
     * The tile's content.  This represents the actual tile's payload,
     * not the content's metadata in the tileset JSON file.
     */
    __publicField(this, "content", null);
    __publicField(this, "contentState", TILE_CONTENT_STATE.UNLOADED);
    __publicField(this, "gpuMemoryUsageInBytes", 0);
    /** The tile's children - an array of Tile3D objects. */
    __publicField(this, "children", []);
    __publicField(this, "depth", 0);
    __publicField(this, "viewportIds", []);
    __publicField(this, "transform", new Matrix4());
    __publicField(this, "extensions", null);
    /** TODO Cesium 3d tiles specific */
    __publicField(this, "implicitTiling", null);
    /** Container to store application specific data */
    __publicField(this, "userData", {});
    __publicField(this, "computedTransform");
    __publicField(this, "hasEmptyContent", false);
    __publicField(this, "hasTilesetContent", false);
    __publicField(this, "traverser", new TilesetTraverser({}));
    /** Used by TilesetCache */
    __publicField(this, "_cacheNode", null);
    __publicField(this, "_frameNumber", null);
    // TODO Cesium 3d tiles specific
    __publicField(this, "_expireDate", null);
    __publicField(this, "_expiredContent", null);
    __publicField(this, "_boundingBox");
    /** updated every frame for tree traversal and rendering optimizations: */
    __publicField(this, "_distanceToCamera", 0);
    __publicField(this, "_screenSpaceError", 0);
    __publicField(this, "_visibilityPlaneMask");
    __publicField(this, "_visible");
    __publicField(this, "_contentBoundingVolume");
    __publicField(this, "_viewerRequestVolume");
    __publicField(this, "_initialTransform", new Matrix4());
    // Used by traverser, cannot be marked private
    __publicField(this, "_priority", 0);
    __publicField(this, "_selectedFrame", 0);
    __publicField(this, "_requestedFrame", 0);
    __publicField(this, "_selectionDepth", 0);
    __publicField(this, "_touchedFrame", 0);
    __publicField(this, "_centerZDepth", 0);
    __publicField(this, "_shouldRefine", false);
    __publicField(this, "_stackLength", 0);
    __publicField(this, "_visitedFrame", 0);
    __publicField(this, "_inRequestVolume", false);
    __publicField(this, "_lodJudge", null);
    this.header = header;
    this.tileset = tileset;
    this.id = extendedId || header.id;
    this.url = header.url;
    this.parent = parentHeader;
    this.refine = this._getRefine(header.refine);
    this.type = header.type;
    this.contentUrl = header.contentUrl;
    this._initializeLodMetric(header);
    this._initializeTransforms(header);
    this._initializeBoundingVolumes(header);
    this._initializeContent(header);
    this._initializeRenderingState(header);
    Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  /** Returns true if tile is not an empty tile and not an external tileset */
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  /** Returns true if tile has children */
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  /**
   * Determines if the tile's content is ready. This is automatically `true` for
   * tiles with empty content.
   */
  get contentReady() {
    return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;
  }
  /**
   * Determines if the tile has available content to render.  `true` if the tile's
   * content is ready or if it has expired content this renders while new content loads; otherwise,
   */
  get contentAvailable() {
    return Boolean(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  /** Returns true if tile has renderable content but it's unloaded */
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  /**
   * Determines if the tile's content has not be requested. `true` if tile's
   * content has not be requested; otherwise, `false`.
   */
  get contentUnloaded() {
    return this.contentState === TILE_CONTENT_STATE.UNLOADED;
  }
  /**
   * Determines if the tile's content is expired. `true` if tile's
   * content is expired; otherwise, `false`.
   */
  get contentExpired() {
    return this.contentState === TILE_CONTENT_STATE.EXPIRED;
  }
  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this.contentState === TILE_CONTENT_STATE.FAILED;
  }
  /**
   * Distance from the tile's bounding volume center to the camera
   */
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  /**
   * Screen space error for LOD selection
   */
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  /**
   * Get bounding box in cartographic coordinates
   * @returns [min, max] each in [longitude, latitude, altitude]
   */
  get boundingBox() {
    if (!this._boundingBox) {
      this._boundingBox = getCartographicBounds(this.header.boundingVolume, this.boundingVolume);
    }
    return this._boundingBox;
  }
  /** Get the tile's screen space error. */
  getScreenSpaceError(frameState, useParentLodMetric) {
    switch (this.tileset.type) {
      case TILESET_TYPE.I3S:
        return getProjectedRadius(this, frameState);
      case TILESET_TYPE.TILES3D:
        return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  /**
   * Make tile unselected than means it won't be shown
   * but it can be still loaded in memory
   */
  unselect() {
    this._selectedFrame = 0;
  }
  /**
   * Memory usage of tile on GPU
   */
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  /*
   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
   * Tiles are prioritized by screen space error.
   */
  // eslint-disable-next-line complexity
  _getPriority() {
    const traverser = this.tileset._traverser;
    const { skipLevelOfDetail } = traverser.options;
    const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;
    if (maySkipTile && !this.isVisible && this._visible !== void 0) {
      return -1;
    }
    if (this.tileset._frameNumber - this._touchedFrame >= 1) {
      return -1;
    }
    if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {
      return -1;
    }
    const parent = this.parent;
    const useParentScreenSpaceError = parent && (!maySkipTile || this._screenSpaceError === 0 || parent.hasTilesetContent);
    const screenSpaceError = useParentScreenSpaceError ? parent._screenSpaceError : this._screenSpaceError;
    const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0;
    return Math.max(rootScreenSpaceError - screenSpaceError, 0);
  }
  /**
   *  Requests the tile's content.
   * The request may not be made if the Request Scheduler can't prioritize it.
   */
  // eslint-disable-next-line max-statements, complexity
  async loadContent() {
    if (this.hasEmptyContent) {
      return false;
    }
    if (this.content) {
      return true;
    }
    const expired = this.contentExpired;
    if (expired) {
      this._expireDate = null;
    }
    this.contentState = TILE_CONTENT_STATE.LOADING;
    const requestToken = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!requestToken) {
      this.contentState = TILE_CONTENT_STATE.UNLOADED;
      return false;
    }
    try {
      const contentUrl = this.tileset.getTileUrl(this.contentUrl);
      const loader = this.tileset.loader;
      const options = {
        ...this.tileset.loadOptions,
        [loader.id]: {
          // @ts-expect-error
          ...this.tileset.loadOptions[loader.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(loader.id)
        }
      };
      this.content = await load(contentUrl, loader, options);
      if (this.tileset.options.contentLoader) {
        await this.tileset.options.contentLoader(this);
      }
      if (this._isTileset()) {
        this.tileset._initializeTileHeaders(this.content, this);
      }
      this.contentState = TILE_CONTENT_STATE.READY;
      this._onContentLoaded();
      return true;
    } catch (error) {
      this.contentState = TILE_CONTENT_STATE.FAILED;
      throw error;
    } finally {
      requestToken.done();
    }
  }
  // Unloads the tile's content.
  unloadContent() {
    if (this.content && this.content.destroy) {
      this.content.destroy();
    }
    this.content = null;
    if (this.header.content && this.header.content.destroy) {
      this.header.content.destroy();
    }
    this.header.content = null;
    this.contentState = TILE_CONTENT_STATE.UNLOADED;
    return true;
  }
  /**
   * Update the tile's visibility
   * @param {Object} frameState - frame state for tile culling
   * @param {string[]} viewportIds - a list of viewport ids that show this tile
   * @return {void}
   */
  updateVisibility(frameState, viewportIds) {
    if (this._frameNumber === frameState.frameNumber) {
      return;
    }
    const parent = this.parent;
    const parentVisibilityPlaneMask = parent ? parent._visibilityPlaneMask : CullingVolume.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(parentTransform);
    }
    this._distanceToCamera = this.distanceToTile(frameState);
    this._screenSpaceError = this.getScreenSpaceError(frameState, false);
    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask);
    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;
    this._inRequestVolume = this.insideViewerRequestVolume(frameState);
    this._frameNumber = frameState.frameNumber;
    this.viewportIds = viewportIds;
  }
  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(frameState, parentVisibilityPlaneMask) {
    const { cullingVolume: cullingVolume2 } = frameState;
    const { boundingVolume } = this;
    return cullingVolume2.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);
  }
  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility() {
    return true;
  }
  /**
   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
   * @param frameState The frame state.
   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
   */
  distanceToTile(frameState) {
    const boundingVolume = this.boundingVolume;
    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));
  }
  /**
   * Computes the tile's camera-space z-depth.
   * @param frameState The frame state.
   * @returns The distance, in meters.
   */
  cameraSpaceZDepth({ camera }) {
    const boundingVolume = this.boundingVolume;
    scratchVector13.subVectors(boundingVolume.center, camera.position);
    return camera.direction.dot(scratchVector13);
  }
  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(frameState) {
    const viewerRequestVolume = this._viewerRequestVolume;
    return !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0;
  }
  // TODO Cesium specific
  // Update whether the tile has expired.
  updateExpiration() {
    if (defined2(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const now = Date.now();
      if (Date.lessThan(this._expireDate, now)) {
        this.contentState = TILE_CONTENT_STATE.EXPIRED;
        this._expiredContent = this.content;
      }
    }
  }
  get extras() {
    return this.header.extras;
  }
  // INTERNAL METHODS
  _initializeLodMetric(header) {
    if ("lodMetricType" in header) {
      this.lodMetricType = header.lodMetricType;
    } else {
      this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType;
      console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);
    }
    if ("lodMetricValue" in header) {
      this.lodMetricValue = header.lodMetricValue;
    } else {
      this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue;
      console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue");
    }
  }
  _initializeTransforms(tileHeader) {
    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();
    const parent = this.parent;
    const tileset = this.tileset;
    const parentTransform = parent && parent.computedTransform ? parent.computedTransform.clone() : tileset.modelMatrix.clone();
    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);
    const parentInitialTransform = parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();
    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(tileHeader) {
    this._contentBoundingVolume = null;
    this._viewerRequestVolume = null;
    this._updateBoundingVolume(tileHeader);
  }
  _initializeContent(tileHeader) {
    this.content = { _tileset: this.tileset, _tile: this };
    this.hasEmptyContent = true;
    this.contentState = TILE_CONTENT_STATE.UNLOADED;
    this.hasTilesetContent = false;
    if (tileHeader.contentUrl) {
      this.content = null;
      this.hasEmptyContent = false;
    }
  }
  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState(header) {
    this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);
    this._shouldRefine = false;
    this._distanceToCamera = 0;
    this._centerZDepth = 0;
    this._screenSpaceError = 0;
    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;
    this._visible = void 0;
    this._inRequestVolume = false;
    this._stackLength = 0;
    this._selectionDepth = 0;
    this._frameNumber = 0;
    this._touchedFrame = 0;
    this._visitedFrame = 0;
    this._selectedFrame = 0;
    this._requestedFrame = 0;
    this._priority = 0;
  }
  _getRefine(refine) {
    return refine || this.parent && this.parent.refine || TILE_REFINEMENT.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = true;
        break;
      default:
    }
    if (this._isTileset()) {
      this.hasTilesetContent = true;
    } else {
      this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
    }
  }
  _updateBoundingVolume(header) {
    this.boundingVolume = createBoundingVolume(header.boundingVolume, this.computedTransform, this.boundingVolume);
    const content = header.content;
    if (!content) {
      return;
    }
    if (content.boundingVolume) {
      this._contentBoundingVolume = createBoundingVolume(content.boundingVolume, this.computedTransform, this._contentBoundingVolume);
    }
    if (header.viewerRequestVolume) {
      this._viewerRequestVolume = createBoundingVolume(header.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume);
    }
  }
  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform(parentTransform = new Matrix4()) {
    const computedTransform = parentTransform.clone().multiplyRight(this.transform);
    const didTransformChange = !computedTransform.equals(this.computedTransform);
    if (!didTransformChange) {
      return;
    }
    this.computedTransform = computedTransform;
    this._updateBoundingVolume(this.header);
  }
  // Get options which are applicable only for the particular loader
  _getLoaderSpecificOptions(loaderId) {
    switch (loaderId) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: false
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return get3dTilesOptions(this.tileset.tileset);
    }
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/format-3d-tiles/tileset-3d-traverser.js
var Tileset3DTraverser = class extends TilesetTraverser {
  compareDistanceToCamera(a3, b3) {
    return b3._distanceToCamera === 0 && a3._distanceToCamera === 0 ? b3._centerZDepth - a3._centerZDepth : b3._distanceToCamera - a3._distanceToCamera;
  }
  updateTileVisibility(tile, frameState) {
    super.updateTileVisibility(tile, frameState);
    if (!tile.isVisibleAndInRequestVolume) {
      return;
    }
    const hasChildren = tile.children.length > 0;
    if (tile.hasTilesetContent && hasChildren) {
      const firstChild = tile.children[0];
      this.updateTileVisibility(firstChild, frameState);
      tile._visible = firstChild._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {
      tile._visible = false;
      return;
    }
    const replace = tile.refine === TILE_REFINEMENT.REPLACE;
    const useOptimization = tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;
    if (replace && useOptimization && hasChildren) {
      if (!this.anyChildrenVisible(tile, frameState)) {
        tile._visible = false;
        return;
      }
    }
  }
  meetsScreenSpaceErrorEarly(tile, frameState) {
    const { parent } = tile;
    if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {
      return false;
    }
    return !this.shouldRefine(tile, frameState, true);
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-pending-tiles-register.js
var I3SPendingTilesRegister = class {
  constructor() {
    __publicField(this, "frameNumberMap", /* @__PURE__ */ new Map());
  }
  /**
   * Register a new pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  register(viewportId, frameNumber) {
    const viewportMap = this.frameNumberMap.get(viewportId) || /* @__PURE__ */ new Map();
    const oldCount = viewportMap.get(frameNumber) || 0;
    viewportMap.set(frameNumber, oldCount + 1);
    this.frameNumberMap.set(viewportId, viewportMap);
  }
  /**
   * Deregister a pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  deregister(viewportId, frameNumber) {
    const viewportMap = this.frameNumberMap.get(viewportId);
    if (!viewportMap) {
      return;
    }
    const oldCount = viewportMap.get(frameNumber) || 1;
    viewportMap.set(frameNumber, oldCount - 1);
  }
  /**
   * Check is there are no pending tile headers registered for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  isZero(viewportId, frameNumber) {
    var _a;
    const count = ((_a = this.frameNumberMap.get(viewportId)) == null ? void 0 : _a.get(frameNumber)) || 0;
    return count === 0;
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-tile-manager.js
var STATUS = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
var I3STileManager = class {
  constructor() {
    __publicField(this, "_statusMap");
    __publicField(this, "pendingTilesRegister", new I3SPendingTilesRegister());
    this._statusMap = {};
  }
  /**
   * Add request to map
   * @param request - node metadata request
   * @param key - unique key
   * @param callback - callback after request completed
   * @param frameState - frameState data
   */
  add(request, key, callback, frameState) {
    if (!this._statusMap[key]) {
      const { frameNumber, viewport: { id } } = frameState;
      this._statusMap[key] = { request, callback, key, frameState, status: STATUS.REQUESTED };
      this.pendingTilesRegister.register(id, frameNumber);
      request().then((data) => {
        this._statusMap[key].status = STATUS.COMPLETED;
        const { frameNumber: actualFrameNumber, viewport: { id: id2 } } = this._statusMap[key].frameState;
        this.pendingTilesRegister.deregister(id2, actualFrameNumber);
        this._statusMap[key].callback(data, frameState);
      }).catch((error) => {
        this._statusMap[key].status = STATUS.ERROR;
        const { frameNumber: actualFrameNumber, viewport: { id: id2 } } = this._statusMap[key].frameState;
        this.pendingTilesRegister.deregister(id2, actualFrameNumber);
        callback(error);
      });
    }
  }
  /**
   * Update request if it is still actual for the new frameState
   * @param key - unique key
   * @param frameState - frameState data
   */
  update(key, frameState) {
    if (this._statusMap[key]) {
      const { frameNumber, viewport: { id } } = this._statusMap[key].frameState;
      this.pendingTilesRegister.deregister(id, frameNumber);
      const { frameNumber: newFrameNumber, viewport: { id: newViewportId } } = frameState;
      this.pendingTilesRegister.register(newViewportId, newFrameNumber);
      this._statusMap[key].frameState = frameState;
    }
  }
  /**
   * Find request in the map
   * @param key - unique key
   * @returns
   */
  find(key) {
    return this._statusMap[key];
  }
  /**
   * Check it there are pending tile headers for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  hasPendingTiles(viewportId, frameNumber) {
    return !this.pendingTilesRegister.isZero(viewportId, frameNumber);
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/format-i3s/i3s-tileset-traverser.js
var I3STilesetTraverser = class extends TilesetTraverser {
  constructor(options) {
    super(options);
    __publicField(this, "_tileManager");
    this._tileManager = new I3STileManager();
  }
  /**
   * Check if there are no penging tile header requests,
   * that means the traversal is finished and we can call
   * following-up callbacks.
   */
  traversalFinished(frameState) {
    return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(tile, frameState) {
    tile._lodJudge = getLodStatus(tile, frameState);
    return tile._lodJudge === "DIG";
  }
  updateChildTiles(tile, frameState) {
    const children = tile.header.children || [];
    const childTiles = tile.children;
    const tileset = tile.tileset;
    for (const child of children) {
      const extendedId = `${child.id}-${frameState.viewport.id}`;
      const childTile = childTiles && childTiles.find((t) => t.id === extendedId);
      if (!childTile) {
        let request = () => this._loadTile(child.id, tileset);
        const cachedRequest = this._tileManager.find(extendedId);
        if (!cachedRequest) {
          if (tileset.tileset.nodePages) {
            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);
          }
          this._tileManager.add(request, extendedId, (header) => this._onTileLoad(header, tile, extendedId), frameState);
        } else {
          this._tileManager.update(extendedId, frameState);
        }
      } else if (childTile) {
        this.updateTile(childTile, frameState);
      }
    }
    return false;
  }
  async _loadTile(nodeId, tileset) {
    const { loader } = tileset;
    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);
    const options = {
      ...tileset.loadOptions,
      i3s: {
        ...tileset.loadOptions.i3s,
        isTileHeader: true
      }
    };
    return await load(nodeUrl, loader, options);
  }
  /**
   * The callback to init Tile3D instance after loading the tile JSON
   * @param {Object} header - the tile JSON from a dataset
   * @param {Tile3D} tile - the parent Tile3D instance
   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
   * @return {void}
   */
  _onTileLoad(header, tile, extendedId) {
    const childTile = new Tile3D(tile.tileset, header, tile, extendedId);
    tile.children.push(childTile);
    const frameState = this._tileManager.find(childTile.id).frameState;
    this.updateTile(childTile, frameState);
    if (this._frameNumber === frameState.frameNumber && (this.traversalFinished(frameState) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime)) {
      this.executeTraversal(childTile, frameState);
    }
  }
};

// node_modules/@loaders.gl/tiles/dist/tileset/tileset-3d.js
var DEFAULT_PROPS2 = {
  description: "",
  ellipsoid: Ellipsoid.WGS84,
  modelMatrix: new Matrix4(),
  throttleRequests: true,
  maxRequests: 64,
  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
  maximumMemoryUsage: 32,
  memoryCacheOverflow: 1,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (selectedTiles) => selectedTiles,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  memoryAdjustedScreenSpaceError: false,
  loadTiles: true,
  updateTransforms: true,
  viewportTraversersMap: null,
  loadOptions: { fetch: {} },
  attributions: [],
  basePath: "",
  i3s: {}
};
var TILES_TOTAL = "Tiles In Tileset(s)";
var TILES_IN_MEMORY = "Tiles In Memory";
var TILES_IN_VIEW = "Tiles In View";
var TILES_RENDERABLE = "Tiles To Render";
var TILES_LOADED = "Tiles Loaded";
var TILES_LOADING = "Tiles Loading";
var TILES_UNLOADED = "Tiles Unloaded";
var TILES_LOAD_FAILED = "Failed Tile Loads";
var POINTS_COUNT = "Points/Vertices";
var TILES_GPU_MEMORY = "Tile Memory Use";
var MAXIMUM_SSE = "Maximum Screen Space Error";
var Tileset3D = class {
  /**
   * Create a new Tileset3D
   * @param json
   * @param props
   */
  // eslint-disable-next-line max-statements
  constructor(tileset, options) {
    // props: Tileset3DProps;
    __publicField(this, "options");
    __publicField(this, "loadOptions");
    __publicField(this, "type");
    __publicField(this, "tileset");
    __publicField(this, "loader");
    __publicField(this, "url");
    __publicField(this, "basePath");
    __publicField(this, "modelMatrix");
    __publicField(this, "ellipsoid");
    __publicField(this, "lodMetricType");
    __publicField(this, "lodMetricValue");
    __publicField(this, "refine");
    __publicField(this, "root", null);
    __publicField(this, "roots", {});
    /** @todo any->unknown */
    __publicField(this, "asset", {});
    // Metadata for the entire tileset
    __publicField(this, "description", "");
    __publicField(this, "properties");
    __publicField(this, "extras", null);
    __publicField(this, "attributions", {});
    __publicField(this, "credits", {});
    __publicField(this, "stats");
    /** flags that contain information about data types in nested tiles */
    __publicField(this, "contentFormats", { draco: false, meshopt: false, dds: false, ktx2: false });
    // view props
    __publicField(this, "cartographicCenter", null);
    __publicField(this, "cartesianCenter", null);
    __publicField(this, "zoom", 1);
    __publicField(this, "boundingVolume", null);
    /** Updated based on the camera position and direction */
    __publicField(this, "dynamicScreenSpaceErrorComputedDensity", 0);
    // METRICS
    /**
     * The maximum amount of GPU memory (in MB) that may be used to cache tiles
     * Tiles not in view are unloaded to enforce private
     */
    __publicField(this, "maximumMemoryUsage", 32);
    /** The total amount of GPU memory in bytes used by the tileset. */
    __publicField(this, "gpuMemoryUsageInBytes", 0);
    /**
     * If loading the level of detail required by maximumScreenSpaceError
     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
     * will instead use this (larger) adjusted screen space error to achieve the
     * best possible visual quality within the available memory.
     */
    __publicField(this, "memoryAdjustedScreenSpaceError", 0);
    __publicField(this, "_cacheBytes", 0);
    __publicField(this, "_cacheOverflowBytes", 0);
    /** Update tracker. increase in each update cycle. */
    __publicField(this, "_frameNumber", 0);
    __publicField(this, "_queryParams", {});
    __publicField(this, "_extensionsUsed", []);
    __publicField(this, "_tiles", {});
    /** counter for tracking tiles requests */
    __publicField(this, "_pendingCount", 0);
    /** Hold traversal results */
    __publicField(this, "selectedTiles", []);
    // TRAVERSAL
    __publicField(this, "traverseCounter", 0);
    __publicField(this, "geometricError", 0);
    __publicField(this, "lastUpdatedVieports", null);
    __publicField(this, "_requestedTiles", []);
    __publicField(this, "_emptyTiles", []);
    __publicField(this, "frameStateData", {});
    __publicField(this, "_traverser");
    __publicField(this, "_cache", new TilesetCache());
    __publicField(this, "_requestScheduler");
    // Promise tracking
    __publicField(this, "updatePromise", null);
    __publicField(this, "tilesetInitializationPromise");
    this.options = { ...DEFAULT_PROPS2, ...options };
    this.tileset = tileset;
    this.loader = tileset.loader;
    this.type = tileset.type;
    this.url = tileset.url;
    this.basePath = tileset.basePath || path_exports.dirname(this.url);
    this.modelMatrix = this.options.modelMatrix;
    this.ellipsoid = this.options.ellipsoid;
    this.lodMetricType = tileset.lodMetricType;
    this.lodMetricValue = tileset.lodMetricValue;
    this.refine = tileset.root.refine;
    this.loadOptions = this.options.loadOptions || {};
    this._traverser = this._initializeTraverser();
    this._requestScheduler = new RequestScheduler({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    });
    this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError;
    this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024;
    this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024;
    this.stats = new Stats({ id: this.url });
    this._initializeStats();
    this.tilesetInitializationPromise = this._initializeTileSet(tileset);
  }
  /** Release resources */
  destroy() {
    this._destroy();
  }
  /** Is the tileset loaded (update needs to have been called at least once) */
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(props) {
    this.options = { ...this.options, ...props };
  }
  /** @deprecated */
  // setOptions(options: Tileset3DProps): void {
  //   this.options = {...this.options, ...options};
  // }
  /**
   * Return a loadable tile url for a specific tile subpath
   * @param tilePath a tile subpath
   */
  getTileUrl(tilePath) {
    const isDataUrl = tilePath.startsWith("data:");
    if (isDataUrl) {
      return tilePath;
    }
    let tileUrl = tilePath;
    if (this.queryParams.length) {
      tileUrl = `${tilePath}${tilePath.includes("?") ? "&" : "?"}${this.queryParams}`;
    }
    return tileUrl;
  }
  // TODO CESIUM specific
  hasExtension(extensionName) {
    return Boolean(this._extensionsUsed.indexOf(extensionName) > -1);
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports - list of viewports
   * @deprecated
   */
  update(viewports = null) {
    this.tilesetInitializationPromise.then(() => {
      if (!viewports && this.lastUpdatedVieports) {
        viewports = this.lastUpdatedVieports;
      } else {
        this.lastUpdatedVieports = viewports;
      }
      if (viewports) {
        this.doUpdate(viewports);
      }
    });
  }
  /**
   * Update visible tiles relying on a list of viewports.
   * Do it with debounce delay to prevent update spam
   * @param viewports viewports
   * @returns Promise of new frameNumber
   */
  async selectTiles(viewports = null) {
    await this.tilesetInitializationPromise;
    if (viewports) {
      this.lastUpdatedVieports = viewports;
    }
    if (!this.updatePromise) {
      this.updatePromise = new Promise((resolve) => {
        setTimeout(() => {
          if (this.lastUpdatedVieports) {
            this.doUpdate(this.lastUpdatedVieports);
          }
          resolve(this._frameNumber);
          this.updatePromise = null;
        }, this.options.debounceTime);
      });
    }
    return this.updatePromise;
  }
  adjustScreenSpaceError() {
    if (this.gpuMemoryUsageInBytes < this._cacheBytes) {
      this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError);
    } else if (this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes) {
      this.memoryAdjustedScreenSpaceError *= 1.02;
    }
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports viewports
   */
  // eslint-disable-next-line max-statements, complexity
  doUpdate(viewports) {
    if ("loadTiles" in this.options && !this.options.loadTiles) {
      return;
    }
    if (this.traverseCounter > 0) {
      return;
    }
    const preparedViewports = viewports instanceof Array ? viewports : [viewports];
    this._cache.reset();
    this._frameNumber++;
    this.traverseCounter = preparedViewports.length;
    const viewportsToTraverse = [];
    for (const viewport of preparedViewports) {
      const id = viewport.id;
      if (this._needTraverse(id)) {
        viewportsToTraverse.push(id);
      } else {
        this.traverseCounter--;
      }
    }
    for (const viewport of preparedViewports) {
      const id = viewport.id;
      if (!this.roots[id]) {
        this.roots[id] = this._initializeTileHeaders(this.tileset, null);
      }
      if (!viewportsToTraverse.includes(id)) {
        continue;
      }
      const frameState = getFrameState(viewport, this._frameNumber);
      this._traverser.traverse(this.roots[id], frameState, this.options);
    }
  }
  /**
   * Check if traversal is needed for particular viewport
   * @param {string} viewportId - id of a viewport
   * @return {boolean}
   */
  _needTraverse(viewportId) {
    let traverserId = viewportId;
    if (this.options.viewportTraversersMap) {
      traverserId = this.options.viewportTraversersMap[viewportId];
    }
    if (traverserId !== viewportId) {
      return false;
    }
    return true;
  }
  /**
   * The callback to post-process tiles after traversal procedure
   * @param frameState - frame state for tile culling
   */
  _onTraversalEnd(frameState) {
    const id = frameState.viewport.id;
    if (!this.frameStateData[id]) {
      this.frameStateData[id] = { selectedTiles: [], _requestedTiles: [], _emptyTiles: [] };
    }
    const currentFrameStateData = this.frameStateData[id];
    const selectedTiles = Object.values(this._traverser.selectedTiles);
    const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(selectedTiles, frameState, this.options.maximumTilesSelected);
    currentFrameStateData.selectedTiles = filteredSelectedTiles;
    for (const tile of unselectedTiles) {
      tile.unselect();
    }
    currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);
    currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);
    this.traverseCounter--;
    if (this.traverseCounter > 0) {
      return;
    }
    this._updateTiles();
  }
  /**
   * Update tiles relying on data from all traversers
   */
  _updateTiles() {
    this.selectedTiles = [];
    this._requestedTiles = [];
    this._emptyTiles = [];
    for (const frameStateKey in this.frameStateData) {
      const frameStateDataValue = this.frameStateData[frameStateKey];
      this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);
      this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);
      this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const tile of this.selectedTiles) {
      this._tiles[tile.id] = tile;
    }
    this._loadTiles();
    this._unloadTiles();
    this._updateStats();
  }
  _tilesChanged(oldSelectedTiles, selectedTiles) {
    if (oldSelectedTiles.length !== selectedTiles.length) {
      return true;
    }
    const set1 = new Set(oldSelectedTiles.map((t) => t.id));
    const set22 = new Set(selectedTiles.map((t) => t.id));
    let changed = oldSelectedTiles.filter((x) => !set22.has(x.id)).length > 0;
    changed = changed || selectedTiles.filter((x) => !set1.has(x.id)).length > 0;
    return changed;
  }
  _loadTiles() {
    for (const tile of this._requestedTiles) {
      if (tile.contentUnloaded) {
        this._loadTile(tile);
      }
    }
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));
  }
  _updateStats() {
    let tilesRenderable = 0;
    let pointsRenderable = 0;
    for (const tile of this.selectedTiles) {
      if (tile.contentAvailable && tile.content) {
        tilesRenderable++;
        if (tile.content.pointCount) {
          pointsRenderable += tile.content.pointCount;
        } else {
          pointsRenderable += tile.content.vertexCount;
        }
      }
    }
    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;
    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;
    this.stats.get(POINTS_COUNT).count = pointsRenderable;
    this.stats.get(MAXIMUM_SSE).count = this.memoryAdjustedScreenSpaceError;
  }
  async _initializeTileSet(tilesetJson) {
    if (this.type === TILESET_TYPE.I3S) {
      this.calculateViewPropsI3S();
      tilesetJson.root = await tilesetJson.root;
    }
    this.root = this._initializeTileHeaders(tilesetJson, null);
    if (this.type === TILESET_TYPE.TILES3D) {
      this._initializeTiles3DTileset(tilesetJson);
      this.calculateViewPropsTiles3D();
    }
    if (this.type === TILESET_TYPE.I3S) {
      this._initializeI3STileset();
    }
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset
   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
   * @returns
   */
  calculateViewPropsI3S() {
    var _a;
    const fullExtent = this.tileset.fullExtent;
    if (fullExtent) {
      const { xmin, xmax, ymin, ymax, zmin, zmax } = fullExtent;
      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, zmin + (zmax - zmin) / 2);
      this.cartesianCenter = new Vector3();
      Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);
      this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const extent = (_a = this.tileset.store) == null ? void 0 : _a.extent;
    if (extent) {
      const [xmin, ymin, xmax, ymax] = extent;
      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);
      this.cartesianCenter = new Vector3();
      Ellipsoid.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter);
      this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header");
    this.cartographicCenter = new Vector3();
    this.zoom = 1;
    return;
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset.
   * For 3DTiles the root tile data is used to calculate view props.
   * @returns
   */
  calculateViewPropsTiles3D() {
    const root = this.root;
    const { center: center2 } = root.boundingVolume;
    if (!center2) {
      console.warn("center was not pre-calculated for the root tile");
      this.cartographicCenter = new Vector3();
      this.zoom = 1;
      return;
    }
    if (center2[0] !== 0 || center2[1] !== 0 || center2[2] !== 0) {
      this.cartographicCenter = new Vector3();
      Ellipsoid.WGS84.cartesianToCartographic(center2, this.cartographicCenter);
    } else {
      this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);
    }
    this.cartesianCenter = center2;
    this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(TILES_TOTAL);
    this.stats.get(TILES_LOADING);
    this.stats.get(TILES_IN_MEMORY);
    this.stats.get(TILES_IN_VIEW);
    this.stats.get(TILES_RENDERABLE);
    this.stats.get(TILES_LOADED);
    this.stats.get(TILES_UNLOADED);
    this.stats.get(TILES_LOAD_FAILED);
    this.stats.get(POINTS_COUNT);
    this.stats.get(TILES_GPU_MEMORY, "memory");
    this.stats.get(MAXIMUM_SSE);
  }
  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(tilesetJson, parentTileHeader) {
    var _a;
    const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader);
    if (parentTileHeader) {
      parentTileHeader.children.push(rootTile);
      rootTile.depth = parentTileHeader.depth + 1;
    }
    if (this.type === TILESET_TYPE.TILES3D) {
      const stack2 = [];
      stack2.push(rootTile);
      while (stack2.length > 0) {
        const tile = stack2.pop();
        this.stats.get(TILES_TOTAL).incrementCount();
        const children = tile.header.children || [];
        for (const childHeader of children) {
          const childTile = new Tile3D(this, childHeader, tile);
          if ((_a = childTile.contentUrl) == null ? void 0 : _a.includes("?session=")) {
            const url = new URL(childTile.contentUrl);
            const session = url.searchParams.get("session");
            if (session) {
              this._queryParams.session = session;
            }
          }
          tile.children.push(childTile);
          childTile.depth = tile.depth + 1;
          stack2.push(childTile);
        }
      }
    }
    return rootTile;
  }
  _initializeTraverser() {
    let TraverserClass;
    const type = this.type;
    switch (type) {
      case TILESET_TYPE.TILES3D:
        TraverserClass = Tileset3DTraverser;
        break;
      case TILESET_TYPE.I3S:
        TraverserClass = I3STilesetTraverser;
        break;
      default:
        TraverserClass = TilesetTraverser;
    }
    return new TraverserClass({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(parentTile) {
    this._destroySubtree(parentTile);
  }
  async _loadTile(tile) {
    let loaded;
    try {
      this._onStartTileLoading();
      loaded = await tile.loadContent();
    } catch (error) {
      this._onTileLoadError(tile, error instanceof Error ? error : new Error("load failed"));
    } finally {
      this._onEndTileLoading();
      this._onTileLoad(tile, loaded);
    }
  }
  _onTileLoadError(tile, error) {
    this.stats.get(TILES_LOAD_FAILED).incrementCount();
    const message = error.message || error.toString();
    const url = tile.url;
    console.error(`A 3D tile failed to load: ${tile.url} ${message}`);
    this.options.onTileError(tile, message, url);
  }
  _onTileLoad(tile, loaded) {
    var _a, _b;
    if (!loaded) {
      return;
    }
    if (this.type === TILESET_TYPE.I3S) {
      const nodesInNodePages = ((_b = (_a = this.tileset) == null ? void 0 : _a.nodePagesTile) == null ? void 0 : _b.nodesInNodePages) || 0;
      this.stats.get(TILES_TOTAL).reset();
      this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);
    }
    if (tile && tile.content) {
      calculateTransformProps(tile, tile.content);
    }
    this.updateContentTypes(tile);
    this._addTileToCache(tile);
    this.options.onTileLoad(tile);
  }
  /**
   * Update information about data types in nested tiles
   * @param tile instance of a nested Tile3D
   */
  updateContentTypes(tile) {
    var _a;
    if (this.type === TILESET_TYPE.I3S) {
      if (tile.header.isDracoGeometry) {
        this.contentFormats.draco = true;
      }
      switch (tile.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = true;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = true;
          break;
        default:
      }
    } else if (this.type === TILESET_TYPE.TILES3D) {
      const { extensionsRemoved = [] } = ((_a = tile.content) == null ? void 0 : _a.gltf) || {};
      if (extensionsRemoved.includes("KHR_draco_mesh_compression")) {
        this.contentFormats.draco = true;
      }
      if (extensionsRemoved.includes("EXT_meshopt_compression")) {
        this.contentFormats.meshopt = true;
      }
      if (extensionsRemoved.includes("KHR_texture_basisu")) {
        this.contentFormats.ktx2 = true;
      }
    }
  }
  _onStartTileLoading() {
    this._pendingCount++;
    this.stats.get(TILES_LOADING).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--;
    this.stats.get(TILES_LOADING).decrementCount();
  }
  _addTileToCache(tile) {
    this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));
  }
  _updateCacheStats(tile) {
    this.stats.get(TILES_LOADED).incrementCount();
    this.stats.get(TILES_IN_MEMORY).incrementCount();
    this.gpuMemoryUsageInBytes += tile.gpuMemoryUsageInBytes || 0;
    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
    if (this.options.memoryAdjustedScreenSpaceError) {
      this.adjustScreenSpaceError();
    }
  }
  _unloadTile(tile) {
    this.gpuMemoryUsageInBytes -= tile.gpuMemoryUsageInBytes || 0;
    this.stats.get(TILES_IN_MEMORY).decrementCount();
    this.stats.get(TILES_UNLOADED).incrementCount();
    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;
    this.options.onTileUnload(tile);
    tile.unloadContent();
  }
  // Traverse the tree and destroy all tiles
  _destroy() {
    const stack2 = [];
    if (this.root) {
      stack2.push(this.root);
    }
    while (stack2.length > 0) {
      const tile = stack2.pop();
      for (const child of tile.children) {
        stack2.push(child);
      }
      this._destroyTile(tile);
    }
    this.root = null;
  }
  // Traverse the tree and destroy all sub tiles
  _destroySubtree(tile) {
    const root = tile;
    const stack2 = [];
    stack2.push(root);
    while (stack2.length > 0) {
      tile = stack2.pop();
      for (const child of tile.children) {
        stack2.push(child);
      }
      if (tile !== root) {
        this._destroyTile(tile);
      }
    }
    root.children = [];
  }
  _destroyTile(tile) {
    this._cache.unloadTile(this, tile);
    this._unloadTile(tile);
    tile.destroy();
  }
  _initializeTiles3DTileset(tilesetJson) {
    if (tilesetJson.queryString) {
      const searchParams = new URLSearchParams(tilesetJson.queryString);
      const queryParams = Object.fromEntries(searchParams.entries());
      this._queryParams = { ...this._queryParams, ...queryParams };
    }
    this.asset = tilesetJson.asset;
    if (!this.asset) {
      throw new Error("Tileset must have an asset property.");
    }
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1") {
      throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
    }
    if ("tilesetVersion" in this.asset) {
      this._queryParams.v = this.asset.tilesetVersion;
    }
    this.credits = {
      attributions: this.options.attributions || []
    };
    this.description = this.options.description || "";
    this.properties = tilesetJson.properties;
    this.geometricError = tilesetJson.geometricError;
    this._extensionsUsed = tilesetJson.extensionsUsed || [];
    this.extras = tilesetJson.extras;
  }
  _initializeI3STileset() {
    if (this.loadOptions.i3s && "token" in this.loadOptions.i3s) {
      this._queryParams.token = this.loadOptions.i3s.token;
    }
  }
};

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/version.js
var VERSION7 = true ? "4.3.3" : "latest";

// node_modules/@loaders.gl/3d-tiles/dist/lib/constants.js
var TILE3D_TYPE = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GEOMETRY: "geom",
  VECTOR: "vect",
  GLTF: "glTF"
};
var TILE3D_TYPES = Object.keys(TILE3D_TYPE);

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-utils.js
function getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  assert2(arrayBuffer instanceof ArrayBuffer);
  const textDecoder = new TextDecoder("utf8");
  const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);
  const string = textDecoder.decode(typedArray);
  return string;
}
function getMagicString2(arrayBuffer, byteOffset = 0) {
  const dataView = new DataView(arrayBuffer);
  return `${String.fromCharCode(dataView.getUint8(byteOffset + 0))}${String.fromCharCode(dataView.getUint8(byteOffset + 1))}${String.fromCharCode(dataView.getUint8(byteOffset + 2))}${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}

// node_modules/@loaders.gl/math/dist/geometry/constants.js
var GL_PRIMITIVE_MODE = {
  POINTS: 0,
  // Points. single points.
  LINES: 1,
  // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 2,
  // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 3,
  // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 4,
  // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 5,
  // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 6
  // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
};
var GL_TYPE = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
};
var GL2 = {
  ...GL_PRIMITIVE_MODE,
  ...GL_TYPE
};

// node_modules/@loaders.gl/math/dist/geometry/gl/gl-type.js
var GL_TYPE_TO_ARRAY_TYPE = {
  [GL_TYPE.DOUBLE]: Float64Array,
  [GL_TYPE.FLOAT]: Float32Array,
  [GL_TYPE.UNSIGNED_SHORT]: Uint16Array,
  [GL_TYPE.UNSIGNED_INT]: Uint32Array,
  [GL_TYPE.UNSIGNED_BYTE]: Uint8Array,
  [GL_TYPE.BYTE]: Int8Array,
  [GL_TYPE.SHORT]: Int16Array,
  [GL_TYPE.INT]: Int32Array
};
var NAME_TO_GL_TYPE = {
  DOUBLE: GL_TYPE.DOUBLE,
  FLOAT: GL_TYPE.FLOAT,
  UNSIGNED_SHORT: GL_TYPE.UNSIGNED_SHORT,
  UNSIGNED_INT: GL_TYPE.UNSIGNED_INT,
  UNSIGNED_BYTE: GL_TYPE.UNSIGNED_BYTE,
  BYTE: GL_TYPE.BYTE,
  SHORT: GL_TYPE.SHORT,
  INT: GL_TYPE.INT
};
var ERR_TYPE_CONVERSION = "Failed to convert GL type";
var GLType = class _GLType {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  /**
   * Returns the size, in bytes, of the corresponding datatype
   * @param arrayOrType
   * @returns glType a a string
   */
  static fromTypedArray(arrayOrType) {
    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {
      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
      if (ArrayType === arrayOrType) {
        return glType;
      }
    }
    throw new Error(ERR_TYPE_CONVERSION);
  }
  /**
   * Extracts name for glType from array NAME_TO_GL_TYPE
   * @param name
   * @returns glType as a number
   */
  static fromName(name12) {
    const glType = NAME_TO_GL_TYPE[name12];
    if (!glType) {
      throw new Error(ERR_TYPE_CONVERSION);
    }
    return glType;
  }
  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(glType) {
    switch (glType) {
      case GL_TYPE.UNSIGNED_SHORT_5_6_5:
      case GL_TYPE.UNSIGNED_SHORT_4_4_4_4:
      case GL_TYPE.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];
        if (!ArrayType) {
          throw new Error(ERR_TYPE_CONVERSION);
        }
        return ArrayType;
    }
  }
  /**
   * Returns the size in bytes of one element of the provided WebGL type
   * @param glType
   * @returns size of glType
   */
  static getByteSize(glType) {
    const ArrayType = _GLType.getArrayType(glType);
    return ArrayType.BYTES_PER_ELEMENT;
  }
  /**
   * Returns `true` if `glType` is a valid WebGL data type.
   * @param glType
   * @returns boolean
   */
  static validate(glType) {
    return Boolean(_GLType.getArrayType(glType));
  }
  /**
   * Creates a typed view of an array of bytes
   * @param glType The type of typed array (ArrayBuffer view) to create
   * @param buffer The buffer storage to use for the view.
   * @param byteOffset The offset, in bytes, to the first element in the view
   * @param length The number of elements in the view. Defaults to buffer length
   * @returns A typed array view of the buffer
   */
  static createTypedArray(glType, buffer, byteOffset = 0, length5) {
    if (length5 === void 0) {
      length5 = (buffer.byteLength - byteOffset) / _GLType.getByteSize(glType);
    }
    const ArrayType = _GLType.getArrayType(glType);
    return new ArrayType(buffer, byteOffset, length5);
  }
};

// node_modules/@loaders.gl/math/dist/geometry/utils/assert.js
function assert5(condition, message) {
  if (!condition) {
    throw new Error(`math.gl assertion failed. ${message}`);
  }
}

// node_modules/@loaders.gl/math/dist/geometry/colors/rgb565.js
function decodeRGB565(rgb565, target = [0, 0, 0]) {
  const r5 = rgb565 >> 11 & 31;
  const g6 = rgb565 >> 5 & 63;
  const b5 = rgb565 & 31;
  target[0] = r5 << 3;
  target[1] = g6 << 2;
  target[2] = b5 << 3;
  return target;
}

// node_modules/@loaders.gl/math/dist/geometry/compression/attribute-compression.js
var RIGHT_SHIFT = 1 / 256;
var scratchVector25 = new Vector2();
var scratchVector34 = new Vector3();
var scratchEncodeVector2 = new Vector2();
var octEncodeScratch = new Vector2();
var uint8ForceArray = new Uint8Array(1);
function fromSNorm(value, rangeMaximum = 255) {
  return clamp(value, 0, rangeMaximum) / rangeMaximum * 2 - 1;
}
function signNotZero(value) {
  return value < 0 ? -1 : 1;
}
function octDecodeInRange(x, y, rangeMax, result) {
  assert5(result);
  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);
  }
  result.x = fromSNorm(x, rangeMax);
  result.y = fromSNorm(y, rangeMax);
  result.z = 1 - (Math.abs(result.x) + Math.abs(result.y));
  if (result.z < 0) {
    const oldVX = result.x;
    result.x = (1 - Math.abs(result.y)) * signNotZero(oldVX);
    result.y = (1 - Math.abs(oldVX)) * signNotZero(result.y);
  }
  return result.normalize();
}
function octDecode(x, y, result) {
  return octDecodeInRange(x, y, 255, result);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-feature-table.js
var Tile3DFeatureTable = class {
  constructor(featureTableJson, featureTableBinary) {
    __publicField(this, "json");
    __publicField(this, "buffer");
    __publicField(this, "featuresLength", 0);
    __publicField(this, "_cachedTypedArrays", {});
    this.json = featureTableJson;
    this.buffer = featureTableBinary;
  }
  getExtension(extensionName) {
    return this.json.extensions && this.json.extensions[extensionName];
  }
  hasProperty(propertyName) {
    return Boolean(this.json[propertyName]);
  }
  getGlobalProperty(propertyName, componentType = GL2.UNSIGNED_INT, componentLength = 1) {
    const jsonValue = this.json[propertyName];
    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, 1, jsonValue.byteOffset);
    }
    return jsonValue;
  }
  getPropertyArray(propertyName, componentType, componentLength) {
    const jsonValue = this.json[propertyName];
    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {
      if ("componentType" in jsonValue) {
        componentType = GLType.fromName(jsonValue.componentType);
      }
      return this._getTypedArrayFromBinary(propertyName, componentType, componentLength, this.featuresLength, jsonValue.byteOffset);
    }
    return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);
  }
  getProperty(propertyName, componentType, componentLength, featureId, result) {
    const jsonValue = this.json[propertyName];
    if (!jsonValue) {
      return jsonValue;
    }
    const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);
    if (componentLength === 1) {
      return typedArray[featureId];
    }
    for (let i = 0; i < componentLength; ++i) {
      result[i] = typedArray[componentLength * featureId + i];
    }
    return result;
  }
  // HELPERS
  _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {
    const cachedTypedArrays = this._cachedTypedArrays;
    let typedArray = cachedTypedArrays[propertyName];
    if (!typedArray) {
      typedArray = GLType.createTypedArray(componentType, this.buffer.buffer, this.buffer.byteOffset + byteOffset, count * componentLength);
      cachedTypedArrays[propertyName] = typedArray;
    }
    return typedArray;
  }
  _getTypedArrayFromArray(propertyName, componentType, array) {
    const cachedTypedArrays = this._cachedTypedArrays;
    let typedArray = cachedTypedArrays[propertyName];
    if (!typedArray) {
      typedArray = GLType.createTypedArray(componentType, array);
      cachedTypedArrays[propertyName] = typedArray;
    }
    return typedArray;
  }
};

// node_modules/@loaders.gl/3d-tiles/dist/lib/classes/helpers/tile-3d-accessor-utils.js
var COMPONENTS_PER_ATTRIBUTE = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};
var UNPACKER = {
  SCALAR: (values, i) => values[i],
  VEC2: (values, i) => [values[2 * i + 0], values[2 * i + 1]],
  VEC3: (values, i) => [values[3 * i + 0], values[3 * i + 1], values[3 * i + 2]],
  VEC4: (values, i) => [values[4 * i + 0], values[4 * i + 1], values[4 * i + 2], values[4 * i + 3]],
  // TODO: check column major
  MAT2: (values, i) => [
    values[4 * i + 0],
    values[4 * i + 1],
    values[4 * i + 2],
    values[4 * i + 3]
  ],
  MAT3: (values, i) => [
    values[9 * i + 0],
    values[9 * i + 1],
    values[9 * i + 2],
    values[9 * i + 3],
    values[9 * i + 4],
    values[9 * i + 5],
    values[9 * i + 6],
    values[9 * i + 7],
    values[9 * i + 8]
  ],
  MAT4: (values, i) => [
    values[16 * i + 0],
    values[16 * i + 1],
    values[16 * i + 2],
    values[16 * i + 3],
    values[16 * i + 4],
    values[16 * i + 5],
    values[16 * i + 6],
    values[16 * i + 7],
    values[16 * i + 8],
    values[16 * i + 9],
    values[16 * i + 10],
    values[16 * i + 11],
    values[16 * i + 12],
    values[16 * i + 13],
    values[16 * i + 14],
    values[16 * i + 15]
  ]
};
var PACKER = {
  SCALAR: (x, values, i) => {
    values[i] = x;
  },
  VEC2: (x, values, i) => {
    values[2 * i + 0] = x[0];
    values[2 * i + 1] = x[1];
  },
  VEC3: (x, values, i) => {
    values[3 * i + 0] = x[0];
    values[3 * i + 1] = x[1];
    values[3 * i + 2] = x[2];
  },
  VEC4: (x, values, i) => {
    values[4 * i + 0] = x[0];
    values[4 * i + 1] = x[1];
    values[4 * i + 2] = x[2];
    values[4 * i + 3] = x[3];
  },
  // TODO: check column major correctness
  MAT2: (x, values, i) => {
    values[4 * i + 0] = x[0];
    values[4 * i + 1] = x[1];
    values[4 * i + 2] = x[2];
    values[4 * i + 3] = x[3];
  },
  MAT3: (x, values, i) => {
    values[9 * i + 0] = x[0];
    values[9 * i + 1] = x[1];
    values[9 * i + 2] = x[2];
    values[9 * i + 3] = x[3];
    values[9 * i + 4] = x[4];
    values[9 * i + 5] = x[5];
    values[9 * i + 6] = x[6];
    values[9 * i + 7] = x[7];
    values[9 * i + 8] = x[8];
    values[9 * i + 9] = x[9];
  },
  MAT4: (x, values, i) => {
    values[16 * i + 0] = x[0];
    values[16 * i + 1] = x[1];
    values[16 * i + 2] = x[2];
    values[16 * i + 3] = x[3];
    values[16 * i + 4] = x[4];
    values[16 * i + 5] = x[5];
    values[16 * i + 6] = x[6];
    values[16 * i + 7] = x[7];
    values[16 * i + 8] = x[8];
    values[16 * i + 9] = x[9];
    values[16 * i + 10] = x[10];
    values[16 * i + 11] = x[11];
    values[16 * i + 12] = x[12];
    values[16 * i + 13] = x[13];
    values[16 * i + 14] = x[14];
    values[16 * i + 15] = x[15];
  }
};
function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length5) {
  const { componentType } = tile3DAccessor;
  assert2(tile3DAccessor.componentType);
  const type = typeof componentType === "string" ? GLType.fromName(componentType) : componentType;
  const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];
  const unpacker = UNPACKER[tile3DAccessor.type];
  const packer = PACKER[tile3DAccessor.type];
  byteOffset += tile3DAccessor.byteOffset;
  const values = GLType.createTypedArray(type, buffer, byteOffset, size * length5);
  return {
    values,
    type,
    size,
    unpacker,
    packer
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-batch-table-hierarchy.js
var defined3 = (x) => x !== void 0;
function initializeHierarchy(batchTable, jsonHeader, binaryBody) {
  if (!jsonHeader) {
    return null;
  }
  let hierarchy = batchTable.getExtension("3DTILES_batch_table_hierarchy");
  const legacyHierarchy = jsonHeader.HIERARCHY;
  if (legacyHierarchy) {
    console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.");
    jsonHeader.extensions = jsonHeader.extensions || {};
    jsonHeader.extensions["3DTILES_batch_table_hierarchy"] = legacyHierarchy;
    hierarchy = legacyHierarchy;
  }
  if (!hierarchy) {
    return null;
  }
  return initializeHierarchyValues(hierarchy, binaryBody);
}
function initializeHierarchyValues(hierarchyJson, binaryBody) {
  let i;
  let classId;
  let binaryAccessor;
  const instancesLength = hierarchyJson.instancesLength;
  const classes = hierarchyJson.classes;
  let classIds = hierarchyJson.classIds;
  let parentCounts = hierarchyJson.parentCounts;
  let parentIds = hierarchyJson.parentIds;
  let parentIdsLength = instancesLength;
  if (defined3(classIds.byteOffset)) {
    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);
    classIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(classIds);
    classIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + classIds.byteOffset, instancesLength);
  }
  let parentIndexes;
  if (defined3(parentCounts)) {
    if (defined3(parentCounts.byteOffset)) {
      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);
      parentCounts.type = AttributeType.SCALAR;
      binaryAccessor = getBinaryAccessor(parentCounts);
      parentCounts = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentCounts.byteOffset, instancesLength);
    }
    parentIndexes = new Uint16Array(instancesLength);
    parentIdsLength = 0;
    for (i = 0; i < instancesLength; ++i) {
      parentIndexes[i] = parentIdsLength;
      parentIdsLength += parentCounts[i];
    }
  }
  if (defined3(parentIds) && defined3(parentIds.byteOffset)) {
    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);
    parentIds.type = AttributeType.SCALAR;
    binaryAccessor = getBinaryAccessor(parentIds);
    parentIds = binaryAccessor.createArrayBufferView(binaryBody.buffer, binaryBody.byteOffset + parentIds.byteOffset, parentIdsLength);
  }
  const classesLength = classes.length;
  for (i = 0; i < classesLength; ++i) {
    const classInstancesLength = classes[i].length;
    const properties = classes[i].instances;
    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);
    classes[i].instances = combine(binaryProperties, properties);
  }
  const classCounts = new Array(classesLength).fill(0);
  const classIndexes = new Uint16Array(instancesLength);
  for (i = 0; i < instancesLength; ++i) {
    classId = classIds[i];
    classIndexes[i] = classCounts[classId];
    ++classCounts[classId];
  }
  const hierarchy = {
    classes,
    classIds,
    classIndexes,
    parentCounts,
    parentIndexes,
    parentIds
  };
  validateHierarchy(hierarchy);
  return hierarchy;
}
function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {
  if (!hierarchy) {
    return;
  }
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  if (parentIds) {
    return endConditionCallback(hierarchy, instanceIndex);
  }
  if (parentCounts > 0) {
    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);
  }
  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);
}
function traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {
  const classIds = hierarchy.classIds;
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const instancesLength = classIds.length;
  const visited = scratchVisited;
  visited.length = Math.max(visited.length, instancesLength);
  const visitedMarker = ++marker;
  const stack2 = scratchStack;
  stack2.length = 0;
  stack2.push(instanceIndex);
  while (stack2.length > 0) {
    instanceIndex = stack2.pop();
    if (visited[instanceIndex] === visitedMarker) {
      continue;
    }
    visited[instanceIndex] = visitedMarker;
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined3(result)) {
      return result;
    }
    const parentCount = parentCounts[instanceIndex];
    const parentIndex = parentIndexes[instanceIndex];
    for (let i = 0; i < parentCount; ++i) {
      const parentId = parentIds[parentIndex + i];
      if (parentId !== instanceIndex) {
        stack2.push(parentId);
      }
    }
  }
  return null;
}
function traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {
  let hasParent = true;
  while (hasParent) {
    const result = endConditionCallback(hierarchy, instanceIndex);
    if (defined3(result)) {
      return result;
    }
    const parentId = hierarchy.parentIds[instanceIndex];
    hasParent = parentId !== instanceIndex;
    instanceIndex = parentId;
  }
  throw new Error("traverseHierarchySingleParent");
}
function validateHierarchy(hierarchy) {
  const scratchValidateStack = [];
  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;
  for (let i = 0; i < instancesLength; ++i) {
    validateInstance(hierarchy, i, stack);
  }
}
function validateInstance(hierarchy, instanceIndex, stack2) {
  const parentCounts = hierarchy.parentCounts;
  const parentIds = hierarchy.parentIds;
  const parentIndexes = hierarchy.parentIndexes;
  const classIds = hierarchy.classIds;
  const instancesLength = classIds.length;
  if (!defined3(parentIds)) {
    return;
  }
  assert(instanceIndex < instancesLength, `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`);
  assert(stack2.indexOf(instanceIndex) === -1, "Circular dependency detected in the batch table hierarchy.");
  stack2.push(instanceIndex);
  const parentCount = defined3(parentCounts) ? parentCounts[instanceIndex] : 1;
  const parentIndex = defined3(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;
  for (let i = 0; i < parentCount; ++i) {
    const parentId = parentIds[parentIndex + i];
    if (parentId !== instanceIndex) {
      validateInstance(hierarchy, parentId, stack2);
    }
  }
  stack2.pop(instanceIndex);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/classes/tile-3d-batch-table.js
function defined4(x) {
  return x !== void 0 && x !== null;
}
var clone6 = (x, y) => x;
var IGNORED_PROPERTY_FIELDS = {
  HIERARCHY: true,
  // Deprecated HIERARCHY property
  extensions: true,
  extras: true
};
var Tile3DBatchTableParser = class {
  constructor(json, binary, featureCount, options = {}) {
    __publicField(this, "json");
    __publicField(this, "binary");
    __publicField(this, "featureCount");
    __publicField(this, "_extensions");
    // Copy all top-level property fields from the json object, ignoring special fields
    __publicField(this, "_properties");
    __publicField(this, "_binaryProperties");
    // TODO: hierarchy support is only partially implemented and not tested
    __publicField(this, "_hierarchy");
    var _a;
    assert2(featureCount >= 0);
    this.json = json || {};
    this.binary = binary;
    this.featureCount = featureCount;
    this._extensions = ((_a = this.json) == null ? void 0 : _a.extensions) || {};
    this._properties = {};
    for (const propertyName in this.json) {
      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {
        this._properties[propertyName] = this.json[propertyName];
      }
    }
    this._binaryProperties = this._initializeBinaryProperties();
    if (options["3DTILES_batch_table_hierarchy"]) {
      this._hierarchy = initializeHierarchy(this, this.json, this.binary);
    }
  }
  getExtension(extensionName) {
    return this.json && this.json.extensions && this.json.extensions[extensionName];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(batchId, className) {
    this._checkBatchId(batchId);
    assert2(typeof className === "string", className);
    if (this._hierarchy) {
      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
        const classId = hierarchy.classIds[instanceIndex];
        const instanceClass = hierarchy.classes[classId];
        return instanceClass.name === className;
      });
      return defined4(result);
    }
    return false;
  }
  isExactClass(batchId, className) {
    assert2(typeof className === "string", className);
    return this.getExactClassName(batchId) === className;
  }
  getExactClassName(batchId) {
    this._checkBatchId(batchId);
    if (this._hierarchy) {
      const classId = this._hierarchy.classIds[batchId];
      const instanceClass = this._hierarchy.classes[classId];
      return instanceClass.name;
    }
    return void 0;
  }
  hasProperty(batchId, name12) {
    this._checkBatchId(batchId);
    assert2(typeof name12 === "string", name12);
    return defined4(this._properties[name12]) || this._hasPropertyInHierarchy(batchId, name12);
  }
  getPropertyNames(batchId, results) {
    this._checkBatchId(batchId);
    results = defined4(results) ? results : [];
    results.length = 0;
    const propertyNames = Object.keys(this._properties);
    results.push(...propertyNames);
    if (this._hierarchy) {
      this._getPropertyNamesInHierarchy(batchId, results);
    }
    return results;
  }
  getProperty(batchId, name12) {
    this._checkBatchId(batchId);
    assert2(typeof name12 === "string", name12);
    if (this._binaryProperties) {
      const binaryProperty = this._binaryProperties[name12];
      if (defined4(binaryProperty)) {
        return this._getBinaryProperty(binaryProperty, batchId);
      }
    }
    const propertyValues = this._properties[name12];
    if (defined4(propertyValues)) {
      return clone6(propertyValues[batchId], true);
    }
    if (this._hierarchy) {
      const hierarchyProperty = this._getHierarchyProperty(batchId, name12);
      if (defined4(hierarchyProperty)) {
        return hierarchyProperty;
      }
    }
    return void 0;
  }
  setProperty(batchId, name12, value) {
    const featureCount = this.featureCount;
    this._checkBatchId(batchId);
    assert2(typeof name12 === "string", name12);
    if (this._binaryProperties) {
      const binaryProperty = this._binaryProperties[name12];
      if (binaryProperty) {
        this._setBinaryProperty(binaryProperty, batchId, value);
        return;
      }
    }
    if (this._hierarchy) {
      if (this._setHierarchyProperty(this, batchId, name12, value)) {
        return;
      }
    }
    let propertyValues = this._properties[name12];
    if (!defined4(propertyValues)) {
      this._properties[name12] = new Array(featureCount);
      propertyValues = this._properties[name12];
    }
    propertyValues[batchId] = clone6(value, true);
  }
  // PRIVATE METHODS
  _checkBatchId(batchId) {
    const valid = batchId >= 0 && batchId < this.featureCount;
    if (!valid) {
      throw new Error("batchId not in range [0, featureCount - 1].");
    }
  }
  _getBinaryProperty(binaryProperty, index) {
    return binaryProperty.unpack(binaryProperty.typedArray, index);
  }
  _setBinaryProperty(binaryProperty, index, value) {
    binaryProperty.pack(value, binaryProperty.typedArray, index);
  }
  _initializeBinaryProperties() {
    let binaryProperties = null;
    for (const name12 in this._properties) {
      const property = this._properties[name12];
      const binaryProperty = this._initializeBinaryProperty(name12, property);
      if (binaryProperty) {
        binaryProperties = binaryProperties || {};
        binaryProperties[name12] = binaryProperty;
      }
    }
    return binaryProperties;
  }
  _initializeBinaryProperty(name12, property) {
    if ("byteOffset" in property) {
      const tile3DAccessor = property;
      assert2(this.binary, `Property ${name12} requires a batch table binary.`);
      assert2(tile3DAccessor.type, `Property ${name12} requires a type.`);
      const accessor = createTypedArrayFromAccessor(tile3DAccessor, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: accessor.values,
        componentCount: accessor.size,
        unpack: accessor.unpacker,
        pack: accessor.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(batchId, name12) {
    if (!this._hierarchy) {
      return false;
    }
    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instances = hierarchy.classes[classId].instances;
      return defined4(instances[name12]);
    });
    return defined4(result);
  }
  _getPropertyNamesInHierarchy(batchId, results) {
    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instances = hierarchy.classes[classId].instances;
      for (const name12 in instances) {
        if (instances.hasOwnProperty(name12)) {
          if (results.indexOf(name12) === -1) {
            results.push(name12);
          }
        }
      }
    });
  }
  _getHierarchyProperty(batchId, name12) {
    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instanceClass = hierarchy.classes[classId];
      const indexInClass = hierarchy.classIndexes[instanceIndex];
      const propertyValues = instanceClass.instances[name12];
      if (defined4(propertyValues)) {
        if (defined4(propertyValues.typedArray)) {
          return this._getBinaryProperty(propertyValues, indexInClass);
        }
        return clone6(propertyValues[indexInClass], true);
      }
      return null;
    });
  }
  _setHierarchyProperty(batchTable, batchId, name12, value) {
    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {
      const classId = hierarchy.classIds[instanceIndex];
      const instanceClass = hierarchy.classes[classId];
      const indexInClass = hierarchy.classIndexes[instanceIndex];
      const propertyValues = instanceClass.instances[name12];
      if (defined4(propertyValues)) {
        assert2(instanceIndex === batchId, `Inherited property "${name12}" is read-only.`);
        if (defined4(propertyValues.typedArray)) {
          this._setBinaryProperty(propertyValues, indexInClass, value);
        } else {
          propertyValues[indexInClass] = clone6(value, true);
        }
        return true;
      }
      return false;
    });
    return defined4(result);
  }
};

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-header.js
var SIZEOF_UINT32 = 4;
function parse3DTileHeaderSync(tile, arrayBuffer, byteOffset = 0) {
  const view = new DataView(arrayBuffer);
  tile.magic = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  tile.version = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  tile.byteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT32;
  if (tile.version !== 1) {
    throw new Error(`3D Tile Version ${tile.version} not supported`);
  }
  return byteOffset;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-tables.js
var SIZEOF_UINT322 = 4;
var DEPRECATION_WARNING = "b3dm tile in legacy format.";
function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {
  const view = new DataView(arrayBuffer);
  let batchLength;
  tile.header = tile.header || {};
  let featureTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let batchTableJsonByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);
  byteOffset += SIZEOF_UINT322;
  if (batchTableJsonByteLength >= 570425344) {
    byteOffset -= SIZEOF_UINT322 * 2;
    batchLength = featureTableJsonByteLength;
    batchTableJsonByteLength = featureTableBinaryByteLength;
    batchTableBinaryByteLength = 0;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;
    console.warn(DEPRECATION_WARNING);
  } else if (batchTableBinaryByteLength >= 570425344) {
    byteOffset -= SIZEOF_UINT322;
    batchLength = batchTableJsonByteLength;
    batchTableJsonByteLength = featureTableJsonByteLength;
    batchTableBinaryByteLength = featureTableBinaryByteLength;
    featureTableJsonByteLength = 0;
    featureTableBinaryByteLength = 0;
    console.warn(DEPRECATION_WARNING);
  }
  tile.header.featureTableJsonByteLength = featureTableJsonByteLength;
  tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;
  tile.header.batchTableJsonByteLength = batchTableJsonByteLength;
  tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;
  tile.header.batchLength = batchLength;
  return byteOffset;
}
function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {
  byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);
  return byteOffset;
}
function parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {
  const { featureTableJsonByteLength, featureTableBinaryByteLength, batchLength } = tile.header || {};
  tile.featureTableJson = {
    BATCH_LENGTH: batchLength || 0
  };
  if (featureTableJsonByteLength && featureTableJsonByteLength > 0) {
    const featureTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, featureTableJsonByteLength);
    tile.featureTableJson = JSON.parse(featureTableString);
  }
  byteOffset += featureTableJsonByteLength || 0;
  tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);
  byteOffset += featureTableBinaryByteLength || 0;
  return byteOffset;
}
function parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {
  const { batchTableJsonByteLength, batchTableBinaryByteLength } = tile.header || {};
  if (batchTableJsonByteLength && batchTableJsonByteLength > 0) {
    const batchTableString = getStringFromArrayBuffer(arrayBuffer, byteOffset, batchTableJsonByteLength);
    tile.batchTableJson = JSON.parse(batchTableString);
    byteOffset += batchTableJsonByteLength;
    if (batchTableBinaryByteLength && batchTableBinaryByteLength > 0) {
      tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);
      tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);
      byteOffset += batchTableBinaryByteLength;
    }
  }
  return byteOffset;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-colors.js
function normalize3DTileColorAttribute(tile, colors, batchTable) {
  if (!colors && (!tile || !tile.batchIds || !batchTable)) {
    return null;
  }
  const { batchIds, isRGB565, pointCount = 0 } = tile;
  if (batchIds && batchTable) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i = 0; i < pointCount; i++) {
      const batchId = batchIds[i];
      const dimensions = batchTable.getProperty(batchId, "dimensions");
      const color = dimensions.map((d2) => d2 * 255);
      colorArray[i * 3] = color[0];
      colorArray[i * 3 + 1] = color[1];
      colorArray[i * 3 + 2] = color[2];
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }
  if (colors && isRGB565) {
    const colorArray = new Uint8ClampedArray(pointCount * 3);
    for (let i = 0; i < pointCount; i++) {
      const color = decodeRGB565(colors[i]);
      colorArray[i * 3] = color[0];
      colorArray[i * 3 + 1] = color[1];
      colorArray[i * 3 + 2] = color[2];
    }
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colorArray,
      size: 3,
      normalized: true
    };
  }
  if (colors && colors.length === pointCount * 3) {
    return {
      type: GL2.UNSIGNED_BYTE,
      value: colors,
      size: 3,
      normalized: true
    };
  }
  return {
    type: GL2.UNSIGNED_BYTE,
    value: colors || new Uint8ClampedArray(),
    size: 4,
    normalized: true
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-normals.js
var scratchNormal4 = new Vector3();
function normalize3DTileNormalAttribute(tile, normals) {
  if (!normals) {
    return null;
  }
  if (tile.isOctEncoded16P) {
    const decodedArray = new Float32Array((tile.pointsLength || 0) * 3);
    for (let i = 0; i < (tile.pointsLength || 0); i++) {
      octDecode(normals[i * 2], normals[i * 2 + 1], scratchNormal4);
      scratchNormal4.toArray(decodedArray, i * 3);
    }
    return {
      type: GL2.FLOAT,
      size: 2,
      value: decodedArray
    };
  }
  return {
    type: GL2.FLOAT,
    size: 2,
    value: normals
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/normalize-3d-tile-positions.js
function normalize3DTilePositionAttribute(tile, positions, options) {
  if (!tile.isQuantized) {
    return positions;
  }
  if (options["3d-tiles"] && options["3d-tiles"].decodeQuantizedPositions) {
    tile.isQuantized = false;
    return decodeQuantizedPositions(tile, positions);
  }
  return {
    type: GL2.UNSIGNED_SHORT,
    value: positions,
    size: 3,
    normalized: true
  };
}
function decodeQuantizedPositions(tile, positions) {
  const scratchPosition5 = new Vector3();
  const decodedArray = new Float32Array(tile.pointCount * 3);
  for (let i = 0; i < tile.pointCount; i++) {
    scratchPosition5.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]).scale(1 / tile.quantizedRange).multiply(tile.quantizedVolumeScale).add(tile.quantizedVolumeOffset).toArray(decodedArray, i * 3);
  }
  return decodedArray;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-point-cloud.js
async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  initializeTile(tile);
  const { featureTable, batchTable } = parsePointCloudTables(tile);
  await parseDraco(tile, featureTable, batchTable, options, context);
  parsePositions(tile, featureTable, options);
  parseColors(tile, featureTable, batchTable);
  parseNormals(tile, featureTable);
  return byteOffset;
}
function initializeTile(tile) {
  tile.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  tile.isQuantized = false;
  tile.isTranslucent = false;
  tile.isRGB565 = false;
  tile.isOctEncoded16P = false;
}
function parsePointCloudTables(tile) {
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  const pointsLength = featureTable.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(pointsLength)) {
    throw new Error("POINTS_LENGTH must be defined");
  }
  featureTable.featuresLength = pointsLength;
  tile.featuresLength = pointsLength;
  tile.pointsLength = pointsLength;
  tile.pointCount = pointsLength;
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
  const batchTable = parseBatchIds(tile, featureTable);
  return { featureTable, batchTable };
}
function parsePositions(tile, featureTable, options) {
  tile.attributes = tile.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  if (!tile.attributes.positions) {
    if (featureTable.hasProperty("POSITION")) {
      tile.attributes.positions = featureTable.getPropertyArray("POSITION", GL2.FLOAT, 3);
    } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
      const positions = featureTable.getPropertyArray("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3);
      tile.isQuantized = true;
      tile.quantizedRange = (1 << 16) - 1;
      tile.quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
      if (!tile.quantizedVolumeScale) {
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      }
      tile.quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
      if (!tile.quantizedVolumeOffset) {
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      }
      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);
    }
  }
  if (!tile.attributes.positions) {
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
  }
}
function parseColors(tile, featureTable, batchTable) {
  tile.attributes = tile.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  if (!tile.attributes.colors) {
    let colors = null;
    if (featureTable.hasProperty("RGBA")) {
      colors = featureTable.getPropertyArray("RGBA", GL2.UNSIGNED_BYTE, 4);
      tile.isTranslucent = true;
    } else if (featureTable.hasProperty("RGB")) {
      colors = featureTable.getPropertyArray("RGB", GL2.UNSIGNED_BYTE, 3);
    } else if (featureTable.hasProperty("RGB565")) {
      colors = featureTable.getPropertyArray("RGB565", GL2.UNSIGNED_SHORT, 1);
      tile.isRGB565 = true;
    }
    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);
  }
  if (featureTable.hasProperty("CONSTANT_RGBA")) {
    tile.constantRGBA = featureTable.getGlobalProperty("CONSTANT_RGBA", GL2.UNSIGNED_BYTE, 4);
  }
}
function parseNormals(tile, featureTable) {
  tile.attributes = tile.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  };
  if (!tile.attributes.normals) {
    let normals = null;
    if (featureTable.hasProperty("NORMAL")) {
      normals = featureTable.getPropertyArray("NORMAL", GL2.FLOAT, 3);
    } else if (featureTable.hasProperty("NORMAL_OCT16P")) {
      normals = featureTable.getPropertyArray("NORMAL_OCT16P", GL2.UNSIGNED_BYTE, 2);
      tile.isOctEncoded16P = true;
    }
    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);
  }
}
function parseBatchIds(tile, featureTable) {
  let batchTable = null;
  if (!tile.batchIds && featureTable.hasProperty("BATCH_ID")) {
    tile.batchIds = featureTable.getPropertyArray("BATCH_ID", GL2.UNSIGNED_SHORT, 1);
    if (tile.batchIds) {
      const batchFeatureLength = featureTable.getGlobalProperty("BATCH_LENGTH");
      if (!batchFeatureLength) {
        throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
      }
      const { batchTableJson, batchTableBinary } = tile;
      batchTable = new Tile3DBatchTableParser(batchTableJson, batchTableBinary, batchFeatureLength);
    }
  }
  return batchTable;
}
async function parseDraco(tile, featureTable, batchTable, options, context) {
  let dracoBuffer;
  let dracoFeatureTableProperties;
  let dracoBatchTableProperties;
  const batchTableDraco = tile.batchTableJson && tile.batchTableJson.extensions && tile.batchTableJson.extensions["3DTILES_draco_point_compression"];
  if (batchTableDraco) {
    dracoBatchTableProperties = batchTableDraco.properties;
  }
  const featureTableDraco = featureTable.getExtension("3DTILES_draco_point_compression");
  if (featureTableDraco) {
    dracoFeatureTableProperties = featureTableDraco.properties;
    const dracoByteOffset = featureTableDraco.byteOffset;
    const dracoByteLength = featureTableDraco.byteLength;
    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    }
    dracoBuffer = (tile.featureTableBinary || []).slice(dracoByteOffset, dracoByteOffset + dracoByteLength);
    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);
    tile.hasColors = Number.isFinite(dracoFeatureTableProperties.RGB) || Number.isFinite(dracoFeatureTableProperties.RGBA);
    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);
    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);
    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);
  }
  if (!dracoBuffer) {
    return true;
  }
  const dracoData = {
    buffer: dracoBuffer,
    properties: { ...dracoFeatureTableProperties, ...dracoBatchTableProperties },
    featureTableProperties: dracoFeatureTableProperties,
    batchTableProperties: dracoBatchTableProperties,
    dequantizeInShader: false
  };
  return await loadDraco(tile, dracoData, options, context);
}
async function loadDraco(tile, dracoData, options, context) {
  if (!context) {
    return;
  }
  const dracoOptions = {
    ...options,
    draco: {
      ...options == null ? void 0 : options.draco,
      extraAttributes: dracoData.batchTableProperties || {}
    }
  };
  delete dracoOptions["3d-tiles"];
  const data = await parseFromContext(dracoData.buffer, DracoLoader2, dracoOptions, context);
  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;
  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;
  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;
  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;
  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;
  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;
  if (isQuantizedDraco) {
    const quantization = data.POSITION.data.quantization;
    const range = quantization.range;
    tile.quantizedVolumeScale = new Vector3(range, range, range);
    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);
    tile.quantizedRange = (1 << quantization.quantizationBits) - 1;
    tile.isQuantizedDraco = true;
  }
  if (isOctEncodedDraco) {
    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1;
    tile.isOctEncodedDraco = true;
  }
  const batchTableAttributes = {};
  if (dracoData.batchTableProperties) {
    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {
      if (data.attributes[attributeName] && data.attributes[attributeName].value) {
        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;
      }
    }
  }
  tile.attributes = {
    // @ts-expect-error
    positions: decodedPositions,
    // @ts-expect-error
    colors: normalize3DTileColorAttribute(tile, decodedColors, void 0),
    // @ts-expect-error
    normals: decodedNormals,
    // @ts-expect-error
    batchIds: decodedBatchIds,
    ...batchTableAttributes
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-gltf-view.js
var GLTF_FORMAT = {
  URI: 0,
  EMBEDDED: 1
};
function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {
  tile.rotateYtoZ = true;
  const gltfByteLength = (tile.byteOffset || 0) + (tile.byteLength || 0) - byteOffset;
  if (gltfByteLength === 0) {
    throw new Error("glTF byte length must be greater than 0.");
  }
  tile.gltfUpAxis = (options == null ? void 0 : options["3d-tiles"]) && options["3d-tiles"].assetGltfUpAxis ? options["3d-tiles"].assetGltfUpAxis : "Y";
  tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);
  tile.gltfByteOffset = 0;
  tile.gltfByteLength = gltfByteLength;
  if (byteOffset % 4 === 0) {
  } else {
    console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);
  }
  return (tile.byteOffset || 0) + (tile.byteLength || 0);
}
async function extractGLTF(tile, gltfFormat, options, context) {
  const tile3DOptions = (options == null ? void 0 : options["3d-tiles"]) || {};
  extractGLTFBufferOrURL(tile, gltfFormat, options);
  if (tile3DOptions.loadGLTF) {
    if (!context) {
      return;
    }
    if (tile.gltfUrl) {
      const { fetch: fetch2 } = context;
      const response = await fetch2(tile.gltfUrl, options);
      tile.gltfArrayBuffer = await response.arrayBuffer();
      tile.gltfByteOffset = 0;
    }
    if (tile.gltfArrayBuffer) {
      const gltfWithBuffers = await parseFromContext(tile.gltfArrayBuffer, GLTFLoader, options, context);
      tile.gltf = postProcessGLTF(gltfWithBuffers);
      tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
      delete tile.gltfArrayBuffer;
      delete tile.gltfByteOffset;
      delete tile.gltfByteLength;
    }
  }
}
function extractGLTFBufferOrURL(tile, gltfFormat, options) {
  switch (gltfFormat) {
    case GLTF_FORMAT.URI:
      if (tile.gltfArrayBuffer) {
        const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);
        const textDecoder = new TextDecoder();
        const gltfUrl = textDecoder.decode(gltfUrlBytes);
        tile.gltfUrl = gltfUrl.replace(/[\s\0]+$/, "");
      }
      delete tile.gltfArrayBuffer;
      delete tile.gltfByteOffset;
      delete tile.gltfByteLength;
      break;
    case GLTF_FORMAT.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-batched-model.js
async function parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  var _a;
  byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options, context);
  await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);
  const extensions = (_a = tile == null ? void 0 : tile.gltf) == null ? void 0 : _a.extensions;
  if (extensions && extensions.CESIUM_RTC) {
    tile.rtcCenter = extensions.CESIUM_RTC.center;
  }
  return byteOffset;
}
function parseBatchedModel(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
  return byteOffset;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-instanced-model.js
async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {
  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);
  await extractGLTF(tile, tile.gltfFormat || 0, options, context);
  return byteOffset;
}
function parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {
  var _a;
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  if (tile.version !== 1) {
    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);
  }
  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);
  const view = new DataView(arrayBuffer);
  tile.gltfFormat = view.getUint32(byteOffset, true);
  byteOffset += 4;
  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);
  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);
  if (!((_a = tile == null ? void 0 : tile.header) == null ? void 0 : _a.featureTableJsonByteLength) || tile.header.featureTableJsonByteLength === 0) {
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  }
  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);
  const instancesLength = featureTable.getGlobalProperty("INSTANCES_LENGTH");
  featureTable.featuresLength = instancesLength;
  if (!Number.isFinite(instancesLength)) {
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  }
  tile.eastNorthUp = featureTable.getGlobalProperty("EAST_NORTH_UP");
  tile.rtcCenter = featureTable.getGlobalProperty("RTC_CENTER", GL2.FLOAT, 3);
  const batchTable = new Tile3DBatchTableParser(tile.batchTableJson, tile.batchTableBinary, instancesLength);
  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);
  return byteOffset;
}
function extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {
  const instances = new Array(instancesLength);
  const instancePosition = new Vector3();
  const instanceNormalRight = new Vector3();
  const instanceNormalUp = new Vector3();
  const instanceNormalForward = new Vector3();
  const instanceRotation = new Matrix3();
  const instanceQuaternion = new Quaternion();
  const instanceScale = new Vector3();
  const instanceTranslationRotationScale = {};
  const instanceTransform = new Matrix4();
  const scratch1 = [];
  const scratch2 = [];
  const scratch3 = [];
  const scratch4 = [];
  for (let i = 0; i < instancesLength; i++) {
    let position;
    if (featureTable.hasProperty("POSITION")) {
      position = featureTable.getProperty("POSITION", GL2.FLOAT, 3, i, instancePosition);
    } else if (featureTable.hasProperty("POSITION_QUANTIZED")) {
      position = featureTable.getProperty("POSITION_QUANTIZED", GL2.UNSIGNED_SHORT, 3, i, instancePosition);
      const quantizedVolumeOffset = featureTable.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", GL2.FLOAT, 3);
      if (!quantizedVolumeOffset) {
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      }
      const quantizedVolumeScale = featureTable.getGlobalProperty("QUANTIZED_VOLUME_SCALE", GL2.FLOAT, 3);
      if (!quantizedVolumeScale) {
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      }
      const MAX_UNSIGNED_SHORT = 65535;
      for (let j = 0; j < 3; j++) {
        position[j] = position[j] / MAX_UNSIGNED_SHORT * quantizedVolumeScale[j] + quantizedVolumeOffset[j];
      }
    }
    if (!position) {
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    }
    instancePosition.copy(position);
    instanceTranslationRotationScale.translation = instancePosition;
    tile.normalUp = featureTable.getProperty("NORMAL_UP", GL2.FLOAT, 3, i, scratch1);
    tile.normalRight = featureTable.getProperty("NORMAL_RIGHT", GL2.FLOAT, 3, i, scratch2);
    const hasCustomOrientation = false;
    if (tile.normalUp) {
      if (!tile.normalRight) {
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      }
      tile.hasCustomOrientation = true;
    } else {
      tile.octNormalUp = featureTable.getProperty("NORMAL_UP_OCT32P", GL2.UNSIGNED_SHORT, 2, i, scratch1);
      tile.octNormalRight = featureTable.getProperty("NORMAL_RIGHT_OCT32P", GL2.UNSIGNED_SHORT, 2, i, scratch2);
      if (tile.octNormalUp) {
        if (!tile.octNormalRight) {
          throw new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
        }
        throw new Error("i3dm: oct-encoded orientation not implemented");
      } else if (tile.eastNorthUp) {
        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);
        instanceTransform.getRotationMatrix3(instanceRotation);
      } else {
        instanceRotation.identity();
      }
    }
    if (hasCustomOrientation) {
      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();
      instanceRotation.setColumn(0, instanceNormalRight);
      instanceRotation.setColumn(1, instanceNormalUp);
      instanceRotation.setColumn(2, instanceNormalForward);
    }
    instanceQuaternion.fromMatrix3(instanceRotation);
    instanceTranslationRotationScale.rotation = instanceQuaternion;
    instanceScale.set(1, 1, 1);
    const scale7 = featureTable.getProperty("SCALE", GL2.FLOAT, 1, i, scratch3);
    if (Number.isFinite(scale7)) {
      instanceScale.multiplyByScalar(scale7);
    }
    const nonUniformScale = featureTable.getProperty("SCALE_NON_UNIFORM", GL2.FLOAT, 3, i, scratch1);
    if (nonUniformScale) {
      instanceScale.scale(nonUniformScale);
    }
    instanceTranslationRotationScale.scale = instanceScale;
    let batchId = featureTable.getProperty("BATCH_ID", GL2.UNSIGNED_SHORT, 1, i, scratch4);
    if (batchId === void 0) {
      batchId = i;
    }
    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);
    instanceTransform.identity();
    instanceTransform.translate(instanceTranslationRotationScale.translation);
    instanceTransform.multiplyRight(rotationMatrix);
    instanceTransform.scale(instanceTranslationRotationScale.scale);
    const modelMatrix2 = instanceTransform.clone();
    instances[i] = {
      modelMatrix: modelMatrix2,
      batchId
    };
  }
  tile.instances = instances;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-composite.js
async function parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile2) {
  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);
  const view = new DataView(arrayBuffer);
  tile.tilesLength = view.getUint32(byteOffset, true);
  byteOffset += 4;
  tile.tiles = [];
  while (tile.tiles.length < tile.tilesLength && (tile.byteLength || 0) - byteOffset > 12) {
    const subtile = { shape: "tile3d" };
    tile.tiles.push(subtile);
    byteOffset = await parse3DTile2(arrayBuffer, byteOffset, options, context, subtile);
  }
  return byteOffset;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-gltf.js
async function parseGltf3DTile(tile, arrayBuffer, options, context) {
  var _a, _b;
  tile.rotateYtoZ = true;
  tile.gltfUpAxis = ((_a = options == null ? void 0 : options["3d-tiles"]) == null ? void 0 : _a.assetGltfUpAxis) ? options["3d-tiles"].assetGltfUpAxis : "Y";
  if ((_b = options == null ? void 0 : options["3d-tiles"]) == null ? void 0 : _b.loadGLTF) {
    if (!context) {
      return arrayBuffer.byteLength;
    }
    const gltfWithBuffers = await parseFromContext(arrayBuffer, GLTFLoader, options, context);
    tile.gltf = postProcessGLTF(gltfWithBuffers);
    tile.gpuMemoryUsageInBytes = getMemoryUsageGLTF(tile.gltf);
  } else {
    tile.gltfArrayBuffer = arrayBuffer;
  }
  return arrayBuffer.byteLength;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile.js
async function parse3DTile(arrayBuffer, byteOffset = 0, options, context, tile = { shape: "tile3d" }) {
  tile.byteOffset = byteOffset;
  tile.type = getMagicString2(arrayBuffer, byteOffset);
  switch (tile.type) {
    case TILE3D_TYPE.COMPOSITE:
      return await parseComposite3DTile(tile, arrayBuffer, byteOffset, options, context, parse3DTile);
    case TILE3D_TYPE.BATCHED_3D_MODEL:
      return await parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
    case TILE3D_TYPE.GLTF:
      return await parseGltf3DTile(tile, arrayBuffer, options, context);
    case TILE3D_TYPE.INSTANCED_3D_MODEL:
      return await parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context);
    case TILE3D_TYPE.POINT_CLOUD:
      return await parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context);
    default:
      throw new Error(`3DTileLoader: unknown type ${tile.type}`);
  }
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-tile-subtree.js
var SUBTREE_FILE_MAGIC = 1952609651;
var SUBTREE_FILE_VERSION = 1;
async function parse3DTilesSubtree(data, options, context) {
  const magic = new Uint32Array(data.slice(0, 4));
  if (magic[0] !== SUBTREE_FILE_MAGIC) {
    throw new Error("Wrong subtree file magic number");
  }
  const version = new Uint32Array(data.slice(4, 8));
  if (version[0] !== SUBTREE_FILE_VERSION) {
    throw new Error("Wrong subtree file verson, must be 1");
  }
  const jsonByteLength = parseUint64Value(data.slice(8, 16));
  const stringAttribute = new Uint8Array(data, 24, jsonByteLength);
  const textDecoder = new TextDecoder("utf8");
  const string = textDecoder.decode(stringAttribute);
  const subtree = JSON.parse(string);
  const binaryByteLength = parseUint64Value(data.slice(16, 24));
  let internalBinaryBuffer = new ArrayBuffer(0);
  if (binaryByteLength) {
    internalBinaryBuffer = data.slice(24 + jsonByteLength);
  }
  await loadExplicitBitstream(subtree, subtree.tileAvailability, internalBinaryBuffer, context);
  if (Array.isArray(subtree.contentAvailability)) {
    for (const contentAvailability of subtree.contentAvailability) {
      await loadExplicitBitstream(subtree, contentAvailability, internalBinaryBuffer, context);
    }
  } else {
    await loadExplicitBitstream(subtree, subtree.contentAvailability, internalBinaryBuffer, context);
  }
  await loadExplicitBitstream(subtree, subtree.childSubtreeAvailability, internalBinaryBuffer, context);
  return subtree;
}
async function loadExplicitBitstream(subtree, availabilityObject, internalBinaryBuffer, context) {
  const bufferViewIndex = Number.isFinite(availabilityObject.bitstream) ? availabilityObject.bitstream : availabilityObject.bufferView;
  if (typeof bufferViewIndex !== "number") {
    return;
  }
  const bufferView = subtree.bufferViews[bufferViewIndex];
  const buffer = subtree.buffers[bufferView.buffer];
  if (!(context == null ? void 0 : context.baseUrl)) {
    throw new Error("Url is not provided");
  }
  if (!context.fetch) {
    throw new Error("fetch is not provided");
  }
  if (buffer.uri) {
    const bufferUri = `${(context == null ? void 0 : context.baseUrl) || ""}/${buffer.uri}`;
    const response = await context.fetch(bufferUri);
    const data = await response.arrayBuffer();
    availabilityObject.explicitBitstream = new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);
    return;
  }
  const bufferStart = subtree.buffers.slice(0, bufferView.buffer).reduce((offset, buf) => offset + buf.byteLength, 0);
  availabilityObject.explicitBitstream = new Uint8Array(internalBinaryBuffer.slice(bufferStart, bufferStart + buffer.byteLength), bufferView.byteOffset, bufferView.byteLength);
}
function parseUint64Value(buffer) {
  const dataView = new DataView(buffer);
  const left = dataView.getUint32(0, true);
  const right = dataView.getUint32(4, true);
  return left + 2 ** 32 * right;
}

// node_modules/@loaders.gl/3d-tiles/dist/tile-3d-subtree-loader.js
var Tile3DSubtreeLoader = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: VERSION7,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: parse3DTilesSubtree,
  options: {}
};

// node_modules/@loaders.gl/3d-tiles/node_modules/long/index.js
var wasm = null;
try {
  wasm = new WebAssembly.Instance(
    new WebAssembly.Module(
      new Uint8Array([
        // \0asm
        0,
        97,
        115,
        109,
        // version 1
        1,
        0,
        0,
        0,
        // section "type"
        1,
        13,
        2,
        // 0, () => i32
        96,
        0,
        1,
        127,
        // 1, (i32, i32, i32, i32) => i32
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        // section "function"
        3,
        7,
        6,
        // 0, type 0
        0,
        // 1, type 1
        1,
        // 2, type 1
        1,
        // 3, type 1
        1,
        // 4, type 1
        1,
        // 5, type 1
        1,
        // section "global"
        6,
        6,
        1,
        // 0, "high", mutable i32
        127,
        1,
        65,
        0,
        11,
        // section "export"
        7,
        50,
        6,
        // 0, "mul"
        3,
        109,
        117,
        108,
        0,
        1,
        // 1, "div_s"
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        // 2, "div_u"
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        // 3, "rem_s"
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        // 4, "rem_u"
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        // 5, "get_high"
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        // section "code"
        10,
        191,
        1,
        6,
        // 0, "get_high"
        4,
        0,
        35,
        0,
        11,
        // 1, "mul"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 2, "div_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 3, "div_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 4, "rem_s"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        // 5, "rem_u"
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])
    ),
    {}
  ).exports;
} catch {
}
function Long3(low, high, unsigned) {
  this.low = low | 0;
  this.high = high | 0;
  this.unsigned = !!unsigned;
}
Long3.prototype.__isLong__;
Object.defineProperty(Long3.prototype, "__isLong__", { value: true });
function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
function ctz32(value) {
  var c2 = Math.clz32(value & -value);
  return value ? 31 - c2 : c2;
}
Long3.isLong = isLong;
var INT_CACHE = {};
var UINT_CACHE = {};
function fromInt(value, unsigned) {
  var obj, cachedObj, cache;
  if (unsigned) {
    value >>>= 0;
    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, 0, true);
    if (cache) UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;
    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj) return cachedObj;
    }
    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache) INT_CACHE[value] = obj;
    return obj;
  }
}
Long3.fromInt = fromInt;
function fromNumber(value, unsigned) {
  if (isNaN(value)) return unsigned ? UZERO : ZERO2;
  if (unsigned) {
    if (value < 0) return UZERO;
    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  }
  if (value < 0) return fromNumber(-value, unsigned).neg();
  return fromBits(
    value % TWO_PWR_32_DBL | 0,
    value / TWO_PWR_32_DBL | 0,
    unsigned
  );
}
Long3.fromNumber = fromNumber;
function fromBits(lowBits, highBits, unsigned) {
  return new Long3(lowBits, highBits, unsigned);
}
Long3.fromBits = fromBits;
var pow_dbl = Math.pow;
function fromString(str5, unsigned, radix) {
  if (str5.length === 0) throw Error("empty string");
  if (typeof unsigned === "number") {
    radix = unsigned;
    unsigned = false;
  } else {
    unsigned = !!unsigned;
  }
  if (str5 === "NaN" || str5 === "Infinity" || str5 === "+Infinity" || str5 === "-Infinity")
    return unsigned ? UZERO : ZERO2;
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  var p;
  if ((p = str5.indexOf("-")) > 0) throw Error("interior hyphen");
  else if (p === 0) {
    return fromString(str5.substring(1), unsigned, radix).neg();
  }
  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO2;
  for (var i = 0; i < str5.length; i += 8) {
    var size = Math.min(8, str5.length - i), value = parseInt(str5.substring(i, i + size), radix);
    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }
  result.unsigned = unsigned;
  return result;
}
Long3.fromString = fromString;
function fromValue(val, unsigned) {
  if (typeof val === "number") return fromNumber(val, unsigned);
  if (typeof val === "string") return fromString(val, unsigned);
  return fromBits(
    val.low,
    val.high,
    typeof unsigned === "boolean" ? unsigned : val.unsigned
  );
}
Long3.fromValue = fromValue;
var TWO_PWR_16_DBL = 1 << 16;
var TWO_PWR_24_DBL = 1 << 24;
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
var ZERO2 = fromInt(0);
Long3.ZERO = ZERO2;
var UZERO = fromInt(0, true);
Long3.UZERO = UZERO;
var ONE = fromInt(1);
Long3.ONE = ONE;
var UONE = fromInt(1, true);
Long3.UONE = UONE;
var NEG_ONE = fromInt(-1);
Long3.NEG_ONE = NEG_ONE;
var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
Long3.MAX_VALUE = MAX_VALUE;
var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
Long3.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
Long3.MIN_VALUE = MIN_VALUE;
var LongPrototype = Long3.prototype;
LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
LongPrototype.toNumber = function toNumber() {
  if (this.unsigned)
    return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative()) {
    if (this.eq(MIN_VALUE)) {
      var radixLong = fromNumber(radix), div3 = this.div(radixLong), rem1 = div3.mul(radixLong).sub(this);
      return div3.toString(radix) + rem1.toInt().toString(radix);
    } else return "-" + this.neg().toString(radix);
  }
  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
  var result = "";
  while (true) {
    var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero()) return digits + result;
    else {
      while (digits.length < 6) digits = "0" + digits;
      result = "" + digits + result;
    }
  }
};
LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative())
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;
  for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
  return this.high != 0 ? bit + 33 : bit + 1;
};
LongPrototype.isSafeInteger = function isSafeInteger() {
  var top11Bits = this.high >> 21;
  if (!top11Bits) return true;
  if (this.unsigned) return false;
  return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
};
LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
LongPrototype.eqz = LongPrototype.isZero;
LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
LongPrototype.equals = function equals7(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
    return false;
  return this.high === other.high && this.low === other.low;
};
LongPrototype.eq = LongPrototype.equals;
LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
    /* validates */
    other
  );
};
LongPrototype.neq = LongPrototype.notEquals;
LongPrototype.ne = LongPrototype.notEquals;
LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
    /* validates */
    other
  ) < 0;
};
LongPrototype.lt = LongPrototype.lessThan;
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) <= 0;
};
LongPrototype.lte = LongPrototype.lessThanOrEqual;
LongPrototype.le = LongPrototype.lessThanOrEqual;
LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
    /* validates */
    other
  ) > 0;
};
LongPrototype.gt = LongPrototype.greaterThan;
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
    /* validates */
    other
  ) >= 0;
};
LongPrototype.gte = LongPrototype.greaterThanOrEqual;
LongPrototype.ge = LongPrototype.greaterThanOrEqual;
LongPrototype.compare = function compare(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.eq(other)) return 0;
  var thisNeg = this.isNegative(), otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) return -1;
  if (!thisNeg && otherNeg) return 1;
  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
LongPrototype.comp = LongPrototype.compare;
LongPrototype.negate = function negate3() {
  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
  return this.not().add(ONE);
};
LongPrototype.neg = LongPrototype.negate;
LongPrototype.add = function add6(addend) {
  if (!isLong(addend)) addend = fromValue(addend);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 65535;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 + b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.subtract = function subtract4(subtrahend) {
  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
LongPrototype.sub = LongPrototype.subtract;
LongPrototype.multiply = function multiply5(multiplier) {
  if (this.isZero()) return this;
  if (!isLong(multiplier)) multiplier = fromValue(multiplier);
  if (wasm) {
    var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO2;
  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO2;
  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO2;
  if (this.isNegative()) {
    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
    else return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
  var a48 = this.high >>> 16;
  var a32 = this.high & 65535;
  var a16 = this.low >>> 16;
  var a00 = this.low & 65535;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 65535;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 65535;
  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 65535;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 65535;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 65535;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 65535;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
LongPrototype.mul = LongPrototype.multiply;
LongPrototype.divide = function divide3(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (divisor.isZero()) throw Error("division by zero");
  if (wasm) {
    if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
      return this;
    }
    var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? UZERO : ZERO2;
  var approx, rem, res;
  if (!this.unsigned) {
    if (this.eq(MIN_VALUE)) {
      if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
        return MIN_VALUE;
      else if (divisor.eq(MIN_VALUE)) return ONE;
      else {
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);
        if (approx.eq(ZERO2)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
    } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO2;
    if (this.isNegative()) {
      if (divisor.isNegative()) return this.neg().div(divisor.neg());
      return this.neg().div(divisor).neg();
    } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
    res = ZERO2;
  } else {
    if (!divisor.unsigned) divisor = divisor.toUnsigned();
    if (divisor.gt(this)) return UZERO;
    if (divisor.gt(this.shru(1)))
      return UONE;
    res = UZERO;
  }
  rem = this;
  while (rem.gte(divisor)) {
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
    var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    }
    if (approxRes.isZero()) approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }
  return res;
};
LongPrototype.div = LongPrototype.divide;
LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (wasm) {
    var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(
      this.low,
      this.high,
      divisor.low,
      divisor.high
    );
    return fromBits(low, wasm["get_high"](), this.unsigned);
  }
  return this.sub(this.div(divisor).mul(divisor));
};
LongPrototype.mod = LongPrototype.modulo;
LongPrototype.rem = LongPrototype.modulo;
LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
LongPrototype.countLeadingZeros = function countLeadingZeros() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
LongPrototype.clz = LongPrototype.countLeadingZeros;
LongPrototype.countTrailingZeros = function countTrailingZeros() {
  return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
};
LongPrototype.ctz = LongPrototype.countTrailingZeros;
LongPrototype.and = function and(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
LongPrototype.or = function or(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
LongPrototype.xor = function xor(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
LongPrototype.shiftLeft = function shiftLeft2(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low << numBits,
      this.high << numBits | this.low >>> 32 - numBits,
      this.unsigned
    );
  else return fromBits(0, this.low << numBits - 32, this.unsigned);
};
LongPrototype.shl = LongPrototype.shiftLeft;
LongPrototype.shiftRight = function shiftRight2(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  else if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >> numBits,
      this.unsigned
    );
  else
    return fromBits(
      this.high >> numBits - 32,
      this.high >= 0 ? 0 : -1,
      this.unsigned
    );
};
LongPrototype.shr = LongPrototype.shiftRight;
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits < 32)
    return fromBits(
      this.low >>> numBits | this.high << 32 - numBits,
      this.high >>> numBits,
      this.unsigned
    );
  if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
  return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
};
LongPrototype.shru = LongPrototype.shiftRightUnsigned;
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
LongPrototype.rotateLeft = function rotateLeft(numBits) {
  var b3;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b3 = 32 - numBits;
    return fromBits(
      this.low << numBits | this.high >>> b3,
      this.high << numBits | this.low >>> b3,
      this.unsigned
    );
  }
  numBits -= 32;
  b3 = 32 - numBits;
  return fromBits(
    this.high << numBits | this.low >>> b3,
    this.low << numBits | this.high >>> b3,
    this.unsigned
  );
};
LongPrototype.rotl = LongPrototype.rotateLeft;
LongPrototype.rotateRight = function rotateRight(numBits) {
  var b3;
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;
  if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
  if (numBits < 32) {
    b3 = 32 - numBits;
    return fromBits(
      this.high << b3 | this.low >>> numBits,
      this.low << b3 | this.high >>> numBits,
      this.unsigned
    );
  }
  numBits -= 32;
  b3 = 32 - numBits;
  return fromBits(
    this.low << b3 | this.high >>> numBits,
    this.high << b3 | this.low >>> numBits,
    this.unsigned
  );
};
LongPrototype.rotr = LongPrototype.rotateRight;
LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned) return this;
  return fromBits(this.low, this.high, false);
};
LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned) return this;
  return fromBits(this.low, this.high, true);
};
LongPrototype.toBytes = function toBytes(le) {
  return le ? this.toBytesLE() : this.toBytesBE();
};
LongPrototype.toBytesLE = function toBytesLE() {
  var hi = this.high, lo = this.low;
  return [
    lo & 255,
    lo >>> 8 & 255,
    lo >>> 16 & 255,
    lo >>> 24,
    hi & 255,
    hi >>> 8 & 255,
    hi >>> 16 & 255,
    hi >>> 24
  ];
};
LongPrototype.toBytesBE = function toBytesBE() {
  var hi = this.high, lo = this.low;
  return [
    hi >>> 24,
    hi >>> 16 & 255,
    hi >>> 8 & 255,
    hi & 255,
    lo >>> 24,
    lo >>> 16 & 255,
    lo >>> 8 & 255,
    lo & 255
  ];
};
Long3.fromBytes = function fromBytes(bytes, unsigned, le) {
  return le ? Long3.fromBytesLE(bytes, unsigned) : Long3.fromBytesBE(bytes, unsigned);
};
Long3.fromBytesLE = function fromBytesLE(bytes, unsigned) {
  return new Long3(
    bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
    bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
    unsigned
  );
};
Long3.fromBytesBE = function fromBytesBE(bytes, unsigned) {
  return new Long3(
    bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
    bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
    unsigned
  );
};
if (typeof BigInt === "function") {
  Long3.fromBigInt = function fromBigInt(value, unsigned) {
    var lowBits = Number(BigInt.asIntN(32, value));
    var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));
    return fromBits(lowBits, highBits, unsigned);
  };
  Long3.fromValue = function fromValueWithBigInt(value, unsigned) {
    if (typeof value === "bigint") return Long3.fromBigInt(value, unsigned);
    return fromValue(value, unsigned);
  };
  LongPrototype.toBigInt = function toBigInt() {
    var lowBigInt = BigInt(this.low >>> 0);
    var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
    return highBigInt << BigInt(32) | lowBigInt;
  };
}
var long_default = Long3;

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2-token-functions.js
var MAXIMUM_TOKEN_LENGTH = 16;
function getS2CellIdFromToken(token) {
  if (token === "X") {
    token = "";
  }
  const paddedToken = token.padEnd(MAXIMUM_TOKEN_LENGTH, "0");
  return long_default.fromString(paddedToken, true, 16);
}
function getS2TokenFromCellId(cellId) {
  if (cellId.isZero()) {
    return "X";
  }
  let numZeroDigits = cellId.countTrailingZeros();
  const remainder = numZeroDigits % 4;
  numZeroDigits = (numZeroDigits - remainder) / 4;
  const trailingZeroHexChars = numZeroDigits;
  numZeroDigits *= 4;
  const x = cellId.shiftRightUnsigned(numZeroDigits);
  const hexString = x.toString(16).replace(/0+$/, "");
  const zeroString = Array(17 - trailingZeroHexChars - hexString.length).join("0");
  return zeroString + hexString;
}
function getS2ChildCellId(cellId, index) {
  const newLsb = lsb(cellId).shiftRightUnsigned(2);
  const childCellId = cellId.add(long_default.fromNumber(2 * index + 1 - 4).multiply(newLsb));
  return childCellId;
}
function lsb(cellId) {
  return cellId.and(cellId.not().add(1));
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2geometry/s2-geometry.js
var FACE_BITS2 = 3;
var MAX_LEVEL2 = 30;
var POS_BITS2 = 2 * MAX_LEVEL2 + 1;
var RADIAN_TO_DEGREE2 = 180 / Math.PI;
function getS2CellFromQuadKey(hilbertQuadkey) {
  if (hilbertQuadkey.length === 0) {
    throw new Error(`Invalid Hilbert quad key ${hilbertQuadkey}`);
  }
  const parts = hilbertQuadkey.split("/");
  const face = parseInt(parts[0], 10);
  const position = parts[1];
  const maxLevel = position.length;
  let level = 0;
  const point2 = [0, 0];
  for (let i = maxLevel - 1; i >= 0; i--) {
    level = maxLevel - i;
    const bit = position[i];
    let rx = 0;
    let ry = 0;
    if (bit === "1") {
      ry = 1;
    } else if (bit === "2") {
      rx = 1;
      ry = 1;
    } else if (bit === "3") {
      rx = 1;
    }
    const val = Math.pow(2, level - 1);
    rotateAndFlipQuadrant2(val, point2, rx, ry);
    point2[0] += val * rx;
    point2[1] += val * ry;
  }
  if (face % 2 === 1) {
    const t = point2[0];
    point2[0] = point2[1];
    point2[1] = t;
  }
  return { face, ij: point2, level };
}
function getS2QuadkeyFromCellId(cellId) {
  if (cellId.isZero()) {
    return "";
  }
  let bin = cellId.toString(2);
  while (bin.length < FACE_BITS2 + POS_BITS2) {
    bin = "0" + bin;
  }
  const lsbIndex = bin.lastIndexOf("1");
  const faceB = bin.substring(0, 3);
  const posB = bin.substring(3, lsbIndex);
  const levelN = posB.length / 2;
  const faceS = long_default.fromString(faceB, true, 2).toString(10);
  let posS = "";
  if (levelN !== 0) {
    posS = long_default.fromString(posB, true, 2).toString(4);
    while (posS.length < levelN) {
      posS = "0" + posS;
    }
  }
  return `${faceS}/${posS}`;
}
function IJToST2(ij, level, offsets) {
  const maxSize = 1 << level;
  return [(ij[0] + offsets[0]) / maxSize, (ij[1] + offsets[1]) / maxSize];
}
function singleSTtoUV2(st) {
  if (st >= 0.5) {
    return 1 / 3 * (4 * st * st - 1);
  }
  return 1 / 3 * (1 - 4 * (1 - st) * (1 - st));
}
function STToUV2(st) {
  return [singleSTtoUV2(st[0]), singleSTtoUV2(st[1])];
}
function FaceUVToXYZ2(face, [u2, v2]) {
  switch (face) {
    case 0:
      return [1, u2, v2];
    case 1:
      return [-u2, 1, v2];
    case 2:
      return [-u2, -v2, 1];
    case 3:
      return [-1, -v2, -u2];
    case 4:
      return [v2, -1, -u2];
    case 5:
      return [v2, u2, -1];
    default:
      throw new Error("Invalid face");
  }
}
function XYZToLngLat2([x, y, z]) {
  const lat = Math.atan2(z, Math.sqrt(x * x + y * y));
  const lng = Math.atan2(y, x);
  return [lng * RADIAN_TO_DEGREE2, lat * RADIAN_TO_DEGREE2];
}
function rotateAndFlipQuadrant2(n, point2, rx, ry) {
  if (ry === 0) {
    if (rx === 1) {
      point2[0] = n - 1 - point2[0];
      point2[1] = n - 1 - point2[1];
    }
    const x = point2[0];
    point2[0] = point2[1];
    point2[1] = x;
  }
}
function getS2LngLatFromS2Cell(s2Cell) {
  const st = IJToST2(s2Cell.ij, s2Cell.level, [0.5, 0.5]);
  const uv = STToUV2(st);
  const xyz = FaceUVToXYZ2(s2Cell.face, uv);
  return XYZToLngLat2(xyz);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-boundary.js
var MAX_RESOLUTION3 = 100;
function getS2BoundaryFlatFromS2Cell(s2cell) {
  const { face, ij, level } = s2cell;
  const offsets = [
    [0, 0],
    [0, 1],
    [1, 1],
    [1, 0],
    [0, 0]
  ];
  const resolution = Math.max(1, Math.ceil(MAX_RESOLUTION3 * Math.pow(2, -level)));
  const result = new Float64Array(4 * resolution * 2 + 2);
  let ptIndex = 0;
  let prevLng = 0;
  for (let i = 0; i < 4; i++) {
    const offset = offsets[i].slice(0);
    const nextOffset = offsets[i + 1];
    const stepI = (nextOffset[0] - offset[0]) / resolution;
    const stepJ = (nextOffset[1] - offset[1]) / resolution;
    for (let j = 0; j < resolution; j++) {
      offset[0] += stepI;
      offset[1] += stepJ;
      const st = IJToST2(ij, level, offset);
      const uv = STToUV2(st);
      const xyz = FaceUVToXYZ2(face, uv);
      const lngLat = XYZToLngLat2(xyz);
      if (Math.abs(lngLat[1]) > 89.999) {
        lngLat[0] = prevLng;
      }
      const deltaLng = lngLat[0] - prevLng;
      lngLat[0] += deltaLng > 180 ? -360 : deltaLng < -180 ? 360 : 0;
      result[ptIndex++] = lngLat[0];
      result[ptIndex++] = lngLat[1];
      prevLng = lngLat[0];
    }
  }
  result[ptIndex++] = result[0];
  result[ptIndex++] = result[1];
  return result;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2geometry/s2-cell-utils.js
function getS2Cell(tokenOrKey) {
  const key = getS2QuadKey2(tokenOrKey);
  const s2cell = getS2CellFromQuadKey(key);
  return s2cell;
}
function getS2QuadKey2(tokenOrKey) {
  if (tokenOrKey.indexOf("/") > 0) {
    return tokenOrKey;
  }
  const id = getS2CellIdFromToken(tokenOrKey);
  return getS2QuadkeyFromCellId(id);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/s2-geometry-functions.js
function getS2LngLat(s2Token) {
  const s2cell = getS2Cell(s2Token);
  return getS2LngLatFromS2Cell(s2cell);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-region.js
function getS2Region(s2cell) {
  let region;
  if (s2cell.face === 2 || s2cell.face === 5) {
    let corners = null;
    let len4 = 0;
    for (let i = 0; i < 4; i++) {
      const key = `${s2cell.face}/${i}`;
      const cell = getS2Cell(key);
      const corns = getS2BoundaryFlatFromS2Cell(cell);
      if (typeof corners === "undefined" || corners === null)
        corners = new Float64Array(4 * corns.length);
      corners.set(corns, len4);
      len4 += corns.length;
    }
    region = get2DRegionFromS2Corners(corners);
  } else {
    const corners = getS2BoundaryFlatFromS2Cell(s2cell);
    region = get2DRegionFromS2Corners(corners);
  }
  return region;
}
function get2DRegionFromS2Corners(corners) {
  if (corners.length % 2 !== 0) {
    throw new Error("Invalid corners");
  }
  const longitudes = [];
  const latitudes = [];
  for (let i = 0; i < corners.length; i += 2) {
    longitudes.push(corners[i]);
    latitudes.push(corners[i + 1]);
  }
  longitudes.sort((a3, b3) => a3 - b3);
  latitudes.sort((a3, b3) => a3 - b3);
  return {
    west: longitudes[0],
    east: longitudes[longitudes.length - 1],
    north: latitudes[latitudes.length - 1],
    south: latitudes[0]
  };
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/s2/converters/s2-to-obb-points.js
function getS2OrientedBoundingBoxCornerPoints(tokenOrKey, heightInfo) {
  const min3 = (heightInfo == null ? void 0 : heightInfo.minimumHeight) || 0;
  const max3 = (heightInfo == null ? void 0 : heightInfo.maximumHeight) || 0;
  const s2cell = getS2Cell(tokenOrKey);
  const region = getS2Region(s2cell);
  const W2 = region.west;
  const S = region.south;
  const E2 = region.east;
  const N = region.north;
  const points = [];
  points.push(new Vector3(W2, N, min3));
  points.push(new Vector3(E2, N, min3));
  points.push(new Vector3(E2, S, min3));
  points.push(new Vector3(W2, S, min3));
  points.push(new Vector3(W2, N, max3));
  points.push(new Vector3(E2, N, max3));
  points.push(new Vector3(E2, S, max3));
  points.push(new Vector3(W2, S, max3));
  return points;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/utils/obb/s2-corners-to-obb.js
function convertS2BoundingVolumetoOBB(s2VolumeInfo) {
  const token = s2VolumeInfo.token;
  const heightInfo = {
    minimumHeight: s2VolumeInfo.minimumHeight,
    maximumHeight: s2VolumeInfo.maximumHeight
  };
  const corners = getS2OrientedBoundingBoxCornerPoints(token, heightInfo);
  const center2 = getS2LngLat(token);
  const centerLng = center2[0];
  const centerLat = center2[1];
  const point2 = Ellipsoid.WGS84.cartographicToCartesian([
    centerLng,
    centerLat,
    heightInfo.maximumHeight
  ]);
  const centerPointAdditional = new Vector3(point2[0], point2[1], point2[2]);
  corners.push(centerPointAdditional);
  const obb = makeOrientedBoundingBoxFromPoints(corners);
  const box = [...obb.center, ...obb.halfAxes];
  return box;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/helpers/parse-3d-implicit-tiles.js
var QUADTREE_DIVISION_COUNT = 4;
var OCTREE_DIVISION_COUNT = 8;
var SUBDIVISION_COUNT_MAP = {
  QUADTREE: QUADTREE_DIVISION_COUNT,
  OCTREE: OCTREE_DIVISION_COUNT
};
function getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme) {
  if (s2VolumeBox == null ? void 0 : s2VolumeBox.box) {
    const cellId = getS2CellIdFromToken(s2VolumeBox.s2VolumeInfo.token);
    const childCellId = getS2ChildCellId(cellId, index);
    const childToken = getS2TokenFromCellId(childCellId);
    const s2ChildVolumeInfo = { ...s2VolumeBox.s2VolumeInfo };
    s2ChildVolumeInfo.token = childToken;
    switch (subdivisionScheme) {
      case "OCTREE":
        const s2VolumeInfo = s2VolumeBox.s2VolumeInfo;
        const delta = s2VolumeInfo.maximumHeight - s2VolumeInfo.minimumHeight;
        const sizeZ = delta / 2;
        const midZ = s2VolumeInfo.minimumHeight + delta / 2;
        s2VolumeInfo.minimumHeight = midZ - sizeZ;
        s2VolumeInfo.maximumHeight = midZ + sizeZ;
        break;
      default:
        break;
    }
    const box = convertS2BoundingVolumetoOBB(s2ChildVolumeInfo);
    const childS2VolumeBox = {
      box,
      s2VolumeInfo: s2ChildVolumeInfo
    };
    return childS2VolumeBox;
  }
  return void 0;
}
async function parseImplicitTiles(params) {
  const { subtree, subtreeData = {
    level: 0,
    x: 0,
    y: 0,
    z: 0
  }, parentData = {
    mortonIndex: 0,
    localLevel: -1,
    localX: 0,
    localY: 0,
    localZ: 0
  }, childIndex = 0, implicitOptions, loaderOptions, s2VolumeBox } = params;
  const { subdivisionScheme, subtreeLevels, maximumLevel, contentUrlTemplate, subtreesUriTemplate, basePath } = implicitOptions;
  const tile = { children: [], lodMetricValue: 0, contentUrl: "" };
  if (!maximumLevel) {
    dist_default.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${contentUrlTemplate} won't be loaded...`);
    return tile;
  }
  const localLevel = parentData.localLevel + 1;
  const level = subtreeData.level + localLevel;
  if (level > maximumLevel) {
    return tile;
  }
  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];
  const bitsPerTile = Math.log2(childrenPerTile);
  const lastBitX = childIndex & 1;
  const lastBitY = childIndex >> 1 & 1;
  const lastBitZ = childIndex >> 2 & 1;
  const localX = concatBits(parentData.localX, lastBitX, 1);
  const localY = concatBits(parentData.localY, lastBitY, 1);
  const localZ = concatBits(parentData.localZ, lastBitZ, 1);
  const x = concatBits(subtreeData.x, localX, localLevel);
  const y = concatBits(subtreeData.y, localY, localLevel);
  const z = concatBits(subtreeData.z, localZ, localLevel);
  const mortonIndex = concatBits(parentData.mortonIndex, childIndex, bitsPerTile);
  const isChildSubtreeAvailable = localLevel === subtreeLevels && getAvailabilityResult(subtree.childSubtreeAvailability, mortonIndex);
  let nextSubtree;
  let nextSubtreeData;
  let nextParentData;
  let tileAvailabilityIndex;
  if (isChildSubtreeAvailable) {
    const subtreePath = `${basePath}/${subtreesUriTemplate}`;
    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, level, x, y, z);
    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader, loaderOptions);
    nextSubtree = childSubtree;
    tileAvailabilityIndex = 0;
    nextSubtreeData = { level, x, y, z };
    nextParentData = { mortonIndex: 0, localLevel: 0, localX: 0, localY: 0, localZ: 0 };
  } else {
    nextSubtree = subtree;
    const levelOffset = (childrenPerTile ** localLevel - 1) / (childrenPerTile - 1);
    tileAvailabilityIndex = levelOffset + mortonIndex;
    nextSubtreeData = subtreeData;
    nextParentData = { mortonIndex, localLevel, localX, localY, localZ };
  }
  const isTileAvailable = getAvailabilityResult(nextSubtree.tileAvailability, tileAvailabilityIndex);
  if (!isTileAvailable) {
    return tile;
  }
  const isContentAvailable = getAvailabilityResult(nextSubtree.contentAvailability, tileAvailabilityIndex);
  if (isContentAvailable) {
    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, level, x, y, z);
  }
  for (let index = 0; index < childrenPerTile; index++) {
    const childS2VolumeBox = getChildS2VolumeBox(s2VolumeBox, index, subdivisionScheme);
    const childTile = await parseImplicitTiles({
      subtree: nextSubtree,
      subtreeData: nextSubtreeData,
      parentData: nextParentData,
      childIndex: index,
      implicitOptions,
      loaderOptions,
      s2VolumeBox: childS2VolumeBox
    });
    if (childTile.contentUrl || childTile.children.length) {
      tile.children.push(childTile);
    }
  }
  if (tile.contentUrl || tile.children.length) {
    const coordinates = { level, x, y, z };
    const formattedTile = formatTileData(tile, coordinates, implicitOptions, s2VolumeBox);
    return formattedTile;
  }
  return tile;
}
function getAvailabilityResult(availabilityData, index) {
  let availabilityObject;
  if (Array.isArray(availabilityData)) {
    availabilityObject = availabilityData[0];
    if (availabilityData.length > 1) {
      dist_default.once('Not supported extension "3DTILES_multiple_contents" has been detected');
    }
  } else {
    availabilityObject = availabilityData;
  }
  if ("constant" in availabilityObject) {
    return Boolean(availabilityObject.constant);
  }
  if (availabilityObject.explicitBitstream) {
    return getBooleanValueFromBitstream(index, availabilityObject.explicitBitstream);
  }
  return false;
}
function formatTileData(tile, coordinates, options, s2VolumeBox) {
  const { basePath, refine, getRefine: getRefine2, lodMetricType, getTileType: getTileType2, rootLodMetricValue, rootBoundingVolume } = options;
  const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, "");
  const lodMetricValue = rootLodMetricValue / 2 ** coordinates.level;
  const boundingVolume = (s2VolumeBox == null ? void 0 : s2VolumeBox.box) ? { box: s2VolumeBox.box } : rootBoundingVolume;
  const boundingVolumeForChildTile = calculateBoundingVolumeForChildTile(boundingVolume, coordinates, options.subdivisionScheme);
  return {
    children: tile.children,
    contentUrl: tile.contentUrl,
    content: { uri },
    id: tile.contentUrl,
    refine: getRefine2(refine),
    type: getTileType2(tile),
    lodMetricType,
    lodMetricValue,
    geometricError: lodMetricValue,
    transform: tile.transform,
    boundingVolume: boundingVolumeForChildTile
  };
}
function calculateBoundingVolumeForChildTile(rootBoundingVolume, coordinates, subdivisionScheme) {
  if (rootBoundingVolume.region) {
    const { level, x, y, z } = coordinates;
    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;
    const boundingVolumesCount = 2 ** level;
    const sizeX = (east - west) / boundingVolumesCount;
    const [childWest, childEast] = [west + sizeX * x, west + sizeX * (x + 1)];
    const sizeY = (north - south) / boundingVolumesCount;
    const [childSouth, childNorth] = [south + sizeY * y, south + sizeY * (y + 1)];
    let childMinimumHeight;
    let childMaximumHeight;
    if (subdivisionScheme === "OCTREE") {
      const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;
      [childMinimumHeight, childMaximumHeight] = [
        minimumHeight + sizeZ * z,
        minimumHeight + sizeZ * (z + 1)
      ];
    } else {
      [childMinimumHeight, childMaximumHeight] = [minimumHeight, maximumHeight];
    }
    return {
      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]
    };
  }
  if (rootBoundingVolume.box) {
    return rootBoundingVolume;
  }
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(rootBoundingVolume)}`);
}
function concatBits(higher, lower, shift) {
  return (higher << shift) + lower;
}
function replaceContentUrlTemplate(templateUrl, level, x, y, z) {
  const mapUrl = generateMapUrl({ level, x, y, z });
  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);
}
function generateMapUrl(items) {
  const mapUrl = {};
  for (const key in items) {
    mapUrl[`{${key}}`] = items[key];
  }
  return mapUrl;
}
function getBooleanValueFromBitstream(availabilityIndex, availabilityBuffer) {
  const byteIndex = Math.floor(availabilityIndex / 8);
  const bitIndex = availabilityIndex % 8;
  const bitValue = availabilityBuffer[byteIndex] >> bitIndex & 1;
  return bitValue === 1;
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/parsers/parse-3d-tile-header.js
function getTileType(tile, tileContentUrl = "") {
  if (!tileContentUrl) {
    return TILE_TYPE.EMPTY;
  }
  const contentUrl = tileContentUrl.split("?")[0];
  const fileExtension = contentUrl.split(".").pop();
  switch (fileExtension) {
    case "pnts":
      return TILE_TYPE.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return TILE_TYPE.SCENEGRAPH;
    default:
      return fileExtension || TILE_TYPE.EMPTY;
  }
}
function getRefine(refine) {
  switch (refine) {
    case "REPLACE":
    case "replace":
      return TILE_REFINEMENT.REPLACE;
    case "ADD":
    case "add":
      return TILE_REFINEMENT.ADD;
    default:
      return refine;
  }
}
function resolveUri(uri, basePath) {
  const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;
  if (urlSchemeRegex.test(basePath)) {
    const url = new URL(uri, `${basePath}/`);
    return decodeURI(url.toString());
  } else if (uri.startsWith("/")) {
    return uri;
  }
  return path_exports.resolve(basePath, uri);
}
function normalizeTileData(tile, basePath) {
  var _a;
  if (!tile) {
    return null;
  }
  let tileContentUrl;
  if (tile.content) {
    const contentUri = tile.content.uri || ((_a = tile.content) == null ? void 0 : _a.url);
    if (typeof contentUri !== "undefined") {
      tileContentUrl = resolveUri(contentUri, basePath);
    }
  }
  const tilePostprocessed = {
    ...tile,
    id: tileContentUrl,
    contentUrl: tileContentUrl,
    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    lodMetricValue: tile.geometricError,
    transformMatrix: tile.transform,
    type: getTileType(tile, tileContentUrl),
    refine: getRefine(tile.refine)
  };
  return tilePostprocessed;
}
async function normalizeTileHeaders(tileset, basePath, options) {
  let root = null;
  const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset.root);
  if (rootImplicitTilingExtension && tileset.root) {
    root = await normalizeImplicitTileHeaders(tileset.root, tileset, basePath, rootImplicitTilingExtension, options);
  } else {
    root = normalizeTileData(tileset.root, basePath);
  }
  const stack2 = [];
  stack2.push(root);
  while (stack2.length > 0) {
    const tile = stack2.pop() || {};
    const children = tile.children || [];
    const childrenPostprocessed = [];
    for (const childHeader of children) {
      const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);
      let childHeaderPostprocessed;
      if (childImplicitTilingExtension) {
        childHeaderPostprocessed = await normalizeImplicitTileHeaders(childHeader, tileset, basePath, childImplicitTilingExtension, options);
      } else {
        childHeaderPostprocessed = normalizeTileData(childHeader, basePath);
      }
      if (childHeaderPostprocessed) {
        childrenPostprocessed.push(childHeaderPostprocessed);
        stack2.push(childHeaderPostprocessed);
      }
    }
    tile.children = childrenPostprocessed;
  }
  return root;
}
async function normalizeImplicitTileHeaders(tile, tileset, basePath, implicitTilingExtension, options) {
  var _a, _b, _c;
  const { subdivisionScheme, maximumLevel, availableLevels, subtreeLevels, subtrees: { uri: subtreesUriTemplate } } = implicitTilingExtension;
  const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);
  const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);
  const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);
  const tileContentUri = (_a = tile.content) == null ? void 0 : _a.uri;
  const contentUrlTemplate = tileContentUri ? resolveUri(tileContentUri, basePath) : "";
  const refine = (_b = tileset == null ? void 0 : tileset.root) == null ? void 0 : _b.refine;
  const rootLodMetricValue = tile.geometricError;
  const s2VolumeInfo = (_c = tile.boundingVolume.extensions) == null ? void 0 : _c["3DTILES_bounding_volume_S2"];
  if (s2VolumeInfo) {
    const box = convertS2BoundingVolumetoOBB(s2VolumeInfo);
    const s2VolumeBox = { box, s2VolumeInfo };
    tile.boundingVolume = s2VolumeBox;
  }
  const rootBoundingVolume = tile.boundingVolume;
  const implicitOptions = {
    contentUrlTemplate,
    subtreesUriTemplate,
    subdivisionScheme,
    subtreeLevels,
    maximumLevel: Number.isFinite(availableLevels) ? availableLevels - 1 : maximumLevel,
    refine,
    basePath,
    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    rootLodMetricValue,
    rootBoundingVolume,
    getTileType,
    getRefine
  };
  return await normalizeImplicitTileData(tile, basePath, subtree, implicitOptions, options);
}
async function normalizeImplicitTileData(tile, basePath, rootSubtree, implicitOptions, loaderOptions) {
  if (!tile) {
    return null;
  }
  const { children, contentUrl } = await parseImplicitTiles({
    subtree: rootSubtree,
    implicitOptions,
    loaderOptions
  });
  let tileContentUrl;
  let tileContent = null;
  if (contentUrl) {
    tileContentUrl = contentUrl;
    tileContent = { uri: contentUrl.replace(`${basePath}/`, "") };
  }
  const tilePostprocessed = {
    ...tile,
    id: tileContentUrl,
    contentUrl: tileContentUrl,
    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    lodMetricValue: tile.geometricError,
    transformMatrix: tile.transform,
    type: getTileType(tile, tileContentUrl),
    refine: getRefine(tile.refine),
    content: tileContent || tile.content,
    children
  };
  return tilePostprocessed;
}
function getImplicitTilingExtensionData(tile) {
  var _a;
  return ((_a = tile == null ? void 0 : tile.extensions) == null ? void 0 : _a["3DTILES_implicit_tiling"]) || (tile == null ? void 0 : tile.implicitTiling);
}

// node_modules/@loaders.gl/3d-tiles/dist/tiles-3d-loader.js
var Tiles3DLoader = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: VERSION7,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: parse3,
  options: {
    "3d-tiles": {
      loadGLTF: true,
      decodeQuantizedPositions: false,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function parse3(data, options = {}, context) {
  const loaderOptions = options["3d-tiles"] || {};
  let isTileset;
  if (loaderOptions.isTileset === "auto") {
    isTileset = (context == null ? void 0 : context.url) && context.url.indexOf(".json") !== -1;
  } else {
    isTileset = loaderOptions.isTileset;
  }
  return isTileset ? parseTileset(data, options, context) : parseTile(data, options, context);
}
async function parseTileset(data, options, context) {
  var _a;
  const tilesetJson = JSON.parse(new TextDecoder().decode(data));
  const tilesetUrl = (context == null ? void 0 : context.url) || "";
  const basePath = getBaseUri(tilesetUrl);
  const normalizedRoot = await normalizeTileHeaders(tilesetJson, basePath, options || {});
  const tilesetJsonPostprocessed = {
    ...tilesetJson,
    shape: "tileset3d",
    loader: Tiles3DLoader,
    url: tilesetUrl,
    queryString: (context == null ? void 0 : context.queryString) || "",
    basePath,
    root: normalizedRoot || tilesetJson.root,
    type: TILESET_TYPE.TILES3D,
    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,
    lodMetricValue: ((_a = tilesetJson.root) == null ? void 0 : _a.geometricError) || 0
  };
  return tilesetJsonPostprocessed;
}
async function parseTile(arrayBuffer, options, context) {
  const tile = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  const byteOffset = 0;
  await parse3DTile(arrayBuffer, byteOffset, options, context, tile.content);
  return tile.content;
}
function getBaseUri(tilesetUrl) {
  return path_exports.dirname(tilesetUrl);
}

// node_modules/@loaders.gl/3d-tiles/dist/lib/ion/ion.js
var CESIUM_ION_URL = "https://api.cesium.com/v1/assets";
async function getIonTilesetMetadata(accessToken, assetId) {
  if (!assetId) {
    const assets = await getIonAssets(accessToken);
    for (const item of assets.items) {
      if (item.type === "3DTILES") {
        assetId = item.id;
      }
    }
  }
  const ionAssetMetadata = await getIonAssetMetadata(accessToken, assetId);
  const { type, url } = ionAssetMetadata;
  assert2(type === "3DTILES" && url);
  ionAssetMetadata.headers = {
    Authorization: `Bearer ${ionAssetMetadata.accessToken}`
  };
  return ionAssetMetadata;
}
async function getIonAssets(accessToken) {
  assert2(accessToken);
  const url = CESIUM_ION_URL;
  const headers = { Authorization: `Bearer ${accessToken}` };
  const response = await fetchFile(url, { headers });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  return await response.json();
}
async function getIonAssetMetadata(accessToken, assetId) {
  assert2(accessToken, assetId);
  const headers = { Authorization: `Bearer ${accessToken}` };
  const url = `${CESIUM_ION_URL}/${assetId}`;
  let response = await fetchFile(`${url}`, { headers });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  let metadata = await response.json();
  response = await fetchFile(`${url}/endpoint`, { headers });
  if (!response.ok) {
    throw new Error(response.statusText);
  }
  const tilesetInfo = await response.json();
  metadata = {
    ...metadata,
    ...tilesetInfo
  };
  return metadata;
}

// node_modules/@loaders.gl/3d-tiles/dist/cesium-ion-loader.js
async function preload(url, options = {}) {
  options = options["cesium-ion"] || {};
  const { accessToken } = options;
  let assetId = options.assetId;
  if (!Number.isFinite(assetId)) {
    const matched = url.match(/\/([0-9]+)\/tileset.json/);
    assetId = matched && matched[1];
  }
  return getIonTilesetMetadata(accessToken, assetId);
}
var CesiumIonLoader = {
  ...Tiles3DLoader,
  id: "cesium-ion",
  name: "Cesium Ion",
  // @ts-ignore
  preload,
  parse: async (data, options, context) => {
    options = { ...options };
    options["3d-tiles"] = options["cesium-ion"];
    options.loader = CesiumIonLoader;
    return Tiles3DLoader.parse(data, options, context);
  },
  options: {
    "cesium-ion": {
      ...Tiles3DLoader.options["3d-tiles"],
      accessToken: null
    }
  }
};

// node_modules/@loaders.gl/zip/dist/zip-loader.js
var import_jszip = __toESM(require_jszip_min(), 1);

// node_modules/@loaders.gl/zip/dist/zip-writer.js
var import_jszip2 = __toESM(require_jszip_min(), 1);

// node_modules/@loaders.gl/zip/dist/parse-zip/zip64-info-generation.js
var signature = new Uint8Array([1, 0]);
var ZIP64_FIELDS = [
  // Header ID 0x0001
  {
    size: 2,
    default: new DataView(signature.buffer).getUint16(0, true)
  },
  // Size of the extra field chunk (8, 16, 24 or 28)
  {
    size: 2,
    name: "zip64Length"
  },
  // Original uncompressed file size
  {
    size: 8,
    name: "size"
  },
  // Size of compressed data
  {
    size: 8,
    name: "size"
  },
  // Offset of local header record
  {
    size: 8,
    name: "offset"
  }
];

// node_modules/@loaders.gl/zip/dist/parse-zip/end-of-central-directory.js
var eoCDSignature = new Uint8Array([80, 75, 5, 6]);
var zip64EoCDLocatorSignature = new Uint8Array([80, 75, 6, 7]);
var zip64EoCDSignature = new Uint8Array([80, 75, 6, 6]);
var EOCD_FIELDS = [
  // End of central directory signature = 0x06054b50
  {
    offset: 0,
    size: 4,
    default: new DataView(eoCDSignature.buffer).getUint32(0, true)
  },
  // Number of this disk (or 0xffff for ZIP64)
  {
    offset: 4,
    size: 2,
    default: 0
  },
  // Disk where central directory starts (or 0xffff for ZIP64)
  {
    offset: 6,
    size: 2,
    default: 0
  },
  // Number of central directory records on this disk (or 0xffff for ZIP64)
  {
    offset: 8,
    size: 2,
    name: "recordsNumber"
  },
  // Total number of central directory records (or 0xffff for ZIP64)
  {
    offset: 10,
    size: 2,
    name: "recordsNumber"
  },
  // Size of central directory (bytes) (or 0xffffffff for ZIP64)
  {
    offset: 12,
    size: 4,
    name: "cdSize"
  },
  // Offset of start of central directory, relative to start of archive (or 0xffffffff for ZIP64)
  {
    offset: 16,
    size: 4,
    name: "cdOffset"
  },
  // Comment length (n)
  {
    offset: 20,
    size: 2,
    default: 0
  }
];
var ZIP64_EOCD_LOCATOR_FIELDS = [
  // zip64 end of central dir locator signature
  {
    offset: 0,
    size: 4,
    default: new DataView(zip64EoCDLocatorSignature.buffer).getUint32(0, true)
  },
  // number of the disk with the start of the zip64 end of
  {
    offset: 4,
    size: 4,
    default: 0
  },
  // start of the zip64 end of central directory
  {
    offset: 8,
    size: 8,
    name: "eoCDStart"
  },
  // total number of disks
  {
    offset: 16,
    size: 4,
    default: 1
  }
];
var ZIP64_EOCD_FIELDS = [
  // End of central directory signature = 0x06064b50
  {
    offset: 0,
    size: 4,
    default: new DataView(zip64EoCDSignature.buffer).getUint32(0, true)
  },
  // Size of the EOCD64 minus 12
  {
    offset: 4,
    size: 8,
    default: 44
  },
  // Version made by
  {
    offset: 12,
    size: 2,
    default: 45
  },
  // Version needed to extract (minimum)
  {
    offset: 14,
    size: 2,
    default: 45
  },
  // Number of this disk
  {
    offset: 16,
    size: 4,
    default: 0
  },
  // Disk where central directory starts
  {
    offset: 20,
    size: 4,
    default: 0
  },
  // Number of central directory records on this disk
  {
    offset: 24,
    size: 8,
    name: "recordsNumber"
  },
  // Total number of central directory records
  {
    offset: 32,
    size: 8,
    name: "recordsNumber"
  },
  // Size of central directory (bytes)
  {
    offset: 40,
    size: 8,
    name: "cdSize"
  },
  // Offset of start of central directory, relative to start of archive
  {
    offset: 48,
    size: 8,
    name: "cdOffset"
  }
];

// node_modules/@loaders.gl/zip/dist/parse-zip/cd-file-header.js
var signature2 = new Uint8Array([80, 75, 1, 2]);
var ZIP_HEADER_FIELDS = [
  // Central directory file header signature = 0x02014b50
  {
    offset: 0,
    size: 4,
    default: new DataView(signature2.buffer).getUint32(0, true)
  },
  // Version made by
  {
    offset: 4,
    size: 2,
    default: 45
  },
  // Version needed to extract (minimum)
  {
    offset: 6,
    size: 2,
    default: 45
  },
  // General purpose bit flag
  {
    offset: 8,
    size: 2,
    default: 0
  },
  // Compression method
  {
    offset: 10,
    size: 2,
    default: 0
  },
  // File last modification time
  {
    offset: 12,
    size: 2,
    default: 0
  },
  // File last modification date
  {
    offset: 14,
    size: 2,
    default: 0
  },
  // CRC-32 of uncompressed data
  {
    offset: 16,
    size: 4,
    name: "crc32"
  },
  // Compressed size (or 0xffffffff for ZIP64)
  {
    offset: 20,
    size: 4,
    name: "length"
  },
  // Uncompressed size (or 0xffffffff for ZIP64)
  {
    offset: 24,
    size: 4,
    name: "length"
  },
  // File name length (n)
  {
    offset: 28,
    size: 2,
    name: "fnlength"
  },
  // Extra field length (m)
  {
    offset: 30,
    size: 2,
    default: 0,
    name: "extraLength"
  },
  // File comment length (k)
  {
    offset: 32,
    size: 2,
    default: 0
  },
  // Disk number where file starts (or 0xffff for ZIP64)
  {
    offset: 34,
    size: 2,
    default: 0
  },
  // Internal file attributes
  {
    offset: 36,
    size: 2,
    default: 0
  },
  // External file attributes
  {
    offset: 38,
    size: 4,
    default: 0
  },
  // Relative offset of local file header
  {
    offset: 42,
    size: 4,
    name: "offset"
  }
];

// node_modules/@loaders.gl/zip/dist/parse-zip/local-file-header.js
var signature3 = new Uint8Array([80, 75, 3, 4]);
var ZIP_HEADER_FIELDS2 = [
  // Local file header signature = 0x04034b50
  {
    offset: 0,
    size: 4,
    default: new DataView(signature3.buffer).getUint32(0, true)
  },
  // Version needed to extract (minimum)
  {
    offset: 4,
    size: 2,
    default: 45
  },
  // General purpose bit flag
  {
    offset: 6,
    size: 2,
    default: 0
  },
  // Compression method
  {
    offset: 8,
    size: 2,
    default: 0
  },
  // File last modification time
  {
    offset: 10,
    size: 2,
    default: 0
  },
  // File last modification date
  {
    offset: 12,
    size: 2,
    default: 0
  },
  // CRC-32 of uncompressed data
  {
    offset: 14,
    size: 4,
    name: "crc32"
  },
  // Compressed size (or 0xffffffff for ZIP64)
  {
    offset: 18,
    size: 4,
    name: "length"
  },
  // Uncompressed size (or 0xffffffff for ZIP64)
  {
    offset: 22,
    size: 4,
    name: "length"
  },
  // File name length (n)
  {
    offset: 26,
    size: 2,
    name: "fnlength"
  },
  // Extra field length (m)
  {
    offset: 28,
    size: 2,
    default: 0,
    name: "extraLength"
  }
];

// node_modules/@loaders.gl/crypto/dist/lib/algorithms/crc32.js
var CRC32TAB = Uint32Array.of(0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117);

// node_modules/@loaders.gl/crypto/dist/lib/algorithms/crc32c.js
var CRC32C_TABLE = Int32Array.of(0, 4067132163, 3778769143, 324072436, 3348797215, 904991772, 648144872, 3570033899, 2329499855, 2024987596, 1809983544, 2575936315, 1296289744, 3207089363, 2893594407, 1578318884, 274646895, 3795141740, 4049975192, 51262619, 3619967088, 632279923, 922689671, 3298075524, 2592579488, 1760304291, 2075979607, 2312596564, 1562183871, 2943781820, 3156637768, 1313733451, 549293790, 3537243613, 3246849577, 871202090, 3878099393, 357341890, 102525238, 4101499445, 2858735121, 1477399826, 1264559846, 3107202533, 1845379342, 2677391885, 2361733625, 2125378298, 820201905, 3263744690, 3520608582, 598981189, 4151959214, 85089709, 373468761, 3827903834, 3124367742, 1213305469, 1526817161, 2842354314, 2107672161, 2412447074, 2627466902, 1861252501, 1098587580, 3004210879, 2688576843, 1378610760, 2262928035, 1955203488, 1742404180, 2511436119, 3416409459, 969524848, 714683780, 3639785095, 205050476, 4266873199, 3976438427, 526918040, 1361435347, 2739821008, 2954799652, 1114974503, 2529119692, 1691668175, 2005155131, 2247081528, 3690758684, 697762079, 986182379, 3366744552, 476452099, 3993867776, 4250756596, 255256311, 1640403810, 2477592673, 2164122517, 1922457750, 2791048317, 1412925310, 1197962378, 3037525897, 3944729517, 427051182, 170179418, 4165941337, 746937522, 3740196785, 3451792453, 1070968646, 1905808397, 2213795598, 2426610938, 1657317369, 3053634322, 1147748369, 1463399397, 2773627110, 4215344322, 153784257, 444234805, 3893493558, 1021025245, 3467647198, 3722505002, 797665321, 2197175160, 1889384571, 1674398607, 2443626636, 1164749927, 3070701412, 2757221520, 1446797203, 137323447, 4198817972, 3910406976, 461344835, 3484808360, 1037989803, 781091935, 3705997148, 2460548119, 1623424788, 1939049696, 2180517859, 1429367560, 2807687179, 3020495871, 1180866812, 410100952, 3927582683, 4182430767, 186734380, 3756733383, 763408580, 1053836080, 3434856499, 2722870694, 1344288421, 1131464017, 2971354706, 1708204729, 2545590714, 2229949006, 1988219213, 680717673, 3673779818, 3383336350, 1002577565, 4010310262, 493091189, 238226049, 4233660802, 2987750089, 1082061258, 1395524158, 2705686845, 1972364758, 2279892693, 2494862625, 1725896226, 952904198, 3399985413, 3656866545, 731699698, 4283874585, 222117402, 510512622, 3959836397, 3280807620, 837199303, 582374963, 3504198960, 68661723, 4135334616, 3844915500, 390545967, 1230274059, 3141532936, 2825850620, 1510247935, 2395924756, 2091215383, 1878366691, 2644384480, 3553878443, 565732008, 854102364, 3229815391, 340358836, 3861050807, 4117890627, 119113024, 1493875044, 2875275879, 3090270611, 1247431312, 2660249211, 1828433272, 2141937292, 2378227087, 3811616794, 291187481, 34330861, 4032846830, 615137029, 3603020806, 3314634738, 939183345, 1776939221, 2609017814, 2295496738, 2058945313, 2926798794, 1545135305, 1330124605, 3173225534, 4084100981, 17165430, 307568514, 3762199681, 888469610, 3332340585, 3587147933, 665062302, 2042050490, 2346497209, 2559330125, 1793573966, 3190661285, 1279665062, 1595330642, 2910671697);

// node_modules/@loaders.gl/crypto/dist/lib/algorithms/md5-wasm.js
var atb = typeof atob === "function" ? atob : typeof Buffer === "function" ? nodeATOB : identity4;
var wasmB64 = atb("AGFzbQEAAAABDANgAX8AYAAAYAABfwIeAgdpbXBvcnRzA2xvZwAAB2ltcG9ydHMDbWVtAgABAzIxAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAAAAAgICAgIAAAAAAAaYARt/AUGBxpS6Bgt/AUGJ17b+fgt/AUH+uevFeQt/AUH2qMmBAQt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALfwFBAAt/AUEAC38BQQALB7oCJQhvbmVGdWxsQQAYCG9uZUZ1bGxCABkIb25lRnVsbEMAGghvbmVGdWxsRAAbBWxvb3BzAAEEbG9vcAACBXByaW1lAAMFbG9vcEEABAZsb29wQTEABQZsb29wQTIABgZsb29wQTMABwZsb29wQTQACAVsb29wQgAJBmxvb3BCMQAKBmxvb3BCMgALBmxvb3BCMwAMBmxvb3BCNAANBWxvb3BDAA4GbG9vcEMxAA8GbG9vcEMyABAGbG9vcEMzABEGbG9vcEM0ABIFbG9vcEQAEwZsb29wRDEAFAZsb29wRDIAFQZsb29wRDMAFgZsb29wRDQAFwRnZXRBACgEZ2V0QgApBGdldEMAKgRnZXREACsEZ2V0WAAsBHNldEEALQRzZXRCAC4Ec2V0QwAvBHNldEQAMARzZXRYADEKzA0xWwEBf0EAJAggAEEGdCEBAkADQCMIIAFGDQEjACQEIwEkBSMCJAYjAyQHEAIjBCMAaiQAIwUjAWokASMGIwJqJAIjByMDaiQDIwhBwABqJAgMAAsLIwgjGmokGgsTACMIIxpqJAkQAxAEEAkQDhATC6IBAEEAIwlqKAIAJApBBCMJaigCACQLQQgjCWooAgAkDEEMIwlqKAIAJA1BECMJaigCACQOQRQjCWooAgAkD0EYIwlqKAIAJBBBHCMJaigCACQRQSAjCWooAgAkEkEkIwlqKAIAJBNBKCMJaigCACQUQSwjCWooAgAkFUEwIwlqKAIAJBZBNCMJaigCACQXQTgjCWooAgAkGEE8IwlqKAIAJBkLCgAQBRAGEAcQCAsuAEH4yKq7fSMKahAYQdbunsZ+IwtqEBtB2+GBoQIjDGoQGkHunfeNfCMNahAZCy0AQa+f8Kt/Iw5qEBhBqoyfvAQjD2oQG0GTjMHBeiMQahAaQYGqmmojEWoQGQssAEHYsYLMBiMSahAYQa/vk9p4IxNqEBtBsbd9IxRqEBpBvq/zyngjFWoQGQstAEGiosDcBiMWahAYQZPj4WwjF2oQG0GOh+WzeiMYahAaQaGQ0M0EIxlqEBkLCgAQChALEAwQDQsuAEHiyviwfyMLahAcQcDmgoJ8IxBqEB9B0bT5sgIjFWoQHkGqj9vNfiMKahAdCy0AQd2gvLF9Iw9qEBxB06iQEiMUahAfQYHNh8V9IxlqEB5ByPfPvn4jDmoQHQsuAEHmm4ePAiMTahAcQdaP3Jl8IxhqEB9Bh5vUpn8jDWoQHkHtqeiqBCMSahAdCy0AQYXSj896IxdqEBxB+Me+ZyMMahAfQdmFvLsGIxFqEB5Bipmp6XgjFmoQHQsKABAPEBAQERASCysAQcLyaCMPahAgQYHtx7t4IxJqECNBosL17AYjFWoQIkGM8JRvIxhqECELLgBBxNT7pXojC2oQIEGpn/veBCMOahAjQeCW7bV/IxFqECJB8Pj+9XsjFGoQIQstAEHG/e3EAiMXahAgQfrPhNV+IwpqECNBheG8p30jDWoQIkGFuqAkIxBqECELLgBBuaDTzn0jE2oQIEHls+62fiMWahAjQfj5if0BIxlqECJB5ayxpXwjDGoQIQsKABAUEBUQFhAXCy0AQcTEpKF/IwpqECRBl/+rmQQjEWoQJ0Gnx9DceiMYahAmQbnAzmQjD2oQJQstAEHDs+2qBiMWahAkQZKZs/h4Iw1qECdB/ei/fyMUahAmQdG7kax4IwtqECULLQBBz/yh/QYjEmoQJEHgzbNxIxlqECdBlIaFmHojEGoQJkGho6DwBCMXahAlCy4AQYL9zbp/Iw5qECRBteTr6XsjFWoQJ0G7pd/WAiMMahAmQZGnm9x+IxNqECULKAEBf0F/IwFzIwNxIwEjAnFyIwBqIABqIgFBB3QgAUEZdnIjAWokAAsoAQF/QX8jAnMjAHEjAiMDcXIjAWogAGoiAUEWdCABQQp2ciMCaiQBCygBAX9BfyMDcyMBcSMDIwBxciMCaiAAaiIBQRF0IAFBD3ZyIwNqJAILKAEBf0F/IwBzIwJxIwAjAXFyIwNqIABqIgFBDHQgAUEUdnIjAGokAwsoAQF/IwJBfyMDc3EjASMDcXIjAGogAGoiAUEFdCABQRt2ciMBaiQACygBAX8jA0F/IwBzcSMCIwBxciMBaiAAaiIBQRR0IAFBDHZyIwJqJAELKAEBfyMAQX8jAXNxIwMjAXFyIwJqIABqIgFBDnQgAUESdnIjA2okAgsoAQF/IwFBfyMCc3EjACMCcXIjA2ogAGoiAUEJdCABQRd2ciMAaiQDCyIBAX8jASMCcyMDcyMAaiAAaiIBQQR0IAFBHHZyIwFqJAALIgEBfyMCIwNzIwBzIwFqIABqIgFBF3QgAUEJdnIjAmokAQsiAQF/IwMjAHMjAXMjAmogAGoiAUEQdCABQRB2ciMDaiQCCyIBAX8jACMBcyMCcyMDaiAAaiIBQQt0IAFBFXZyIwBqJAMLJQEBf0F/IwNzIwFyIwJzIwBqIABqIgFBBnQgAUEadnIjAWokAAslAQF/QX8jAHMjAnIjA3MjAWogAGoiAUEVdCABQQt2ciMCaiQBCyUBAX9BfyMBcyMDciMAcyMCaiAAaiIBQQ90IAFBEXZyIwNqJAILJQEBf0F/IwJzIwByIwFzIwNqIABqIgFBCnQgAUEWdnIjAGokAwsEACMACwQAIwELBAAjAgsEACMDCwQAIxoLBgAgACQACwYAIAAkAQsGACAAJAILBgAgACQDCwYAIAAkGgsA6gQEbmFtZQGSAzIAA2xvZwEFbG9vcHMCBGxvb3ADBXByaW1lBAVsb29wQQUGbG9vcEExBgZsb29wQTIHBmxvb3BBMwgGbG9vcEE0CQVsb29wQgoGbG9vcEIxCwZsb29wQjIMBmxvb3BCMw0GbG9vcEI0DgVsb29wQw8GbG9vcEMxEAZsb29wQzIRBmxvb3BDMxIGbG9vcEM0EwVsb29wRBQGbG9vcEQxFQZsb29wRDIWBmxvb3BEMxcGbG9vcEQ0GAhvbmVGdWxsQRkIb25lRnVsbEIaCG9uZUZ1bGxDGwhvbmVGdWxsRBwIdHdvRnVsbEEdCHR3b0Z1bGxCHgh0d29GdWxsQx8IdHdvRnVsbEQgCHRyZUZ1bGxBIQh0cmVGdWxsQiIIdHJlRnVsbEMjCHRyZUZ1bGxEJAhxdWFGdWxsQSUIcXVhRnVsbEImCHF1YUZ1bGxDJwhxdWFGdWxsRCgEZ2V0QSkEZ2V0QioEZ2V0QysEZ2V0RCwEZ2V0WC0Ec2V0QS4Ec2V0Qi8Ec2V0QzAEc2V0RDEEc2V0WALNATIAAQAAAQIAAAEIbnVtbG9vcHMCAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgCAAABAW4ZAgAAAQFuGgIAAAEBbhsCAAABAW4cAgAAAQFuHQIAAAEBbh4CAAABAW4fAgAAAQFuIAIAAAEBbiECAAABAW4iAgAAAQFuIwIAAAEBbiQCAAABAW4lAgAAAQFuJgIAAAEBbicCAAABAW4oACkAKgArACwALQEAAC4BAAAvAQAAMAEAADEBAAA=");
var wasm2 = WebAssembly && atb !== identity4 ? str2AB(wasmB64).buffer : false;
var crypt = makeCrypt();
var biteSize = 240 * 16 * 16;
var bounder = Math.floor(biteSize * 16 * 1.066666667);
var upperLimit = 268435456 - 65536;
if (!wasm2) {
  console.log("WebAssembly not available or WASM module could not be decoded; md5WASM will fall back to JavaScript");
}
function str2AB(str5) {
  var l, buff, buffView, i = -1;
  l = str5.length - 1;
  buff = new ArrayBuffer(str5.length);
  buffView = new Uint8Array(buff);
  while (l > i++) {
    buffView[i] = str5.charCodeAt(i);
  }
  return buffView;
}
function nodeATOB(str5) {
  return Buffer.from(str5, "base64").toString("binary");
}
function identity4(x) {
  return x;
}
function makeCrypt() {
  var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  return {
    rotl: function(n, b3) {
      return n << b3 | n >>> 32 - b3;
    },
    endian: function(n) {
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 16711935 | crypt.rotl(n, 24) & 4278255360;
      }
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b3 = 0; i < bytes.length; i++, b3 += 8)
        words[b3 >>> 5] |= bytes[i] << 24 - b3 % 32;
      return words;
    },
    wordsToBytes: function(words) {
      for (var bytes = [], b3 = 0; b3 < words.length * 32; b3 += 8)
        bytes.push(words[b3 >>> 5] >>> 24 - b3 % 32 & 255);
      return bytes;
    },
    bytesconvertNumberToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 15).toString(16));
      }
      return hex.join("");
    }
  };
}

// node_modules/@loaders.gl/compression/dist/lib/deflate-compression.js
var import_pako = __toESM(require_pako(), 1);
var import_zlib = __toESM(require_zlib(), 1);

// node_modules/@loaders.gl/compression/dist/brotli/decode.js
var makeBrotliDecode = () => {
  function InputStream(bytes) {
    this.data = bytes;
    this.offset = 0;
  }
  let MAX_HUFFMAN_TABLE_SIZE = Int32Array.from([
    256,
    402,
    436,
    468,
    500,
    534,
    566,
    598,
    630,
    662,
    694,
    726,
    758,
    790,
    822,
    854,
    886,
    920,
    952,
    984,
    1016,
    1048,
    1080
  ]);
  let CODE_LENGTH_CODE_ORDER = Int32Array.from([
    1,
    2,
    3,
    4,
    0,
    5,
    17,
    6,
    16,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15
  ]);
  let DISTANCE_SHORT_CODE_INDEX_OFFSET = Int32Array.from([
    0,
    3,
    2,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    3,
    3,
    3,
    3,
    3
  ]);
  let DISTANCE_SHORT_CODE_VALUE_OFFSET = Int32Array.from([
    0,
    0,
    0,
    0,
    -1,
    1,
    -2,
    2,
    -3,
    3,
    -1,
    1,
    -2,
    2,
    -3,
    3
  ]);
  let FIXED_TABLE = Int32Array.from([
    131072,
    131076,
    131075,
    196610,
    131072,
    131076,
    131075,
    262145,
    131072,
    131076,
    131075,
    196610,
    131072,
    131076,
    131075,
    262149
  ]);
  let BLOCK_LENGTH_OFFSET = Int32Array.from([
    1,
    5,
    9,
    13,
    17,
    25,
    33,
    41,
    49,
    65,
    81,
    97,
    113,
    145,
    177,
    209,
    241,
    305,
    369,
    497,
    753,
    1265,
    2289,
    4337,
    8433,
    16625
  ]);
  let BLOCK_LENGTH_N_BITS = Int32Array.from([
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    6,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    24
  ]);
  let INSERT_LENGTH_N_BITS = Int16Array.from([
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    7,
    8,
    9,
    10,
    12,
    14,
    24
  ]);
  let COPY_LENGTH_N_BITS = Int16Array.from([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    7,
    8,
    9,
    10,
    24
  ]);
  let CMD_LOOKUP = new Int16Array(2816);
  {
    unpackCommandLookupTable(CMD_LOOKUP);
  }
  function log2floor(i) {
    let result = -1;
    let step = 16;
    while (step > 0) {
      if (i >>> step != 0) {
        result += step;
        i = i >>> step;
      }
      step = step >> 1;
    }
    return result + i;
  }
  function calculateDistanceAlphabetSize(npostfix, ndirect, maxndistbits) {
    return 16 + ndirect + 2 * (maxndistbits << npostfix);
  }
  function calculateDistanceAlphabetLimit(maxDistance, npostfix, ndirect) {
    if (maxDistance < ndirect + (2 << npostfix)) {
      throw "maxDistance is too small";
    }
    let offset = (maxDistance - ndirect >> npostfix) + 4;
    let ndistbits = log2floor(offset) - 1;
    let group = ndistbits - 1 << 1 | offset >> ndistbits & 1;
    return (group - 1 << npostfix) + (1 << npostfix) + ndirect + 16;
  }
  function unpackCommandLookupTable(cmdLookup) {
    let insertLengthOffsets = new Int16Array(24);
    let copyLengthOffsets = new Int16Array(24);
    copyLengthOffsets[0] = 2;
    for (let i = 0; i < 23; ++i) {
      insertLengthOffsets[i + 1] = insertLengthOffsets[i] + (1 << INSERT_LENGTH_N_BITS[i]);
      copyLengthOffsets[i + 1] = copyLengthOffsets[i] + (1 << COPY_LENGTH_N_BITS[i]);
    }
    for (let cmdCode = 0; cmdCode < 704; ++cmdCode) {
      let rangeIdx = cmdCode >>> 6;
      let distanceContextOffset = -4;
      if (rangeIdx >= 2) {
        rangeIdx -= 2;
        distanceContextOffset = 0;
      }
      let insertCode = (170064 >>> rangeIdx * 2 & 3) << 3 | cmdCode >>> 3 & 7;
      let copyCode = (156228 >>> rangeIdx * 2 & 3) << 3 | cmdCode & 7;
      let copyLengthOffset = copyLengthOffsets[copyCode];
      let distanceContext = distanceContextOffset + (copyLengthOffset > 4 ? 3 : copyLengthOffset - 2);
      let index = cmdCode * 4;
      cmdLookup[index + 0] = INSERT_LENGTH_N_BITS[insertCode] | COPY_LENGTH_N_BITS[copyCode] << 8;
      cmdLookup[index + 1] = insertLengthOffsets[insertCode];
      cmdLookup[index + 2] = copyLengthOffsets[copyCode];
      cmdLookup[index + 3] = distanceContext;
    }
  }
  function decodeWindowBits(s) {
    let largeWindowEnabled = s.isLargeWindow;
    s.isLargeWindow = 0;
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    if (readFewBits(s, 1) == 0) {
      return 16;
    }
    let n = readFewBits(s, 3);
    if (n != 0) {
      return 17 + n;
    }
    n = readFewBits(s, 3);
    if (n != 0) {
      if (n == 1) {
        if (largeWindowEnabled == 0) {
          return -1;
        }
        s.isLargeWindow = 1;
        if (readFewBits(s, 1) == 1) {
          return -1;
        }
        n = readFewBits(s, 6);
        if (n < 10 || n > 30) {
          return -1;
        }
        return n;
      } else {
        return 8 + n;
      }
    }
    return 17;
  }
  function enableEagerOutput(s) {
    if (s.runningState != 1) {
      throw "State MUST be freshly initialized";
    }
    s.isEager = 1;
  }
  function enableLargeWindow(s) {
    if (s.runningState != 1) {
      throw "State MUST be freshly initialized";
    }
    s.isLargeWindow = 1;
  }
  function attachDictionaryChunk(s, data2) {
    if (s.runningState != 1) {
      throw "State MUST be freshly initialized";
    }
    if (s.cdNumChunks == 0) {
      s.cdChunks = new Array(16);
      s.cdChunkOffsets = new Int32Array(16);
      s.cdBlockBits = -1;
    }
    if (s.cdNumChunks == 15) {
      throw "Too many dictionary chunks";
    }
    s.cdChunks[s.cdNumChunks] = data2;
    s.cdNumChunks++;
    s.cdTotalSize += data2.length;
    s.cdChunkOffsets[s.cdNumChunks] = s.cdTotalSize;
  }
  function initState(s, input) {
    if (s.runningState != 0) {
      throw "State MUST be uninitialized";
    }
    s.blockTrees = new Int32Array(3091);
    s.blockTrees[0] = 7;
    s.distRbIdx = 3;
    let maxDistanceAlphabetLimit = calculateDistanceAlphabetLimit(2147483644, 3, 15 << 3);
    s.distExtraBits = new Int8Array(maxDistanceAlphabetLimit);
    s.distOffset = new Int32Array(maxDistanceAlphabetLimit);
    s.input = input;
    initBitReader(s);
    s.runningState = 1;
  }
  function close(s) {
    if (s.runningState == 0) {
      throw "State MUST be initialized";
    }
    if (s.runningState == 11) {
      return;
    }
    s.runningState = 11;
    if (s.input != null) {
      closeInput(s.input);
      s.input = null;
    }
  }
  function decodeVarLenUnsignedByte(s) {
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    if (readFewBits(s, 1) != 0) {
      let n = readFewBits(s, 3);
      if (n == 0) {
        return 1;
      } else {
        return readFewBits(s, n) + (1 << n);
      }
    }
    return 0;
  }
  function decodeMetaBlockLength(s) {
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    s.inputEnd = readFewBits(s, 1);
    s.metaBlockLength = 0;
    s.isUncompressed = 0;
    s.isMetadata = 0;
    if (s.inputEnd != 0 && readFewBits(s, 1) != 0) {
      return;
    }
    let sizeNibbles = readFewBits(s, 2) + 4;
    if (sizeNibbles == 7) {
      s.isMetadata = 1;
      if (readFewBits(s, 1) != 0) {
        throw "Corrupted reserved bit";
      }
      let sizeBytes = readFewBits(s, 2);
      if (sizeBytes == 0) {
        return;
      }
      for (let i = 0; i < sizeBytes; i++) {
        if (s.bitOffset >= 16) {
          s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
          s.bitOffset -= 16;
        }
        let bits = readFewBits(s, 8);
        if (bits == 0 && i + 1 == sizeBytes && sizeBytes > 1) {
          throw "Exuberant nibble";
        }
        s.metaBlockLength |= bits << i * 8;
      }
    } else {
      for (let i = 0; i < sizeNibbles; i++) {
        if (s.bitOffset >= 16) {
          s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
          s.bitOffset -= 16;
        }
        let bits = readFewBits(s, 4);
        if (bits == 0 && i + 1 == sizeNibbles && sizeNibbles > 4) {
          throw "Exuberant nibble";
        }
        s.metaBlockLength |= bits << i * 4;
      }
    }
    s.metaBlockLength++;
    if (s.inputEnd == 0) {
      s.isUncompressed = readFewBits(s, 1);
    }
  }
  function readSymbol(tableGroup, tableIdx, s) {
    let offset = tableGroup[tableIdx];
    let val = s.accumulator32 >>> s.bitOffset;
    offset += val & 255;
    let bits = tableGroup[offset] >> 16;
    let sym = tableGroup[offset] & 65535;
    if (bits <= 8) {
      s.bitOffset += bits;
      return sym;
    }
    offset += sym;
    let mask = (1 << bits) - 1;
    offset += (val & mask) >>> 8;
    s.bitOffset += (tableGroup[offset] >> 16) + 8;
    return tableGroup[offset] & 65535;
  }
  function readBlockLength(tableGroup, tableIdx, s) {
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    let code = readSymbol(tableGroup, tableIdx, s);
    let n = BLOCK_LENGTH_N_BITS[code];
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    return BLOCK_LENGTH_OFFSET[code] + (n <= 16 ? readFewBits(s, n) : readManyBits(s, n));
  }
  function moveToFront(v2, index) {
    let value = v2[index];
    for (; index > 0; index--) {
      v2[index] = v2[index - 1];
    }
    v2[0] = value;
  }
  function inverseMoveToFrontTransform(v2, vLen) {
    let mtf = new Int32Array(256);
    for (let i = 0; i < 256; i++) {
      mtf[i] = i;
    }
    for (let i = 0; i < vLen; i++) {
      let index = v2[i] & 255;
      v2[i] = mtf[index];
      if (index != 0) {
        moveToFront(mtf, index);
      }
    }
  }
  function readHuffmanCodeLengths(codeLengthCodeLengths, numSymbols, codeLengths, s) {
    let symbol = 0;
    let prevCodeLen = 8;
    let repeat = 0;
    let repeatCodeLen = 0;
    let space = 32768;
    let table = new Int32Array(32 + 1);
    let tableIdx = table.length - 1;
    buildHuffmanTable(table, tableIdx, 5, codeLengthCodeLengths, 18);
    while (symbol < numSymbols && space > 0) {
      if (s.halfOffset > 2030) {
        doReadMoreInput(s);
      }
      if (s.bitOffset >= 16) {
        s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
        s.bitOffset -= 16;
      }
      let p = s.accumulator32 >>> s.bitOffset & 31;
      s.bitOffset += table[p] >> 16;
      let codeLen = table[p] & 65535;
      if (codeLen < 16) {
        repeat = 0;
        codeLengths[symbol++] = codeLen;
        if (codeLen != 0) {
          prevCodeLen = codeLen;
          space -= 32768 >> codeLen;
        }
      } else {
        let extraBits = codeLen - 14;
        let newLen = 0;
        if (codeLen == 16) {
          newLen = prevCodeLen;
        }
        if (repeatCodeLen != newLen) {
          repeat = 0;
          repeatCodeLen = newLen;
        }
        let oldRepeat = repeat;
        if (repeat > 0) {
          repeat -= 2;
          repeat <<= extraBits;
        }
        if (s.bitOffset >= 16) {
          s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
          s.bitOffset -= 16;
        }
        repeat += readFewBits(s, extraBits) + 3;
        let repeatDelta = repeat - oldRepeat;
        if (symbol + repeatDelta > numSymbols) {
          throw "symbol + repeatDelta > numSymbols";
        }
        for (let i = 0; i < repeatDelta; i++) {
          codeLengths[symbol++] = repeatCodeLen;
        }
        if (repeatCodeLen != 0) {
          space -= repeatDelta << 15 - repeatCodeLen;
        }
      }
    }
    if (space != 0) {
      throw "Unused space";
    }
    codeLengths.fill(0, symbol, numSymbols);
  }
  function checkDupes(symbols, length5) {
    for (let i = 0; i < length5 - 1; ++i) {
      for (let j = i + 1; j < length5; ++j) {
        if (symbols[i] == symbols[j]) {
          throw "Duplicate simple Huffman code symbol";
        }
      }
    }
  }
  function readSimpleHuffmanCode(alphabetSizeMax, alphabetSizeLimit, tableGroup, tableIdx, s) {
    let codeLengths = new Int32Array(alphabetSizeLimit);
    let symbols = new Int32Array(4);
    let maxBits = 1 + log2floor(alphabetSizeMax - 1);
    let numSymbols = readFewBits(s, 2) + 1;
    for (let i = 0; i < numSymbols; i++) {
      if (s.bitOffset >= 16) {
        s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
        s.bitOffset -= 16;
      }
      let symbol = readFewBits(s, maxBits);
      if (symbol >= alphabetSizeLimit) {
        throw "Can't readHuffmanCode";
      }
      symbols[i] = symbol;
    }
    checkDupes(symbols, numSymbols);
    let histogramId = numSymbols;
    if (numSymbols == 4) {
      histogramId += readFewBits(s, 1);
    }
    switch (histogramId) {
      case 1:
        codeLengths[symbols[0]] = 1;
        break;
      case 2:
        codeLengths[symbols[0]] = 1;
        codeLengths[symbols[1]] = 1;
        break;
      case 3:
        codeLengths[symbols[0]] = 1;
        codeLengths[symbols[1]] = 2;
        codeLengths[symbols[2]] = 2;
        break;
      case 4:
        codeLengths[symbols[0]] = 2;
        codeLengths[symbols[1]] = 2;
        codeLengths[symbols[2]] = 2;
        codeLengths[symbols[3]] = 2;
        break;
      case 5:
        codeLengths[symbols[0]] = 1;
        codeLengths[symbols[1]] = 2;
        codeLengths[symbols[2]] = 3;
        codeLengths[symbols[3]] = 3;
        break;
      default:
        break;
    }
    return buildHuffmanTable(tableGroup, tableIdx, 8, codeLengths, alphabetSizeLimit);
  }
  function readComplexHuffmanCode(alphabetSizeLimit, skip, tableGroup, tableIdx, s) {
    let codeLengths = new Int32Array(alphabetSizeLimit);
    let codeLengthCodeLengths = new Int32Array(18);
    let space = 32;
    let numCodes = 0;
    for (let i = skip; i < 18 && space > 0; i++) {
      let codeLenIdx = CODE_LENGTH_CODE_ORDER[i];
      if (s.bitOffset >= 16) {
        s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
        s.bitOffset -= 16;
      }
      let p = s.accumulator32 >>> s.bitOffset & 15;
      s.bitOffset += FIXED_TABLE[p] >> 16;
      let v2 = FIXED_TABLE[p] & 65535;
      codeLengthCodeLengths[codeLenIdx] = v2;
      if (v2 != 0) {
        space -= 32 >> v2;
        numCodes++;
      }
    }
    if (space != 0 && numCodes != 1) {
      throw "Corrupted Huffman code histogram";
    }
    readHuffmanCodeLengths(codeLengthCodeLengths, alphabetSizeLimit, codeLengths, s);
    return buildHuffmanTable(tableGroup, tableIdx, 8, codeLengths, alphabetSizeLimit);
  }
  function readHuffmanCode(alphabetSizeMax, alphabetSizeLimit, tableGroup, tableIdx, s) {
    if (s.halfOffset > 2030) {
      doReadMoreInput(s);
    }
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    let simpleCodeOrSkip = readFewBits(s, 2);
    if (simpleCodeOrSkip == 1) {
      return readSimpleHuffmanCode(alphabetSizeMax, alphabetSizeLimit, tableGroup, tableIdx, s);
    } else {
      return readComplexHuffmanCode(alphabetSizeLimit, simpleCodeOrSkip, tableGroup, tableIdx, s);
    }
  }
  function decodeContextMap(contextMapSize, contextMap, s) {
    if (s.halfOffset > 2030) {
      doReadMoreInput(s);
    }
    let numTrees = decodeVarLenUnsignedByte(s) + 1;
    if (numTrees == 1) {
      contextMap.fill(0, 0, contextMapSize);
      return numTrees;
    }
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    let useRleForZeros = readFewBits(s, 1);
    let maxRunLengthPrefix = 0;
    if (useRleForZeros != 0) {
      maxRunLengthPrefix = readFewBits(s, 4) + 1;
    }
    let alphabetSize = numTrees + maxRunLengthPrefix;
    let tableSize = MAX_HUFFMAN_TABLE_SIZE[alphabetSize + 31 >> 5];
    let table = new Int32Array(tableSize + 1);
    let tableIdx = table.length - 1;
    readHuffmanCode(alphabetSize, alphabetSize, table, tableIdx, s);
    for (let i = 0; i < contextMapSize; ) {
      if (s.halfOffset > 2030) {
        doReadMoreInput(s);
      }
      if (s.bitOffset >= 16) {
        s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
        s.bitOffset -= 16;
      }
      let code = readSymbol(table, tableIdx, s);
      if (code == 0) {
        contextMap[i] = 0;
        i++;
      } else if (code <= maxRunLengthPrefix) {
        if (s.bitOffset >= 16) {
          s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
          s.bitOffset -= 16;
        }
        let reps = (1 << code) + readFewBits(s, code);
        while (reps != 0) {
          if (i >= contextMapSize) {
            throw "Corrupted context map";
          }
          contextMap[i] = 0;
          i++;
          reps--;
        }
      } else {
        contextMap[i] = code - maxRunLengthPrefix;
        i++;
      }
    }
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    if (readFewBits(s, 1) == 1) {
      inverseMoveToFrontTransform(contextMap, contextMapSize);
    }
    return numTrees;
  }
  function decodeBlockTypeAndLength(s, treeType, numBlockTypes) {
    let ringBuffers = s.rings;
    let offset = 4 + treeType * 2;
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    let blockType = readSymbol(s.blockTrees, 2 * treeType, s);
    let result = readBlockLength(s.blockTrees, 2 * treeType + 1, s);
    if (blockType == 1) {
      blockType = ringBuffers[offset + 1] + 1;
    } else if (blockType == 0) {
      blockType = ringBuffers[offset];
    } else {
      blockType -= 2;
    }
    if (blockType >= numBlockTypes) {
      blockType -= numBlockTypes;
    }
    ringBuffers[offset] = ringBuffers[offset + 1];
    ringBuffers[offset + 1] = blockType;
    return result;
  }
  function decodeLiteralBlockSwitch(s) {
    s.literalBlockLength = decodeBlockTypeAndLength(s, 0, s.numLiteralBlockTypes);
    let literalBlockType = s.rings[5];
    s.contextMapSlice = literalBlockType << 6;
    s.literalTreeIdx = s.contextMap[s.contextMapSlice] & 255;
    let contextMode = s.contextModes[literalBlockType];
    s.contextLookupOffset1 = contextMode << 9;
    s.contextLookupOffset2 = s.contextLookupOffset1 + 256;
  }
  function decodeCommandBlockSwitch(s) {
    s.commandBlockLength = decodeBlockTypeAndLength(s, 1, s.numCommandBlockTypes);
    s.commandTreeIdx = s.rings[7];
  }
  function decodeDistanceBlockSwitch(s) {
    s.distanceBlockLength = decodeBlockTypeAndLength(s, 2, s.numDistanceBlockTypes);
    s.distContextMapSlice = s.rings[9] << 2;
  }
  function maybeReallocateRingBuffer(s) {
    let newSize = s.maxRingBufferSize;
    if (newSize > s.expectedTotalSize) {
      let minimalNewSize = s.expectedTotalSize;
      while (newSize >> 1 > minimalNewSize) {
        newSize >>= 1;
      }
      if (s.inputEnd == 0 && newSize < 16384 && s.maxRingBufferSize >= 16384) {
        newSize = 16384;
      }
    }
    if (newSize <= s.ringBufferSize) {
      return;
    }
    let ringBufferSizeWithSlack = newSize + 37;
    let newBuffer = new Int8Array(ringBufferSizeWithSlack);
    if (s.ringBuffer.length != 0) {
      newBuffer.set(s.ringBuffer.subarray(0, 0 + s.ringBufferSize), 0);
    }
    s.ringBuffer = newBuffer;
    s.ringBufferSize = newSize;
  }
  function readNextMetablockHeader(s) {
    if (s.inputEnd != 0) {
      s.nextRunningState = 10;
      s.runningState = 12;
      return;
    }
    s.literalTreeGroup = new Int32Array(0);
    s.commandTreeGroup = new Int32Array(0);
    s.distanceTreeGroup = new Int32Array(0);
    if (s.halfOffset > 2030) {
      doReadMoreInput(s);
    }
    decodeMetaBlockLength(s);
    if (s.metaBlockLength == 0 && s.isMetadata == 0) {
      return;
    }
    if (s.isUncompressed != 0 || s.isMetadata != 0) {
      jumpToByteBoundary(s);
      s.runningState = s.isMetadata != 0 ? 5 : 6;
    } else {
      s.runningState = 3;
    }
    if (s.isMetadata != 0) {
      return;
    }
    s.expectedTotalSize += s.metaBlockLength;
    if (s.expectedTotalSize > 1 << 30) {
      s.expectedTotalSize = 1 << 30;
    }
    if (s.ringBufferSize < s.maxRingBufferSize) {
      maybeReallocateRingBuffer(s);
    }
  }
  function readMetablockPartition(s, treeType, numBlockTypes) {
    let offset = s.blockTrees[2 * treeType];
    if (numBlockTypes <= 1) {
      s.blockTrees[2 * treeType + 1] = offset;
      s.blockTrees[2 * treeType + 2] = offset;
      return 1 << 28;
    }
    let blockTypeAlphabetSize = numBlockTypes + 2;
    offset += readHuffmanCode(blockTypeAlphabetSize, blockTypeAlphabetSize, s.blockTrees, 2 * treeType, s);
    s.blockTrees[2 * treeType + 1] = offset;
    let blockLengthAlphabetSize = 26;
    offset += readHuffmanCode(blockLengthAlphabetSize, blockLengthAlphabetSize, s.blockTrees, 2 * treeType + 1, s);
    s.blockTrees[2 * treeType + 2] = offset;
    return readBlockLength(s.blockTrees, 2 * treeType + 1, s);
  }
  function calculateDistanceLut(s, alphabetSizeLimit) {
    let distExtraBits = s.distExtraBits;
    let distOffset = s.distOffset;
    let npostfix = s.distancePostfixBits;
    let ndirect = s.numDirectDistanceCodes;
    let postfix = 1 << npostfix;
    let bits = 1;
    let half = 0;
    let i = 16;
    for (let j = 0; j < ndirect; ++j) {
      distExtraBits[i] = 0;
      distOffset[i] = j + 1;
      ++i;
    }
    while (i < alphabetSizeLimit) {
      let base = ndirect + ((2 + half << bits) - 4 << npostfix) + 1;
      for (let j = 0; j < postfix; ++j) {
        distExtraBits[i] = bits;
        distOffset[i] = base + j;
        ++i;
      }
      bits = bits + half;
      half = half ^ 1;
    }
  }
  function readMetablockHuffmanCodesAndContextMaps(s) {
    s.numLiteralBlockTypes = decodeVarLenUnsignedByte(s) + 1;
    s.literalBlockLength = readMetablockPartition(s, 0, s.numLiteralBlockTypes);
    s.numCommandBlockTypes = decodeVarLenUnsignedByte(s) + 1;
    s.commandBlockLength = readMetablockPartition(s, 1, s.numCommandBlockTypes);
    s.numDistanceBlockTypes = decodeVarLenUnsignedByte(s) + 1;
    s.distanceBlockLength = readMetablockPartition(s, 2, s.numDistanceBlockTypes);
    if (s.halfOffset > 2030) {
      doReadMoreInput(s);
    }
    if (s.bitOffset >= 16) {
      s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
      s.bitOffset -= 16;
    }
    s.distancePostfixBits = readFewBits(s, 2);
    s.numDirectDistanceCodes = readFewBits(s, 4) << s.distancePostfixBits;
    s.contextModes = new Int8Array(s.numLiteralBlockTypes);
    for (let i = 0; i < s.numLiteralBlockTypes; ) {
      let limit = min3(i + 96, s.numLiteralBlockTypes);
      for (; i < limit; ++i) {
        if (s.bitOffset >= 16) {
          s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
          s.bitOffset -= 16;
        }
        s.contextModes[i] = readFewBits(s, 2);
      }
      if (s.halfOffset > 2030) {
        doReadMoreInput(s);
      }
    }
    s.contextMap = new Int8Array(s.numLiteralBlockTypes << 6);
    let numLiteralTrees = decodeContextMap(s.numLiteralBlockTypes << 6, s.contextMap, s);
    s.trivialLiteralContext = 1;
    for (let j = 0; j < s.numLiteralBlockTypes << 6; j++) {
      if (s.contextMap[j] != j >> 6) {
        s.trivialLiteralContext = 0;
        break;
      }
    }
    s.distContextMap = new Int8Array(s.numDistanceBlockTypes << 2);
    let numDistTrees = decodeContextMap(s.numDistanceBlockTypes << 2, s.distContextMap, s);
    s.literalTreeGroup = decodeHuffmanTreeGroup(256, 256, numLiteralTrees, s);
    s.commandTreeGroup = decodeHuffmanTreeGroup(704, 704, s.numCommandBlockTypes, s);
    let distanceAlphabetSizeMax = calculateDistanceAlphabetSize(s.distancePostfixBits, s.numDirectDistanceCodes, 24);
    let distanceAlphabetSizeLimit = distanceAlphabetSizeMax;
    if (s.isLargeWindow == 1) {
      distanceAlphabetSizeMax = calculateDistanceAlphabetSize(s.distancePostfixBits, s.numDirectDistanceCodes, 62);
      distanceAlphabetSizeLimit = calculateDistanceAlphabetLimit(2147483644, s.distancePostfixBits, s.numDirectDistanceCodes);
    }
    s.distanceTreeGroup = decodeHuffmanTreeGroup(distanceAlphabetSizeMax, distanceAlphabetSizeLimit, numDistTrees, s);
    calculateDistanceLut(s, distanceAlphabetSizeLimit);
    s.contextMapSlice = 0;
    s.distContextMapSlice = 0;
    s.contextLookupOffset1 = s.contextModes[0] * 512;
    s.contextLookupOffset2 = s.contextLookupOffset1 + 256;
    s.literalTreeIdx = 0;
    s.commandTreeIdx = 0;
    s.rings[4] = 1;
    s.rings[5] = 0;
    s.rings[6] = 1;
    s.rings[7] = 0;
    s.rings[8] = 1;
    s.rings[9] = 0;
  }
  function copyUncompressedData(s) {
    let ringBuffer = s.ringBuffer;
    if (s.metaBlockLength <= 0) {
      reload(s);
      s.runningState = 2;
      return;
    }
    let chunkLength = min3(s.ringBufferSize - s.pos, s.metaBlockLength);
    copyRawBytes(s, ringBuffer, s.pos, chunkLength);
    s.metaBlockLength -= chunkLength;
    s.pos += chunkLength;
    if (s.pos == s.ringBufferSize) {
      s.nextRunningState = 6;
      s.runningState = 12;
      return;
    }
    reload(s);
    s.runningState = 2;
  }
  function writeRingBuffer(s) {
    let toWrite = min3(s.outputLength - s.outputUsed, s.ringBufferBytesReady - s.ringBufferBytesWritten);
    if (toWrite != 0) {
      s.output.set(s.ringBuffer.subarray(s.ringBufferBytesWritten, s.ringBufferBytesWritten + toWrite), s.outputOffset + s.outputUsed);
      s.outputUsed += toWrite;
      s.ringBufferBytesWritten += toWrite;
    }
    if (s.outputUsed < s.outputLength) {
      return 1;
    } else {
      return 0;
    }
  }
  function decodeHuffmanTreeGroup(alphabetSizeMax, alphabetSizeLimit, n, s) {
    let maxTableSize = MAX_HUFFMAN_TABLE_SIZE[alphabetSizeLimit + 31 >> 5];
    let group = new Int32Array(n + n * maxTableSize);
    let next = n;
    for (let i = 0; i < n; ++i) {
      group[i] = next;
      next += readHuffmanCode(alphabetSizeMax, alphabetSizeLimit, group, i, s);
    }
    return group;
  }
  function calculateFence(s) {
    let result = s.ringBufferSize;
    if (s.isEager != 0) {
      result = min3(result, s.ringBufferBytesWritten + s.outputLength - s.outputUsed);
    }
    return result;
  }
  function doUseDictionary(s, fence) {
    if (s.distance > 2147483644) {
      throw "Invalid backward reference";
    }
    let address = s.distance - s.maxDistance - 1 - s.cdTotalSize;
    if (address < 0) {
      initializeCompoundDictionaryCopy(s, -address - 1, s.copyLength);
      s.runningState = 14;
    } else {
      let dictionaryData = (
        /** @type{!Int8Array} */
        data
      );
      let wordLength = s.copyLength;
      if (wordLength > 31) {
        throw "Invalid backward reference";
      }
      let shift = sizeBits[wordLength];
      if (shift == 0) {
        throw "Invalid backward reference";
      }
      let offset = offsets[wordLength];
      let mask = (1 << shift) - 1;
      let wordIdx = address & mask;
      let transformIdx = address >>> shift;
      offset += wordIdx * wordLength;
      let transforms = RFC_TRANSFORMS;
      if (transformIdx >= transforms.numTransforms) {
        throw "Invalid backward reference";
      }
      let len4 = transformDictionaryWord(s.ringBuffer, s.pos, dictionaryData, offset, wordLength, transforms, transformIdx);
      s.pos += len4;
      s.metaBlockLength -= len4;
      if (s.pos >= fence) {
        s.nextRunningState = 4;
        s.runningState = 12;
        return;
      }
      s.runningState = 4;
    }
  }
  function initializeCompoundDictionary(s) {
    s.cdBlockMap = new Int8Array(256);
    let blockBits = 8;
    while (s.cdTotalSize - 1 >>> blockBits != 0) {
      blockBits++;
    }
    blockBits -= 8;
    s.cdBlockBits = blockBits;
    let cursor = 0;
    let index = 0;
    while (cursor < s.cdTotalSize) {
      while (s.cdChunkOffsets[index + 1] < cursor) {
        index++;
      }
      s.cdBlockMap[cursor >>> blockBits] = index;
      cursor += 1 << blockBits;
    }
  }
  function initializeCompoundDictionaryCopy(s, address, length5) {
    if (s.cdBlockBits == -1) {
      initializeCompoundDictionary(s);
    }
    let index = s.cdBlockMap[address >>> s.cdBlockBits];
    while (address >= s.cdChunkOffsets[index + 1]) {
      index++;
    }
    if (s.cdTotalSize > address + length5) {
      throw "Invalid backward reference";
    }
    s.distRbIdx = s.distRbIdx + 1 & 3;
    s.rings[s.distRbIdx] = s.distance;
    s.metaBlockLength -= length5;
    s.cdBrIndex = index;
    s.cdBrOffset = address - s.cdChunkOffsets[index];
    s.cdBrLength = length5;
    s.cdBrCopied = 0;
  }
  function copyFromCompoundDictionary(s, fence) {
    let pos = s.pos;
    let origPos = pos;
    while (s.cdBrLength != s.cdBrCopied) {
      let space = fence - pos;
      let chunkLength = s.cdChunkOffsets[s.cdBrIndex + 1] - s.cdChunkOffsets[s.cdBrIndex];
      let remChunkLength = chunkLength - s.cdBrOffset;
      let length5 = s.cdBrLength - s.cdBrCopied;
      if (length5 > remChunkLength) {
        length5 = remChunkLength;
      }
      if (length5 > space) {
        length5 = space;
      }
      copyBytes(s.ringBuffer, pos, s.cdChunks[s.cdBrIndex], s.cdBrOffset, s.cdBrOffset + length5);
      pos += length5;
      s.cdBrOffset += length5;
      s.cdBrCopied += length5;
      if (length5 == remChunkLength) {
        s.cdBrIndex++;
        s.cdBrOffset = 0;
      }
      if (pos >= fence) {
        break;
      }
    }
    return pos - origPos;
  }
  function decompress(s) {
    if (s.runningState == 0) {
      throw "Can't decompress until initialized";
    }
    if (s.runningState == 11) {
      throw "Can't decompress after close";
    }
    if (s.runningState == 1) {
      let windowBits = decodeWindowBits(s);
      if (windowBits == -1) {
        throw "Invalid 'windowBits' code";
      }
      s.maxRingBufferSize = 1 << windowBits;
      s.maxBackwardDistance = s.maxRingBufferSize - 16;
      s.runningState = 2;
    }
    let fence = calculateFence(s);
    let ringBufferMask = s.ringBufferSize - 1;
    let ringBuffer = s.ringBuffer;
    while (s.runningState != 10) {
      switch (s.runningState) {
        case 2:
          if (s.metaBlockLength < 0) {
            throw "Invalid metablock length";
          }
          readNextMetablockHeader(s);
          fence = calculateFence(s);
          ringBufferMask = s.ringBufferSize - 1;
          ringBuffer = s.ringBuffer;
          continue;
        case 3:
          readMetablockHuffmanCodesAndContextMaps(s);
          s.runningState = 4;
        case 4:
          if (s.metaBlockLength <= 0) {
            s.runningState = 2;
            continue;
          }
          if (s.halfOffset > 2030) {
            doReadMoreInput(s);
          }
          if (s.commandBlockLength == 0) {
            decodeCommandBlockSwitch(s);
          }
          s.commandBlockLength--;
          if (s.bitOffset >= 16) {
            s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
            s.bitOffset -= 16;
          }
          let cmdCode = readSymbol(s.commandTreeGroup, s.commandTreeIdx, s) << 2;
          let insertAndCopyExtraBits = CMD_LOOKUP[cmdCode];
          let insertLengthOffset = CMD_LOOKUP[cmdCode + 1];
          let copyLengthOffset = CMD_LOOKUP[cmdCode + 2];
          s.distanceCode = CMD_LOOKUP[cmdCode + 3];
          if (s.bitOffset >= 16) {
            s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
            s.bitOffset -= 16;
          }
          let insertLengthExtraBits = insertAndCopyExtraBits & 255;
          s.insertLength = insertLengthOffset + (insertLengthExtraBits <= 16 ? readFewBits(s, insertLengthExtraBits) : readManyBits(s, insertLengthExtraBits));
          if (s.bitOffset >= 16) {
            s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
            s.bitOffset -= 16;
          }
          let copyLengthExtraBits = insertAndCopyExtraBits >> 8;
          s.copyLength = copyLengthOffset + (copyLengthExtraBits <= 16 ? readFewBits(s, copyLengthExtraBits) : readManyBits(s, copyLengthExtraBits));
          s.j = 0;
          s.runningState = 7;
        case 7:
          if (s.trivialLiteralContext != 0) {
            while (s.j < s.insertLength) {
              if (s.halfOffset > 2030) {
                doReadMoreInput(s);
              }
              if (s.literalBlockLength == 0) {
                decodeLiteralBlockSwitch(s);
              }
              s.literalBlockLength--;
              if (s.bitOffset >= 16) {
                s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
                s.bitOffset -= 16;
              }
              ringBuffer[s.pos] = readSymbol(s.literalTreeGroup, s.literalTreeIdx, s);
              s.pos++;
              s.j++;
              if (s.pos >= fence) {
                s.nextRunningState = 7;
                s.runningState = 12;
                break;
              }
            }
          } else {
            let prevByte1 = ringBuffer[s.pos - 1 & ringBufferMask] & 255;
            let prevByte2 = ringBuffer[s.pos - 2 & ringBufferMask] & 255;
            while (s.j < s.insertLength) {
              if (s.halfOffset > 2030) {
                doReadMoreInput(s);
              }
              if (s.literalBlockLength == 0) {
                decodeLiteralBlockSwitch(s);
              }
              let literalContext = LOOKUP[s.contextLookupOffset1 + prevByte1] | LOOKUP[s.contextLookupOffset2 + prevByte2];
              let literalTreeIdx = s.contextMap[s.contextMapSlice + literalContext] & 255;
              s.literalBlockLength--;
              prevByte2 = prevByte1;
              if (s.bitOffset >= 16) {
                s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
                s.bitOffset -= 16;
              }
              prevByte1 = readSymbol(s.literalTreeGroup, literalTreeIdx, s);
              ringBuffer[s.pos] = prevByte1;
              s.pos++;
              s.j++;
              if (s.pos >= fence) {
                s.nextRunningState = 7;
                s.runningState = 12;
                break;
              }
            }
          }
          if (s.runningState != 7) {
            continue;
          }
          s.metaBlockLength -= s.insertLength;
          if (s.metaBlockLength <= 0) {
            s.runningState = 4;
            continue;
          }
          let distanceCode = s.distanceCode;
          if (distanceCode < 0) {
            s.distance = s.rings[s.distRbIdx];
          } else {
            if (s.halfOffset > 2030) {
              doReadMoreInput(s);
            }
            if (s.distanceBlockLength == 0) {
              decodeDistanceBlockSwitch(s);
            }
            s.distanceBlockLength--;
            if (s.bitOffset >= 16) {
              s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
              s.bitOffset -= 16;
            }
            let distTreeIdx = s.distContextMap[s.distContextMapSlice + distanceCode] & 255;
            distanceCode = readSymbol(s.distanceTreeGroup, distTreeIdx, s);
            if (distanceCode < 16) {
              let index = s.distRbIdx + DISTANCE_SHORT_CODE_INDEX_OFFSET[distanceCode] & 3;
              s.distance = s.rings[index] + DISTANCE_SHORT_CODE_VALUE_OFFSET[distanceCode];
              if (s.distance < 0) {
                throw "Negative distance";
              }
            } else {
              let extraBits = s.distExtraBits[distanceCode];
              let bits;
              if (s.bitOffset + extraBits <= 32) {
                bits = readFewBits(s, extraBits);
              } else {
                if (s.bitOffset >= 16) {
                  s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
                  s.bitOffset -= 16;
                }
                bits = extraBits <= 16 ? readFewBits(s, extraBits) : readManyBits(s, extraBits);
              }
              s.distance = s.distOffset[distanceCode] + (bits << s.distancePostfixBits);
            }
          }
          if (s.maxDistance != s.maxBackwardDistance && s.pos < s.maxBackwardDistance) {
            s.maxDistance = s.pos;
          } else {
            s.maxDistance = s.maxBackwardDistance;
          }
          if (s.distance > s.maxDistance) {
            s.runningState = 9;
            continue;
          }
          if (distanceCode > 0) {
            s.distRbIdx = s.distRbIdx + 1 & 3;
            s.rings[s.distRbIdx] = s.distance;
          }
          if (s.copyLength > s.metaBlockLength) {
            throw "Invalid backward reference";
          }
          s.j = 0;
          s.runningState = 8;
        case 8:
          let src = s.pos - s.distance & ringBufferMask;
          let dst = s.pos;
          let copyLength = s.copyLength - s.j;
          let srcEnd = src + copyLength;
          let dstEnd = dst + copyLength;
          if (srcEnd < ringBufferMask && dstEnd < ringBufferMask) {
            if (copyLength < 12 || srcEnd > dst && dstEnd > src) {
              for (let k = 0; k < copyLength; k += 4) {
                ringBuffer[dst++] = ringBuffer[src++];
                ringBuffer[dst++] = ringBuffer[src++];
                ringBuffer[dst++] = ringBuffer[src++];
                ringBuffer[dst++] = ringBuffer[src++];
              }
            } else {
              ringBuffer.copyWithin(dst, src, srcEnd);
            }
            s.j += copyLength;
            s.metaBlockLength -= copyLength;
            s.pos += copyLength;
          } else {
            for (; s.j < s.copyLength; ) {
              ringBuffer[s.pos] = ringBuffer[s.pos - s.distance & ringBufferMask];
              s.metaBlockLength--;
              s.pos++;
              s.j++;
              if (s.pos >= fence) {
                s.nextRunningState = 8;
                s.runningState = 12;
                break;
              }
            }
          }
          if (s.runningState == 8) {
            s.runningState = 4;
          }
          continue;
        case 9:
          doUseDictionary(s, fence);
          continue;
        case 14:
          s.pos += copyFromCompoundDictionary(s, fence);
          if (s.pos >= fence) {
            s.nextRunningState = 14;
            s.runningState = 12;
            return;
          }
          s.runningState = 4;
          continue;
        case 5:
          while (s.metaBlockLength > 0) {
            if (s.halfOffset > 2030) {
              doReadMoreInput(s);
            }
            if (s.bitOffset >= 16) {
              s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
              s.bitOffset -= 16;
            }
            readFewBits(s, 8);
            s.metaBlockLength--;
          }
          s.runningState = 2;
          continue;
        case 6:
          copyUncompressedData(s);
          continue;
        case 12:
          s.ringBufferBytesReady = min3(s.pos, s.ringBufferSize);
          s.runningState = 13;
        case 13:
          if (writeRingBuffer(s) == 0) {
            return;
          }
          if (s.pos >= s.maxBackwardDistance) {
            s.maxDistance = s.maxBackwardDistance;
          }
          if (s.pos >= s.ringBufferSize) {
            if (s.pos > s.ringBufferSize) {
              ringBuffer.copyWithin(0, s.ringBufferSize, s.pos);
            }
            s.pos &= ringBufferMask;
            s.ringBufferBytesWritten = 0;
          }
          s.runningState = s.nextRunningState;
          continue;
        default:
          throw "Unexpected state " + s.runningState;
      }
    }
    if (s.runningState == 10) {
      if (s.metaBlockLength < 0) {
        throw "Invalid metablock length";
      }
      jumpToByteBoundary(s);
      checkHealth(s, 1);
    }
  }
  function Transforms(numTransforms, prefixSuffixLen, prefixSuffixCount) {
    this.numTransforms = 0;
    this.triplets = new Int32Array(0);
    this.prefixSuffixStorage = new Int8Array(0);
    this.prefixSuffixHeads = new Int32Array(0);
    this.params = new Int16Array(0);
    this.numTransforms = numTransforms;
    this.triplets = new Int32Array(numTransforms * 3);
    this.params = new Int16Array(numTransforms);
    this.prefixSuffixStorage = new Int8Array(prefixSuffixLen);
    this.prefixSuffixHeads = new Int32Array(prefixSuffixCount + 1);
  }
  let RFC_TRANSFORMS = new Transforms(121, 167, 50);
  function unpackTransforms(prefixSuffix, prefixSuffixHeads, transforms, prefixSuffixSrc, transformsSrc) {
    let n = prefixSuffixSrc.length;
    let index = 1;
    let j = 0;
    for (let i = 0; i < n; ++i) {
      let c2 = prefixSuffixSrc.charCodeAt(i);
      if (c2 == 35) {
        prefixSuffixHeads[index++] = j;
      } else {
        prefixSuffix[j++] = c2;
      }
    }
    for (let i = 0; i < 363; ++i) {
      transforms[i] = transformsSrc.charCodeAt(i) - 32;
    }
  }
  {
    unpackTransforms(RFC_TRANSFORMS.prefixSuffixStorage, RFC_TRANSFORMS.prefixSuffixHeads, RFC_TRANSFORMS.triplets, `# #s #, #e #.# the #.com/#Â # of # and # in # to #"#">#
#]# for # a # that #. # with #'# from # by #. The # on # as # is #ing #
	#:#ed #(# at #ly #="# of the #. This #,# not #er #al #='#ful #ive #less #est #ize #ous #`, `     !! ! ,  *!  &!  " !  ) *   * -  ! # !  #!*!  +  ,$ !  -  %  .  / #   0  1 .  "   2  3!*   4%  ! # /   5  6  7  8 0  1 &   $   9 +   :  ;  < '  !=  >  ?! 4  @ 4  2  &   A *# (   B  C& ) %  ) !*# *-% A +! *.  D! %'  & E *6  F  G% ! *A *%  H! D  I!+!  J!+   K +- *4! A  L!*4  M  N +6  O!*% +.! K *G  P +%(  ! G *D +D  Q +# *K!*G!+D!+# +G +A +4!+% +K!+4!*D!+K!*K`);
  }
  function transformDictionaryWord(dst, dstOffset, src, srcOffset, len4, transforms, transformIndex) {
    let offset = dstOffset;
    let triplets = transforms.triplets;
    let prefixSuffixStorage = transforms.prefixSuffixStorage;
    let prefixSuffixHeads = transforms.prefixSuffixHeads;
    let transformOffset = 3 * transformIndex;
    let prefixIdx = triplets[transformOffset];
    let transformType = triplets[transformOffset + 1];
    let suffixIdx = triplets[transformOffset + 2];
    let prefix = prefixSuffixHeads[prefixIdx];
    let prefixEnd = prefixSuffixHeads[prefixIdx + 1];
    let suffix = prefixSuffixHeads[suffixIdx];
    let suffixEnd = prefixSuffixHeads[suffixIdx + 1];
    let omitFirst = transformType - 11;
    let omitLast = transformType - 0;
    if (omitFirst < 1 || omitFirst > 9) {
      omitFirst = 0;
    }
    if (omitLast < 1 || omitLast > 9) {
      omitLast = 0;
    }
    while (prefix != prefixEnd) {
      dst[offset++] = prefixSuffixStorage[prefix++];
    }
    if (omitFirst > len4) {
      omitFirst = len4;
    }
    srcOffset += omitFirst;
    len4 -= omitFirst;
    len4 -= omitLast;
    let i = len4;
    while (i > 0) {
      dst[offset++] = src[srcOffset++];
      i--;
    }
    if (transformType == 10 || transformType == 11) {
      let uppercaseOffset = offset - len4;
      if (transformType == 10) {
        len4 = 1;
      }
      while (len4 > 0) {
        let c0 = dst[uppercaseOffset] & 255;
        if (c0 < 192) {
          if (c0 >= 97 && c0 <= 122) {
            dst[uppercaseOffset] ^= 32;
          }
          uppercaseOffset += 1;
          len4 -= 1;
        } else if (c0 < 224) {
          dst[uppercaseOffset + 1] ^= 32;
          uppercaseOffset += 2;
          len4 -= 2;
        } else {
          dst[uppercaseOffset + 2] ^= 5;
          uppercaseOffset += 3;
          len4 -= 3;
        }
      }
    } else if (transformType == 21 || transformType == 22) {
      let shiftOffset = offset - len4;
      let param = transforms.params[transformIndex];
      let scalar = (param & 32767) + (16777216 - (param & 32768));
      while (len4 > 0) {
        let step = 1;
        let c0 = dst[shiftOffset] & 255;
        if (c0 < 128) {
          scalar += c0;
          dst[shiftOffset] = scalar & 127;
        } else if (c0 < 192) {
        } else if (c0 < 224) {
          if (len4 >= 2) {
            let c1 = dst[shiftOffset + 1];
            scalar += c1 & 63 | (c0 & 31) << 6;
            dst[shiftOffset] = 192 | scalar >> 6 & 31;
            dst[shiftOffset + 1] = c1 & 192 | scalar & 63;
            step = 2;
          } else {
            step = len4;
          }
        } else if (c0 < 240) {
          if (len4 >= 3) {
            let c1 = dst[shiftOffset + 1];
            let c2 = dst[shiftOffset + 2];
            scalar += c2 & 63 | (c1 & 63) << 6 | (c0 & 15) << 12;
            dst[shiftOffset] = 224 | scalar >> 12 & 15;
            dst[shiftOffset + 1] = c1 & 192 | scalar >> 6 & 63;
            dst[shiftOffset + 2] = c2 & 192 | scalar & 63;
            step = 3;
          } else {
            step = len4;
          }
        } else if (c0 < 248) {
          if (len4 >= 4) {
            let c1 = dst[shiftOffset + 1];
            let c2 = dst[shiftOffset + 2];
            let c3 = dst[shiftOffset + 3];
            scalar += c3 & 63 | (c2 & 63) << 6 | (c1 & 63) << 12 | (c0 & 7) << 18;
            dst[shiftOffset] = 240 | scalar >> 18 & 7;
            dst[shiftOffset + 1] = c1 & 192 | scalar >> 12 & 63;
            dst[shiftOffset + 2] = c2 & 192 | scalar >> 6 & 63;
            dst[shiftOffset + 3] = c3 & 192 | scalar & 63;
            step = 4;
          } else {
            step = len4;
          }
        }
        shiftOffset += step;
        len4 -= step;
        if (transformType == 21) {
          len4 = 0;
        }
      }
    }
    while (suffix != suffixEnd) {
      dst[offset++] = prefixSuffixStorage[suffix++];
    }
    return offset - dstOffset;
  }
  function getNextKey(key, len4) {
    let step = 1 << len4 - 1;
    while ((key & step) != 0) {
      step >>= 1;
    }
    return (key & step - 1) + step;
  }
  function replicateValue(table, offset, step, end, item) {
    do {
      end -= step;
      table[offset + end] = item;
    } while (end > 0);
  }
  function nextTableBitSize(count, len4, rootBits) {
    let left = 1 << len4 - rootBits;
    while (len4 < 15) {
      left -= count[len4];
      if (left <= 0) {
        break;
      }
      len4++;
      left <<= 1;
    }
    return len4 - rootBits;
  }
  function buildHuffmanTable(tableGroup, tableIdx, rootBits, codeLengths, codeLengthsSize) {
    let tableOffset = tableGroup[tableIdx];
    let key;
    let sorted = new Int32Array(codeLengthsSize);
    let count = new Int32Array(16);
    let offset = new Int32Array(16);
    let symbol;
    for (symbol = 0; symbol < codeLengthsSize; symbol++) {
      count[codeLengths[symbol]]++;
    }
    offset[1] = 0;
    for (let len4 = 1; len4 < 15; len4++) {
      offset[len4 + 1] = offset[len4] + count[len4];
    }
    for (symbol = 0; symbol < codeLengthsSize; symbol++) {
      if (codeLengths[symbol] != 0) {
        sorted[offset[codeLengths[symbol]]++] = symbol;
      }
    }
    let tableBits = rootBits;
    let tableSize = 1 << tableBits;
    let totalSize = tableSize;
    if (offset[15] == 1) {
      for (key = 0; key < totalSize; key++) {
        tableGroup[tableOffset + key] = sorted[0];
      }
      return totalSize;
    }
    key = 0;
    symbol = 0;
    for (let len4 = 1, step = 2; len4 <= rootBits; len4++, step <<= 1) {
      for (; count[len4] > 0; count[len4]--) {
        replicateValue(tableGroup, tableOffset + key, step, tableSize, len4 << 16 | sorted[symbol++]);
        key = getNextKey(key, len4);
      }
    }
    let mask = totalSize - 1;
    let low = -1;
    let currentOffset = tableOffset;
    for (let len4 = rootBits + 1, step = 2; len4 <= 15; len4++, step <<= 1) {
      for (; count[len4] > 0; count[len4]--) {
        if ((key & mask) != low) {
          currentOffset += tableSize;
          tableBits = nextTableBitSize(count, len4, rootBits);
          tableSize = 1 << tableBits;
          totalSize += tableSize;
          low = key & mask;
          tableGroup[tableOffset + low] = tableBits + rootBits << 16 | currentOffset - tableOffset - low;
        }
        replicateValue(tableGroup, currentOffset + (key >> rootBits), step, tableSize, len4 - rootBits << 16 | sorted[symbol++]);
        key = getNextKey(key, len4);
      }
    }
    return totalSize;
  }
  function doReadMoreInput(s) {
    if (s.endOfStreamReached != 0) {
      if (halfAvailable(s) >= -2) {
        return;
      }
      throw "No more input";
    }
    let readOffset = s.halfOffset << 1;
    let bytesInBuffer = 4096 - readOffset;
    s.byteBuffer.copyWithin(0, readOffset, 4096);
    s.halfOffset = 0;
    while (bytesInBuffer < 4096) {
      let spaceLeft = 4096 - bytesInBuffer;
      let len4 = readInput(s.input, s.byteBuffer, bytesInBuffer, spaceLeft);
      if (len4 <= 0) {
        s.endOfStreamReached = 1;
        s.tailBytes = bytesInBuffer;
        bytesInBuffer += 1;
        break;
      }
      bytesInBuffer += len4;
    }
    bytesToNibbles(s, bytesInBuffer);
  }
  function checkHealth(s, endOfStream) {
    if (s.endOfStreamReached == 0) {
      return;
    }
    let byteOffset = (s.halfOffset << 1) + (s.bitOffset + 7 >> 3) - 4;
    if (byteOffset > s.tailBytes) {
      throw "Read after end";
    }
    if (endOfStream != 0 && byteOffset != s.tailBytes) {
      throw "Unused bytes after end";
    }
  }
  function assertAccumulatorHealthy(s) {
    if (s.bitOffset > 32) {
      throw "Accumulator underloaded: " + s.bitOffset;
    }
  }
  function readFewBits(s, n) {
    let val = s.accumulator32 >>> s.bitOffset & (1 << n) - 1;
    s.bitOffset += n;
    return val;
  }
  function readManyBits(s, n) {
    let low = readFewBits(s, 16);
    s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
    s.bitOffset -= 16;
    return low | readFewBits(s, n - 16) << 16;
  }
  function initBitReader(s) {
    s.byteBuffer = new Int8Array(4160);
    s.accumulator32 = 0;
    s.shortBuffer = new Int16Array(2080);
    s.bitOffset = 32;
    s.halfOffset = 2048;
    s.endOfStreamReached = 0;
    prepare(s);
  }
  function prepare(s) {
    if (s.halfOffset > 2030) {
      doReadMoreInput(s);
    }
    checkHealth(s, 0);
    s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
    s.bitOffset -= 16;
    s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
    s.bitOffset -= 16;
  }
  function reload(s) {
    if (s.bitOffset == 32) {
      prepare(s);
    }
  }
  function jumpToByteBoundary(s) {
    let padding = 32 - s.bitOffset & 7;
    if (padding != 0) {
      let paddingBits = readFewBits(s, padding);
      if (paddingBits != 0) {
        throw "Corrupted padding bits";
      }
    }
  }
  function halfAvailable(s) {
    let limit = 2048;
    if (s.endOfStreamReached != 0) {
      limit = s.tailBytes + 1 >> 1;
    }
    return limit - s.halfOffset;
  }
  function copyRawBytes(s, data2, offset, length5) {
    if ((s.bitOffset & 7) != 0) {
      throw "Unaligned copyBytes";
    }
    while (s.bitOffset != 32 && length5 != 0) {
      data2[offset++] = s.accumulator32 >>> s.bitOffset;
      s.bitOffset += 8;
      length5--;
    }
    if (length5 == 0) {
      return;
    }
    let copyNibbles = min3(halfAvailable(s), length5 >> 1);
    if (copyNibbles > 0) {
      let readOffset = s.halfOffset << 1;
      let delta = copyNibbles << 1;
      data2.set(s.byteBuffer.subarray(readOffset, readOffset + delta), offset);
      offset += delta;
      length5 -= delta;
      s.halfOffset += copyNibbles;
    }
    if (length5 == 0) {
      return;
    }
    if (halfAvailable(s) > 0) {
      if (s.bitOffset >= 16) {
        s.accumulator32 = s.shortBuffer[s.halfOffset++] << 16 | s.accumulator32 >>> 16;
        s.bitOffset -= 16;
      }
      while (length5 != 0) {
        data2[offset++] = s.accumulator32 >>> s.bitOffset;
        s.bitOffset += 8;
        length5--;
      }
      checkHealth(s, 0);
      return;
    }
    while (length5 > 0) {
      let len4 = readInput(s.input, data2, offset, length5);
      if (len4 == -1) {
        throw "Unexpected end of input";
      }
      offset += len4;
      length5 -= len4;
    }
  }
  function bytesToNibbles(s, byteLen) {
    let byteBuffer = s.byteBuffer;
    let halfLen = byteLen >> 1;
    let shortBuffer = s.shortBuffer;
    for (let i = 0; i < halfLen; ++i) {
      shortBuffer[i] = byteBuffer[i * 2] & 255 | (byteBuffer[i * 2 + 1] & 255) << 8;
    }
  }
  let LOOKUP = new Int32Array(2048);
  function unpackLookupTable(lookup, map, rle) {
    for (let i = 0; i < 256; ++i) {
      lookup[i] = i & 63;
      lookup[512 + i] = i >> 2;
      lookup[1792 + i] = 2 + (i >> 6);
    }
    for (let i = 0; i < 128; ++i) {
      lookup[1024 + i] = 4 * (map.charCodeAt(i) - 32);
    }
    for (let i = 0; i < 64; ++i) {
      lookup[1152 + i] = i & 1;
      lookup[1216 + i] = 2 + (i & 1);
    }
    let offset = 1280;
    for (let k = 0; k < 19; ++k) {
      let value = k & 3;
      let rep = rle.charCodeAt(k) - 32;
      for (let i = 0; i < rep; ++i) {
        lookup[offset++] = value;
      }
    }
    for (let i = 0; i < 16; ++i) {
      lookup[1792 + i] = 1;
      lookup[2032 + i] = 6;
    }
    lookup[1792] = 0;
    lookup[2047] = 7;
    for (let i = 0; i < 256; ++i) {
      lookup[1536 + i] = lookup[1792 + i] << 3;
    }
  }
  {
    unpackLookupTable(LOOKUP, `         !!  !                  "#$##%#$&'##(#)#++++++++++((&*'##,---,---,-----,-----,-----&#'###.///.///./////./////./////&#'# `, "A/*  ':  & : $   @");
  }
  function State() {
    this.ringBuffer = new Int8Array(0);
    this.contextModes = new Int8Array(0);
    this.contextMap = new Int8Array(0);
    this.distContextMap = new Int8Array(0);
    this.distExtraBits = new Int8Array(0);
    this.output = new Int8Array(0);
    this.byteBuffer = new Int8Array(0);
    this.shortBuffer = new Int16Array(0);
    this.intBuffer = new Int32Array(0);
    this.rings = new Int32Array(0);
    this.blockTrees = new Int32Array(0);
    this.literalTreeGroup = new Int32Array(0);
    this.commandTreeGroup = new Int32Array(0);
    this.distanceTreeGroup = new Int32Array(0);
    this.distOffset = new Int32Array(0);
    this.runningState = 0;
    this.nextRunningState = 0;
    this.accumulator32 = 0;
    this.bitOffset = 0;
    this.halfOffset = 0;
    this.tailBytes = 0;
    this.endOfStreamReached = 0;
    this.metaBlockLength = 0;
    this.inputEnd = 0;
    this.isUncompressed = 0;
    this.isMetadata = 0;
    this.literalBlockLength = 0;
    this.numLiteralBlockTypes = 0;
    this.commandBlockLength = 0;
    this.numCommandBlockTypes = 0;
    this.distanceBlockLength = 0;
    this.numDistanceBlockTypes = 0;
    this.pos = 0;
    this.maxDistance = 0;
    this.distRbIdx = 0;
    this.trivialLiteralContext = 0;
    this.literalTreeIdx = 0;
    this.commandTreeIdx = 0;
    this.j = 0;
    this.insertLength = 0;
    this.contextMapSlice = 0;
    this.distContextMapSlice = 0;
    this.contextLookupOffset1 = 0;
    this.contextLookupOffset2 = 0;
    this.distanceCode = 0;
    this.numDirectDistanceCodes = 0;
    this.distancePostfixBits = 0;
    this.distance = 0;
    this.copyLength = 0;
    this.maxBackwardDistance = 0;
    this.maxRingBufferSize = 0;
    this.ringBufferSize = 0;
    this.expectedTotalSize = 0;
    this.outputOffset = 0;
    this.outputLength = 0;
    this.outputUsed = 0;
    this.ringBufferBytesWritten = 0;
    this.ringBufferBytesReady = 0;
    this.isEager = 0;
    this.isLargeWindow = 0;
    this.cdNumChunks = 0;
    this.cdTotalSize = 0;
    this.cdBrIndex = 0;
    this.cdBrOffset = 0;
    this.cdBrLength = 0;
    this.cdBrCopied = 0;
    this.cdChunks = new Array(0);
    this.cdChunkOffsets = new Int32Array(0);
    this.cdBlockBits = 0;
    this.cdBlockMap = new Int8Array(0);
    this.input = null;
    this.ringBuffer = new Int8Array(0);
    this.rings = new Int32Array(10);
    this.rings[0] = 16;
    this.rings[1] = 15;
    this.rings[2] = 11;
    this.rings[3] = 4;
  }
  let data = null;
  let offsets = new Int32Array(32);
  let sizeBits = new Int32Array(32);
  function setData(newData, newSizeBits) {
    if (isDirect(newData) == 0 || isReadOnly(newData) == 0) {
      throw "newData must be a direct read-only byte buffer";
    }
    if (newSizeBits.length > 31) {
      throw "sizeBits length must be at most 31";
    }
    for (let i = 0; i < 4; ++i) {
      if (newSizeBits[i] != 0) {
        throw "first 4 must be 0";
      }
    }
    let dictionaryOffsets = offsets;
    let dictionarySizeBits = sizeBits;
    dictionarySizeBits.set(newSizeBits.subarray(0, 0 + newSizeBits.length), 0);
    let pos = 0;
    let limit = newData.length;
    for (let i = 0; i < newSizeBits.length; ++i) {
      dictionaryOffsets[i] = pos;
      let bits = dictionarySizeBits[i];
      if (bits != 0) {
        if (bits >= 31) {
          throw "newSizeBits values must be less than 31";
        }
        pos += i << bits;
        if (pos <= 0 || pos > limit) {
          throw "newSizeBits is inconsistent: overflow";
        }
      }
    }
    for (let i = newSizeBits.length; i < 32; ++i) {
      dictionaryOffsets[i] = pos;
    }
    if (pos != limit) {
      throw "newSizeBits is inconsistent: underflow";
    }
    data = newData;
  }
  function unpackDictionaryData(dictionary, data0, data1, skipFlip, sizeBits2, sizeBitsData) {
    let dict = toUsAsciiBytes(data0 + data1);
    if (dict.length != dictionary.length) {
      throw "Corrupted brotli dictionary";
    }
    let offset = 0;
    let n = skipFlip.length;
    for (let i = 0; i < n; i += 2) {
      let skip = skipFlip.charCodeAt(i) - 36;
      let flip = skipFlip.charCodeAt(i + 1) - 36;
      for (let j = 0; j < skip; ++j) {
        dict[offset] ^= 3;
        offset++;
      }
      for (let j = 0; j < flip; ++j) {
        dict[offset] ^= 236;
        offset++;
      }
    }
    for (let i = 0; i < sizeBitsData.length; ++i) {
      sizeBits2[i] = sizeBitsData.charCodeAt(i) - 65;
    }
    dictionary.set(dict);
  }
  {
    let dictionaryData = new Int8Array(122784);
    let dictionarySizeBits = new Int32Array(25);
    unpackDictionaryData(dictionaryData, 'wjnfgltmojefofewab`h`lgfgbwbpkltlmozpjwf`jwzlsfmivpwojhfeqfftlqhwf{wzfbqlufqalgzolufelqnallhsobzojufojmfkfosklnfpjgfnlqftlqgolmdwkfnujftejmgsbdfgbzpevookfbgwfqnfb`kbqfbeqlnwqvfnbqhbaofvslmkjdkgbwfobmgmftpfufmmf{w`bpfalwkslpwvpfgnbgfkbmgkfqftkbwmbnfOjmhaoldpjyfabpfkfognbhfnbjmvpfq$*#(klogfmgptjwkMftpqfbgtfqfpjdmwbhfkbufdbnfpffm`boosbwktfoosovpnfmvejonsbqwiljmwkjpojpwdllgmffgtbzptfpwilapnjmgboploldlqj`kvpfpobpwwfbnbqnzellghjmdtjoofbpwtbqgafpwejqfSbdfhmltbtbz-smdnlufwkbmolbgdjufpfoemlwfnv`keffgnbmzql`hj`lmlm`follhkjgfgjfgKlnfqvofklpwbib{jmel`ovaobtpofppkboeplnfpv`kylmf233&lmfp`bqfWjnfqb`faovfelvqtffheb`fklsfdbufkbqgolpwtkfmsbqhhfswsbpppkjsqllnKWNOsobmWzsfglmfpbufhffseobdojmhplogejufwllhqbwfwltmivnswkvpgbqh`bqgejofefbqpwbzhjoowkbweboobvwlfufq-`lnwbohpklsulwfgffsnlgfqfpwwvqmalqmabmgefooqlpfvqo+phjmqlof`lnfb`wpbdfpnffwdlog-isdjwfnubqzefowwkfmpfmggqlsUjft`lsz2-3!?,b=pwlsfopfojfpwlvqsb`h-djesbpw`pp<dqbznfbm%dw8qjgfpklwobwfpbjgqlbgubq#effoilkmqj`hslqwebpw$VB.gfbg?,a=sllqajoowzsfV-P-tllgnvpw1s{8JmelqbmhtjgftbmwtbooofbgX3^8sbvotbufpvqf\'+$ tbjwnbppbqnpdlfpdbjmobmdsbjg"..#ol`hvmjwqllwtbohejqntjef{no!plmdwfpw13s{hjmgqltpwlloelmwnbjopbefpwbqnbsp`lqfqbjmeoltabazpsbmpbzp7s{85s{8bqwpellwqfbotjhjkfbwpwfswqjslqd,obhftfbhwlogElqn`bpwebmpabmhufqzqvmpivozwbph2s{8dlbodqftpoltfgdfjg>!pfwp6s{8-ip<73s{je#+pllmpfbwmlmfwvafyfqlpfmwqffgeb`wjmwldjewkbqn2;s{`bnfkjooalogyllnuljgfbpzqjmdejoosfbhjmjw`lpw0s{8ib`hwbdpajwpqloofgjwhmftmfbq?"..dqltIPLMgvwzMbnfpbofzlv#olwpsbjmibyy`logfzfpejpkttt-qjphwbapsqfu23s{qjpf16s{Aovfgjmd033/abooelqgfbqmtjogal{-ebjqob`hufqpsbjqivmfwf`kje+"sj`hfujo\'+! tbqnolqgglfpsvoo/333jgfbgqbtkvdfpslwevmgavqmkqfe`foohfzpwj`hklvqolppevfo21s{pvjwgfboQPP!bdfgdqfzDFW!fbpfbjnpdjqobjgp;s{8mbuzdqjgwjsp :::tbqpobgz`bqp*8#~sks<kfoowbootklnyk9	),	#233kboo-		B4s{8svpk`kbw3s{8`qft),?,kbpk46s{eobwqbqf#%%#wfoo`bnslmwlobjgnjppphjswfmwejmfnbofdfwpsolw733/		`lloeffw-sks?aq=fqj`nlpwdvjgafoogfp`kbjqnbwkbwln,jnd% ;1ov`h`fmw3338wjmzdlmfkwnopfoogqvdEQFFmlgfmj`h<jg>olpfmvooubpwtjmgQPP#tfbqqfozaffmpbnfgvhfmbpb`bsftjpkdvoeW109kjwppolwdbwfhj`haovqwkfz26s{$$*8*8!=npjftjmpajqgplqwafwbpffhW2;9lqgpwqffnboo53s{ebqnlupalzpX3^-$*8!SLPWafbqhjgp*8~~nbqzwfmg+VH*rvbgyk9\n.pjy....sqls$*8ojewW2:9uj`fbmgzgfaw=QPPsllomf`haoltW259gllqfuboW249ofwpebjolqbosloomlub`lopdfmf#lxplewqlnfwjooqlpp?k0=slvqebgfsjmh?wq=njmj*"+njmfyk9abqpkfbq33*8njoh#..=jqlmeqfggjphtfmwpljosvwp,ip,klozW119JPAMW139bgbnpffp?k1=iplm$/#$`lmwW129#QPPollsbpjbnllm?,s=plvoOJMFelqw`bqwW279?k2=;3s{"..?:s{8W379njhf975Ymj`fjm`kZlqhqj`fyk9\b$**8svqfnbdfsbqbwlmfalmg904Y\\le\\$^*8333/yk9\vwbmhzbqgaltoavpk965YIbub03s{	~	&@0&907YifeeF[SJ`bpkujpbdloepmltyk9rvfq-`pppj`hnfbwnjm-ajmggfookjqfsj`pqfmw905YKWWS.132elwltloeFMG#{al{967YALGZgj`h8	~	f{jw906Yubqpafbw$~*8gjfw:::8bmmf~~?,Xj^-Obmdhn.^tjqfwlzpbggppfbobof{8	\n~f`klmjmf-lqd336*wlmziftppbmgofdpqlle333*#133tjmfdfbqgldpallwdbqz`vwpwzofwfnswjlm-{no`l`hdbmd\'+$-63s{Sk-Gnjp`bobmolbmgfphnjofqzbmvmj{gjp`*8~	gvpw`ojs*-		43s{.133GUGp4^=?wbsfgfnlj((*tbdffvqlskjolswpklofEBRpbpjm.15WobapsfwpVQO#avoh`llh8~	KFBGX3^*baaqivbm+2:;ofpkwtjm?,j=plmzdvzpev`hsjsf.	"331*mgltX2^8X^8	Old#pbow	\n\nabmdwqjnabwk*x	33s{	~*8hl9\0effpbg=p9,,#X^8wloosovd+*x	x	#-ip$133sgvboalbw-ISD*8	~rvlw*8		$*8		~1327132613251324132;132:13131312131113101317131613151314131;131:130313021301130013071306130513041320132113221323133:133;133413351336133713301331133213332:::2::;2::42::52::62::72::02::12::22::32:;:2:;;2:;42:;52:;62:;72:;02:;12:;22:;32:4:2:4;2:442:452:462:472:402:412:422:432:5:2:5;2:542:552:562:572:502:512:522:532:6:2:6;2:642:652:662:672:602:612:622:632333231720:73333::::`lnln/Mpfpwffpwbsfqlwlglkb`f`bgbb/]lajfmg/Abbp/Aujgb`bpllwqlelqlplollwqb`vbogjilpjgldqbmwjslwfnbgfafbodlrv/Efpwlmbgbwqfpsl`l`bpbabilwlgbpjmlbdvbsvfpvmlpbmwfgj`fovjpfoobnbzlylmbbnlqsjpllaqb`oj`foolgjlpklqb`bpj<[<\\<Q<\\<R<P=l<\\=l=o=n<\\<Q<Y<S<R<R=n<T<[<Q<R<X<R=n<R<Z<Y<R<Q<T=i<q<\\<Y<Y<]=g<P=g<~=g=m<R<^=g<^<R<q<R<R<]<s<R<W<T<Q<T<L<H<q<Y<p=g=n=g<r<Q<T<P<X<\\<{<\\<x<\\<q=o<r<]=n<Y<t<[<Y<U<Q=o<P<P<N=g=o<Z5m5f4O5j5i4K5i4U5o5h4O5d4]4C5f4K5m5e5k5d5h5i5h5o4K5d5h5k4D4_4K5h4I5j5k5f4O5f5n4C5k5h4G5i4D5k5h5d5h5f4D5h4K5f4D5o4X5f4K5i4O5i5j4F4D5f5h5j4A4D5k5i5i4X5d4Xejqpwujgflojdkwtlqognfgjbtkjwf`olpfaob`hqjdkwpnbooallhpsob`fnvpj`ejfoglqgfqsljmwubovfofufowbaofalbqgklvpfdqlvstlqhpzfbqppwbwfwlgbztbwfqpwbqwpwzofgfbwksltfqsklmfmjdkwfqqlqjmsvwbalvwwfqnpwjwofwllopfufmwol`bowjnfpobqdftlqgpdbnfppklqwpsb`fel`vp`ofbqnlgfoaol`hdvjgfqbgjlpkbqftlnfmbdbjmnlmfzjnbdfmbnfpzlvmdojmfpobwfq`lolqdqffmeqlmw%bns8tbw`kelq`fsqj`fqvofpafdjmbewfqujpjwjppvfbqfbpafoltjmgf{wlwboklvqpobafosqjmwsqfppavjowojmhppsffgpwvgzwqbgfelvmgpfmpfvmgfqpkltmelqnpqbmdfbggfgpwjoonlufgwbhfmbalufeobpkej{fglewfmlwkfqujftp`kf`hofdboqjufqjwfnprvj`hpkbsfkvnbmf{jpwdljmdnlujfwkjqgabpj`sfb`fpwbdftjgwkoldjmjgfbptqlwfsbdfpvpfqpgqjufpwlqfaqfbhplvwkulj`fpjwfpnlmwktkfqfavjogtkj`kfbqwkelqvnwkqffpslqwsbqwz@oj`holtfqojufp`obppobzfqfmwqzpwlqzvpbdfplvmg`lvqwzlvq#ajqwkslsvswzsfpbssozJnbdfafjmdvssfqmlwfpfufqzpkltpnfbmpf{wqbnbw`kwqb`hhmltmfbqozafdbmpvsfqsbsfqmlqwkofbqmdjufmmbnfgfmgfgWfqnpsbqwpDqlvsaqbmgvpjmdtlnbmebopfqfbgzbvgjlwbhfptkjof-`ln,ojufg`bpfpgbjoz`kjogdqfbwivgdfwklpfvmjwpmfufqaqlbg`lbpw`lufqbssofejofp`z`ofp`fmfsobmp`oj`htqjwfrvffmsjf`ffnbjoeqbnflogfqsklwlojnjw`b`kf`jujop`boffmwfqwkfnfwkfqfwlv`kalvmgqlzbobphfgtklofpjm`fpwl`h#mbnfebjwkkfbqwfnswzleefqp`lsfltmfgnjdkwboavnwkjmhaollgbqqbznbilqwqvpw`bmlmvmjlm`lvmwubojgpwlmfPwzofOldjmkbsszl``vqofew9eqfpkrvjwfejonpdqbgfmffgpvqabmejdkwabpjpklufqbvwl8qlvwf-kwnonj{fgejmboZlvq#pojgfwlsj`aqltmbolmfgqbtmpsojwqfb`kQjdkwgbwfpnbq`krvlwfdllgpOjmhpglvawbpzm`wkvnaboolt`kjfezlvwkmlufo23s{8pfqufvmwjokbmgp@kf`hPsb`frvfqzibnfpfrvbowtj`f3/333Pwbqwsbmfoplmdpqlvmgfjdkwpkjewtlqwkslpwpofbgptffhpbuljgwkfpfnjofpsobmfpnbqwboskbsobmwnbqhpqbwfpsobzp`objnpbofpwf{wppwbqptqlmd?,k0=wkjmd-lqd,nvowjkfbqgSltfqpwbmgwlhfmplojg+wkjpaqjmdpkjsppwbeewqjfg`boopevoozeb`wpbdfmwWkjp#,,..=bgnjmfdzswFufmw26s{8Fnbjowqvf!`qlpppsfmwaoldpal{!=mlwfgofbuf`kjmbpjyfpdvfpw?,k7=qlalwkfbuzwqvf/pfufmdqbmg`qjnfpjdmpbtbqfgbm`fskbpf=?"..fm\\VP% 0:8133s{\\mbnfobwjmfmilzbib{-bwjlmpnjwkV-P-#klogpsfwfqjmgjbmbu!=`kbjmp`lqf`lnfpgljmdsqjlqPkbqf2::3pqlnbmojpwpibsbmeboopwqjboltmfqbdqff?,k1=bavpfbofqwlsfqb!.,,T`bqgpkjoopwfbnpSklwlwqvwk`ofbm-sks<pbjmwnfwboolvjpnfbmwsqlleaqjfeqlt!=dfmqfwqv`hollhpUbovfEqbnf-mfw,..=	?wqz#x	ubq#nbhfp`lpwpsobjmbgvowrvfpwwqbjmobalqkfosp`bvpfnbdj`nlwlqwkfjq163s{ofbpwpwfsp@lvmw`lvogdobpppjgfpevmgpklwfobtbqgnlvwknlufpsbqjpdjufpgvw`kwf{bpeqvjwmvoo/X^8wls!=	?"..SLPW!l`fbm?aq,=eollqpsfbhgfswk#pjyfabmhp`bw`k`kbqw13s{8bojdmgfboptlvog63s{8vqo>!sbqhpnlvpfNlpw#---?,bnlmdaqbjmalgz#mlmf8abpfg`bqqzgqbewqfefqsbdf\\klnf-nfwfqgfobzgqfbnsqlufiljmw?,wq=gqvdp?"..#bsqjojgfboboofmf{b`welqwk`lgfpoldj`Ujft#pffnpaobmhslqwp#+133pbufg\\ojmhdlbopdqbmwdqffhklnfpqjmdpqbwfg03s{8tklpfsbqpf+*8!#Aol`hojmv{ilmfpsj{fo$*8!=*8je+.ofewgbujgklqpfEl`vpqbjpfal{fpWqb`hfnfmw?,fn=abq!=-pq`>wltfqbow>!`baofkfmqz17s{8pfwvsjwbozpkbqsnjmlqwbpwftbmwpwkjp-qfpfwtkffodjqop,`pp,233&8`ovappwveeajaofulwfp#2333hlqfb~*8	abmgprvfvf>#x~8;3s{8`hjmdx	\n\nbkfbg`ol`hjqjpkojhf#qbwjlpwbwpElqn!zbkll*X3^8Balvwejmgp?,k2=gfavdwbphpVQO#>`foop~*+*821s{8sqjnfwfoopwvqmp3{533-isd!psbjmafb`kwb{fpnj`qlbmdfo..=?,djewppwfuf.ojmhalgz-~*8	\nnlvmw#+2::EBR?,qldfqeqbmh@obpp1;s{8effgp?k2=?p`lwwwfpwp11s{8gqjmh*##oftjppkboo 30:8#elq#olufgtbpwf33s{8ib9npjnlm?elmwqfsoznffwpvmwfq`kfbswjdkwAqbmg*#">#gqfpp`ojspqllnplmhfznlajonbjm-Mbnf#sobwfevmmzwqffp`ln,!2-isdtnlgfsbqbnPWBQWofew#jggfm/#132*8	~	elqn-ujqvp`kbjqwqbmptlqpwSbdfpjwjlmsbw`k?"..	l.`b`ejqnpwlvqp/333#bpjbmj((*xbglaf$*X3^jg>23alwk8nfmv#-1-nj-smd!hfujm`lb`k@kjogaqv`f1-isdVQO*(-isdpvjwfpoj`fkbqqz213!#ptffwwq=	mbnf>gjfdlsbdf#ptjpp..=		 eee8!=Old-`ln!wqfbwpkffw*#%%#27s{8poffsmwfmwejofgib9ojg>!`Mbnf!tlqpfpklwp.al{.gfowb	%ow8afbqp97;Y?gbwb.qvqbo?,b=#psfmgabhfqpklsp>#!!8sks!=`wjlm20s{8aqjbmkfoolpjyf>l>&1E#iljmnbzaf?jnd#jnd!=/#eipjnd!#!*X3^NWlsAWzsf!mftozGbmph`yf`kwqbjohmltp?,k6=ebr!=yk.`m23*8	.2!*8wzsf>aovfpwqvozgbujp-ip$8=	?"pwffo#zlv#k1=	elqn#ifpvp233&#nfmv-	\n	tbofpqjphpvnfmwggjmda.ojhwfb`kdje!#ufdbpgbmphffpwjpkrjspvlnjplaqfgfpgffmwqfwlglpsvfgfb/]lpfpw/Mwjfmfkbpwblwqlpsbqwfglmgfmvfulkb`fqelqnbnjpnlnfilqnvmglbrv/Ag/Abpp/_olbzvgbef`kbwlgbpwbmwlnfmlpgbwlplwqbppjwjlnv`klbklqbovdbqnbzlqfpwlpklqbpwfmfqbmwfpelwlpfpwbpsb/Apmvfubpbovgelqlpnfgjlrvjfmnfpfpslgfq`kjofpfq/Muf`fpgf`jqilp/Efpwbqufmwbdqvslkf`klfoolpwfmdlbnjdl`lpbpmjufodfmwfnjpnbbjqfpivojlwfnbpkb`jbebulqivmjlojaqfsvmwlavfmlbvwlqbaqjoavfmbwf{wlnbqylpbafqojpwbovfdl`/_nlfmfqlivfdlsfq/Vkbafqfpwlzmvm`bnvifqubolqevfqbojaqldvpwbjdvboulwlp`bplpdv/Absvfglplnlpbujplvpwfggfafmml`kfavp`bebowbfvqlppfqjfgj`kl`vqpl`obuf`bpbpof/_msobylobqdllaqbpujpwbbslzlivmwlwqbwbujpwl`qfbq`bnslkfnlp`jm`l`bqdlsjplplqgfmkb`fm/Mqfbgjp`lsfgql`fq`bsvfgbsbsfonfmlq/Vwjo`obqlilqdf`boofslmfqwbqgfmbgjfnbq`bpjdvffoobppjdol`l`kfnlwlpnbgqf`obpfqfpwlmj/]lrvfgbsbpbqabm`lkjilpujbifsbaol/Epwfujfmfqfjmlgfibqelmgl`bmbomlqwfofwqb`bvpbwlnbqnbmlpovmfpbvwlpujoobufmglsfpbqwjslpwfmdbnbq`loofubsbgqfvmjglubnlpylmbpbnalpabmgbnbqjbbavplnv`kbpvajqqjlibujujqdqbgl`kj`bboo/Ailufmgj`kbfpwbmwbofppbojqpvfolsfplpejmfpoobnbavp`l/Epwboofdbmfdqlsobybkvnlqsbdbqivmwbglaofjpobpalopbab/]lkbaobov`kb/mqfbgj`fmivdbqmlwbpuboofboo/M`bqdbglolqbabilfpw/Edvpwlnfmwfnbqjlejqnb`lpwlej`kbsobwbkldbqbqwfpofzfpbrvfonvpflabpfpsl`lpnjwbg`jfol`kj`lnjfgldbmbqpbmwlfwbsbgfafpsobzbqfgfppjfwf`lqwf`lqfbgvgbpgfpflujfilgfpfbbdvbp%rvlw8glnbjm`lnnlmpwbwvpfufmwpnbpwfqpzpwfnb`wjlmabmmfqqfnlufp`qloovsgbwfdolabonfgjvnejowfqmvnafq`kbmdfqfpvowsvaoj`p`qffm`kllpfmlqnbowqbufojppvfpplvq`fwbqdfwpsqjmdnlgvofnlajofptjw`ksklwlpalqgfqqfdjlmjwpfoepl`jbob`wjuf`lovnmqf`lqgelooltwjwof=fjwkfqofmdwkebnjozeqjfmgobzlvwbvwklq`qfbwfqfujftpvnnfqpfqufqsobzfgsobzfqf{sbmgsloj`zelqnbwglvaofsljmwppfqjfpsfqplmojujmdgfpjdmnlmwkpelq`fpvmjrvftfjdkwsflsoffmfqdzmbwvqfpfbq`kejdvqfkbujmd`vpwlnleepfwofwwfqtjmgltpvanjwqfmgfqdqlvspvsolbgkfbowknfwklgujgflpp`klloevwvqfpkbgltgfabwfubovfpLaif`wlwkfqpqjdkwpofbdvf`kqlnfpjnsofmlwj`fpkbqfgfmgjmdpfbplmqfslqwlmojmfprvbqfavwwlmjnbdfpfmbaofnlujmdobwfpwtjmwfqEqbm`fsfqjlgpwqlmdqfsfbwOlmglmgfwbjoelqnfggfnbmgpf`vqfsbppfgwlddofsob`fpgfuj`fpwbwj``jwjfppwqfbnzfooltbwwb`hpwqffweojdkwkjggfmjmel!=lsfmfgvpfevouboofz`bvpfpofbgfqpf`qfwpf`lmggbnbdfpslqwpf{`fswqbwjmdpjdmfgwkjmdpfeef`wejfogppwbwfpleej`fujpvbofgjwlqulovnfQfslqwnvpfvnnlujfpsbqfmwb``fppnlpwoznlwkfq!#jg>!nbqhfwdqlvmg`kbm`fpvqufzafelqfpznalonlnfmwpsff`knlwjlmjmpjgfnbwwfq@fmwfqlaif`wf{jpwpnjggofFvqlsfdqltwkofdb`znbmmfqfmlvdk`bqffqbmptfqlqjdjmslqwbo`ojfmwpfof`wqbmgln`olpfgwlsj`p`lnjmdebwkfqlswjlmpjnsozqbjpfgfp`bsf`klpfm`kvq`kgfejmfqfbplm`lqmfqlvwsvwnfnlqzjeqbnfsloj`fnlgfopMvnafqgvqjmdleefqppwzofphjoofgojpwfg`boofgpjoufqnbqdjmgfofwfafwwfqaqltpfojnjwpDolabopjmdoftjgdfw`fmwfqavgdfwmltqbs`qfgjw`objnpfmdjmfpbefwz`klj`fpsjqjw.pwzofpsqfbgnbhjmdmffgfgqvppjbsofbpff{wfmwP`qjswaqlhfmbooltp`kbqdfgjujgfeb`wlqnfnafq.abpfgwkflqz`lmejdbqlvmgtlqhfgkfosfg@kvq`kjnsb`wpklvogbotbzpoldl!#alwwlnojpw!=*xubq#sqfej{lqbmdfKfbgfq-svpk+`lvsofdbqgfmaqjgdfobvm`kQfujftwbhjmdujpjlmojwwofgbwjmdAvwwlmafbvwzwkfnfpelqdlwPfbq`kbm`klqbonlpwolbgfg@kbmdfqfwvqmpwqjmdqfolbgNlajofjm`lnfpvssozPlvq`flqgfqpujftfg%maps8`lvqpfBalvw#jpobmg?kwno#`llhjfmbnf>!bnbylmnlgfqmbguj`fjm?,b=9#Wkf#gjboldklvpfpAFDJM#Nf{j`lpwbqwp`fmwqfkfjdkwbggjmdJpobmgbppfwpFnsjqfP`kllofeelqwgjqf`wmfbqoznbmvboPfof`w-		Lmfiljmfgnfmv!=SkjojsbtbqgpkbmgofjnslqwLeej`fqfdbqgphjoopmbwjlmPslqwpgfdqfftffhoz#+f-d-afkjmggl`wlqolddfgvmjwfg?,a=?,afdjmpsobmwpbppjpwbqwjpwjppvfg033s{`bmbgbbdfm`zp`kfnfqfnbjmAqbyjopbnsofoldl!=afzlmg.p`bofb``fswpfqufgnbqjmfEllwfq`bnfqb?,k2=	\\elqn!ofbufppwqfpp!#,=	-dje!#lmolbgolbgfqL{elqgpjpwfqpvqujuojpwfmefnbofGfpjdmpjyf>!bssfbowf{w!=ofufopwkbmhpkjdkfqelq`fgbmjnbobmzlmfBeqj`bbdqffgqf`fmwSflsof?aq#,=tlmgfqsqj`fpwvqmfg#x~8nbjm!=jmojmfpvmgbztqbs!=ebjofg`fmpvpnjmvwfafb`lmrvlwfp263s{fpwbwfqfnlwffnbjo!ojmhfgqjdkw8pjdmboelqnbo2-kwnopjdmvssqjm`feolbw9-smd!#elqvn-B``fppsbsfqpplvmgpf{wfmgKfjdkwpojgfqVWE.;!%bns8#Afelqf-#TjwkpwvgjlltmfqpnbmbdfsqlejwiRvfqzbmmvbosbqbnpalvdkwebnlvpdlldofolmdfqj((*#xjpqbfopbzjmdgf`jgfklnf!=kfbgfqfmpvqfaqbm`ksjf`fpaol`h8pwbwfgwls!=?qb`jmdqfpjyf..%dw8sb`jwzpf{vboavqfbv-isd!#23/333lawbjmwjwofpbnlvmw/#Jm`-`lnfgznfmv!#ozqj`pwlgbz-jmgffg`lvmwz\\oldl-EbnjozollhfgNbqhfwopf#jeSobzfqwvqhfz*8ubq#elqfpwdjujmdfqqlqpGlnbjm~fopfxjmpfqwAold?,ellwfqoldjm-ebpwfqbdfmwp?algz#23s{#3sqbdnbeqjgbzivmjlqgloobqsob`fg`lufqpsovdjm6/333#sbdf!=alpwlm-wfpw+bubwbqwfpwfg\\`lvmwelqvnpp`kfnbjmgf{/ejoofgpkbqfpqfbgfqbofqw+bssfbqPvanjwojmf!=algz!=	)#WkfWklvdkpffjmdifqpfzMftp?,ufqjezf{sfqwjmivqztjgwk>@llhjfPWBQW#b`qlpp\\jnbdfwkqfbgmbwjufsl`hfwal{!=	Pzpwfn#Gbujg`bm`fqwbaofpsqlufgBsqjo#qfboozgqjufqjwfn!=nlqf!=albqgp`lolqp`bnsvpejqpw##X^8nfgjb-dvjwbqejmjpktjgwk9pkltfgLwkfq#-sks!#bppvnfobzfqptjoplmpwlqfpqfojfeptfgfm@vpwlnfbpjoz#zlvq#Pwqjmd		Tkjowbzolq`ofbq9qfplqweqfm`kwklvdk!*#(#!?algz=avzjmdaqbmgpNfnafqmbnf!=lssjmdpf`wlq6s{8!=upsb`fslpwfqnbilq#`leeffnbqwjmnbwvqfkbssfm?,mbu=hbmpbpojmh!=Jnbdfp>ebopftkjof#kpsb`f3%bns8#		Jm##sltfqSlophj.`lolqilqgbmAlwwlnPwbqw#.`lvmw1-kwnomftp!=32-isdLmojmf.qjdkwnjoofqpfmjlqJPAM#33/333#dvjgfpubovf*f`wjlmqfsbjq-{no!##qjdkwp-kwno.aol`hqfdF{s9klufqtjwkjmujqdjmsklmfp?,wq=vpjmd#	\nubq#=$*8	\n?,wg=	?,wq=	abkbpbaqbpjodbofdlnbdzbqslophjpqsphj4]4C5d\bTA\nzk\vBl\bQ\vUmGx\bSM\nmC\bTA	wQ\nd}\bW@\bTl\bTF	i@	cT\vBM\v|jBV	qw	cC\bWI\npa	fM\n{Z{X\bTF\bVV\bVK	mkF	[]\bPm\bTv\nsI\vpg	[I\bQpmx\v_W\n^M\npe\vQ}\vGu\nel\npeChBV\bTA	So\nzk\vGL\vxD\nd[JzMY\bQpli\nfl\npC{BNt\vwT	i_\bTgQQ\n|p\vXN\bQS\vxDQC\bWZ	pD\vVS\bTWNtYh\nzuKjN}	wr	Ha\n_D	j`\vQ}\vWp\nxZ{c	ji	BU\nbDa|	Tn	pV\nZd\nmC\vEV{X	c}	To\bWl\bUd	IQ	cg\vxs\nXW	wR\vek	c}	]y	Jn\nrp\neg\npV\nz\\{W\npl\nz\\\nzU	Pc	`{\bV@\nc|\bRw	i_\bVb\nwX	HvSu\bTF\v_W\vWs\vsIm\nTT\ndc	US	}f	iZ\bWz	c}MD	Be	iD\v@@\bTl\bPv	}tSwM`\vnU	kW\ved\nqo\vxY	A|\bTz\vy`BRBM	iaXU\nyun^	fL	iI\nXW	fD\bWz\bW@	yj	m	av	BN\vb\\	pD\bTf\nY[	Jn\bQy	[^\vWc\vyuDlCJ\vWj\vHR	`V\vuW	Qy\np@\vGuplJm\bW[\nLP\nxC\n`m	wQuiR\nbI	wQ	BZ	WVBR\npg	cgtiCW\n_y	Rg\bQa\vQB\vWc\nYble\ngESu\nL[	Q	ea	dj\v]W\nb~M`	wL\bTV\bVH\nt\npl	|bs_\bU|\bTaoQlvSkM`\bTv\vK}\nfl	cCoQBR	Hk	|d\bQp	HK	BZ\vHR\bPv\vLx\vEZ\bT\bTv	iDoDMU\vwBSuk`St\ntC	Pl	Kg\noi	jY\vxYh}\nzk\bWZ	m\ve`	TB	fE\nzk	`zYh\nV|	HK	AJ	AJ\bUL	p\\	ql\nYcKd\nfyYh	[I\vDgJm\n]n\nlb\bUd\n{Z	lu	fsoQ\bTWJm\vwB	eaYhBC	sb	Tn\nzU\n_y\vxY	Q]\ngwmt	O\\\ntb\bWW\bQy	mI	V[\ny\\\naB\vRb	wQ\n]QQJ\bWg\vWa\bQj\ntC\bVH\nYm\vxs\bVK\nel\bWI\vxYCq\ntR\vHV\bTl\bVw	ay\bQa\bVV	}t	dj\nr|	p\\	wR\n{i\nTT	[I	i[	AJ\vxs\v_W	d{\vQ}	cg	Tz	A|	Cj\vLmN}m\nbK	dZ	p\\	`V	sV\np@	iD	wQ\vQ}\bTfkaJm\v@@\bV`	zp\n@NSw	iI	cg\noiSu\bVwloCy	c}\vb\\	sUBA\bWI\bTf\nxS	Vp\nd|\bTV\vbC	NoJu\nTC	|`\n{Z	D]\bU|	c}lm\bTl	Bv	Pl	c}\bQp	m\nLk	kj\n@NSbKO	j_	p\\\nzU\bTl\bTg\bWI	cfXO\bWW\ndzli	BN\nd[\bWOMD\vKC	dj	I_\bVV\ny\\\vLmxl	xB	kV\vb\\\vJW\vVS	Vx\vxD	d{MD\bTa	|`\vPzR}\vWsBM\nsICN\bTaJm\npe	i_\npV\nrh	Rd	Hv\n~A\nxR\vWh\vWk\nxS\vAz\vwX\nbIoQ	fw\nqI\nV|\nunz\vpg	d\\\voA{D	i_xB\bT	`Vqr	TTg]CA\vuR	VJ	T`\npw\vRb	I_\nCxRo\vsICjKh	Bv	WVBBoD{D\nhcKm\v^R	QE\n{I\np@\nc|Gt	c}Dl\nzUqN	sVk}	Hh\v|j\nqou|	Q]\vekZM`St\npe	dj\bVG\veE	m\vWc|I\n[W	fL\bT	BZSu\vKaCqNtY[\nqI\bTv	fM	i@	}fB\\	Qy\vBl\bWgXDkc\vx[\bVV	Q]	a	Py\vxD\nfI	}foD	dj	SGls	~DCN\n{Z	\\v\n_D\nhc\vx_C[	AJ\nLM	VxCI	bj	c^	cF\ntCSx	wrXA\bU\\	|a\vK\\\bTV\bVj\nd|	fsCX\ntb\bRw	Vx	AE	A|\bTNt\vDg	Vc\bTld@\npo	M	cF\npe	iZ	Bo\bSq\nfHl`\bTx\bWf	HE\vF{	cO	fD\nlm\vfZ\nlm\veU	dGBH\bTV	SiMW\nwX\nz\\	\\cCX\nd}	l}\bQp\bTV	F~\bQ	`i\ng@nO\bUd\bTl\nL[	wQ	ji\ntC	|J\nLU\naB\vxYKj	AJuN	i[\npeSk\vDg\vx]\bVb\bVV\nea	kV\nqI\bTaSk\nAO	pD\ntb\nts\nyi\bVg	i_\v_W\nLkNt	yj	fMR	iI\bTl\vwX	sV\vMl\nyu	AJ\bVjKO	WV\vA}\vW\nrp	iD\v|olv\vsIBM	d~	CU\bVbeV\npC\vwT	j`	c}\vxs\vps\vvh	WV\vGg\vAe\vVK\v]W	rg\vWcF`	Br\vb\\	dZ\bQp\nqIkF\nLk\vAR\bWI\bTg	bs	dw\n{L\n_y	iZ\bTA	lg\bVV\bTl	dk\n`k	a{	i_{Awj	wN\v@@\bTe	i_\n_D	wL\nAH\viK\vek\n[]	p_	yj\bTv	US	[r\n{I\npsGt\vVK\nplS}\vWP	|dMD\vHV\bTR}M`\bTV\bVHlvCh\bW[Ke	R{\v^R	ab	BZ	VA	B`\nd|\nhsKe	BeOi	R{	d\\nB\bWZ	dZ	VJOs	muQ\vhZQ@QQ\nfI\bW[B\\li\nzU\nMdM`\nxS\bVV\n\\}\vxD	m\bTpIS\nc|	kVi~	V{\vhZ	|b\bWt\n@R\voA\vnU\bWI	ea	B`	iD	c}	TzBR\vQBNj	CP	[I\bTv	`WuN\vpg\vpg\vWc	iT	bs	wL	U_	c\\	|h\vKa	Nr	fL\nq|\nzu\nz\\	Nr\bUg	|bm`\bTv\nyd\nrp\bWf	UXBV\nzk\nd}	wQ	}fCe\ved\bTW\bSB\nxU	cn\bTb\ne	a\\	SG\bU|\npV\nN\\Kn\vnU	At	pD\v^R\vIrb[	R{	dE\vxD\vWK\vWA\bQL\bW@Su\bUd\nDM	PcCADloQ	Hswiub\na\bQpOb\nLP\bTlY[\vK}	AJ\bQn^\vsA\bSM\nqM\bWZ\n^W\vz{S|	fD\bVK\bTv\bPvBB	CPdF	id\vxsmx\vws	cC\ntC	ycM`\vW\nrh\bQp\vxD\\o\nsI_k\nzukF	fDXsXO	jp\bTvBS{B	Br\nzQ\nbI	c{BDBVnO\bTF	caJd	fL	PV	I_\nlK`o	wX\npa	gu\bP}{^\bWf\n{I	BN\npaKl\vpg	cn	fL\vvhCq\bTl\vnU\bSqCm	wR\bUJ\npe\nyd\nYgCy\vKW	fD\neaoQ	j_	BvnM\vID\bTa\nzApl\n]n\bTa	R{	fr\n_y\bUg{Xkk\vxD|Ixl\nfyCe\vwB\nLk\vd]\noi\n}h	Q]\npe\bVwHkOQ\nzk	AJ\npV\bPv\ny\\	A{Oi\bSBXA\veE	jp\nq}	iDqN\v^R	m	iZ	Br\bVg\noi\n\\X	U_\nc|\vHV\bTf	Tn\\N\\N\nuBlv\nyu	Td\bTf\bPL\v]W	dG\nA`\nw^\ngI\npe	dw\nz\\ia\bWZ	cFJm\n{Z\bWO_kDfRR	d\\\bVV\vxsBNtilm	Td	]y\vHV	So\v|jXX	A|\vZ^\vGu\bTWM`kF\vhZ\vVK	dG\vBl	ay\nxUqEnO\bVw\nqICX\ne	Pl\bWO\vLm	dLuHCm	dTfn\vwBka\vnU\n@M\nyT	Hv	\\}Kh	d~Yhk}\neR	d\\\bWI	|b	HK	iD\bTWMY\npl\bQ_	wr\vAx	HE\bTg\bSqvp\vb\\\bWO\nOl\nsI\nfy\vID	\\c\n{Z\n^~\npe\nAO	TT\vxvk_\bWO\v|j\vwB	Qy	i@	Pl	Ha	dZk}ra	UT\vJc\ved\np@	QN\nd|	kj	HkM`\noi	wr	d\\\nlq\no_\nlb\nL[	acBBBHCm\npl	IQ\bVK\vxs\n`e\viK\npaOi	US\bTp	fD\nPGkkXA\nz\\\neg\vWh	wRqN\nqS	cnlo\nxS\n^W	BU\nt	HE	p\\	fF	fw\bVV\bW@	ak\vVKls	VJ\bVV\veE\\o\nyX\nYmM`lL\nd|\nzk	A{sE	wQXT\nt	Pl	]y\vwT{pMD\vb\\	Q]Kj	Jn\nAH\vRb	BU	HK	\\c\nfIm\nqM\n@R	So\noiBT	Hv\n_yKh	BZ	]i\bUJ	V{Sr\nbI\vGg	a_\bTR\nfI\nfl	[K	IIS|\vuW	iI\bWI\nqI\v|jBV\bVg\bWZkF\vx]\bTA	ab	fr	i@	Jd	Jd\vps\nAO\bTaxu	iD\nzk	|d	|`\bW[	lP	dG\bVV\vw}\vqO	i[\bQ\bTz\vVF	wNts	dw\bTv\neS\ngi	NryS\npe\bVV\bSq\n`m	yj	BZ\vWX\bSB	c\\\nUR	[J	c_nM\bWQ\vAx\nMd	Brui\vxY\bSM\vWc\v|j\vxs	}Q	BO\bPL\bWW	fM\nAO	Pc\veUe^\bTg\nqI	ac\bPv	cFoQ	Q\vhZka\nz\\	iK	BU\n`k	CPS|M`\n{I	S{_O	BZZiSk	ps	p\\\nYu\n]s\nxC\bWt\nbD	kV\vGuyS\nqA	[r\neKM`	dZlL\bUg\bTl\nbD	US\vb\\	pV\nccS\\	ct	`z\bPL\vWs\nA`\neg\bSquECR\vDg	`W\vz{\vWcSkSk	bW\bUg	ea\nxZ	iI	UX	VJ\nqn	S{\vRb\bTQ\nplGt\vuWuj\npF\nqI	fL	[I	iaXO\nyu\vDg\ved	q{VG\bQka	Vj	kV	xB\nd|\np@	QN	Pc	ps]j	kV	oU\bTp\nzUnB\vB]	a{\bV@\n]nm`	cz	R{m`\bQa\vwT\bSMMYqN	dj~s\vQ}MY\vMB	Bv	wR\bRg\vQ}	ql\vKC\nrmxuCC\vwB\vvh	BqXq\npV	i_ObuE\nbd\nqo\v{i\nC~	BL\veEuH\bVjEyGz\vzR\v{i	cf\n{Z\n]nXA\vGu\vnU	hS\vGI\nCc	HE\bTA	HBBHCj\nCc\bTF	HE\nXI	A{\bQ	c\\\vmO\vWX\nfH\np@MY\bTF\nlK	Bt\nzU	TTKm\vwT\npV\ndt\vyI	Vx	Q	Rg	Td\nzU\bRS\nLM	wAnM	Tn\ndS	]g\nLc\vwB	}t	[I	CPkX\vFm\vhZm	i[\np@\vQ}\vW	|d\nMO\nMd	f_	fD	cJ	Hz\vRb	io	PyY[\nxU	ct\v@@	ww\bPvBMFF\ntbv|\vKm	Bq	BqKh`o\nZdXU	i]	|`	StB\\\bQ\v_W	TJ\nqI	|a	A{\vuPMD	Pl\nxR	fL\vws	c{	d\\\bV`\neg	HKkc\nd|\bVV\ny\\kc	i]\bVG	`V	ss	I_	AE	bs	du\nel	pD\vW\nqslv\bSMZi\vVKia\vQB	Q\n{Z\bPt\vKl\nlK\nhs\ndS\bVKmf\nd^	kV	cO\nc|\bVH	\\]\bTv\bSq	mI\vDg	VJ	cn\ny\\\bVg\bTv\nyX\bTF	]]\bTp\noi\nhs\veU\nBf	djMr\n|p	\\g	]r\bVb{D\nd[XN	fM	O\\s_	cf	iZXN\vWc	qv\n`m	U^oD\nd|\vGg	dE\vwflou}\nd|oQ	`iOi\vxD\ndZ\nCxYw\nzk\ntb\ngw	yj	B`\nyX\vps\ntC\vpP\vqw\bPu\bPX	Dm\npwNj	ss	aG\vxs\bPt\noLGz	Ok	i@	i]eC	IQ	ii	dj\v@J	|duh\bWZ\veU\vnU\bTa	cCg]\nzkYh\bVK\nLU\np@\ntb\ntR	Cj\vNP	i@\bP{\n\\}\n{c\nwX	fL\bVG	c{	|`	AJ	|C	fDln	|d	bs\nqI{B\vAx\np@\nzk\vRbOs\vWSe^\vD_	Bv\vWd\bVb\vxs\veE\bRw\n]n\n|p\vg|	fwkc\bTIka\n\\TSp	ju\vps\npeu|\vGr\bVe	CU]MXU\vxD\bTa	IQ\vWq	CU	am	dj\bSoSw\vnUCh	Q]s_\bPt	fS\bTa	\\}\n@OYc	UZ\bTx\npe\vnU\nzU	|}	iD\nz\\\bSM\vxDBR\nzQ	QN]MYh\nLP\vFm\vLXvc\vqlka	HK\bVb\ntC\nCy\bTv\nuVoQ	`z	[I	B`\vRb	yj	sb\vWs\bTl	kV\ved\nelL\vxN	m\nJn	jY\vxD\bVb\bSq\vyu	wL\vXL\bTA	pg	At	nDXX	wR\npl\nhwyS\nps	cO\bW[\v|jXN	sV	p\\	Be\nb~\nAJ\n]ek`qN	dw	WV	HE\vEVJz	id	B`	zhE]	fD\bTgqN\bTa	jaCv\bSM\nhc\bUet_	ieg]	wQ\nPn\bVB	jw\bVg\vbE	BZ\vRH\bP{	jp\n\\}	a_	cC	|a\vD]	BZ	i[	fD\vxW\no_	d\\\n_D\ntb	\\c	AJ\nlKoQlo\vLx\vM@\bWZKn\vpg\nTi\nIv\n|r\v@}JzLmWhk}ln\vxD\n]sgc\vps	Br\bTW\vBMtZ\nBYDW	jf\vSWC}\nqo	dE	mv	IQ\bPP\bUblvBC\nzQ	[I\vgl\nig\bUsBT\vbC\bSq	sU	iW\nJn	SY	HK	rg\npV\vID\v|jKO	`S	|a`vbmglfmujbqnbgqjgavp`bqjmj`jlwjfnslslqrvf`vfmwbfpwbglsvfgfmivfdlp`lmwqbfpw/Mmmlnaqfwjfmfmsfqejonbmfqbbnjdlp`jvgbg`fmwqlbvmrvfsvfgfpgfmwqlsqjnfqsqf`jlpfd/Vmavfmlpuloufqsvmwlppfnbmbkba/Abbdlpwlmvfulpvmjglp`bqolpfrvjslmj/]lpnv`klpbodvmb`lqqfljnbdfmsbqwjqbqqjabnbq/Abklnaqffnsoflufqgbg`bnajlnv`kbpevfqlmsbpbglo/Amfbsbqf`fmvfubp`vqplpfpwbabrvjfqlojaqlp`vbmwlb``fplnjdvfoubqjlp`vbwqlwjfmfpdqvslppfq/Mmfvqlsbnfgjlpeqfmwfb`fq`bgfn/Mplefqwb`l`kfpnlgfoljwbojbofwqbpbod/Vm`lnsqb`vbofpf{jpwf`vfqslpjfmglsqfmpboofdbqujbifpgjmfqlnvq`jbslgq/Msvfpwlgjbqjlsvfaolrvjfqfnbmvfosqlsjl`qjpjp`jfqwlpfdvqlnvfqwfevfmwf`fqqbqdqbmgffef`wlsbqwfpnfgjgbsqlsjbleqf`fwjfqqbf.nbjoubqjbpelqnbpevwvqllaifwlpfdvjqqjfpdlmlqnbpnjpnlp/Vmj`l`bnjmlpjwjlpqby/_mgfajglsqvfabwlofglwfm/Abifp/Vpfpsfql`l`jmblqjdfmwjfmgb`jfmwl`/Mgjykbaobqpfq/Abobwjmbevfqybfpwjoldvfqqbfmwqbq/E{jwlo/_sfybdfmgbu/Agflfujwbqsbdjmbnfwqlpibujfqsbgqfpe/M`jo`bafyb/Mqfbppbojgbfmu/Alibs/_mbavplpajfmfpwf{wlpoofubqsvfgbmevfqwf`ln/Vm`obpfpkvnbmlwfmjglajoablvmjgbgfpw/Mpfgjwbq`qfbgl<X<W=c=k=n<R<V<\\<V<T<W<T=a=n<R<^=m<Y<Y<_<R<S=l<T=n<\\<V<Y=e<Y=o<Z<Y<v<\\<V<]<Y<[<]=g<W<R<Q<T<~=m<Y<S<R<X<A=n<R=n<R<P=k<Y<P<Q<Y=n<W<Y=n=l<\\<[<R<Q<\\<_<X<Y<P<Q<Y<x<W=c<s=l<T<Q<\\=m<Q<T=i=n<Y<P<V=n<R<_<R<X<^<R=n=n<\\<P<M<D<|<P<\\=c<K=n<R<^<\\=m<^<\\<P<Y<P=o<N<\\<V<X<^<\\<Q<\\<P=a=n<T=a=n=o<~<\\<P=n<Y=i<S=l<R=n=o=n<Q<\\<X<X<Q=c<~<R=n=n=l<T<Q<Y<U<~<\\=m<Q<T<P=m<\\<P=n<R=n=l=o<]<r<Q<T<P<T=l<Q<Y<Y<r<r<r<W<T=j=a=n<\\<r<Q<\\<Q<Y<P<X<R<P<P<R<U<X<^<Y<R<Q<R=m=o<X\fHy\fIk\fHU\fId\fHy\fIl\fHT\fIk\fHy\fHR\fHy\fIg\fHx\fH\\\fHF\fH\\\fHD\fIk\fHc\fHy\fHy\fHS\fHA\fIl\fHk\fHT\fHy\fH\\\fHH\fIg\fHU\fIg\fHj\fHF\fHU\fIl\fHC\fHU\fHC\fHR\fHH\fHy\fHI\fHRibdqbm\fHj\fHp\fHp\fIg\fHi\fH@\fHJ\fIg\fH{\fHd\fHp\fHR\fH{\fHc\fHU\fHB\fHk\fHD\fHY\fHU\fHC\fIk\fHI\fIk\fHI\fIl\fHt\fH\\\fHp\fH@\fHJ\fIl\fHy\fHd\fHp\fIl\fHY\fIk\fHD\fHd\fHD\fHc\fHU\fH\\\fHe\fHT\fHB\fIk\fHy\fHB\fHY\fIg\fH^\fIk\fHT\fH@\fHB\fHd\fHJ\fIk\fH\fH\\\fHj\fHB\fH@\fHT\fHA\fH\\\fH@\fHD\fHv\fH^\fHB\fHD\fHj\fH{\fHT\fIl\fH^\fIl4U5h5e4I5h5e5k4\\4K4N4B4]4U4C4C4K5h5e5k4\\5k4Y5d4]4V5f4]5o4K5j5d5h4K4D5f5j4U4]4Z4\\5h5o5k5j4K5f5d5i5n4K5h4U5h5f4K5j4K5h5o5j4A4F5e5n4D5h5d4A4E4K4B4]5m5n4[4U4D4C4]5o5j4I4\\4K5o5i4K4K4A4C4I5h4K5m5f5k4D4U4Z5o5f5m4D4A4G5d5i5j5d5k5d4O5j4K4@4C4K5h5k4K4_5h5i4U5j4C5h5f4_4U4D4]4Y5h5e5i5j4\\4D5k4K4O5j5k5i4G5h5o5j4F4K5h4K4A5f4G5i4Y4]4X4]4A4A5d5h5d5m5f4K4\\4K5h5o5h5i4]4E4K5j4F4K5h5m4O4D5d4B4K4Y4O5j4F4K5j5k4K5h5f4U4Z5d5d5n4C4K4D5j4B5f4]4D5j4F5h5o5i4X4K4M5d5k5f4K4D5d5n4Y4Y5d5i4K4]5n5i4O4A4C5j4A5j4U4C5i4]4O5f4K4A4E5o4F4D4C5d5j5f4@4D5i5j5k4F4A4F4@5k4E4_5j4E5f4F5i5o4]4E4V4^4E5j5m4_4D5f4F5h5h5k5h5j4K4F5h5o5n5h4D5h5i4K4U5j5k4O5d5h4X5f4M5j5d4]4O5i4K5m5f5o4D5o5h4\\4K4F4]4F4D4D4O5j5k5i4_4K5j5o4D5f4U5m5n4C4A4_5j5h5k5i4X4U4]4O5k5h4X5k4]5n4[4]4[5h4Dsqlejofpfquj`fgfebvowkjnpfoegfwbjop`lmwfmwpvsslqwpwbqwfgnfppbdfpv``fppebpkjlm?wjwof=`lvmwqzb``lvmw`qfbwfgpwlqjfpqfpvowpqvmmjmdsql`fpptqjwjmdlaif`wpujpjaoftfo`lnfbqwj`ofvmhmltmmfwtlqh`lnsbmzgzmbnj`aqltpfqsqjub`zsqlaofnPfquj`fqfpsf`wgjpsobzqfrvfpwqfpfquftfapjwfkjpwlqzeqjfmgplswjlmptlqhjmdufqpjlmnjoojlm`kbmmfotjmglt-bggqfppujpjwfgtfbwkfq`lqqf`wsqlgv`wfgjqf`welqtbqgzlv#`bmqfnlufgpvaif`w`lmwqlobq`kjuf`vqqfmwqfbgjmdojaqbqzojnjwfgnbmbdfqevqwkfqpvnnbqznb`kjmfnjmvwfpsqjubwf`lmwf{wsqldqbnpl`jfwzmvnafqptqjwwfmfmbaofgwqjddfqplvq`fpolbgjmdfofnfmwsbqwmfqejmboozsfqef`wnfbmjmdpzpwfnphffsjmd`vowvqf%rvlw8/ilvqmbosqlif`wpvqeb`fp%rvlw8f{sjqfpqfujftpabobm`fFmdojpk@lmwfmwwkqlvdkSofbpf#lsjmjlm`lmwb`wbufqbdfsqjnbqzujoobdfPsbmjpkdboofqzgf`ojmfnffwjmdnjppjlmslsvobqrvbojwznfbpvqfdfmfqbopsf`jfppfppjlmpf`wjlmtqjwfqp`lvmwfqjmjwjboqfslqwpejdvqfpnfnafqpklogjmdgjpsvwffbqojfqf{sqfppgjdjwbosj`wvqfBmlwkfqnbqqjfgwqbeej`ofbgjmd`kbmdfg`fmwqbouj`wlqzjnbdfp,qfbplmppwvgjfpefbwvqfojpwjmdnvpw#afp`kllopUfqpjlmvpvboozfsjplgfsobzjmddqltjmdlaujlvplufqobzsqfpfmwb`wjlmp?,vo=	tqbssfqboqfbgz`fqwbjmqfbojwzpwlqbdfbmlwkfqgfphwlsleefqfgsbwwfqmvmvpvboGjdjwbo`bsjwboTfapjwfebjovqf`lmmf`wqfgv`fgBmgqljggf`bgfpqfdvobq#%bns8#bmjnbopqfofbpfBvwlnbwdfwwjmdnfwklgpmlwkjmdSlsvobq`bswjlmofwwfqp`bswvqfp`jfm`foj`fmpf`kbmdfpFmdobmg>2%bns8Kjpwlqz#>#mft#@fmwqbovsgbwfgPsf`jboMfwtlqhqfrvjqf`lnnfmwtbqmjmd@loofdfwlloabqqfnbjmpaf`bvpffof`wfgGfvwp`kejmbm`ftlqhfqprvj`hozafwtffmf{b`wozpfwwjmdgjpfbpfPl`jfwztfbslmpf{kjajw%ow8"..@lmwqlo`obppfp`lufqfglvwojmfbwwb`hpgfuj`fp+tjmgltsvqslpfwjwof>!Nlajof#hjoojmdpkltjmdJwbojbmgqlssfgkfbujozfeef`wp.2$^*8	`lmejqn@vqqfmwbgubm`fpkbqjmdlsfmjmdgqbtjmdajoojlmlqgfqfgDfqnbmzqfobwfg?,elqn=jm`ovgftkfwkfqgfejmfgP`jfm`f`bwboldBqwj`ofavwwlmpobqdfpwvmjelqnilvqmfzpjgfabq@kj`bdlklojgbzDfmfqbosbppbdf/%rvlw8bmjnbwfeffojmdbqqjufgsbppjmdmbwvqboqlvdkoz-		Wkf#avw#mlwgfmpjwzAqjwbjm@kjmfpfob`h#lewqjavwfJqfobmg!#gbwb.eb`wlqpqf`fjufwkbw#jpOjaqbqzkvpabmgjm#eb`wbeebjqp@kbqofpqbgj`boaqlvdkwejmgjmdobmgjmd9obmd>!qfwvqm#ofbgfqpsobmmfgsqfnjvnsb`hbdfBnfqj`bFgjwjlm^%rvlw8Nfppbdfmffg#wlubovf>!`lnsof{ollhjmdpwbwjlmafojfufpnboofq.nlajofqf`lqgptbmw#wlhjmg#leEjqfel{zlv#bqfpjnjobqpwvgjfgnb{jnvnkfbgjmdqbsjgoz`ojnbwfhjmdglnfnfqdfgbnlvmwpelvmgfgsjlmffqelqnvobgzmbpwzklt#wl#Pvsslqwqfufmvff`lmlnzQfpvowpaqlwkfqplogjfqobqdfoz`boojmd-%rvlw8B``lvmwFgtbqg#pfdnfmwQlafqw#feelqwpSb`jej`ofbqmfgvs#tjwkkfjdkw9tf#kbufBmdfofpmbwjlmp\\pfbq`kbssojfgb`rvjqfnbppjufdqbmwfg9#ebopfwqfbwfgajddfpwafmfejwgqjujmdPwvgjfpnjmjnvnsfqkbspnlqmjmdpfoojmdjp#vpfgqfufqpfubqjbmw#qlof>!njppjmdb`kjfufsqlnlwfpwvgfmwplnflmff{wqfnfqfpwlqfalwwln9fuloufgboo#wkfpjwfnbsfmdojpktbz#wl##Bvdvpwpznalop@lnsbmznbwwfqpnvpj`bobdbjmpwpfqujmd~*+*8	sbznfmwwqlvaof`lm`fsw`lnsbqfsbqfmwpsobzfqpqfdjlmpnlmjwlq#$$Wkf#tjmmjmdf{solqfbgbswfgDboofqzsqlgv`fbajojwzfmkbm`f`bqffqp*-#Wkf#`loof`wPfbq`k#bm`jfmwf{jpwfgellwfq#kbmgofqsqjmwfg`lmplofFbpwfqmf{slqwptjmgltp@kbmmfojoofdbomfvwqbopvddfpw\\kfbgfqpjdmjmd-kwno!=pfwwofgtfpwfqm`bvpjmd.tfahjw`objnfgIvpwj`f`kbswfquj`wjnpWklnbp#nlyjoobsqlnjpfsbqwjfpfgjwjlmlvwpjgf9ebopf/kvmgqfgLoznsj`\\avwwlmbvwklqpqfb`kfg`kqlmj`gfnbmgppf`lmgpsqlwf`wbglswfgsqfsbqfmfjwkfqdqfbwozdqfbwfqlufqboojnsqluf`lnnbmgpsf`jbopfbq`k-tlqpkjsevmgjmdwklvdkwkjdkfpwjmpwfbgvwjojwzrvbqwfq@vowvqfwfpwjmd`ofbqozf{slpfgAqltpfqojafqbo~#`bw`kSqlif`wf{bnsofkjgf+*8EolqjgbbmptfqpbooltfgFnsfqlqgfefmpfpfqjlvpeqffglnPfufqbo.avwwlmEvqwkfqlvw#le#">#mvoowqbjmfgGfmnbqhuljg+3*,boo-ipsqfufmwQfrvfpwPwfskfm		Tkfm#lapfquf?,k1=	Nlgfqm#sqlujgf!#bow>!alqgfqp-		Elq#		Nbmz#bqwjpwpsltfqfgsfqelqnej`wjlmwzsf#lenfgj`bowj`hfwplsslpfg@lvm`jotjwmfppivpwj`fDflqdf#Afodjvn---?,b=wtjwwfqmlwbaoztbjwjmdtbqebqf#Lwkfq#qbmhjmdskqbpfpnfmwjlmpvqujufp`klobq?,s=	#@lvmwqzjdmlqfgolpp#leivpw#bpDflqdjbpwqbmdf?kfbg=?pwlssfg2$^*8	jpobmgpmlwbaofalqgfq9ojpw#le`bqqjfg233/333?,k0=	#pfufqboaf`lnfppfof`w#tfggjmd33-kwnonlmbq`klee#wkfwfb`kfqkjdkoz#ajloldzojef#lelq#fufmqjpf#le%qbrvl8sovplmfkvmwjmd+wklvdkGlvdobpiljmjmd`jq`ofpElq#wkfBm`jfmwUjfwmbnufkj`ofpv`k#bp`qzpwboubovf#>Tjmgltpfmilzfgb#pnboobppvnfg?b#jg>!elqfjdm#Boo#qjklt#wkfGjpsobzqfwjqfgkltfufqkjggfm8abwwofppffhjmd`bajmfwtbp#mlwollh#bw`lmgv`wdfw#wkfIbmvbqzkbssfmpwvqmjmdb9klufqLmojmf#Eqfm`k#ob`hjmdwzsj`bof{wqb`wfmfnjfpfufm#jedfmfqbwgf`jgfgbqf#mlw,pfbq`kafojfep.jnbdf9ol`bwfgpwbwj`-oldjm!=`lmufqwujlofmwfmwfqfgejqpw!=`jq`vjwEjmobmg`kfnjpwpkf#tbp23s{8!=bp#pv`kgjujgfg?,psbm=tjoo#afojmf#leb#dqfbwnzpwfqz,jmgf{-eboojmdgvf#wl#qbjotbz`loofdfnlmpwfqgfp`fmwjw#tjwkmv`ofbqIftjpk#sqlwfpwAqjwjpkeoltfqpsqfgj`wqfelqnpavwwlm#tkl#tbpof`wvqfjmpwbmwpvj`jgfdfmfqj`sfqjlgpnbqhfwpPl`jbo#ejpkjmd`lnajmfdqbskj`tjmmfqp?aq#,=?az#wkf#MbwvqboSqjub`z`llhjfplvw`lnfqfploufPtfgjpkaqjfeozSfqpjbmpl#nv`k@fmwvqzgfsj`wp`lovnmpklvpjmdp`qjswpmf{w#wlafbqjmdnbssjmdqfujpfgiRvfqz+.tjgwk9wjwof!=wllowjsPf`wjlmgfpjdmpWvqhjpkzlvmdfq-nbw`k+~*+*8		avqmjmdlsfqbwfgfdqffpplvq`f>Qj`kbqg`olpfozsobpwj`fmwqjfp?,wq=	`lolq9 vo#jg>!slppfppqloojmdskzpj`pebjojmdf{f`vwf`lmwfpwojmh#wlGfebvow?aq#,=	9#wqvf/`kbqwfqwlvqjpn`obppj`sql`ffgf{sobjm?,k2=	lmojmf-<{no#ufkfosjmdgjbnlmgvpf#wkfbjqojmffmg#..=*-bwwq+qfbgfqpklpwjmd eeeeeeqfbojyfUjm`fmwpjdmbop#pq`>!,Sqlgv`wgfpsjwfgjufqpfwfoojmdSvaoj`#kfog#jmIlpfsk#wkfbwqfbeef`wp?pwzof=b#obqdfglfpm$wobwfq/#Fofnfmwebuj`lm`qfbwlqKvmdbqzBjqslqwpff#wkfpl#wkbwNj`kbfoPzpwfnpSqldqbnp/#bmg##tjgwk>f%rvlw8wqbgjmdofew!=	sfqplmpDlogfm#Beebjqpdqbnnbqelqnjmdgfpwqlzjgfb#le`bpf#lelogfpw#wkjp#jp-pq`#>#`bqwllmqfdjpwq@lnnlmpNvpojnpTkbw#jpjm#nbmznbqhjmdqfufbopJmgffg/frvbooz,pklt\\blvwgllqfp`bsf+Bvpwqjbdfmfwj`pzpwfn/Jm#wkf#pjwwjmdKf#boplJpobmgpB`bgfnz	\n\n?"..Gbmjfo#ajmgjmdaol`h!=jnslpfgvwjojyfBaqbkbn+f{`fswxtjgwk9svwwjmd*-kwno+#X^8	GBWBX#)hjw`kfmnlvmwfgb`wvbo#gjbof`wnbjmoz#\\aobmh$jmpwboof{sfqwpje+wzsfJw#bopl%`lsz8#!=Wfqnpalqm#jmLswjlmpfbpwfqmwbohjmd`lm`fqmdbjmfg#lmdljmdivpwjez`qjwj`peb`wlqzjwp#ltmbppbvowjmujwfgobpwjmdkjp#ltmkqfe>!,!#qfo>!gfufols`lm`fqwgjbdqbngloobqp`ovpwfqsks<jg>bo`lklo*8~*+*8vpjmd#b=?psbm=ufppfopqfujuboBggqfppbnbwfvqbmgqljgboofdfgjoomfpptbohjmd`fmwfqprvbojeznbw`kfpvmjejfgf{wjm`wGfefmpfgjfg#jm	\n?"..#`vpwlnpojmhjmdOjwwof#Allh#lefufmjmdnjm-ip<bqf#wkfhlmwbhwwlgbz$p-kwno!#wbqdfw>tfbqjmdBoo#Qjd8	~*+*8qbjpjmd#Bopl/#`qv`jbobalvw!=gf`obqf..=	?p`ejqfel{bp#nv`kbssojfpjmgf{/#p/#avw#wzsf#>#		?"..wltbqgpQf`lqgpSqjubwfElqfjdmSqfnjfq`klj`fpUjqwvboqfwvqmp@lnnfmwSltfqfgjmojmf8slufqwz`kbnafqOjujmd#ulovnfpBmwklmzoldjm!#QfobwfgF`lmlnzqfb`kfp`vwwjmddqbujwzojef#jm@kbswfq.pkbgltMlwbaof?,wg=	#qfwvqmpwbgjvntjgdfwpubqzjmdwqbufopkfog#aztkl#bqftlqh#jmeb`vowzbmdvobqtkl#kbgbjqslqwwltm#le		Plnf#$`oj`h$`kbqdfphfztlqgjw#tjoo`jwz#le+wkjp*8Bmgqft#vmjrvf#`kf`hfglq#nlqf033s{8#qfwvqm8qpjlm>!sovdjmptjwkjm#kfqpfoePwbwjlmEfgfqboufmwvqfsvaojpkpfmw#wlwfmpjlmb`wqfpp`lnf#wlejmdfqpGvhf#lesflsof/f{soljwtkbw#jpkbqnlmzb#nbilq!9!kwwsjm#kjp#nfmv!=	nlmwkozleej`fq`lvm`jodbjmjmdfufm#jmPvnnbqzgbwf#leolzbowzejwmfppbmg#tbpfnsfqlqpvsqfnfPf`lmg#kfbqjmdQvppjbmolmdfpwBoafqwbobwfqbopfw#le#pnboo!=-bssfmggl#tjwkefgfqboabmh#leafmfbwkGfpsjwf@bsjwbodqlvmgp*/#bmg#sfq`fmwjw#eqln`olpjmd`lmwbjmJmpwfbgejewffmbp#tfoo-zbkll-qfpslmgejdkwfqlap`vqfqfeof`wlqdbmj`>#Nbwk-fgjwjmdlmojmf#sbggjmdb#tkloflmfqqlqzfbq#lefmg#le#abqqjfqtkfm#jwkfbgfq#klnf#leqfpvnfgqfmbnfgpwqlmd=kfbwjmdqfwbjmp`olvgeqtbz#le#Nbq`k#2hmltjmdjm#sbqwAfwtffmofpplmp`olpfpwujqwvboojmhp!=`qlppfgFMG#..=ebnlvp#btbqgfgOj`fmpfKfbowk#ebjqoz#tfbowkznjmjnboBeqj`bm`lnsfwfobafo!=pjmdjmdebqnfqpAqbpjo*gjp`vppqfsob`fDqfdlqzelmw#`lsvqpvfgbssfbqpnbhf#vsqlvmgfgalwk#leaol`hfgpbt#wkfleej`fp`lolvqpje+gl`vtkfm#kffmelq`fsvpk+evBvdvpw#VWE.;!=Ebmwbpzjm#nlpwjmivqfgVpvboozebqnjmd`olpvqflaif`w#gfefm`fvpf#le#Nfgj`bo?algz=	fujgfmwaf#vpfghfz@lgfpj{wffmJpobnj` 333333fmwjqf#tjgfoz#b`wjuf#+wzsflelmf#`bm`lolq#>psfbhfqf{wfmgpSkzpj`pwfqqbjm?walgz=evmfqboujftjmdnjggof#`qj`hfwsqlskfwpkjewfggl`wlqpQvppfoo#wbqdfw`lnsb`wbodfaqbpl`jbo.avoh#lenbm#bmg?,wg=	#kf#ofew*-ubo+*ebopf*8oldj`boabmhjmdklnf#wlmbnjmd#Bqjylmb`qfgjwp*8	~*8	elvmgfqjm#wvqm@loojmpafelqf#Avw#wkf`kbqdfgWjwof!=@bswbjmpsfoofgdlggfppWbd#..=Bggjmd9avw#tbpQf`fmw#sbwjfmwab`h#jm>ebopf%Ojm`lomtf#hmlt@lvmwfqIvgbjpnp`qjsw#bowfqfg$^*8	##kbp#wkfvm`ofbqFufmw$/alwk#jmmlw#boo		?"..#sob`jmdkbqg#wl#`fmwfqplqw#le`ojfmwppwqffwpAfqmbqgbppfqwpwfmg#wlebmwbpzgltm#jmkbqalvqEqffglniftfoqz,balvw--pfbq`kofdfmgpjp#nbgfnlgfqm#lmoz#lmlmoz#wljnbdf!#ojmfbq#sbjmwfqbmg#mlwqbqfoz#b`qlmzngfojufqpklqwfq33%bns8bp#nbmztjgwk>!,)#?"X@wjwof#>le#wkf#oltfpw#sj`hfg#fp`bsfgvpfp#lesflsofp#Svaoj`Nbwwkftwb`wj`pgbnbdfgtbz#elqobtp#lefbpz#wl#tjmgltpwqlmd##pjnsof~`bw`k+pfufmwkjmelal{tfmw#wlsbjmwfg`jwjyfmJ#glm$wqfwqfbw-#Plnf#tt-!*8	alnajmdnbjowl9nbgf#jm-#Nbmz#`bqqjfpx~8tjtlqh#lepzmlmzngfefbwpebulqfglswj`bosbdfWqbvmofpp#pfmgjmdofew!=?`lnP`lqBoo#wkfiRvfqz-wlvqjpw@obppj`ebopf!#Tjokfonpvavqapdfmvjmfajpklsp-psojw+dolabo#elooltpalgz#lemlnjmbo@lmwb`wpf`vobqofew#wl`kjfeoz.kjggfm.abmmfq?,oj=		-#Tkfm#jm#alwkgjpnjppF{solqfbotbzp#ujb#wkfpsb/]lotfoebqfqvojmd#bqqbmdf`bswbjmkjp#plmqvof#lekf#wllhjwpfoe/>3%bns8+`boofgpbnsofpwl#nbhf`ln,sbdNbqwjm#Hfmmfgzb``fswpevoo#lekbmgofgAfpjgfp,,..=?,baof#wlwbqdfwpfppfm`fkjn#wl#jwp#az#`lnnlm-njmfqbowl#wbhftbzp#wlp-lqd,obgujpfgsfmbowzpjnsof9je#wkfzOfwwfqpb#pklqwKfqafqwpwqjhfp#dqlvsp-ofmdwkeojdkwplufqobspoltoz#ofppfq#pl`jbo#?,s=	\n\njw#jmwlqbmhfg#qbwf#levo=	##bwwfnswsbjq#lenbhf#jwHlmwbhwBmwlmjlkbujmd#qbwjmdp#b`wjufpwqfbnpwqbssfg!*-`pp+klpwjofofbg#wlojwwof#dqlvsp/Sj`wvqf..=		#qltp>!#laif`wjmufqpf?ellwfq@vpwlnU=?_,p`qploujmd@kbnafqpobufqztlvmgfgtkfqfbp">#$vmgelq#boosbqwoz#.qjdkw9Bqbajbmab`hfg#`fmwvqzvmjw#lenlajof.Fvqlsf/jp#klnfqjph#legfpjqfg@ojmwlm`lpw#lebdf#le#af`lnf#mlmf#les%rvlw8Njggof#fbg$*X3@qjwj`ppwvgjlp=%`lsz8dqlvs!=bppfnaonbhjmd#sqfppfgtjgdfw-sp9!#<#qfavjowaz#plnfElqnfq#fgjwlqpgfobzfg@bmlmj`kbg#wkfsvpkjmd`obpp>!avw#bqfsbqwjboAbazolmalwwln#`bqqjfq@lnnbmgjwp#vpfBp#tjwk`lvqpfpb#wkjqggfmlwfpbopl#jmKlvpwlm13s{8!=b``vpfgglvaof#dlbo#leEbnlvp#*-ajmg+sqjfpwp#Lmojmfjm#Ivozpw#(#!d`lmpvowgf`jnbokfosevoqfujufgjp#ufqzq$($jswolpjmd#efnbofpjp#boplpwqjmdpgbzp#lebqqjuboevwvqf#?laif`welq`jmdPwqjmd+!#,=	\n\nkfqf#jpfm`lgfg-##Wkf#aboollmglmf#az,`lnnlmad`lolqobt#le#Jmgjbmbbuljgfgavw#wkf1s{#0s{irvfqz-bewfq#bsloj`z-nfm#bmgellwfq.>#wqvf8elq#vpfp`qffm-Jmgjbm#jnbdf#>ebnjoz/kwws9,,#%maps8gqjufqpfwfqmbopbnf#bpmlwj`fgujftfqp~*+*8	#jp#nlqfpfbplmpelqnfq#wkf#mftjp#ivpw`lmpfmw#Pfbq`ktbp#wkftkz#wkfpkjssfgaq=?aq=tjgwk9#kfjdkw>nbgf#le`vjpjmfjp#wkbwb#ufqz#Bgnjqbo#ej{fg8mlqnbo#NjppjlmSqfpp/#lmwbqjl`kbqpfwwqz#wl#jmubgfg>!wqvf!psb`jmdjp#nlpwb#nlqf#wlwboozeboo#le~*8	##jnnfmpfwjnf#jmpfw#lvwpbwjpezwl#ejmggltm#wlolw#le#Sobzfqpjm#Ivmfrvbmwvnmlw#wkfwjnf#wlgjpwbmwEjmmjpkpq`#>#+pjmdof#kfos#leDfqnbm#obt#bmgobafofgelqfpwp`llhjmdpsb`f!=kfbgfq.tfoo#bpPwbmofzaqjgdfp,dolabo@qlbwjb#Balvw#X3^8	##jw/#bmgdqlvsfgafjmd#b*xwkqltkf#nbgfojdkwfqfwkj`boEEEEEE!alwwln!ojhf#b#fnsolzpojuf#jmbp#pffmsqjmwfqnlpw#leva.ojmhqfif`wpbmg#vpfjnbdf!=pv``ffgeffgjmdMv`ofbqjmelqnbwl#kfosTlnfm$pMfjwkfqNf{j`bmsqlwfjm?wbaof#az#nbmzkfbowkzobtpvjwgfujpfg-svpk+xpfoofqppjnsoz#Wkqlvdk-`llhjf#Jnbdf+logfq!=vp-ip!=#Pjm`f#vmjufqpobqdfq#lsfm#wl"..#fmgojfp#jm$^*8	##nbqhfwtkl#jp#+!GLN@lnbmbdfglmf#elqwzsfle#Hjmdglnsqlejwpsqlslpfwl#pklt`fmwfq8nbgf#jwgqfppfgtfqf#jmnj{wvqfsqf`jpfbqjpjmdpq`#>#$nbhf#b#pf`vqfgAbswjpwulwjmd#	\n\nubq#Nbq`k#1dqft#vs@ojnbwf-qfnlufphjoofgtbz#wkf?,kfbg=eb`f#leb`wjmd#qjdkw!=wl#tlqhqfgv`fpkbp#kbgfqf`wfgpklt+*8b`wjlm>allh#lebm#bqfb>>#!kww?kfbgfq	?kwno=`lmelqneb`jmd#`llhjf-qfoz#lmklpwfg#-`vpwlnkf#tfmwavw#elqpsqfbg#Ebnjoz#b#nfbmplvw#wkfelqvnp-ellwbdf!=Nlajo@ofnfmwp!#jg>!bp#kjdkjmwfmpf..=?"..efnbof#jp#pffmjnsojfgpfw#wkfb#pwbwfbmg#kjpebpwfpwafpjgfpavwwlm\\alvmgfg!=?jnd#Jmelal{fufmwp/b#zlvmdbmg#bqfMbwjuf#`kfbsfqWjnflvwbmg#kbpfmdjmfptlm#wkf+nlpwozqjdkw9#ejmg#b#.alwwlnSqjm`f#bqfb#lenlqf#lepfbq`k\\mbwvqf/ofdboozsfqjlg/obmg#lelq#tjwkjmgv`fgsqlujmdnjppjofol`boozBdbjmpwwkf#tbzh%rvlw8s{8!=	svpkfg#babmglmmvnfqbo@fqwbjmJm#wkjpnlqf#jmlq#plnfmbnf#jpbmg/#jm`qltmfgJPAM#3.`qfbwfpL`wlafqnbz#mlw`fmwfq#obwf#jmGfefm`ffmb`wfgtjpk#wlaqlbgoz`llojmdlmolbg>jw-#Wkfqf`lufqNfnafqpkfjdkw#bppvnfp?kwno=	sflsof-jm#lmf#>tjmgltellwfq\\b#dllg#qfhobnblwkfqp/wl#wkjp\\`llhjfsbmfo!=Olmglm/gfejmfp`qvpkfgabswjpn`lbpwbopwbwvp#wjwof!#nluf#wlolpw#jmafwwfq#jnsojfpqjuboqzpfqufqp#PzpwfnSfqkbspfp#bmg#`lmwfmgeoltjmdobpwfg#qjpf#jmDfmfpjpujft#leqjpjmd#pffn#wlavw#jm#ab`hjmdkf#tjoodjufm#bdjujmd#`jwjfp-eolt#le#Obwfq#boo#avwKjdktbzlmoz#azpjdm#lekf#glfpgjeefqpabwwfqz%bns8obpjmdofpwkqfbwpjmwfdfqwbhf#lmqfevpfg`boofg#>VP%bnsPff#wkfmbwjufpaz#wkjppzpwfn-kfbg#le9klufq/ofpajbmpvqmbnfbmg#boo`lnnlm,kfbgfq\\\\sbqbnpKbqubqg,sj{fo-qfnlubopl#olmdqlof#leiljmwozphzp`qbVmj`lgfaq#,=	Bwobmwbmv`ofvp@lvmwz/svqfoz#`lvmw!=fbpjoz#avjog#blm`oj`hb#djufmsljmwfqk%rvlw8fufmwp#fopf#x	gjwjlmpmlt#wkf/#tjwk#nbm#tkllqd,Tfalmf#bmg`buboqzKf#gjfgpfbwwof33/333#xtjmgltkbuf#wlje+tjmgbmg#jwpplofoz#n%rvlw8qfmftfgGfwqljwbnlmdpwfjwkfq#wkfn#jmPfmbwlqVp?,b=?Hjmd#leEqbm`jp.sqlgv`kf#vpfgbqw#bmgkjn#bmgvpfg#azp`lqjmdbw#klnfwl#kbufqfobwfpjajojwzeb`wjlmAveebolojmh!=?tkbw#kfeqff#wl@jwz#le`lnf#jmpf`wlqp`lvmwfglmf#gbzmfqulvpprvbqf#~8je+dljm#tkbwjnd!#bojp#lmozpfbq`k,wvfpgbzollpfozPlolnlmpf{vbo#.#?b#kqnfgjvn!GL#MLW#Eqbm`f/tjwk#b#tbq#bmgpf`lmg#wbhf#b#=			nbqhfw-kjdktbzglmf#jm`wjujwz!obpw!=laojdfgqjpf#wl!vmgfejnbgf#wl#Fbqoz#sqbjpfgjm#jwp#elq#kjpbwkofwfIvsjwfqZbkll"#wfqnfg#pl#nbmzqfbooz#p-#Wkf#b#tlnbm<ubovf>gjqf`w#qjdkw!#aj`z`ofb`jmd>!gbz#bmgpwbwjmdQbwkfq/kjdkfq#Leej`f#bqf#mltwjnfp/#tkfm#b#sbz#elqlm#wkjp.ojmh!=8alqgfqbqlvmg#bmmvbo#wkf#Mftsvw#wkf-`ln!#wbhjm#wlb#aqjfe+jm#wkfdqlvsp-8#tjgwkfmyznfppjnsof#jm#obwfxqfwvqmwkfqbszb#sljmwabmmjmdjmhp!=	+*8!#qfb#sob`f_v330@bbalvw#bwq=	\n\n``lvmw#djufp#b?P@QJSWQbjotbzwkfnfp,wlloal{AzJg+!{kvnbmp/tbw`kfpjm#plnf#je#+tj`lnjmd#elqnbwp#Vmgfq#avw#kbpkbmgfg#nbgf#azwkbm#jmefbq#legfmlwfg,jeqbnfofew#jmulowbdfjm#fb`kb%rvlw8abpf#leJm#nbmzvmgfqdlqfdjnfpb`wjlm#?,s=	?vpwlnUb8%dw8?,jnslqwplq#wkbwnlpwoz#%bns8qf#pjyf>!?,b=?,kb#`obppsbppjufKlpw#>#TkfwkfqefqwjofUbqjlvp>X^8+ev`bnfqbp,=?,wg=b`wp#bpJm#plnf=		?"lqdbmjp#?aq#,=Afjijmd`bwbo/Lgfvwp`kfvqlsfvfvphbqbdbfjodfpufmphbfpsb/]bnfmpbifvpvbqjlwqbabiln/E{j`ls/Mdjmbpjfnsqfpjpwfnbl`wvaqfgvqbmwfb/]bgjqfnsqfpbnlnfmwlmvfpwqlsqjnfqbwqbu/Epdqb`jbpmvfpwqbsql`fplfpwbglp`bojgbgsfqplmbm/Vnfqlb`vfqgln/Vpj`bnjfnaqllefqwbpbodvmlpsb/Apfpfifnsolgfqf`klbgfn/Mpsqjubglbdqfdbqfmob`fpslpjaofklwfofppfujoobsqjnfql/Vowjnlfufmwlpbq`kjul`vowvqbnvifqfpfmwqbgbbmvm`jlfnabqdlnfq`bgldqbmgfpfpwvgjlnfilqfpefaqfqlgjpf/]lwvqjpnl`/_gjdlslqwbgbfpsb`jlebnjojbbmwlmjlsfqnjwfdvbqgbqbodvmbpsqf`jlpbodvjfmpfmwjglujpjwbpw/Awvol`lml`fqpfdvmgl`lmpfileqbm`jbnjmvwlppfdvmgbwfmfnlpfef`wlpn/Mobdbpfpj/_mqfujpwbdqbmbgb`lnsqbqjmdqfpldbq`/Abb``j/_mf`vbglqrvjfmfpjm`ovplgfafq/Mnbwfqjbklnaqfpnvfpwqbslgq/Abnb/]bmb/Vowjnbfpwbnlplej`jbowbnajfmmjmd/Vmpbovglpslgfnlpnfilqbqslpjwjlmavpjmfppklnfsbdfpf`vqjwzobmdvbdfpwbmgbqg`bnsbjdmefbwvqfp`bwfdlqzf{wfqmbo`kjogqfmqfpfqufgqfpfbq`kf{`kbmdfebulqjwfwfnsobwfnjojwbqzjmgvpwqzpfquj`fpnbwfqjbosqlgv`wpy.jmgf{9`lnnfmwpplewtbqf`lnsofwf`bofmgbqsobwelqnbqwj`ofpqfrvjqfgnlufnfmwrvfpwjlmavjogjmdslojwj`pslppjaofqfojdjlmskzpj`boeffgab`hqfdjpwfqsj`wvqfpgjpbaofgsqlwl`lobvgjfm`fpfwwjmdpb`wjujwzfofnfmwpofbqmjmdbmzwkjmdbapwqb`wsqldqfpplufqujftnbdbyjmff`lmlnj`wqbjmjmdsqfppvqfubqjlvp#?pwqlmd=sqlsfqwzpklssjmdwldfwkfqbgubm`fgafkbujlqgltmolbgefbwvqfgellwaboopfof`wfgObmdvbdfgjpwbm`fqfnfnafqwqb`hjmdsbpptlqgnlgjejfgpwvgfmwpgjqf`wozejdkwjmdmlqwkfqmgbwbabpfefpwjuboaqfbhjmdol`bwjlmjmwfqmfwgqlsgltmsqb`wj`ffujgfm`fevm`wjlmnbqqjbdfqfpslmpfsqlaofnpmfdbwjufsqldqbnpbmbozpjpqfofbpfgabmmfq!=svq`kbpfsloj`jfpqfdjlmbo`qfbwjufbqdvnfmwallhnbqhqfefqqfq`kfnj`bogjujpjlm`booab`hpfsbqbwfsqlif`wp`lmeoj`wkbqgtbqfjmwfqfpwgfojufqznlvmwbjmlawbjmfg>#ebopf8elq+ubq#b``fswfg`bsb`jwz`lnsvwfqjgfmwjwzbjq`qbewfnsolzfgsqlslpfgglnfpwj`jm`ovgfpsqlujgfgklpsjwboufqwj`bo`loobspfbssqlb`ksbqwmfqpoldl!=?bgbvdkwfqbvwklq!#`vowvqboebnjojfp,jnbdfp,bppfnaozsltfqevowfb`kjmdejmjpkfggjpwqj`w`qjwj`bo`dj.ajm,svqslpfpqfrvjqfpfof`wjlmaf`lnjmdsqlujgfpb`bgfnj`f{fq`jpfb`wvbooznfgj`jmf`lmpwbmwb``jgfmwNbdbyjmfgl`vnfmwpwbqwjmdalwwln!=lapfqufg9#%rvlw8f{wfmgfgsqfujlvpPlewtbqf`vpwlnfqgf`jpjlmpwqfmdwkgfwbjofgpojdkwozsobmmjmdwf{wbqfb`vqqfm`zfufqzlmfpwqbjdkwwqbmpefqslpjwjufsqlgv`fgkfqjwbdfpkjssjmdbaplovwfqf`fjufgqfofubmwavwwlm!#ujlofm`fbmztkfqfafmfejwpobvm`kfgqf`fmwozboojbm`felooltfgnvowjsofavoofwjmjm`ovgfgl``vqqfgjmwfqmbo\'+wkjp*-qfsvaoj`=?wq=?wg`lmdqfppqf`lqgfgvowjnbwfplovwjlm?vo#jg>!gjp`lufqKlnf?,b=tfapjwfpmfwtlqhpbowklvdkfmwjqfoznfnlqjbonfppbdfp`lmwjmvfb`wjuf!=plnftkbwuj`wlqjbTfpwfqm##wjwof>!Ol`bwjlm`lmwqb`wujpjwlqpGltmolbgtjwklvw#qjdkw!=	nfbpvqfptjgwk#>#ubqjbaofjmuloufgujqdjmjbmlqnboozkbssfmfgb``lvmwppwbmgjmdmbwjlmboQfdjpwfqsqfsbqfg`lmwqlopb``vqbwfajqwkgbzpwqbwfdzleej`jbodqbskj`p`qjnjmboslppjaoz`lmpvnfqSfqplmbopsfbhjmdubojgbwfb`kjfufg-isd!#,=nb`kjmfp?,k1=	##hfztlqgpeqjfmgozaqlwkfqp`lnajmfglqjdjmbo`lnslpfgf{sf`wfgbgfrvbwfsbhjpwbmeloolt!#ubovbaof?,obafo=qfobwjufaqjmdjmdjm`qfbpfdlufqmlqsovdjmp,Ojpw#le#Kfbgfq!=!#mbnf>!#+%rvlw8dqbgvbwf?,kfbg=	`lnnfq`fnbobzpjbgjqf`wlqnbjmwbjm8kfjdkw9p`kfgvof`kbmdjmdab`h#wl#`bwkloj`sbwwfqmp`lolq9# dqfbwfpwpvssojfpqfojbaof?,vo=	\n\n?pfof`w#`jwjyfmp`olwkjmdtbw`kjmd?oj#jg>!psf`jej``bqqzjmdpfmwfm`f?`fmwfq=`lmwqbpwwkjmhjmd`bw`k+f*plvwkfqmNj`kbfo#nfq`kbmw`bqlvpfosbggjmd9jmwfqjlq-psojw+!ojybwjlmL`wlafq#*xqfwvqmjnsqlufg..%dw8		`lufqbdf`kbjqnbm-smd!#,=pvaif`wpQj`kbqg#tkbwfufqsqlabaozqf`lufqzabpfabooivgdnfmw`lmmf`w--`pp!#,=#tfapjwfqfslqwfggfebvow!,=?,b=	fof`wqj`p`lwobmg`qfbwjlmrvbmwjwz-#JPAM#3gjg#mlw#jmpwbm`f.pfbq`k.!#obmd>!psfbhfqp@lnsvwfq`lmwbjmpbq`kjufpnjmjpwfqqfb`wjlmgjp`lvmwJwbojbml`qjwfqjbpwqlmdoz9#$kwws9$p`qjsw$`lufqjmdleefqjmdbssfbqfgAqjwjpk#jgfmwjezEb`fallhmvnfqlvpufkj`ofp`lm`fqmpBnfqj`bmkbmgojmdgju#jg>!Tjoojbn#sqlujgfq\\`lmwfmwb``vqb`zpf`wjlm#bmgfqplmeof{jaof@bwfdlqzobtqfm`f?p`qjsw=obzlvw>!bssqlufg#nb{jnvnkfbgfq!=?,wbaof=Pfquj`fpkbnjowlm`vqqfmw#`bmbgjbm`kbmmfop,wkfnfp,,bqwj`oflswjlmboslqwvdboubovf>!!jmwfqubotjqfofppfmwjwofgbdfm`jfpPfbq`k!#nfbpvqfgwklvpbmgpsfmgjmd%kfoojs8mft#Gbwf!#pjyf>!sbdfMbnfnjggof!#!#,=?,b=kjggfm!=pfrvfm`fsfqplmbolufqeoltlsjmjlmpjoojmljpojmhp!=	\n?wjwof=ufqpjlmppbwvqgbzwfqnjmbojwfnsqlsfmdjmffqpf`wjlmpgfpjdmfqsqlslpbo>!ebopf!Fpsb/]loqfofbpfppvanjw!#fq%rvlw8bggjwjlmpznswlnplqjfmwfgqfplvq`fqjdkw!=?sofbpvqfpwbwjlmpkjpwlqz-ofbujmd##alqgfq>`lmwfmwp`fmwfq!=-		Plnf#gjqf`wfgpvjwbaofavodbqjb-pklt+*8gfpjdmfgDfmfqbo#`lm`fswpF{bnsofptjoojbnpLqjdjmbo!=?psbm=pfbq`k!=lsfqbwlqqfrvfpwpb#%rvlw8booltjmdGl`vnfmwqfujpjlm-#		Wkf#zlvqpfoe@lmwb`w#nj`kjdbmFmdojpk#`lovnajbsqjlqjwzsqjmwjmdgqjmhjmdeb`jojwzqfwvqmfg@lmwfmw#leej`fqpQvppjbm#dfmfqbwf.;;6:.2!jmgj`bwfebnjojbq#rvbojwznbqdjm93#`lmwfmwujftslqw`lmwb`wp.wjwof!=slqwbaof-ofmdwk#fojdjaofjmuloufpbwobmwj`lmolbg>!gfebvow-pvssojfgsbznfmwpdolppbqz		Bewfq#dvjgbm`f?,wg=?wgfm`lgjmdnjggof!=`bnf#wl#gjpsobzpp`lwwjpkilmbwkbmnbilqjwztjgdfwp-`ojmj`bowkbjobmgwfb`kfqp?kfbg=	\nbeef`wfgpvsslqwpsljmwfq8wlPwqjmd?,pnboo=lhobklnbtjoo#af#jmufpwlq3!#bow>!klojgbzpQfplvq`foj`fmpfg#+tkj`k#-#Bewfq#`lmpjgfqujpjwjmdf{solqfqsqjnbqz#pfbq`k!#bmgqljg!rvj`hoz#nffwjmdpfpwjnbwf8qfwvqm#8`lolq9 #kfjdkw>bssqlubo/#%rvlw8#`kf`hfg-njm-ip!nbdmfwj`=?,b=?,kelqf`bpw-#Tkjof#wkvqpgbzgufqwjpf%fb`vwf8kbp@obppfubovbwflqgfqjmdf{jpwjmdsbwjfmwp#Lmojmf#`lolqbglLswjlmp!`bnsafoo?"..#fmg?,psbm=??aq#,=	\\slsvspp`jfm`fp/%rvlw8#rvbojwz#Tjmgltp#bppjdmfgkfjdkw9#?a#`obppof%rvlw8#ubovf>!#@lnsbmzf{bnsofp?jeqbnf#afojfufpsqfpfmwpnbqpkboosbqw#le#sqlsfqoz*-		Wkf#wb{lmlnznv`k#le#?,psbm=	!#gbwb.pqwvdv/Fpp`qlooWl#sqlif`w?kfbg=	bwwlqmfzfnskbpjppslmplqpebm`zal{tlqog$p#tjogojef`kf`hfg>pfppjlmpsqldqbnns{8elmw.#Sqlif`wilvqmbopafojfufgub`bwjlmwklnsplmojdkwjmdbmg#wkf#psf`jbo#alqgfq>3`kf`hjmd?,walgz=?avwwlm#@lnsofwf`ofbqej{	?kfbg=	bqwj`of#?pf`wjlmejmgjmdpqlof#jm#slsvobq##L`wlafqtfapjwf#f{slpvqfvpfg#wl##`kbmdfplsfqbwfg`oj`hjmdfmwfqjmd`lnnbmgpjmelqnfg#mvnafqp##?,gju=`qfbwjmdlmPvanjwnbqzobmg`loofdfpbmbozwj`ojpwjmdp`lmwb`w-olddfgJmbgujplqzpjaojmdp`lmwfmw!p%rvlw8*p-#Wkjp#sb`hbdfp`kf`hal{pvddfpwpsqfdmbmwwlnlqqltpsb`jmd>j`lm-smdibsbmfpf`lgfabpfavwwlm!=dbnaojmdpv`k#bp#/#tkjof#?,psbm=#njpplvqjpslqwjmdwls92s{#-?,psbm=wfmpjlmptjgwk>!1obyzolbgmlufnafqvpfg#jm#kfjdkw>!`qjsw!=	%maps8?,?wq=?wg#kfjdkw91,sqlgv`w`lvmwqz#jm`ovgf#ellwfq!#%ow8"..#wjwof!=?,irvfqz-?,elqn=	+\vBl\bQ*+\vUmGx*kqubwphjjwbojbmlqln/Nm(ow/Pqh/Kf4K4]4C5dwbnaj/Emmlwj`jbpnfmpbifpsfqplmbpgfqf`klpmb`jlmbopfquj`jl`lmwb`wlvpvbqjlpsqldqbnbdlajfqmlfnsqfpbpbmvm`jlpubofm`jb`lolnajbgfpsv/Epgfslqwfpsqlzf`wlsqlgv`wls/Vaoj`lmlplwqlpkjpwlqjbsqfpfmwfnjoolmfpnfgjbmwfsqfdvmwbbmwfqjlqqf`vqplpsqlaofnbpbmwjbdlmvfpwqlplsjmj/_mjnsqjnjqnjfmwqbpbn/Eqj`bufmgfglqpl`jfgbgqfpsf`wlqfbojybqqfdjpwqlsbobaqbpjmwfq/Epfmwlm`fpfpsf`jbonjfnaqlpqfbojgbg`/_qglabybqbdlybs/Mdjmbppl`jbofpaolrvfbqdfpwj/_mborvjofqpjpwfnbp`jfm`jbp`lnsofwlufqpj/_m`lnsofwbfpwvgjlps/Vaoj`blaifwjulboj`bmwfavp`bglq`bmwjgbgfmwqbgbpb``jlmfpbq`kjulppvsfqjlqnbzlq/Abbofnbmjbevm`j/_m/Vowjnlpkb`jfmglbrvfoolpfgj`j/_mefqmbmglbnajfmwfeb`fallhmvfpwqbp`ojfmwfpsql`fplpabpwbmwfsqfpfmwbqfslqwbq`lmdqfplsvaoj`bq`lnfq`jl`lmwqbwli/_ufmfpgjpwqjwlw/E`mj`b`lmivmwlfmfqd/Abwqbabibqbpwvqjbpqf`jfmwfvwjojybqalofw/Ampboubglq`lqqf`wbwqbabilpsqjnfqlpmfdl`jlpojafqwbggfwboofpsbmwboobsq/_{jnlbonfq/Abbmjnbofprvj/Emfp`lqby/_mpf``j/_mavp`bmglls`jlmfpf{wfqjlq`lm`fswlwlgbu/Abdbofq/Abfp`qjajqnfgj`jmboj`fm`jb`lmpvowbbpsf`wlp`q/Awj`bg/_obqfpivpwj`jbgfafq/Mmsfq/Alglmf`fpjwbnbmwfmfqsfrvf/]lqf`jajgbwqjavmbowfmfqjef`bm`j/_m`bmbqjbpgfp`bqdbgjufqplpnboolq`bqfrvjfqfw/E`mj`lgfafq/Abujujfmgbejmbmybpbgfobmwfevm`jlmb`lmpfilpgje/A`jo`jvgbgfpbmwjdvbpbubmybgbw/Eqnjmlvmjgbgfpp/Mm`kfy`bnsb/]bplewlmj`qfujpwbp`lmwjfmfpf`wlqfpnlnfmwlpeb`vowbg`q/Egjwlgjufqpbppvsvfpwleb`wlqfppfdvmglpsfrvf/]b<_<R<X<\\<Y=m<W<T<Y=m=n=`<]=g<W<R<]=g=n=`=a=n<R<P<y=m<W<T=n<R<_<R<P<Y<Q=c<^=m<Y=i=a=n<R<U<X<\\<Z<Y<]=g<W<T<_<R<X=o<X<Y<Q=`=a=n<R=n<]=g<W<\\=m<Y<]=c<R<X<T<Q=m<Y<]<Y<Q<\\<X<R=m<\\<U=n=h<R=n<R<Q<Y<_<R=m<^<R<T=m<^<R<U<T<_=l=g=n<R<Z<Y<^=m<Y<P=m<^<R=b<W<T=d=`=a=n<T=i<S<R<V<\\<X<Q<Y<U<X<R<P<\\<P<T=l<\\<W<T<]<R=n<Y<P=o=i<R=n=c<X<^=o=i=m<Y=n<T<W=b<X<T<X<Y<W<R<P<T=l<Y=n<Y<]=c=m<^<R<Y<^<T<X<Y=k<Y<_<R=a=n<T<P=m=k<Y=n=n<Y<P=g=j<Y<Q=g=m=n<\\<W<^<Y<X=`=n<Y<P<Y<^<R<X=g=n<Y<]<Y<^=g=d<Y<Q<\\<P<T=n<T<S<\\=n<R<P=o<S=l<\\<^<W<T=j<\\<R<X<Q<\\<_<R<X=g<[<Q<\\=b<P<R<_=o<X=l=o<_<^=m<Y<U<T<X<Y=n<V<T<Q<R<R<X<Q<R<X<Y<W<\\<X<Y<W<Y=m=l<R<V<T=b<Q=c<^<Y=m=`<y=m=n=`=l<\\<[<\\<Q<\\=d<T4K5h5h5k4K5h4F5f4@5i5f4U4B4K4Y4E4K5h4\\5f4U5h5f5k4@4C5f4C4K5h4N5j4K5h4]4C4F4A5o5i4Y5m4A4E5o4K5j4F4K5h5h5f5f5o5d5j4X4D5o4E5m5f5k4K4D5j4K4F4A5d4K4M4O5o4G4]4B5h4K5h4K5h4A4D4C5h5f5h4C4]5d4_4K4Z4V4[4F5o5d5j5k5j4K5o4_4K4A4E5j4K4C5f4K5h4[4D4U5h5f5o4X5o4]4K5f5i5o5j5i5j5k4K4X4]5o4E4]4J5f4_5j4X5f4[5i4K4\\4K4K5h5m5j4X4D4K4D4F4U4D4]4]4A5i4E5o4K5m4E5f5n5d5h5i4]5o4^5o5h5i4E4O4A5i4C5n5h4D5f5f4U5j5f4Y5d4]4E4[4]5f5n4X4K4]5o4@5d4K5h4O4B4]5e5i4U5j4K4K4D4A4G4U4]5d4Z4D4X5o5h5i4_4@5h4D5j4K5j4B4K5h4C5o4F4K4D5o5h5f4E4D4C5d5j4O5f4Z4K5f5d4@4C5m4]5f5n5o4F4D4F4O5m4Z5h5i4[4D4B4K5o4G4]4D4K4]5o4K5m4Z5h4K4A5h5e5j5m4_5k4O5f4K5i4]4C5d4C4O5j5k4K4C5f5j4K4K5h4K5j5i4U4]4Z4F4U5h5i4C4K4B5h5i5i5o5j\x07\x07\x07\x07\0\x07\x07\0\v\n	\b\r\f\f\r\b	\n\v\x1B\x1B\0\v\v\v\v\0\x07qfplvq`fp`lvmwqjfprvfpwjlmpfrvjsnfmw`lnnvmjwzbubjobaofkjdkojdkwGWG,{kwnonbqhfwjmdhmltofgdfplnfwkjmd`lmwbjmfqgjqf`wjlmpvap`qjafbgufqwjpf`kbqb`wfq!#ubovf>!?,pfof`w=Bvpwqbojb!#`obpp>!pjwvbwjlmbvwklqjwzelooltjmdsqjnbqjozlsfqbwjlm`kboofmdfgfufolsfgbmlmznlvpevm`wjlm#evm`wjlmp`lnsbmjfppwqv`wvqfbdqffnfmw!#wjwof>!slwfmwjbofgv`bwjlmbqdvnfmwppf`lmgbqz`lszqjdkwobmdvbdfpf{`ovpjuf`lmgjwjlm?,elqn=	pwbwfnfmwbwwfmwjlmAjldqbskz~#fopf#x	plovwjlmptkfm#wkf#Bmbozwj`pwfnsobwfpgbmdfqlvppbwfoojwfgl`vnfmwpsvaojpkfqjnslqwbmwsqlwlwzsfjmeovfm`f%qbrvl8?,feef`wjufdfmfqboozwqbmpelqnafbvwjevowqbmpslqwlqdbmjyfgsvaojpkfgsqlnjmfmwvmwjo#wkfwkvnambjoMbwjlmbo#-el`vp+*8lufq#wkf#njdqbwjlmbmmlvm`fgellwfq!=	f{`fswjlmofpp#wkbmf{sfmpjufelqnbwjlmeqbnftlqhwfqqjwlqzmgj`bwjlm`vqqfmwoz`obppMbnf`qjwj`jpnwqbgjwjlmfopftkfqfBof{bmgfqbssljmwfgnbwfqjbopaqlbg`bpwnfmwjlmfgbeejojbwf?,lswjlm=wqfbwnfmwgjeefqfmw,gfebvow-Sqfpjgfmwlm`oj`h>!ajldqbskzlwkfqtjpfsfqnbmfmwEqbm/KbjpKlooztllgf{sbmpjlmpwbmgbqgp?,pwzof=	qfgv`wjlmGf`fnafq#sqfefqqfg@bnaqjgdflsslmfmwpAvpjmfpp#`lmevpjlm=	?wjwof=sqfpfmwfgf{sobjmfgglfp#mlw#tlqogtjgfjmwfqeb`fslpjwjlmpmftpsbsfq?,wbaof=	nlvmwbjmpojhf#wkf#fppfmwjboejmbm`jbopfof`wjlmb`wjlm>!,babmglmfgFgv`bwjlmsbqpfJmw+pwbajojwzvmbaof#wl?,wjwof=	qfobwjlmpMlwf#wkbwfeej`jfmwsfqelqnfgwtl#zfbqpPjm`f#wkfwkfqfelqftqbssfq!=bowfqmbwfjm`qfbpfgAbwwof#lesfq`fjufgwqzjmd#wlmf`fppbqzslqwqbzfgfof`wjlmpFojybafwk?,jeqbnf=gjp`lufqzjmpvqbm`fp-ofmdwk8ofdfmgbqzDfldqbskz`bmgjgbwf`lqslqbwfplnfwjnfppfquj`fp-jmkfqjwfg?,pwqlmd=@lnnvmjwzqfojdjlvpol`bwjlmp@lnnjwwffavjogjmdpwkf#tlqogml#olmdfqafdjmmjmdqfefqfm`f`bmmlw#afeqfrvfm`zwzsj`boozjmwl#wkf#qfobwjuf8qf`lqgjmdsqfpjgfmwjmjwjboozwf`kmjrvfwkf#lwkfqjw#`bm#aff{jpwfm`fvmgfqojmfwkjp#wjnfwfofsklmfjwfnp`lsfsqb`wj`fpbgubmwbdf*8qfwvqm#Elq#lwkfqsqlujgjmdgfnl`qb`zalwk#wkf#f{wfmpjufpveefqjmdpvsslqwfg`lnsvwfqp#evm`wjlmsqb`wj`bopbjg#wkbwjw#nbz#afFmdojpk?,eqln#wkf#p`kfgvofggltmolbgp?,obafo=	pvpsf`wfgnbqdjm9#3psjqjwvbo?,kfbg=		nj`qlplewdqbgvboozgjp`vppfgkf#af`bnff{f`vwjufirvfqz-ipklvpfklog`lmejqnfgsvq`kbpfgojwfqboozgfpwqlzfgvs#wl#wkfubqjbwjlmqfnbjmjmdjw#jp#mlw`fmwvqjfpIbsbmfpf#bnlmd#wkf`lnsofwfgbodlqjwknjmwfqfpwpqfafoojlmvmgfejmfgfm`lvqbdfqfpjybaofjmuloujmdpfmpjwjufvmjufqpbosqlujpjlm+bowklvdkefbwvqjmd`lmgv`wfg*/#tkj`k#`lmwjmvfg.kfbgfq!=Efaqvbqz#mvnfqlvp#lufqeolt9`lnslmfmweqbdnfmwpf{`foofmw`lopsbm>!wf`kmj`bomfbq#wkf#Bgubm`fg#plvq`f#lef{sqfppfgKlmd#Hlmd#Eb`fallhnvowjsof#nf`kbmjpnfofubwjlmleefmpjuf?,elqn=	\npslmplqfggl`vnfmw-lq#%rvlw8wkfqf#bqfwklpf#tklnlufnfmwpsql`fppfpgjeej`vowpvanjwwfgqf`lnnfmg`lmujm`fgsqlnlwjmd!#tjgwk>!-qfsob`f+`obppj`bo`lbojwjlmkjp#ejqpwgf`jpjlmpbppjpwbmwjmgj`bwfgfulovwjlm.tqbssfq!fmlvdk#wlbolmd#wkfgfojufqfg..=	?"..Bnfqj`bm#sqlwf`wfgMlufnafq#?,pwzof=?evqmjwvqfJmwfqmfw##lmaovq>!pvpsfmgfgqf`jsjfmwabpfg#lm#Nlqflufq/balojpkfg`loof`wfgtfqf#nbgffnlwjlmbofnfqdfm`zmbqqbwjufbgul`bwfps{8alqgfq`lnnjwwfggjq>!owq!fnsolzffpqfpfbq`k-#pfof`wfgpv``fpplq`vpwlnfqpgjpsobzfgPfswfnafqbgg@obpp+Eb`fallh#pvddfpwfgbmg#obwfqlsfqbwjmdfobalqbwfPlnfwjnfpJmpwjwvwf`fqwbjmozjmpwboofgelooltfqpIfqvpbofnwkfz#kbuf`lnsvwjmddfmfqbwfgsqlujm`fpdvbqbmwffbqajwqbqzqf`ldmjyftbmwfg#wls{8tjgwk9wkflqz#leafkbujlvqTkjof#wkffpwjnbwfgafdbm#wl#jw#af`bnfnbdmjwvgfnvpw#kbufnlqf#wkbmGjqf`wlqzf{wfmpjlmpf`qfwbqzmbwvqboozl``vqqjmdubqjbaofpdjufm#wkfsobwelqn-?,obafo=?ebjofg#wl`lnslvmgphjmgp#le#pl`jfwjfpbolmdpjgf#..%dw8		plvwktfpwwkf#qjdkwqbgjbwjlmnbz#kbuf#vmfp`bsf+pslhfm#jm!#kqfe>!,sqldqbnnflmoz#wkf#`lnf#eqlngjqf`wlqzavqjfg#jmb#pjnjobqwkfz#tfqf?,elmw=?,Mlqtfdjbmpsf`jejfgsqlgv`jmdsbppfmdfq+mft#Gbwfwfnslqbqzej`wjlmboBewfq#wkffrvbwjlmpgltmolbg-qfdvobqozgfufolsfqbaluf#wkfojmhfg#wlskfmlnfmbsfqjlg#lewllowjs!=pvapwbm`fbvwlnbwj`bpsf`w#leBnlmd#wkf`lmmf`wfgfpwjnbwfpBjq#Elq`fpzpwfn#lelaif`wjufjnnfgjbwfnbhjmd#jwsbjmwjmdp`lmrvfqfgbqf#pwjoosql`fgvqfdqltwk#lekfbgfg#azFvqlsfbm#gjujpjlmpnlof`vofpeqbm`kjpfjmwfmwjlmbwwqb`wfg`kjogkllgbopl#vpfggfgj`bwfgpjmdbslqfgfdqff#leebwkfq#le`lmeoj`wp?,b=?,s=	`bnf#eqlntfqf#vpfgmlwf#wkbwqf`fjujmdF{f`vwjuffufm#nlqfb``fpp#wl`lnnbmgfqSlojwj`bonvpj`jbmpgfoj`jlvpsqjplmfqpbgufmw#leVWE.;!#,=?"X@GBWBX!=@lmwb`wPlvwkfqm#ad`lolq>!pfqjfp#le-#Jw#tbp#jm#Fvqlsfsfqnjwwfgubojgbwf-bssfbqjmdleej`jboppfqjlvpoz.obmdvbdfjmjwjbwfgf{wfmgjmdolmd.wfqnjmeobwjlmpv`k#wkbwdfw@llhjfnbqhfg#az?,avwwlm=jnsofnfmwavw#jw#jpjm`qfbpfpgltm#wkf#qfrvjqjmdgfsfmgfmw..=	?"..#jmwfqujftTjwk#wkf#`lsjfp#le`lmpfmpvptbp#avjowUfmfyvfob+elqnfqozwkf#pwbwfsfqplmmfopwqbwfdj`ebulvq#lejmufmwjlmTjhjsfgjb`lmwjmfmwujqwvbooztkj`k#tbpsqjm`jsof@lnsofwf#jgfmwj`bopklt#wkbwsqjnjwjufbtbz#eqlnnlof`vobqsqf`jpfozgjpploufgVmgfq#wkfufqpjlm>!=%maps8?,Jw#jp#wkf#Wkjp#jp#tjoo#kbuflqdbmjpnpplnf#wjnfEqjfgqj`ktbp#ejqpwwkf#lmoz#eb`w#wkbwelqn#jg>!sqf`fgjmdWf`kmj`boskzpj`jpwl``vqp#jmmbujdbwlqpf`wjlm!=psbm#jg>!plvdkw#wlafolt#wkfpvqujujmd~?,pwzof=kjp#gfbwkbp#jm#wkf`bvpfg#azsbqwjboozf{jpwjmd#vpjmd#wkftbp#djufmb#ojpw#leofufop#lemlwjlm#leLeej`jbo#gjpnjppfgp`jfmwjpwqfpfnaofpgvsoj`bwff{solpjufqf`lufqfgboo#lwkfqdboofqjfpxsbggjmd9sflsof#leqfdjlm#lebggqfppfpbppl`jbwfjnd#bow>!jm#nlgfqmpklvog#afnfwklg#leqfslqwjmdwjnfpwbnsmffgfg#wlwkf#Dqfbwqfdbqgjmdpffnfg#wlujftfg#bpjnsb`w#lmjgfb#wkbwwkf#Tlqogkfjdkw#lef{sbmgjmdWkfpf#bqf`vqqfmw!=`bqfevooznbjmwbjmp`kbqdf#le@obppj`bobggqfppfgsqfgj`wfgltmfqpkjs?gju#jg>!qjdkw!=	qfpjgfm`fofbuf#wkf`lmwfmw!=bqf#lewfm##~*+*8	sqlabaoz#Sqlefpplq.avwwlm!#qfpslmgfgpbzp#wkbwkbg#wl#afsob`fg#jmKvmdbqjbmpwbwvp#lepfqufp#bpVmjufqpbof{f`vwjlmbddqfdbwfelq#tkj`kjmef`wjlmbdqffg#wlkltfufq/#slsvobq!=sob`fg#lm`lmpwqv`wfof`wlqbopznalo#lejm`ovgjmdqfwvqm#wlbq`kjwf`w@kqjpwjbmsqfujlvp#ojujmd#jmfbpjfq#wlsqlefpplq	%ow8"..#feef`w#lebmbozwj`ptbp#wbhfmtkfqf#wkfwllh#lufqafojfe#jmBeqjhbbmpbp#ebq#bpsqfufmwfgtlqh#tjwkb#psf`jbo?ejfogpfw@kqjpwnbpQfwqjfufg		Jm#wkf#ab`h#jmwlmlqwkfbpwnbdbyjmfp=?pwqlmd=`lnnjwwffdlufqmjmddqlvsp#lepwlqfg#jmfpwbaojpkb#dfmfqbojwp#ejqpwwkfjq#ltmslsvobwfgbm#laif`w@bqjaafbmboolt#wkfgjpwqj`wptjp`lmpjmol`bwjlm-8#tjgwk9#jmkbajwfgPl`jbojpwIbmvbqz#2?,ellwfq=pjnjobqoz`klj`f#lewkf#pbnf#psf`jej`#avpjmfpp#Wkf#ejqpw-ofmdwk8#gfpjqf#wlgfbo#tjwkpjm`f#wkfvpfqBdfmw`lm`fjufgjmgf{-sksbp#%rvlw8fmdbdf#jmqf`fmwoz/eft#zfbqptfqf#bopl	?kfbg=	?fgjwfg#azbqf#hmltm`jwjfp#jmb``fpphfz`lmgfnmfgbopl#kbufpfquj`fp/ebnjoz#leP`kllo#le`lmufqwfgmbwvqf#le#obmdvbdfnjmjpwfqp?,laif`w=wkfqf#jp#b#slsvobqpfrvfm`fpbgul`bwfgWkfz#tfqfbmz#lwkfqol`bwjlm>fmwfq#wkfnv`k#nlqfqfeof`wfgtbp#mbnfglqjdjmbo#b#wzsj`botkfm#wkfzfmdjmffqp`lvog#mlwqfpjgfmwptfgmfpgbzwkf#wkjqg#sqlgv`wpIbmvbqz#1tkbw#wkfzb#`fqwbjmqfb`wjlmpsql`fpplqbewfq#kjpwkf#obpw#`lmwbjmfg!=?,gju=	?,b=?,wg=gfsfmg#lmpfbq`k!=	sjf`fp#le`lnsfwjmdQfefqfm`fwfmmfppfftkj`k#kbp#ufqpjlm>?,psbm=#??,kfbgfq=djufp#wkfkjpwlqjbmubovf>!!=sbggjmd93ujft#wkbwwldfwkfq/wkf#nlpw#tbp#elvmgpvapfw#lebwwb`h#lm`kjogqfm/sljmwp#lesfqplmbo#slpjwjlm9boofdfgoz@ofufobmgtbp#obwfqbmg#bewfqbqf#djufmtbp#pwjoop`qloojmdgfpjdm#lenbhfp#wkfnv`k#ofppBnfqj`bmp-		Bewfq#/#avw#wkfNvpfvn#leolvjpjbmb+eqln#wkfnjmmfplwbsbqwj`ofpb#sql`fppGlnjmj`bmulovnf#leqfwvqmjmdgfefmpjuf33s{qjdknbgf#eqlnnlvpflufq!#pwzof>!pwbwfp#le+tkj`k#jp`lmwjmvfpEqbm`jp`lavjogjmd#tjwklvw#btjwk#plnftkl#tlvogb#elqn#leb#sbqw#leafelqf#jwhmltm#bp##Pfquj`fpol`bwjlm#bmg#lewfmnfbpvqjmdbmg#jw#jpsbsfqab`hubovfp#le	?wjwof=>#tjmglt-gfwfqnjmffq%rvlw8#sobzfg#azbmg#fbqoz?,`fmwfq=eqln#wkjpwkf#wkqffsltfq#bmgle#%rvlw8jmmfqKWNO?b#kqfe>!z9jmojmf8@kvq`k#lewkf#fufmwufqz#kjdkleej`jbo#.kfjdkw9#`lmwfmw>!,`dj.ajm,wl#`qfbwfbeqjhbbmpfpsfqbmwleqbm/Kbjpobwujf)Mvojfwvuj)_(`f)Mwjmb(af)Mwjmb\fUh\fT{\fTN\n{I\np@Fr\vBl\bQ	A{\vUmGx	A{ypYA\0zX\bTV\bWl\bUdBM\vB{\npV\v@xB\\\np@DbGz	al\npa	fM	uD\bV~mx\vQ}\ndS	p\\\bVK\bS]\bU|oD	kV\ved\vHR\nb~M`\nJpoD|Q\nLPSw\bTl\nAI\nxC\bWt	BqF`Cm\vLm	Kx	}t\bPv\ny\\\naB	V\nZdXUli	fr	i@	BHBDBV	`V\n[]	p_	Tn\n~A\nxR	uD	`{\bV@	Tn	HK	AJ\vxsZf\nqIZf\vBM\v|j	}t\bSM\nmC\vQ}pfquj`jlpbqw/A`volbqdfmwjmbabq`folmb`vborvjfqsvaoj`bglsqlgv`wlpslo/Awj`bqfpsvfpwbtjhjsfgjbpjdvjfmwfa/Vprvfgb`lnvmjgbgpfdvqjgbgsqjm`jsbosqfdvmwbp`lmwfmjglqfpslmgfqufmfyvfobsqlaofnbpgj`jfnaqfqfob`j/_mmlujfnaqfpjnjobqfpsqlzf`wlpsqldqbnbpjmpwjwvwlb`wjujgbgfm`vfmwqbf`lmln/Abjn/Mdfmfp`lmwb`wbqgfp`bqdbqmf`fpbqjlbwfm`j/_mwfo/Eelml`lnjpj/_m`bm`jlmfp`bsb`jgbgfm`lmwqbqbm/Mojpjpebulqjwlpw/Eqnjmlpsqlujm`jbfwjrvfwbpfofnfmwlpevm`jlmfpqfpvowbgl`bq/M`wfqsqlsjfgbgsqjm`jsjlmf`fpjgbgnvmj`jsbo`qfb`j/_mgfp`bqdbpsqfpfm`jb`lnfq`jbolsjmjlmfpfifq`j`jlfgjwlqjbopbobnbm`bdlmy/Mofygl`vnfmwlsfo/A`vobqf`jfmwfpdfmfqbofpwbqqbdlmbsq/M`wj`bmlufgbgfpsqlsvfpwbsb`jfmwfpw/E`mj`bplaifwjulp`lmwb`wlp\fHB\fIk\fHn\fH^\fHS\fHc\fHU\fId\fHn\fH{\fHC\fHR\fHT\fHR\fHI\fHc\fHY\fHn\fH\\\fHU\fIk\fHy\fIg\fHd\fHy\fIm\fHw\fH\\\fHU\fHR\fH@\fHR\fHJ\fHy\fHU\fHR\fHT\fHA\fIl\fHU\fIm\fHc\fH\\\fHU\fIl\fHB\fId\fHn\fHJ\fHS\fHD\fH@\fHR\fHHgjsolgl`p\fHT\fHB\fHC\fH\\\fIn\fHF\fHD\fHR\fHB\fHF\fHH\fHR\fHG\fHS\fH\\\fHx\fHT\fHH\fHH\fH\\\fHU\fH^\fIg\fH{\fHU\fIm\fHj\fH@\fHR\fH\\\fHJ\fIk\fHZ\fHU\fIm\fHd\fHz\fIk\fH^\fHC\fHJ\fHS\fHy\fHR\fHB\fHY\fIk\fH@\fHH\fIl\fHD\fH@\fIl\fHv\fHB\fI`\fHH\fHT\fHR\fH^\fH^\fIk\fHz\fHp\fIe\fH@\fHB\fHJ\fHJ\fHH\fHI\fHR\fHD\fHU\fIl\fHZ\fHU\fH\\\fHi\fH^\fH{\fHy\fHA\fIl\fHD\fH{\fH\\\fHF\fHR\fHT\fH\\\fHR\fHH\fHy\fHS\fHc\fHe\fHT\fIk\fH{\fHC\fIl\fHU\fIn\fHm\fHj\fH{\fIk\fHs\fIl\fHB\fHz\fIg\fHp\fHy\fHR\fH\\\fHi\fHA\fIl\fH{\fHC\fIk\fHH\fIm\fHB\fHY\fIg\fHs\fHJ\fIk\fHn\fHi\fH{\fH\\\fH|\fHT\fIk\fHB\fIk\fH^\fH^\fH{\fHR\fHU\fHR\fH^\fHf\fHF\fH\\\fHv\fHR\fH\\\fH|\fHT\fHR\fHJ\fIk\fH\\\fHp\fHS\fHT\fHJ\fHS\fH^\fH@\fHn\fHJ\fH@\fHD\fHR\fHU\fIn\fHn\fH^\fHR\fHz\fHp\fIl\fHH\fH@\fHs\fHD\fHB\fHS\fH^\fHk\fHT\fIk\fHj\fHD\fIk\fHD\fHC\fHR\fHy\fIm\fH^\fH^\fIe\fH{\fHA\fHR\fH{\fH\\\fIk\fH^\fHp\fH{\fHU\fH\\\fHR\fHB\fH^\fH{\fIk\fHF\fIk\fHp\fHU\fHR\fHI\fHk\fHT\fIl\fHT\fHU\fIl\fHy\fH^\fHR\fHL\fIl\fHy\fHU\fHR\fHm\fHJ\fIn\fH\\\fHH\fHU\fHH\fHT\fHR\fHH\fHC\fHR\fHJ\fHj\fHC\fHR\fHF\fHR\fHy\fHy\fI`\fHD\fHZ\fHR\fHB\fHJ\fIk\fHz\fHC\fHU\fIl\fH\\\fHR\fHC\fHz\fIm\fHJ\fH^\fH{\fIl`bwfdlqjfpf{sfqjfm`f?,wjwof=	@lszqjdkw#ibubp`qjsw`lmgjwjlmpfufqzwkjmd?s#`obpp>!wf`kmloldzab`hdqlvmg?b#`obpp>!nbmbdfnfmw%`lsz8#132ibubP`qjsw`kbqb`wfqpaqfbg`qvnawkfnpfoufpklqjylmwbodlufqmnfmw@bojelqmjbb`wjujwjfpgjp`lufqfgMbujdbwjlmwqbmpjwjlm`lmmf`wjlmmbujdbwjlmbssfbqbm`f?,wjwof=?n`kf`hal{!#wf`kmjrvfpsqlwf`wjlmbssbqfmwozbp#tfoo#bpvmw$/#$VB.qfplovwjlmlsfqbwjlmpwfofujpjlmwqbmpobwfgTbpkjmdwlmmbujdbwlq-#>#tjmglt-jnsqfppjlm%ow8aq%dw8ojwfqbwvqfslsvobwjlmad`lolq>! fpsf`jbooz#`lmwfmw>!sqlgv`wjlmmftpofwwfqsqlsfqwjfpgfejmjwjlmofbgfqpkjsWf`kmloldzSbqojbnfmw`lnsbqjplmvo#`obpp>!-jmgf{Le+!`lm`ovpjlmgjp`vppjlm`lnslmfmwpajloldj`boQfulovwjlm\\`lmwbjmfqvmgfqpwllgmlp`qjsw=?sfqnjppjlmfb`k#lwkfqbwnlpskfqf#lmel`vp>!?elqn#jg>!sql`fppjmdwkjp-ubovfdfmfqbwjlm@lmefqfm`fpvapfrvfmwtfoo.hmltmubqjbwjlmpqfsvwbwjlmskfmlnfmlmgjp`jsojmfoldl-smd!#+gl`vnfmw/alvmgbqjfpf{sqfppjlmpfwwofnfmwAb`hdqlvmglvw#le#wkffmwfqsqjpf+!kwwsp9!#vmfp`bsf+!sbpptlqg!#gfnl`qbwj`?b#kqfe>!,tqbssfq!=	nfnafqpkjsojmdvjpwj`s{8sbggjmdskjolplskzbppjpwbm`fvmjufqpjwzeb`jojwjfpqf`ldmjyfgsqfefqfm`fje#+wzsflenbjmwbjmfgul`bavobqzkzslwkfpjp-pvanjw+*8%bns8maps8bmmlwbwjlmafkjmg#wkfElvmgbwjlmsvaojpkfq!bppvnswjlmjmwqlgv`fg`lqqvswjlmp`jfmwjpwpf{soj`jwozjmpwfbg#legjnfmpjlmp#lm@oj`h>!`lmpjgfqfggfsbqwnfmwl``vsbwjlmpllm#bewfqjmufpwnfmwsqlmlvm`fgjgfmwjejfgf{sfqjnfmwNbmbdfnfmwdfldqbskj`!#kfjdkw>!ojmh#qfo>!-qfsob`f+,gfsqfppjlm`lmefqfm`fsvmjpknfmwfojnjmbwfgqfpjpwbm`fbgbswbwjlmlsslpjwjlmtfoo#hmltmpvssofnfmwgfwfqnjmfgk2#`obpp>!3s{8nbqdjmnf`kbmj`bopwbwjpwj`p`fofaqbwfgDlufqmnfmw		Gvqjmd#wgfufolsfqpbqwjej`jbofrvjubofmwlqjdjmbwfg@lnnjppjlmbwwb`knfmw?psbm#jg>!wkfqf#tfqfMfgfqobmgpafzlmg#wkfqfdjpwfqfgilvqmbojpweqfrvfmwozboo#le#wkfobmd>!fm!#?,pwzof=	baplovwf8#pvsslqwjmdf{wqfnfoz#nbjmpwqfbn?,pwqlmd=#slsvobqjwzfnsolznfmw?,wbaof=	#`lopsbm>!?,elqn=	##`lmufqpjlmbalvw#wkf#?,s=?,gju=jmwfdqbwfg!#obmd>!fmSlqwvdvfpfpvapwjwvwfjmgjujgvbojnslppjaofnvowjnfgjbbonlpw#boos{#plojg# bsbqw#eqlnpvaif`w#wljm#Fmdojpk`qjwj`jyfgf{`fsw#elqdvjgfojmfplqjdjmboozqfnbqhbaofwkf#pf`lmgk1#`obpp>!?b#wjwof>!+jm`ovgjmdsbqbnfwfqpsqlkjajwfg>#!kwws9,,gj`wjlmbqzsfq`fswjlmqfulovwjlmelvmgbwjlms{8kfjdkw9pv``fppevopvsslqwfqpnjoofmmjvnkjp#ebwkfqwkf#%rvlw8ml.qfsfbw8`lnnfq`jbojmgvpwqjbofm`lvqbdfgbnlvmw#le#vmleej`jbofeej`jfm`zQfefqfm`fp`llqgjmbwfgjp`objnfqf{sfgjwjlmgfufolsjmd`bo`vobwfgpjnsojejfgofdjwjnbwfpvapwqjmd+3!#`obpp>!`lnsofwfozjoovpwqbwfejuf#zfbqpjmpwqvnfmwSvaojpkjmd2!#`obpp>!spz`kloldz`lmejgfm`fmvnafq#le#bapfm`f#leel`vpfg#lmiljmfg#wkfpwqv`wvqfpsqfujlvpoz=?,jeqbnf=lm`f#bdbjmavw#qbwkfqjnnjdqbmwple#`lvqpf/b#dqlvs#leOjwfqbwvqfVmojhf#wkf?,b=%maps8	evm`wjlm#jw#tbp#wkf@lmufmwjlmbvwlnlajofSqlwfpwbmwbddqfppjufbewfq#wkf#Pjnjobqoz/!#,=?,gju=`loof`wjlm	evm`wjlmujpjajojwzwkf#vpf#leulovmwffqpbwwqb`wjlmvmgfq#wkf#wkqfbwfmfg)?"X@GBWBXjnslqwbm`fjm#dfmfqbowkf#obwwfq?,elqn=	?,-jmgf{Le+$j#>#38#j#?gjeefqfm`fgfulwfg#wlwqbgjwjlmppfbq`k#elqvowjnbwfozwlvqmbnfmwbwwqjavwfppl.`boofg#~	?,pwzof=fubovbwjlmfnskbpjyfgb``fppjaof?,pf`wjlm=pv``fppjlmbolmd#tjwkNfbmtkjof/jmgvpwqjfp?,b=?aq#,=kbp#af`lnfbpsf`wp#leWfofujpjlmpveej`jfmwabphfwabooalwk#pjgfp`lmwjmvjmdbm#bqwj`of?jnd#bow>!bgufmwvqfpkjp#nlwkfqnbm`kfpwfqsqjm`jsofpsbqwj`vobq`lnnfmwbqzfeef`wp#legf`jgfg#wl!=?pwqlmd=svaojpkfqpIlvqmbo#legjeej`vowzeb`jojwbwfb``fswbaofpwzof-`pp!\nevm`wjlm#jmmlubwjlm=@lszqjdkwpjwvbwjlmptlvog#kbufavpjmfppfpGj`wjlmbqzpwbwfnfmwplewfm#vpfgsfqpjpwfmwjm#Ibmvbqz`lnsqjpjmd?,wjwof=	\ngjsolnbwj``lmwbjmjmdsfqelqnjmdf{wfmpjlmpnbz#mlw#af`lm`fsw#le#lm`oj`h>!Jw#jp#boplejmbm`jbo#nbhjmd#wkfOv{fnalvqdbggjwjlmbobqf#`boofgfmdbdfg#jm!p`qjsw!*8avw#jw#tbpfof`wqlmj`lmpvanjw>!	?"..#Fmg#fof`wqj`boleej`jboozpvddfpwjlmwls#le#wkfvmojhf#wkfBvpwqbojbmLqjdjmboozqfefqfm`fp	?,kfbg=	qf`ldmjpfgjmjwjbojyfojnjwfg#wlBof{bmgqjbqfwjqfnfmwBgufmwvqfpelvq#zfbqp		%ow8"..#jm`qfbpjmdgf`lqbwjlmk0#`obpp>!lqjdjmp#lelaojdbwjlmqfdvobwjlm`obppjejfg+evm`wjlm+bgubmwbdfpafjmd#wkf#kjpwlqjbmp?abpf#kqfeqfsfbwfgoztjoojmd#wl`lnsbqbaofgfpjdmbwfgmlnjmbwjlmevm`wjlmbojmpjgf#wkfqfufobwjlmfmg#le#wkfp#elq#wkf#bvwklqjyfgqfevpfg#wlwbhf#sob`fbvwlmlnlvp`lnsqlnjpfslojwj`bo#qfpwbvqbmwwtl#le#wkfEfaqvbqz#1rvbojwz#leptelaif`w-vmgfqpwbmgmfbqoz#bootqjwwfm#azjmwfqujftp!#tjgwk>!2tjwkgqbtboeolbw9ofewjp#vpvbooz`bmgjgbwfpmftpsbsfqpnzpwfqjlvpGfsbqwnfmwafpw#hmltmsbqojbnfmwpvssqfppfg`lmufmjfmwqfnfnafqfggjeefqfmw#pzpwfnbwj`kbp#ofg#wlsqlsbdbmgb`lmwqloofgjmeovfm`fp`fqfnlmjbosql`objnfgSqlwf`wjlmoj#`obpp>!P`jfmwjej``obpp>!ml.wqbgfnbqhpnlqf#wkbm#tjgfpsqfbgOjafqbwjlmwllh#sob`fgbz#le#wkfbp#olmd#bpjnsqjplmfgBggjwjlmbo	?kfbg=	?nObalqbwlqzMlufnafq#1f{`fswjlmpJmgvpwqjboubqjfwz#leeolbw9#ofeGvqjmd#wkfbppfppnfmwkbuf#affm#gfbop#tjwkPwbwjpwj`pl``vqqfm`f,vo=?,gju=`ofbqej{!=wkf#svaoj`nbmz#zfbqptkj`k#tfqflufq#wjnf/pzmlmznlvp`lmwfmw!=	sqfpvnbaozkjp#ebnjozvpfqBdfmw-vmf{sf`wfgjm`ovgjmd#`kboofmdfgb#njmlqjwzvmgfejmfg!afolmdp#wlwbhfm#eqlnjm#L`wlafqslpjwjlm9#pbjg#wl#afqfojdjlvp#Efgfqbwjlm#qltpsbm>!lmoz#b#eftnfbmw#wkbwofg#wl#wkf..=	?gju#?ejfogpfw=Bq`kajpkls#`obpp>!mlafjmd#vpfgbssqlb`kfpsqjujofdfpmlp`qjsw=	qfpvowp#jmnbz#af#wkfFbpwfq#fddnf`kbmjpnpqfbplmbaofSlsvobwjlm@loof`wjlmpfof`wfg!=mlp`qjsw=,jmgf{-sksbqqjubo#le.ippgh$**8nbmbdfg#wljm`lnsofwf`bpvbowjfp`lnsofwjlm@kqjpwjbmpPfswfnafq#bqjwknfwj`sql`fgvqfpnjdkw#kbufSqlgv`wjlmjw#bssfbqpSkjolplskzeqjfmgpkjsofbgjmd#wldjujmd#wkfwltbqg#wkfdvbqbmwffggl`vnfmwfg`lolq9 333ujgfl#dbnf`lnnjppjlmqfeof`wjmd`kbmdf#wkfbppl`jbwfgpbmp.pfqjelmhfzsqfpp8#sbggjmd9Kf#tbp#wkfvmgfqozjmdwzsj`booz#/#bmg#wkf#pq`Fofnfmwpv``fppjufpjm`f#wkf#pklvog#af#mfwtlqhjmdb``lvmwjmdvpf#le#wkfoltfq#wkbmpkltp#wkbw?,psbm=	\n\n`lnsobjmwp`lmwjmvlvprvbmwjwjfpbpwqlmlnfqkf#gjg#mlwgvf#wl#jwpbssojfg#wlbm#bufqbdffeelqwp#wlwkf#evwvqfbwwfnsw#wlWkfqfelqf/`bsbajojwzQfsvaoj`bmtbp#elqnfgFof`wqlmj`hjolnfwfqp`kboofmdfpsvaojpkjmdwkf#elqnfqjmgjdfmlvpgjqf`wjlmppvapjgjbqz`lmpsjqb`zgfwbjop#lebmg#jm#wkfbeelqgbaofpvapwbm`fpqfbplm#elq`lmufmwjlmjwfnwzsf>!baplovwfozpvsslpfgozqfnbjmfg#bbwwqb`wjufwqbufoojmdpfsbqbwfozel`vpfp#lmfofnfmwbqzbssoj`baofelvmg#wkbwpwzofpkffwnbmvp`qjswpwbmgp#elq#ml.qfsfbw+plnfwjnfp@lnnfq`jbojm#Bnfqj`bvmgfqwbhfmrvbqwfq#lebm#f{bnsofsfqplmboozjmgf{-sks<?,avwwlm=	sfq`fmwbdfafpw.hmltm`qfbwjmd#b!#gjq>!owqOjfvwfmbmw	?gju#jg>!wkfz#tlvogbajojwz#lenbgf#vs#lemlwfg#wkbw`ofbq#wkbwbqdvf#wkbwwl#bmlwkfq`kjogqfm$psvqslpf#leelqnvobwfgabpfg#vslmwkf#qfdjlmpvaif`w#lesbppfmdfqpslppfppjlm-		Jm#wkf#Afelqf#wkfbewfqtbqgp`vqqfmwoz#b`qlpp#wkfp`jfmwjej``lnnvmjwz-`bsjwbojpnjm#Dfqnbmzqjdkw.tjmdwkf#pzpwfnPl`jfwz#leslojwj`jbmgjqf`wjlm9tfmw#lm#wlqfnlubo#le#Mft#Zlqh#bsbqwnfmwpjmgj`bwjlmgvqjmd#wkfvmofpp#wkfkjpwlqj`bokbg#affm#bgfejmjwjufjmdqfgjfmwbwwfmgbm`f@fmwfq#elqsqlnjmfm`fqfbgzPwbwfpwqbwfdjfpavw#jm#wkfbp#sbqw#le`lmpwjwvwf`objn#wkbwobalqbwlqz`lnsbwjaofebjovqf#le/#pv`k#bp#afdbm#tjwkvpjmd#wkf#wl#sqlujgfefbwvqf#leeqln#tkj`k,!#`obpp>!dfloldj`bopfufqbo#legfojafqbwfjnslqwbmw#klogp#wkbwjmd%rvlw8#ubojdm>wlswkf#Dfqnbmlvwpjgf#lemfdlwjbwfgkjp#`bqffqpfsbqbwjlmjg>!pfbq`ktbp#`boofgwkf#elvqwkqf`qfbwjlmlwkfq#wkbmsqfufmwjlmtkjof#wkf#fgv`bwjlm/`lmmf`wjmdb``vqbwfoztfqf#avjowtbp#hjoofgbdqffnfmwpnv`k#nlqf#Gvf#wl#wkftjgwk9#233plnf#lwkfqHjmdgln#lewkf#fmwjqfebnlvp#elqwl#`lmmf`wlaif`wjufpwkf#Eqfm`ksflsof#bmgefbwvqfg!=jp#pbjg#wlpwqv`wvqboqfefqfmgvnnlpw#lewfmb#pfsbqbwf.=	?gju#jg#Leej`jbo#tlqogtjgf-bqjb.obafowkf#sobmfwbmg#jw#tbpg!#ubovf>!ollhjmd#bwafmfej`jbobqf#jm#wkfnlmjwlqjmdqfslqwfgozwkf#nlgfqmtlqhjmd#lmbooltfg#wltkfqf#wkf#jmmlubwjuf?,b=?,gju=plvmgwqb`hpfbq`kElqnwfmg#wl#afjmsvw#jg>!lsfmjmd#leqfpwqj`wfgbglswfg#azbggqfppjmdwkfloldjbmnfwklgp#leubqjbmw#le@kqjpwjbm#ufqz#obqdfbvwlnlwjufaz#ebq#wkfqbmdf#eqlnsvqpvjw#leeloolt#wkfaqlvdkw#wljm#Fmdobmgbdqff#wkbwb``vpfg#le`lnfp#eqlnsqfufmwjmdgju#pwzof>kjp#lq#kfqwqfnfmglvpeqffgln#le`lm`fqmjmd3#2fn#2fn8Abphfwaboo,pwzof-`ppbm#fbqojfqfufm#bewfq,!#wjwof>!-`ln,jmgf{wbhjmd#wkfsjwwpavqdk`lmwfmw!=?p`qjsw=+ewvqmfg#lvwkbujmd#wkf?,psbm=	#l``bpjlmboaf`bvpf#jwpwbqwfg#wlskzpj`booz=?,gju=	##`qfbwfg#az@vqqfmwoz/#ad`lolq>!wbajmgf{>!gjpbpwqlvpBmbozwj`p#bopl#kbp#b=?gju#jg>!?,pwzof=	?`boofg#elqpjmdfq#bmg-pq`#>#!,,ujlobwjlmpwkjp#sljmw`lmpwbmwozjp#ol`bwfgqf`lqgjmdpg#eqln#wkfmfgfqobmgpslqwvdv/Fp;N;};D;u;F5m4K4]4_7`gfpbqqlool`lnfmwbqjlfgv`b`j/_mpfswjfnaqfqfdjpwqbglgjqf``j/_mvaj`b`j/_msvaoj`jgbgqfpsvfpwbpqfpvowbglpjnslqwbmwfqfpfqubglpbqw/A`volpgjefqfmwfppjdvjfmwfpqfs/Vaoj`bpjwvb`j/_mnjmjpwfqjlsqjub`jgbggjqf`wlqjlelqnb`j/_mslaob`j/_msqfpjgfmwf`lmw', 'fmjglpb``fplqjlpwf`kmlqbwjsfqplmbofp`bwfdlq/Abfpsf`jbofpgjpslmjaofb`wvbojgbgqfefqfm`jbuboobglojgajaojlwf`bqfob`jlmfp`bofmgbqjlslo/Awj`bpbmwfqjlqfpgl`vnfmwlpmbwvqbofybnbwfqjbofpgjefqfm`jbf`lm/_nj`bwqbmpslqwfqlgq/Advfysbqwj`jsbqfm`vfmwqbmgjp`vpj/_mfpwqv`wvqbevmgb`j/_meqf`vfmwfpsfqnbmfmwfwlwbonfmwf<P<R<Z<Q<R<]=o<X<Y=n<P<R<Z<Y=n<^=l<Y<P=c=n<\\<V<Z<Y=k=n<R<]=g<]<R<W<Y<Y<R=k<Y<Q=`=a=n<R<_<R<V<R<_<X<\\<S<R=m<W<Y<^=m<Y<_<R=m<\\<U=n<Y=k<Y=l<Y<[<P<R<_=o=n=m<\\<U=n<\\<Z<T<[<Q<T<P<Y<Z<X=o<]=o<X=o=n<s<R<T=m<V<[<X<Y=m=`<^<T<X<Y<R=m<^=c<[<T<Q=o<Z<Q<R=m<^<R<Y<U<W=b<X<Y<U<S<R=l<Q<R<P<Q<R<_<R<X<Y=n<Y<U=m<^<R<T=i<S=l<\\<^<\\=n<\\<V<R<U<P<Y=m=n<R<T<P<Y<Y=n<Z<T<[<Q=`<R<X<Q<R<U<W=o=k=d<Y<S<Y=l<Y<X=k<\\=m=n<T=k<\\=m=n=`=l<\\<]<R=n<Q<R<^=g=i<S=l<\\<^<R=m<R<]<R<U<S<R=n<R<P<P<Y<Q<Y<Y=k<T=m<W<Y<Q<R<^=g<Y=o=m<W=o<_<R<V<R<W<R<Q<\\<[<\\<X=n<\\<V<R<Y=n<R<_<X<\\<S<R=k=n<T<s<R=m<W<Y=n<\\<V<T<Y<Q<R<^=g<U=m=n<R<T=n=n<\\<V<T=i=m=l<\\<[=o<M<\\<Q<V=n=h<R=l=o<P<v<R<_<X<\\<V<Q<T<_<T=m<W<R<^<\\<Q<\\=d<Y<U<Q<\\<U=n<T=m<^<R<T<P=m<^=c<[=`<W=b<]<R<U=k<\\=m=n<R=m=l<Y<X<T<v=l<R<P<Y<H<R=l=o<P=l=g<Q<V<Y=m=n<\\<W<T<S<R<T=m<V=n=g=m=c=k<P<Y=m=c=j=j<Y<Q=n=l=n=l=o<X<\\=m<\\<P=g=i=l=g<Q<V<\\<q<R<^=g<U=k<\\=m<R<^<P<Y=m=n<\\=h<T<W=`<P<P<\\=l=n<\\=m=n=l<\\<Q<P<Y=m=n<Y=n<Y<V=m=n<Q<\\=d<T=i<P<T<Q=o=n<T<P<Y<Q<T<T<P<Y=b=n<Q<R<P<Y=l<_<R=l<R<X=m<\\<P<R<P=a=n<R<P=o<V<R<Q=j<Y=m<^<R<Y<P<V<\\<V<R<U<|=l=i<T<^5i5j4F4C5e4I4]4_4K5h4]4_4K5h4E4K5h4U4K5i5o4F4D5k4K4D4]4K5i4@4K5h5f5d5i4K5h4Y5d4]4@4C5f4C4E4K5h4U4Z5d4I4Z4K5m4E4K5h5n4_5i4K5h4U4K4D4F4A5i5f5h5i5h5m4K4F5i5h4F5n5e4F4U4C5f5h4K5h4X4U4]4O4B4D4K4]4F4[5d5f4]4U5h5f5o5i4I4]5m4K5n4[5h4D4K4F4K5h5h4V4E4F4]4F5f4D4K5h5j4K4_4K5h4X5f4B5i5j4F4C5f4K5h4U4]4D4K5h5n4Y4Y4K5m5h4K5i4U5h5f5k4K4F4A4C5f4G4K5h5h5k5i4K5h4U5i5h5i5o4F4D4E5f5i5o5j5o4K5h4[5m5h5m5f4C5f5d4I4C4K4]4E4F4K4]5f4B4K5h4Y4A4E4F4_4@5f5h4K5h5d5n4F4U5j4C5i4K5i4C5f5j4E4F4Y5i5f5i4O4]4X5f5m4K5h4\\5f5j4U4]4D5f4E4D5d4K4D4E4O5h4U4K4D4K5h4_5m4]5i4X4K5o5h4F4U4K5h5e4K5h4O5d5h4K5h4_5j4E4@4K5i4U4E4K5h4Y4A5m4K5h4C5f5j5o5h5i4K4F4K5h4B4K4Y4K5h5i5h5m4O4U4Z4K4M5o4F4K4D4E4K5h4B5f4]4]4_4K4J5h4K5h5n5h4D4K5h4O4C4D5i5n4K4[4U5i4]4K4_5h5i5j4[5n4E4K5h5o4F4D4K5h4]4@5h4K4X4F4]5o4K5h5n4C5i5f4U4[5f5opAzWbdMbnf+-isd!#bow>!2s{#plojg# -dje!#bow>!wqbmpsbqfmwjmelqnbwjlmbssoj`bwjlm!#lm`oj`h>!fpwbaojpkfgbgufqwjpjmd-smd!#bow>!fmujqlmnfmwsfqelqnbm`fbssqlsqjbwf%bns8ngbpk8jnnfgjbwfoz?,pwqlmd=?,qbwkfq#wkbmwfnsfqbwvqfgfufolsnfmw`lnsfwjwjlmsob`fklogfqujpjajojwz9`lszqjdkw!=3!#kfjdkw>!fufm#wklvdkqfsob`fnfmwgfpwjmbwjlm@lqslqbwjlm?vo#`obpp>!Bppl`jbwjlmjmgjujgvbopsfqpsf`wjufpfwWjnflvw+vqo+kwws9,,nbwkfnbwj`pnbqdjm.wls9fufmwvbooz#gfp`qjswjlm*#ml.qfsfbw`loof`wjlmp-ISDwkvnasbqwj`jsbwf,kfbg=?algzeolbw9ofew8?oj#`obpp>!kvmgqfgp#le		Kltfufq/#`lnslpjwjlm`ofbq9alwk8`llsfqbwjlmtjwkjm#wkf#obafo#elq>!alqgfq.wls9Mft#Yfbobmgqf`lnnfmgfgsklwldqbskzjmwfqfpwjmd%ow8pvs%dw8`lmwqlufqpzMfwkfqobmgpbowfqmbwjufnb{ofmdwk>!ptjwyfqobmgGfufolsnfmwfppfmwjbooz		Bowklvdk#?,wf{wbqfb=wkvmgfqajqgqfsqfpfmwfg%bns8mgbpk8psf`vobwjlm`lnnvmjwjfpofdjpobwjlmfof`wqlmj`p	\n?gju#jg>!joovpwqbwfgfmdjmffqjmdwfqqjwlqjfpbvwklqjwjfpgjpwqjavwfg5!#kfjdkw>!pbmp.pfqje8`bsbaof#le#gjpbssfbqfgjmwfqb`wjufollhjmd#elqjw#tlvog#afBedkbmjpwbmtbp#`qfbwfgNbwk-eollq+pvqqlvmgjmd`bm#bopl#aflapfqubwjlmnbjmwfmbm`ffm`lvmwfqfg?k1#`obpp>!nlqf#qf`fmwjw#kbp#affmjmubpjlm#le*-dfwWjnf+*evmgbnfmwboGfpsjwf#wkf!=?gju#jg>!jmpsjqbwjlmf{bnjmbwjlmsqfsbqbwjlmf{sobmbwjlm?jmsvw#jg>!?,b=?,psbm=ufqpjlmp#lejmpwqvnfmwpafelqf#wkf##>#$kwws9,,Gfp`qjswjlmqfobwjufoz#-pvapwqjmd+fb`k#le#wkff{sfqjnfmwpjmeovfmwjbojmwfdqbwjlmnbmz#sflsofgvf#wl#wkf#`lnajmbwjlmgl#mlw#kbufNjggof#Fbpw?mlp`qjsw=?`lszqjdkw!#sfqkbsp#wkfjmpwjwvwjlmjm#Gf`fnafqbqqbmdfnfmwnlpw#ebnlvpsfqplmbojwz`qfbwjlm#leojnjwbwjlmpf{`ovpjufozplufqfjdmwz.`lmwfmw!=	?wg#`obpp>!vmgfqdqlvmgsbqboofo#wlgl`wqjmf#lel``vsjfg#azwfqnjmloldzQfmbjppbm`fb#mvnafq#lepvsslqw#elqf{solqbwjlmqf`ldmjwjlmsqfgf`fpplq?jnd#pq`>!,?k2#`obpp>!svaoj`bwjlmnbz#bopl#afpsf`jbojyfg?,ejfogpfw=sqldqfppjufnjoojlmp#lepwbwfp#wkbwfmelq`fnfmwbqlvmg#wkf#lmf#bmlwkfq-sbqfmwMlgfbdqj`vowvqfBowfqmbwjufqfpfbq`kfqpwltbqgp#wkfNlpw#le#wkfnbmz#lwkfq#+fpsf`jbooz?wg#tjgwk>!8tjgwk9233&jmgfsfmgfmw?k0#`obpp>!#lm`kbmdf>!*-bgg@obpp+jmwfqb`wjlmLmf#le#wkf#gbvdkwfq#leb``fpplqjfpaqbm`kfp#le	?gju#jg>!wkf#obqdfpwgf`obqbwjlmqfdvobwjlmpJmelqnbwjlmwqbmpobwjlmgl`vnfmwbqzjm#lqgfq#wl!=	?kfbg=	?!#kfjdkw>!2b`qlpp#wkf#lqjfmwbwjlm*8?,p`qjsw=jnsofnfmwfg`bm#af#pffmwkfqf#tbp#bgfnlmpwqbwf`lmwbjmfq!=`lmmf`wjlmpwkf#Aqjwjpktbp#tqjwwfm"jnslqwbmw8s{8#nbqdjm.elooltfg#azbajojwz#wl#`lnsoj`bwfggvqjmd#wkf#jnnjdqbwjlmbopl#`boofg?k7#`obpp>!gjpwjm`wjlmqfsob`fg#azdlufqmnfmwpol`bwjlm#lejm#Mlufnafqtkfwkfq#wkf?,s=	?,gju=b`rvjpjwjlm`boofg#wkf#sfqpf`vwjlmgfpjdmbwjlmxelmw.pjyf9bssfbqfg#jmjmufpwjdbwff{sfqjfm`fgnlpw#ojhfoztjgfoz#vpfggjp`vppjlmpsqfpfm`f#le#+gl`vnfmw-f{wfmpjufozJw#kbp#affmjw#glfp#mlw`lmwqbqz#wljmkbajwbmwpjnsqlufnfmwp`klobqpkjs`lmpvnswjlmjmpwqv`wjlmelq#f{bnsoflmf#lq#nlqfs{8#sbggjmdwkf#`vqqfmwb#pfqjfp#lebqf#vpvboozqlof#jm#wkfsqfujlvpoz#gfqjubwjufpfujgfm`f#lef{sfqjfm`fp`lolqp`kfnfpwbwfg#wkbw`fqwjej`bwf?,b=?,gju=	#pfof`wfg>!kjdk#p`klloqfpslmpf#wl`lnelqwbaofbglswjlm#lewkqff#zfbqpwkf#`lvmwqzjm#Efaqvbqzpl#wkbw#wkfsflsof#tkl#sqlujgfg#az?sbqbn#mbnfbeef`wfg#azjm#wfqnp#lebssljmwnfmwJPL.;;6:.2!tbp#alqm#jmkjpwlqj`bo#qfdbqgfg#bpnfbpvqfnfmwjp#abpfg#lm#bmg#lwkfq#9#evm`wjlm+pjdmjej`bmw`fofaqbwjlmwqbmpnjwwfg,ip,irvfqz-jp#hmltm#bpwkflqfwj`bo#wbajmgf{>!jw#`lvog#af?mlp`qjsw=	kbujmd#affm	?kfbg=	?#%rvlw8Wkf#`lnsjobwjlmkf#kbg#affmsqlgv`fg#azskjolplskfq`lmpwqv`wfgjmwfmgfg#wlbnlmd#lwkfq`lnsbqfg#wlwl#pbz#wkbwFmdjmffqjmdb#gjeefqfmwqfefqqfg#wlgjeefqfm`fpafojfe#wkbwsklwldqbskpjgfmwjezjmdKjpwlqz#le#Qfsvaoj`#lemf`fppbqjozsqlabajojwzwf`kmj`boozofbujmd#wkfpsf`wb`vobqeqb`wjlm#lefof`wqj`jwzkfbg#le#wkfqfpwbvqbmwpsbqwmfqpkjsfnskbpjp#lmnlpw#qf`fmwpkbqf#tjwk#pbzjmd#wkbwejoofg#tjwkgfpjdmfg#wljw#jp#lewfm!=?,jeqbnf=bp#elooltp9nfqdfg#tjwkwkqlvdk#wkf`lnnfq`jbo#sljmwfg#lvwlsslqwvmjwzujft#le#wkfqfrvjqfnfmwgjujpjlm#lesqldqbnnjmdkf#qf`fjufgpfwJmwfqubo!=?,psbm=?,jm#Mft#Zlqhbggjwjlmbo#`lnsqfppjlm		?gju#jg>!jm`lqslqbwf8?,p`qjsw=?bwwb`kFufmwaf`bnf#wkf#!#wbqdfw>!\\`bqqjfg#lvwPlnf#le#wkfp`jfm`f#bmgwkf#wjnf#le@lmwbjmfq!=nbjmwbjmjmd@kqjpwlskfqNv`k#le#wkftqjwjmdp#le!#kfjdkw>!1pjyf#le#wkfufqpjlm#le#nj{wvqf#le#afwtffm#wkfF{bnsofp#lefgv`bwjlmbo`lnsfwjwjuf#lmpvanjw>!gjqf`wlq#legjpwjm`wjuf,GWG#[KWNO#qfobwjmd#wlwfmgfm`z#wlsqlujm`f#letkj`k#tlvoggfpsjwf#wkfp`jfmwjej`#ofdjpobwvqf-jmmfqKWNO#boofdbwjlmpBdqj`vowvqftbp#vpfg#jmbssqlb`k#wljmwfoojdfmwzfbqp#obwfq/pbmp.pfqjegfwfqnjmjmdSfqelqnbm`fbssfbqbm`fp/#tkj`k#jp#elvmgbwjlmpbaaqfujbwfgkjdkfq#wkbmp#eqln#wkf#jmgjujgvbo#`lnslpfg#lepvsslpfg#wl`objnp#wkbwbwwqjavwjlmelmw.pjyf92fofnfmwp#leKjpwlqj`bo#kjp#aqlwkfqbw#wkf#wjnfbmmjufqpbqzdlufqmfg#azqfobwfg#wl#vowjnbwfoz#jmmlubwjlmpjw#jp#pwjoo`bm#lmoz#afgfejmjwjlmpwlDNWPwqjmdB#mvnafq#lejnd#`obpp>!Fufmwvbooz/tbp#`kbmdfgl``vqqfg#jmmfjdkalqjmdgjpwjmdvjpktkfm#kf#tbpjmwqlgv`jmdwfqqfpwqjboNbmz#le#wkfbqdvfp#wkbwbm#Bnfqj`bm`lmrvfpw#letjgfpsqfbg#tfqf#hjoofgp`qffm#bmg#Jm#lqgfq#wlf{sf`wfg#wlgfp`fmgbmwpbqf#ol`bwfgofdjpobwjufdfmfqbwjlmp#ab`hdqlvmgnlpw#sflsofzfbqp#bewfqwkfqf#jp#mlwkf#kjdkfpweqfrvfmwoz#wkfz#gl#mlwbqdvfg#wkbwpkltfg#wkbwsqfglnjmbmwwkfloldj`boaz#wkf#wjnf`lmpjgfqjmdpklqw.ojufg?,psbm=?,b=`bm#af#vpfgufqz#ojwwoflmf#le#wkf#kbg#boqfbgzjmwfqsqfwfg`lnnvmj`bwfefbwvqfp#ledlufqmnfmw/?,mlp`qjsw=fmwfqfg#wkf!#kfjdkw>!0Jmgfsfmgfmwslsvobwjlmpobqdf.p`bof-#Bowklvdk#vpfg#jm#wkfgfpwqv`wjlmslppjajojwzpwbqwjmd#jmwtl#lq#nlqff{sqfppjlmppvalqgjmbwfobqdfq#wkbmkjpwlqz#bmg?,lswjlm=	@lmwjmfmwbofojnjmbwjmdtjoo#mlw#afsqb`wj`f#lejm#eqlmw#lepjwf#le#wkffmpvqf#wkbwwl#`qfbwf#bnjppjppjssjslwfmwjboozlvwpwbmgjmdafwwfq#wkbmtkbw#jp#mltpjwvbwfg#jmnfwb#mbnf>!WqbgjwjlmbopvddfpwjlmpWqbmpobwjlmwkf#elqn#lebwnlpskfqj`jgfloldj`bofmwfqsqjpfp`bo`vobwjmdfbpw#le#wkfqfnmbmwp#lesovdjmpsbdf,jmgf{-sks<qfnbjmfg#jmwqbmpelqnfgKf#tbp#bopltbp#boqfbgzpwbwjpwj`bojm#ebulq#leNjmjpwqz#lenlufnfmw#leelqnvobwjlmjp#qfrvjqfg?ojmh#qfo>!Wkjp#jp#wkf#?b#kqfe>!,slsvobqjyfgjmuloufg#jmbqf#vpfg#wlbmg#pfufqbonbgf#az#wkfpffnp#wl#afojhfoz#wkbwSbofpwjmjbmmbnfg#bewfqjw#kbg#affmnlpw#`lnnlmwl#qfefq#wlavw#wkjp#jp`lmpf`vwjufwfnslqbqjozJm#dfmfqbo/`lmufmwjlmpwbhfp#sob`fpvagjujpjlmwfqqjwlqjbolsfqbwjlmbosfqnbmfmwoztbp#obqdfozlvwaqfbh#lejm#wkf#sbpwelooltjmd#b#{nomp9ld>!=?b#`obpp>!`obpp>!wf{w@lmufqpjlm#nbz#af#vpfgnbmveb`wvqfbewfq#afjmd`ofbqej{!=	rvfpwjlm#letbp#fof`wfgwl#af`lnf#baf`bvpf#le#plnf#sflsofjmpsjqfg#azpv``fppevo#b#wjnf#tkfmnlqf#`lnnlmbnlmdpw#wkfbm#leej`jbotjgwk9233&8wf`kmloldz/tbp#bglswfgwl#hffs#wkfpfwwofnfmwpojuf#ajqwkpjmgf{-kwno!@lmmf`wj`vwbppjdmfg#wl%bns8wjnfp8b``lvmw#elqbojdm>qjdkwwkf#`lnsbmzbotbzp#affmqfwvqmfg#wljmuloufnfmwAf`bvpf#wkfwkjp#sfqjlg!#mbnf>!r!#`lmejmfg#wlb#qfpvow#leubovf>!!#,=jp#b`wvboozFmujqlmnfmw	?,kfbg=	@lmufqpfoz/=	?gju#jg>!3!#tjgwk>!2jp#sqlabaozkbuf#af`lnf`lmwqloojmdwkf#sqlaofn`jwjyfmp#leslojwj`jbmpqfb`kfg#wkfbp#fbqoz#bp9mlmf8#lufq?wbaof#`fooubojgjwz#legjqf`woz#wllmnlvpfgltmtkfqf#jw#jptkfm#jw#tbpnfnafqp#le#qfobwjlm#wlb``lnnlgbwfbolmd#tjwk#Jm#wkf#obwfwkf#Fmdojpkgfoj`jlvp!=wkjp#jp#mlwwkf#sqfpfmwje#wkfz#bqfbmg#ejmboozb#nbwwfq#le	\n?,gju=		?,p`qjsw=ebpwfq#wkbmnbilqjwz#lebewfq#tkj`k`lnsbqbwjufwl#nbjmwbjmjnsqluf#wkfbtbqgfg#wkffq!#`obpp>!eqbnfalqgfqqfpwlqbwjlmjm#wkf#pbnfbmbozpjp#lewkfjq#ejqpwGvqjmd#wkf#`lmwjmfmwbopfrvfm`f#leevm`wjlm+*xelmw.pjyf9#tlqh#lm#wkf?,p`qjsw=	?afdjmp#tjwkibubp`qjsw9`lmpwjwvfmwtbp#elvmgfgfrvjojaqjvnbppvnf#wkbwjp#djufm#azmffgp#wl#af`llqgjmbwfpwkf#ubqjlvpbqf#sbqw#lelmoz#jm#wkfpf`wjlmp#lejp#b#`lnnlmwkflqjfp#legjp`lufqjfpbppl`jbwjlmfgdf#le#wkfpwqfmdwk#leslpjwjlm#jmsqfpfmw.gbzvmjufqpboozwl#elqn#wkfavw#jmpwfbg`lqslqbwjlmbwwb`kfg#wljp#`lnnlmozqfbplmp#elq#%rvlw8wkf#`bm#af#nbgftbp#baof#wltkj`k#nfbmpavw#gjg#mlwlmNlvpfLufqbp#slppjaoflsfqbwfg#az`lnjmd#eqlnwkf#sqjnbqzbggjwjlm#leelq#pfufqbowqbmpefqqfgb#sfqjlg#lebqf#baof#wlkltfufq/#jwpklvog#kbufnv`k#obqdfq	\n?,p`qjsw=bglswfg#wkfsqlsfqwz#legjqf`wfg#azfeef`wjufoztbp#aqlvdkw`kjogqfm#leSqldqbnnjmdolmdfq#wkbmnbmvp`qjswptbq#bdbjmpwaz#nfbmp#lebmg#nlpw#lepjnjobq#wl#sqlsqjfwbqzlqjdjmbwjmdsqfpwjdjlvpdqbnnbwj`bof{sfqjfm`f-wl#nbhf#wkfJw#tbp#bopljp#elvmg#jm`lnsfwjwlqpjm#wkf#V-P-qfsob`f#wkfaqlvdkw#wkf`bo`vobwjlmeboo#le#wkfwkf#dfmfqbosqb`wj`boozjm#klmlq#leqfofbpfg#jmqfpjgfmwjbobmg#plnf#lehjmd#le#wkfqfb`wjlm#wl2pw#Fbqo#le`vowvqf#bmgsqjm`jsbooz?,wjwof=	##wkfz#`bm#afab`h#wl#wkfplnf#le#kjpf{slpvqf#wlbqf#pjnjobqelqn#le#wkfbggEbulqjwf`jwjyfmpkjssbqw#jm#wkfsflsof#tjwkjm#sqb`wj`fwl#`lmwjmvf%bns8njmvp8bssqlufg#az#wkf#ejqpw#booltfg#wkfbmg#elq#wkfevm`wjlmjmdsobzjmd#wkfplovwjlm#wlkfjdkw>!3!#jm#kjp#allhnlqf#wkbm#belooltp#wkf`qfbwfg#wkfsqfpfm`f#jm%maps8?,wg=mbwjlmbojpwwkf#jgfb#leb#`kbqb`wfqtfqf#elq`fg#`obpp>!awmgbzp#le#wkfefbwvqfg#jmpkltjmd#wkfjmwfqfpw#jmjm#sob`f#lewvqm#le#wkfwkf#kfbg#leOlqg#le#wkfslojwj`boozkbp#jwp#ltmFgv`bwjlmbobssqlubo#leplnf#le#wkffb`k#lwkfq/afkbujlq#lebmg#af`bvpfbmg#bmlwkfqbssfbqfg#lmqf`lqgfg#jmaob`h%rvlw8nbz#jm`ovgfwkf#tlqog$p`bm#ofbg#wlqfefqp#wl#balqgfq>!3!#dlufqmnfmw#tjmmjmd#wkfqfpvowfg#jm#tkjof#wkf#Tbpkjmdwlm/wkf#pvaif`w`jwz#jm#wkf=?,gju=	\n\nqfeof`w#wkfwl#`lnsofwfaf`bnf#nlqfqbgjlb`wjufqfif`wfg#aztjwklvw#bmzkjp#ebwkfq/tkj`k#`lvog`lsz#le#wkfwl#jmgj`bwfb#slojwj`bob``lvmwp#le`lmpwjwvwfptlqhfg#tjwkfq?,b=?,oj=le#kjp#ojefb``lnsbmjfg`ojfmwTjgwksqfufmw#wkfOfdjpobwjufgjeefqfmwozwldfwkfq#jmkbp#pfufqboelq#bmlwkfqwf{w#le#wkfelvmgfg#wkff#tjwk#wkf#jp#vpfg#elq`kbmdfg#wkfvpvbooz#wkfsob`f#tkfqftkfqfbp#wkf=#?b#kqfe>!!=?b#kqfe>!wkfnpfoufp/bowklvdk#kfwkbw#`bm#afwqbgjwjlmboqlof#le#wkfbp#b#qfpvowqfnluf@kjoggfpjdmfg#aztfpw#le#wkfPlnf#sflsofsqlgv`wjlm/pjgf#le#wkfmftpofwwfqpvpfg#az#wkfgltm#wl#wkfb``fswfg#azojuf#jm#wkfbwwfnswp#wllvwpjgf#wkfeqfrvfm`jfpKltfufq/#jmsqldqbnnfqpbw#ofbpw#jmbssql{jnbwfbowklvdk#jwtbp#sbqw#lebmg#ubqjlvpDlufqmlq#lewkf#bqwj`ofwvqmfg#jmwl=?b#kqfe>!,wkf#f`lmlnzjp#wkf#nlpwnlpw#tjgfoztlvog#obwfqbmg#sfqkbspqjpf#wl#wkfl``vqp#tkfmvmgfq#tkj`k`lmgjwjlmp-wkf#tfpwfqmwkflqz#wkbwjp#sqlgv`fgwkf#`jwz#lejm#tkj`k#kfpffm#jm#wkfwkf#`fmwqboavjogjmd#lenbmz#le#kjpbqfb#le#wkfjp#wkf#lmoznlpw#le#wkfnbmz#le#wkfwkf#TfpwfqmWkfqf#jp#mlf{wfmgfg#wlPwbwjpwj`bo`lopsbm>1#pklqw#pwlqzslppjaof#wlwlsloldj`bo`qjwj`bo#leqfslqwfg#wlb#@kqjpwjbmgf`jpjlm#wljp#frvbo#wlsqlaofnp#leWkjp#`bm#afnfq`kbmgjpfelq#nlpw#leml#fujgfm`ffgjwjlmp#lefofnfmwp#jm%rvlw8-#Wkf`ln,jnbdfp,tkj`k#nbhfpwkf#sql`fppqfnbjmp#wkfojwfqbwvqf/jp#b#nfnafqwkf#slsvobqwkf#bm`jfmwsqlaofnp#jmwjnf#le#wkfgfefbwfg#azalgz#le#wkfb#eft#zfbqpnv`k#le#wkfwkf#tlqh#le@bojelqmjb/pfqufg#bp#bdlufqmnfmw-`lm`fswp#lenlufnfmw#jm\n\n?gju#jg>!jw!#ubovf>!obmdvbdf#lebp#wkfz#bqfsqlgv`fg#jmjp#wkbw#wkff{sobjm#wkfgju=?,gju=	Kltfufq#wkfofbg#wl#wkf\n?b#kqfe>!,tbp#dqbmwfgsflsof#kbuf`lmwjmvbooztbp#pffm#bpbmg#qfobwfgwkf#qlof#lesqlslpfg#azle#wkf#afpwfb`k#lwkfq-@lmpwbmwjmfsflsof#eqlngjbof`wp#lewl#qfujpjlmtbp#qfmbnfgb#plvq`f#lewkf#jmjwjboobvm`kfg#jmsqlujgf#wkfwl#wkf#tfpwtkfqf#wkfqfbmg#pjnjobqafwtffm#wtljp#bopl#wkfFmdojpk#bmg`lmgjwjlmp/wkbw#jw#tbpfmwjwofg#wlwkfnpfoufp-rvbmwjwz#leqbmpsbqfm`zwkf#pbnf#bpwl#iljm#wkf`lvmwqz#bmgwkjp#jp#wkfWkjp#ofg#wlb#pwbwfnfmw`lmwqbpw#wlobpwJmgf{Lewkqlvdk#kjpjp#gfpjdmfgwkf#wfqn#jpjp#sqlujgfgsqlwf`w#wkfmd?,b=?,oj=Wkf#`vqqfmwwkf#pjwf#lepvapwbmwjbof{sfqjfm`f/jm#wkf#Tfpwwkfz#pklvogpolufm(ajmb`lnfmwbqjlpvmjufqpjgbg`lmgj`jlmfpb`wjujgbgfpf{sfqjfm`jbwf`mlold/Absqlgv``j/_msvmwvb`j/_mbsoj`b`j/_m`lmwqbpf/]b`bwfdlq/Abpqfdjpwqbqpfsqlefpjlmbowqbwbnjfmwlqfd/Apwqbwfpf`qfwbq/Absqjm`jsbofpsqlwf``j/_mjnslqwbmwfpjnslqwbm`jbslpjajojgbgjmwfqfpbmwf`qf`jnjfmwlmf`fpjgbgfppvp`qjajqpfbpl`jb`j/_mgjpslmjaofpfubovb`j/_mfpwvgjbmwfpqfpslmpbaofqfplov`j/_mdvbgbobibqbqfdjpwqbglplslqwvmjgbg`lnfq`jbofpelwldqbe/Abbvwlqjgbgfpjmdfmjfq/Abwfofujpj/_m`lnsfwfm`jblsfqb`jlmfpfpwbaof`jglpjnsofnfmwfb`wvbonfmwfmbufdb`j/_m`lmelqnjgbgojmf.kfjdkw9elmw.ebnjoz9!#9#!kwws9,,bssoj`bwjlmpojmh!#kqfe>!psf`jej`booz,,?"X@GBWBX	Lqdbmjybwjlmgjpwqjavwjlm3s{8#kfjdkw9qfobwjlmpkjsgfuj`f.tjgwk?gju#`obpp>!?obafo#elq>!qfdjpwqbwjlm?,mlp`qjsw=	,jmgf{-kwno!tjmglt-lsfm+#"jnslqwbmw8bssoj`bwjlm,jmgfsfmgfm`f,,ttt-dlldoflqdbmjybwjlmbvwl`lnsofwfqfrvjqfnfmwp`lmpfqubwjuf?elqn#mbnf>!jmwfoof`wvbonbqdjm.ofew92;wk#`fmwvqzbm#jnslqwbmwjmpwjwvwjlmpbaaqfujbwjlm?jnd#`obpp>!lqdbmjpbwjlm`jujojybwjlm2:wk#`fmwvqzbq`kjwf`wvqfjm`lqslqbwfg13wk#`fmwvqz.`lmwbjmfq!=nlpw#mlwbaoz,=?,b=?,gju=mlwjej`bwjlm$vmgfejmfg$*Evqwkfqnlqf/afojfuf#wkbwjmmfqKWNO#>#sqjlq#wl#wkfgqbnbwj`boozqfefqqjmd#wlmfdlwjbwjlmpkfbgrvbqwfqpPlvwk#Beqj`bvmpv``fppevoSfmmpzoubmjbBp#b#qfpvow/?kwno#obmd>!%ow8,pvs%dw8gfbojmd#tjwkskjobgfoskjbkjpwlqj`booz*8?,p`qjsw=	sbggjmd.wls9f{sfqjnfmwbodfwBwwqjavwfjmpwqv`wjlmpwf`kmloldjfpsbqw#le#wkf#>evm`wjlm+*xpvap`qjswjlmo-gwg!=	?kwdfldqbskj`bo@lmpwjwvwjlm$/#evm`wjlm+pvsslqwfg#azbdqj`vowvqbo`lmpwqv`wjlmsvaoj`bwjlmpelmw.pjyf9#2b#ubqjfwz#le?gju#pwzof>!Fm`z`olsfgjbjeqbnf#pq`>!gfnlmpwqbwfgb``lnsojpkfgvmjufqpjwjfpGfnldqbskj`p*8?,p`qjsw=?gfgj`bwfg#wlhmltofgdf#lepbwjpeb`wjlmsbqwj`vobqoz?,gju=?,gju=Fmdojpk#+VP*bssfmg@kjog+wqbmpnjppjlmp-#Kltfufq/#jmwfoojdfm`f!#wbajmgf{>!eolbw9qjdkw8@lnnlmtfbowkqbmdjmd#eqlnjm#tkj`k#wkfbw#ofbpw#lmfqfsqlgv`wjlmfm`z`olsfgjb8elmw.pjyf92ivqjpgj`wjlmbw#wkbw#wjnf!=?b#`obpp>!Jm#bggjwjlm/gfp`qjswjlm(`lmufqpbwjlm`lmwb`w#tjwkjp#dfmfqboozq!#`lmwfmw>!qfsqfpfmwjmd%ow8nbwk%dw8sqfpfmwbwjlml``bpjlmbooz?jnd#tjgwk>!mbujdbwjlm!=`lnsfmpbwjlm`kbnsjlmpkjsnfgjb>!boo!#ujlobwjlm#leqfefqfm`f#wlqfwvqm#wqvf8Pwqj`w,,FM!#wqbmpb`wjlmpjmwfqufmwjlmufqjej`bwjlmJmelqnbwjlm#gjeej`vowjfp@kbnsjlmpkjs`bsbajojwjfp?"Xfmgje^..=~	?,p`qjsw=	@kqjpwjbmjwzelq#f{bnsof/Sqlefppjlmboqfpwqj`wjlmppvddfpw#wkbwtbp#qfofbpfg+pv`k#bp#wkfqfnluf@obpp+vmfnsolznfmwwkf#Bnfqj`bmpwqv`wvqf#le,jmgf{-kwno#svaojpkfg#jmpsbm#`obpp>!!=?b#kqfe>!,jmwqlgv`wjlmafolmdjmd#wl`objnfg#wkbw`lmpfrvfm`fp?nfwb#mbnf>!Dvjgf#wl#wkflufqtkfonjmdbdbjmpw#wkf#`lm`fmwqbwfg/	-mlmwlv`k#lapfqubwjlmp?,b=	?,gju=	e#+gl`vnfmw-alqgfq9#2s{#xelmw.pjyf92wqfbwnfmw#le3!#kfjdkw>!2nlgjej`bwjlmJmgfsfmgfm`fgjujgfg#jmwldqfbwfq#wkbmb`kjfufnfmwpfpwbaojpkjmdIbubP`qjsw!#mfufqwkfofpppjdmjej`bm`fAqlbg`bpwjmd=%maps8?,wg=`lmwbjmfq!=	pv`k#bp#wkf#jmeovfm`f#leb#sbqwj`vobqpq`>$kwws9,,mbujdbwjlm!#kboe#le#wkf#pvapwbmwjbo#%maps8?,gju=bgubmwbdf#legjp`lufqz#leevmgbnfmwbo#nfwqlslojwbmwkf#lsslpjwf!#{no9obmd>!gfojafqbwfozbojdm>`fmwfqfulovwjlm#lesqfpfqubwjlmjnsqlufnfmwpafdjmmjmd#jmIfpvp#@kqjpwSvaoj`bwjlmpgjpbdqffnfmwwf{w.bojdm9q/#evm`wjlm+*pjnjobqjwjfpalgz=?,kwno=jp#`vqqfmwozboskbafwj`bojp#plnfwjnfpwzsf>!jnbdf,nbmz#le#wkf#eolt9kjggfm8bubjobaof#jmgfp`qjaf#wkff{jpwfm`f#leboo#lufq#wkfwkf#Jmwfqmfw\n?vo#`obpp>!jmpwboobwjlmmfjdkalqkllgbqnfg#elq`fpqfgv`jmd#wkf`lmwjmvfp#wlMlmfwkfofpp/wfnsfqbwvqfp	\n\n?b#kqfe>!`olpf#wl#wkff{bnsofp#le#jp#balvw#wkf+pff#afolt*-!#jg>!pfbq`ksqlefppjlmbojp#bubjobaofwkf#leej`jbo\n\n?,p`qjsw=		\n\n?gju#jg>!b``fofqbwjlmwkqlvdk#wkf#Kboo#le#Ebnfgfp`qjswjlmpwqbmpobwjlmpjmwfqefqfm`f#wzsf>$wf{w,qf`fmw#zfbqpjm#wkf#tlqogufqz#slsvobqxab`hdqlvmg9wqbgjwjlmbo#plnf#le#wkf#`lmmf`wfg#wlf{soljwbwjlmfnfqdfm`f#le`lmpwjwvwjlmB#Kjpwlqz#lepjdmjej`bmw#nbmveb`wvqfgf{sf`wbwjlmp=?mlp`qjsw=?`bm#af#elvmgaf`bvpf#wkf#kbp#mlw#affmmfjdkalvqjmdtjwklvw#wkf#bggfg#wl#wkf\n?oj#`obpp>!jmpwqvnfmwboPlujfw#Vmjlmb`hmltofgdfgtkj`k#`bm#afmbnf#elq#wkfbwwfmwjlm#wlbwwfnswp#wl#gfufolsnfmwpJm#eb`w/#wkf?oj#`obpp>!bjnsoj`bwjlmppvjwbaof#elqnv`k#le#wkf#`lolmjybwjlmsqfpjgfmwjbo`bm`foAvaaof#Jmelqnbwjlmnlpw#le#wkf#jp#gfp`qjafgqfpw#le#wkf#nlqf#lq#ofppjm#PfswfnafqJmwfoojdfm`fpq`>!kwws9,,s{8#kfjdkw9#bubjobaof#wlnbmveb`wvqfqkvnbm#qjdkwpojmh#kqfe>!,bubjobajojwzsqlslqwjlmbolvwpjgf#wkf#bpwqlmlnj`bokvnbm#afjmdpmbnf#le#wkf#bqf#elvmg#jmbqf#abpfg#lmpnboofq#wkbmb#sfqplm#tklf{sbmpjlm#lebqdvjmd#wkbwmlt#hmltm#bpJm#wkf#fbqozjmwfqnfgjbwfgfqjufg#eqlnP`bmgjmbujbm?,b=?,gju=	`lmpjgfq#wkfbm#fpwjnbwfgwkf#Mbwjlmbo?gju#jg>!sbdqfpvowjmd#jm`lnnjppjlmfgbmboldlvp#wlbqf#qfrvjqfg,vo=	?,gju=	tbp#abpfg#lmbmg#af`bnf#b%maps8%maps8w!#ubovf>!!#tbp#`bswvqfgml#nlqf#wkbmqfpsf`wjufoz`lmwjmvf#wl#=	?kfbg=	?tfqf#`qfbwfgnlqf#dfmfqbojmelqnbwjlm#vpfg#elq#wkfjmgfsfmgfmw#wkf#Jnsfqjbo`lnslmfmw#lewl#wkf#mlqwkjm`ovgf#wkf#@lmpwqv`wjlmpjgf#le#wkf#tlvog#mlw#afelq#jmpwbm`fjmufmwjlm#lenlqf#`lnsof{`loof`wjufozab`hdqlvmg9#wf{w.bojdm9#jwp#lqjdjmbojmwl#b``lvmwwkjp#sql`fppbm#f{wfmpjufkltfufq/#wkfwkfz#bqf#mlwqfif`wfg#wkf`qjwj`jpn#legvqjmd#tkj`ksqlabaoz#wkfwkjp#bqwj`of+evm`wjlm+*xJw#pklvog#afbm#bdqffnfmwb``jgfmwboozgjeefqp#eqlnBq`kjwf`wvqfafwwfq#hmltmbqqbmdfnfmwpjmeovfm`f#lmbwwfmgfg#wkfjgfmwj`bo#wlplvwk#le#wkfsbpp#wkqlvdk{no!#wjwof>!tfjdkw9alog8`qfbwjmd#wkfgjpsobz9mlmfqfsob`fg#wkf?jnd#pq`>!,jkwwsp9,,ttt-Tlqog#Tbq#JJwfpwjnlmjbopelvmg#jm#wkfqfrvjqfg#wl#bmg#wkbw#wkfafwtffm#wkf#tbp#gfpjdmfg`lmpjpwp#le#`lmpjgfqbaozsvaojpkfg#azwkf#obmdvbdf@lmpfqubwjlm`lmpjpwfg#leqfefq#wl#wkfab`h#wl#wkf#`pp!#nfgjb>!Sflsof#eqln#bubjobaof#lmsqlufg#wl#afpvddfpwjlmp!tbp#hmltm#bpubqjfwjfp#leojhfoz#wl#af`lnsqjpfg#lepvsslqw#wkf#kbmgp#le#wkf`lvsofg#tjwk`lmmf`w#bmg#alqgfq9mlmf8sfqelqnbm`fpafelqf#afjmdobwfq#af`bnf`bo`vobwjlmplewfm#`boofgqfpjgfmwp#lenfbmjmd#wkbw=?oj#`obpp>!fujgfm`f#elqf{sobmbwjlmpfmujqlmnfmwp!=?,b=?,gju=tkj`k#booltpJmwqlgv`wjlmgfufolsfg#azb#tjgf#qbmdflm#afkboe#leubojdm>!wls!sqjm`jsof#lebw#wkf#wjnf/?,mlp`qjsw=pbjg#wl#kbufjm#wkf#ejqpwtkjof#lwkfqpkzslwkfwj`boskjolplskfqpsltfq#le#wkf`lmwbjmfg#jmsfqelqnfg#azjmbajojwz#wltfqf#tqjwwfmpsbm#pwzof>!jmsvw#mbnf>!wkf#rvfpwjlmjmwfmgfg#elqqfif`wjlm#lejnsojfp#wkbwjmufmwfg#wkfwkf#pwbmgbqgtbp#sqlabaozojmh#afwtffmsqlefpplq#lejmwfqb`wjlmp`kbmdjmd#wkfJmgjbm#L`fbm#`obpp>!obpwtlqhjmd#tjwk$kwws9,,ttt-zfbqp#afelqfWkjp#tbp#wkfqf`qfbwjlmbofmwfqjmd#wkfnfbpvqfnfmwpbm#f{wqfnfozubovf#le#wkfpwbqw#le#wkf	?,p`qjsw=		bm#feelqw#wljm`qfbpf#wkfwl#wkf#plvwkpsb`jmd>!3!=pveej`jfmwozwkf#Fvqlsfbm`lmufqwfg#wl`ofbqWjnflvwgjg#mlw#kbuf`lmpfrvfmwozelq#wkf#mf{wf{wfmpjlm#lef`lmlnj`#bmgbowklvdk#wkfbqf#sqlgv`fgbmg#tjwk#wkfjmpveej`jfmwdjufm#az#wkfpwbwjmd#wkbwf{sfmgjwvqfp?,psbm=?,b=	wklvdkw#wkbwlm#wkf#abpjp`foosbggjmd>jnbdf#le#wkfqfwvqmjmd#wljmelqnbwjlm/pfsbqbwfg#azbppbppjmbwfgp!#`lmwfmw>!bvwklqjwz#lemlqwktfpwfqm?,gju=	?gju#!=?,gju=	##`lmpvowbwjlm`lnnvmjwz#lewkf#mbwjlmbojw#pklvog#afsbqwj`jsbmwp#bojdm>!ofewwkf#dqfbwfpwpfof`wjlm#lepvsfqmbwvqbogfsfmgfmw#lmjp#nfmwjlmfgbooltjmd#wkftbp#jmufmwfgb``lnsbmzjmdkjp#sfqplmbobubjobaof#bwpwvgz#le#wkflm#wkf#lwkfqf{f`vwjlm#leKvnbm#Qjdkwpwfqnp#le#wkfbppl`jbwjlmpqfpfbq`k#bmgpv``ffgfg#azgfefbwfg#wkfbmg#eqln#wkfavw#wkfz#bqf`lnnbmgfq#lepwbwf#le#wkfzfbqp#le#bdfwkf#pwvgz#le?vo#`obpp>!psob`f#jm#wkftkfqf#kf#tbp?oj#`obpp>!ewkfqf#bqf#mltkj`k#af`bnfkf#svaojpkfgf{sqfppfg#jmwl#tkj`k#wkf`lnnjppjlmfqelmw.tfjdkw9wfqqjwlqz#lef{wfmpjlmp!=Qlnbm#Fnsjqffrvbo#wl#wkfJm#`lmwqbpw/kltfufq/#bmgjp#wzsj`boozbmg#kjp#tjef+bopl#`boofg=?vo#`obpp>!feef`wjufoz#fuloufg#jmwlpffn#wl#kbuftkj`k#jp#wkfwkfqf#tbp#mlbm#f{`foofmwboo#le#wkfpfgfp`qjafg#azJm#sqb`wj`f/aqlbg`bpwjmd`kbqdfg#tjwkqfeof`wfg#jmpvaif`wfg#wlnjojwbqz#bmgwl#wkf#sljmwf`lmlnj`boozpfwWbqdfwjmdbqf#b`wvboozuj`wlqz#lufq+*8?,p`qjsw=`lmwjmvlvpozqfrvjqfg#elqfulovwjlmbqzbm#feef`wjufmlqwk#le#wkf/#tkj`k#tbp#eqlmw#le#wkflq#lwkfqtjpfplnf#elqn#lekbg#mlw#affmdfmfqbwfg#azjmelqnbwjlm-sfqnjwwfg#wljm`ovgfp#wkfgfufolsnfmw/fmwfqfg#jmwlwkf#sqfujlvp`lmpjpwfmwozbqf#hmltm#bpwkf#ejfog#lewkjp#wzsf#ledjufm#wl#wkfwkf#wjwof#le`lmwbjmp#wkfjmpwbm`fp#lejm#wkf#mlqwkgvf#wl#wkfjqbqf#gfpjdmfg`lqslqbwjlmptbp#wkbw#wkflmf#le#wkfpfnlqf#slsvobqpv``ffgfg#jmpvsslqw#eqlnjm#gjeefqfmwglnjmbwfg#azgfpjdmfg#elqltmfqpkjs#lebmg#slppjaozpwbmgbqgjyfgqfpslmpfWf{wtbp#jmwfmgfgqf`fjufg#wkfbppvnfg#wkbwbqfbp#le#wkfsqjnbqjoz#jmwkf#abpjp#lejm#wkf#pfmpfb``lvmwp#elqgfpwqlzfg#azbw#ofbpw#wtltbp#gf`obqfg`lvog#mlw#afPf`qfwbqz#lebssfbq#wl#afnbqdjm.wls92,]_p(_p(\',df*xwkqlt#f~8wkf#pwbqw#lewtl#pfsbqbwfobmdvbdf#bmgtkl#kbg#affmlsfqbwjlm#legfbwk#le#wkfqfbo#mvnafqp\n?ojmh#qfo>!sqlujgfg#wkfwkf#pwlqz#le`lnsfwjwjlmpfmdojpk#+VH*fmdojpk#+VP*<p<R<Q<_<R<W<M=l<S=m<V<T=m=l<S=m<V<T=m=l<S=m<V<R5h4U4]4D5f4E\nAOGx\bTA\nzk\vBl\bQ\bTA\nzk\vUm\bQ\bTA\nzk\npeu|	i@	cT\bVV\n\\}\nxS	VptSk`	[X	[X\vHR\bPv\bTW\bUe\na\bQp\v_W\vWs\nxS\vAz\n_yKhjmelqnb`j/_mkfqqbnjfmwbpfof`wq/_mj`lgfp`qjs`j/_m`obpjej`bglp`lml`jnjfmwlsvaoj`b`j/_mqfob`jlmbgbpjmelqn/Mwj`bqfob`jlmbglpgfsbqwbnfmwlwqbabibglqfpgjqf`wbnfmwfbzvmwbnjfmwlnfq`bglOjaqf`lmw/M`wfmlpkbajwb`jlmfp`vnsojnjfmwlqfpwbvqbmwfpgjpslpj`j/_m`lmpf`vfm`jbfof`wq/_mj`bbsoj`b`jlmfpgfp`lmf`wbgljmpwbob`j/_mqfbojyb`j/_mvwjojyb`j/_mfm`j`olsfgjbfmefqnfgbgfpjmpwqvnfmwlpf{sfqjfm`jbpjmpwjwv`j/_msbqwj`vobqfppva`bwfdlqjb=n<R<W=`<V<R<L<R=m=m<T<T=l<\\<]<R=n=g<]<R<W=`=d<Y<S=l<R=m=n<R<P<R<Z<Y=n<Y<X=l=o<_<T=i=m<W=o=k<\\<Y=m<Y<U=k<\\=m<^=m<Y<_<X<\\<L<R=m=m<T=c<p<R=m<V<^<Y<X=l=o<_<T<Y<_<R=l<R<X<\\<^<R<S=l<R=m<X<\\<Q<Q=g=i<X<R<W<Z<Q=g<T<P<Y<Q<Q<R<p<R=m<V<^=g=l=o<]<W<Y<U<p<R=m<V<^<\\=m=n=l<\\<Q=g<Q<T=k<Y<_<R=l<\\<]<R=n<Y<X<R<W<Z<Y<Q=o=m<W=o<_<T=n<Y<S<Y=l=`<r<X<Q<\\<V<R<S<R=n<R<P=o=l<\\<]<R=n=o<\\<S=l<Y<W=c<^<R<R<]=e<Y<R<X<Q<R<_<R=m<^<R<Y<_<R=m=n<\\=n=`<T<X=l=o<_<R<U=h<R=l=o<P<Y=i<R=l<R=d<R<S=l<R=n<T<^=m=m=g<W<V<\\<V<\\<Z<X=g<U<^<W<\\=m=n<T<_=l=o<S<S=g<^<P<Y=m=n<Y=l<\\<]<R=n<\\=m<V<\\<[<\\<W<S<Y=l<^=g<U<X<Y<W<\\=n=`<X<Y<Q=`<_<T<S<Y=l<T<R<X<]<T<[<Q<Y=m<R=m<Q<R<^<Y<P<R<P<Y<Q=n<V=o<S<T=n=`<X<R<W<Z<Q<\\=l<\\<P<V<\\=i<Q<\\=k<\\<W<R<L<\\<]<R=n<\\<N<R<W=`<V<R=m<R<^=m<Y<P<^=n<R=l<R<U<Q<\\=k<\\<W<\\=m<S<T=m<R<V=m<W=o<Z<]=g=m<T=m=n<Y<P<S<Y=k<\\=n<T<Q<R<^<R<_<R<S<R<P<R=e<T=m<\\<U=n<R<^<S<R=k<Y<P=o<S<R<P<R=e=`<X<R<W<Z<Q<R=m=m=g<W<V<T<]=g=m=n=l<R<X<\\<Q<Q=g<Y<P<Q<R<_<T<Y<S=l<R<Y<V=n<M<Y<U=k<\\=m<P<R<X<Y<W<T=n<\\<V<R<_<R<R<Q<W<\\<U<Q<_<R=l<R<X<Y<^<Y=l=m<T=c=m=n=l<\\<Q<Y=h<T<W=`<P=g=o=l<R<^<Q=c=l<\\<[<Q=g=i<T=m<V<\\=n=`<Q<Y<X<Y<W=b=c<Q<^<\\=l=c<P<Y<Q=`=d<Y<P<Q<R<_<T=i<X<\\<Q<Q<R<U<[<Q<\\=k<T=n<Q<Y<W=`<[=c=h<R=l=o<P<\\<N<Y<S<Y=l=`<P<Y=m=c=j<\\<[<\\=e<T=n=g<w=o=k=d<T<Y\fHD\fHU\fIl\fHn\fHy\fH\\\fHD\fIk\fHi\fHF\fHD\fIk\fHy\fHS\fHC\fHR\fHy\fH\\\fIk\fHn\fHi\fHD\fIa\fHC\fHy\fIa\fHC\fHR\fH{\fHR\fHk\fHM\fH@\fHR\fH\\\fIk\fHy\fHS\fHT\fIl\fHJ\fHS\fHC\fHR\fHF\fHU\fH^\fIk\fHT\fHS\fHn\fHU\fHA\fHR\fH\\\fHH\fHi\fHF\fHD\fIl\fHY\fHR\fH^\fIk\fHT\fIk\fHY\fHR\fHy\fH\\\fHH\fIk\fHB\fIk\fH\\\fIk\fHU\fIg\fHD\fIk\fHT\fHy\fHH\fIk\fH@\fHU\fIm\fHH\fHT\fHR\fHk\fHs\fHU\fIg\fH{\fHR\fHp\fHR\fHD\fIk\fHB\fHS\fHD\fHs\fHy\fH\\\fHH\fHR\fHy\fH\\\fHD\fHR\fHe\fHD\fHy\fIk\fHC\fHU\fHR\fHm\fHT\fH@\fHT\fIk\fHA\fHR\fH[\fHR\fHj\fHF\fHy\fIk\fH^\fHS\fHC\fIk\fHZ\fIm\fH\\\fIn\fHk\fHT\fHy\fIk\fHt\fHn\fHs\fIk\fHB\fIk\fH\\\fIl\fHT\fHy\fHH\fHR\fHB\fIk\fH\\\fHR\fH^\fIk\fHy\fH\\\fHi\fHK\fHS\fHy\fHi\fHF\fHD\fHR\fHT\fHB\fHR\fHp\fHB\fIm\fHq\fIk\fHy\fHR\fH\\\fHO\fHU\fIg\fHH\fHR\fHy\fHM\fHP\fIl\fHC\fHU\fHR\fHn\fHU\fIg\fHs\fH^\fHZ\fH@\fIa\fHJ\fH^\fHS\fHC\fHR\fHp\fIl\fHY\fHD\fHp\fHR\fHH\fHR\fHy\fId\fHT\fIk\fHj\fHF\fHy\fHR\fHY\fHR\fH^\fIl\fHJ\fIk\fHD\fIk\fHF\fIn\fH\\\fIl\fHF\fHR\fHD\fIl\fHe\fHT\fHy\fIk\fHU\fIg\fH{\fIl\fH@\fId\fHL\fHy\fHj\fHF\fHy\fIl\fHY\fH\\\fIa\fH[\fH{\fHR\fHn\fHY\fHj\fHF\fHy\fIg\fHp\fHS\fH^\fHR\fHp\fHR\fHD\fHR\fHT\fHU\fHB\fHH\fHU\fHB\fIk\fHn\fHe\fHD\fHy\fIl\fHC\fHR\fHU\fIn\fHJ\fH\\\fIa\fHp\fHT\fIn\fHv\fIl\fHF\fHT\fHn\fHJ\fHT\fHY\fHR\fH^\fHU\fIg\fHD\fHR\fHU\fIg\fHH\fIl\fHp\fId\fHT\fIk\fHY\fHR\fHF\fHT\fHp\fHD\fHH\fHR\fHD\fIk\fHH\fHR\fHp\fHR\fH\\\fIl\fHt\fHR\fHC\fH^\fHp\fHS\fH^\fIk\fHD\fIl\fHv\fIk\fHp\fHR\fHn\fHv\fHF\fHH\fIa\fH\\\fH{\fIn\fH{\fH^\fHp\fHR\fHH\fIk\fH@\fHR\fHU\fH\\\fHj\fHF\fHD\fIk\fHY\fHR\fHU\fHD\fHk\fHT\fHy\fHR\fHT\fIm\fH@\fHU\fH\\\fHU\fHD\fIk\fHk\fHT\fHT\fIk\fHT\fHU\fHS\fHH\fH@\fHM\fHP\fIk\fHt\fHs\fHD\fHR\fHH\fH^\fHR\fHZ\fHF\fHR\fHn\fHv\fHZ\fIa\fH\\\fIl\fH@\fHM\fHP\fIl\fHU\fIg\fHH\fIk\fHT\fHR\fHd\fHs\fHZ\fHR\fHC\fHJ\fHT\fHy\fHH\fIl\fHp\fHR\fHH\fIl\fHY\fHR\fH^\fHR\fHU\fHp\fHR\fH\\\fHF\fHs\fHD\fHR\fH\\\fHz\fHD\fIk\fHT\fHM\fHP\fHy\fHB\fHS\fH^\fHR\fHe\fHT\fHy\fIl\fHy\fIk\fHY\fH^\fH^\fH{\fHH\fHR\fHz\fHR\fHD\fHR\fHi\fH\\\fIa\fHI\fHp\fHU\fHR\fHn\fHJ\fIk\fHz\fHR\fHF\fHU\fH^\fIl\fHD\fHS\fHC\fHB\fH@\fHS\fHD\fHR\fH@\fId\fHn\fHy\fHy\fHU\fIl\fHn\fHy\fHU\fHD\fHR\fHJ\fIk\fHH\fHR\fHU\fHB\fH^\fIk\fHy\fHR\fHG\fIl\fHp\fH@\fHy\fHS\fHH\fIm\fH\\\fHH\fHB\fHR\fHn\fH{\fHY\fHU\fIl\fHn\fH\\\fIg\fHp\fHP\fHB\fHS\fH^\fIl\fHj\fH\\\fIg\fHF\fHT\fIk\fHD\fHR\fHC\fHR\fHJ\fHY\fH^\fIk\fHD\fIk\fHz\fHR\fHH\fHR\fHy\fH\\\fIl\fH@\fHe\fHD\fHy\fHR\fHp\fHY\fHR\fH@\fHF\fIn\fH\\\fHR\fH@\fHM\fHP\fHR\fHT\fI`\fHJ\fHR\fHZ\fIk\fHC\fH\\\fHy\fHS\fHC\fIk\fHy\fHU\fHR\fHn\fHi\fHy\fHT\fH\\\fH@\fHD\fHR\fHc\fHY\fHU\fHR\fHn\fHT\fIa\fHI\fH^\fHB\fHS\fH^\fIk\fH^\fIk\fHz\fHy\fHY\fHS\fH[\fHC\fHy\fIa\fH\\\fHn\fHT\fHB\fIn\fHU\fHI\fHR\fHD\fHR4F4_4F4[5f4U5i4X4K4]5o4E4D5d4K4_4[4E4K5h4Y5m4A4E5i5d4K4Z5f4U4K5h4B4K4Y4E4K5h5i4^5f4C4K5h4U4K5i4E4K5h5o4K4F4D4K5h4]4C5d4C4D4]5j4K5i4@4K5h4C5d5h4E4K5h4U4K5h5i4K5h5i5d5n4U4K5h4U4]4D5f4K5h4_4]5f4U4K5h4@5d4K5h4K5h4\\5k4K4D4K5h4A5f4K4E4K5h4A5n5d5n4K5h5o4]5f5i4K5h4U4]4K5n5i4A5m5d4T4E4K5h4G4K5j5f5i4X4K5k4C4E4K5h5i4]4O4E4K5h5n4]4N5j4K5h4X4D4K4D4K5h4A5d4K4]4K5h4@4C5f4C4K5h4O4_4]4E4K5h4U5h5d5i5i4@5i5d4U4E4K5h4]4A5i5j4K5h5j5n4K4[5m5h4_4[5f5j4K5h5o5d5f4F4K5h4C5j5f4K4D4]5o4K4F5k4K5h4]5f4K4Z4F4A5f4K4F5f4D4F5d5n5f4F4K5h4O5d5h5e4K5h4D4]5f4C4K5h5o5h4K5i4K5h4]4K4D4[4K5h4X4B4Y5f4_5f4K4]4K4F4K5h4G4K5h4G4K5h4Y5h4K4E4K5h4A4C5f4G4K5h4^5d4K4]4K5h4B5h5f4@4K5h4@5i5f4U4K5h4U4K5i5k4K5h4@5i4K5h4K5h4_4K4U4E5i4X4K5k4C5k4K5h4]4J5f4_4K5h4C4B5d5h4K5h5m5j5f4E4K5h5o4F4K4D4K5h4C5d4]5f4K5h4C4]5d4_4K4_4F4V4]5n4F4Y4K5i5f5i4K5h4D5j4K4F4K5h4U4T5f5ifmwfqwbjmnfmwvmgfqpwbmgjmd#>#evm`wjlm+*-isd!#tjgwk>!`lmejdvqbwjlm-smd!#tjgwk>!?algz#`obpp>!Nbwk-qbmgln+*`lmwfnslqbqz#Vmjwfg#Pwbwfp`jq`vnpwbm`fp-bssfmg@kjog+lqdbmjybwjlmp?psbm#`obpp>!!=?jnd#pq`>!,gjpwjmdvjpkfgwklvpbmgp#le#`lnnvmj`bwjlm`ofbq!=?,gju=jmufpwjdbwjlmebuj`lm-j`l!#nbqdjm.qjdkw9abpfg#lm#wkf#Nbppb`kvpfwwpwbaof#alqgfq>jmwfqmbwjlmbobopl#hmltm#bpsqlmvm`jbwjlmab`hdqlvmg9 esbggjmd.ofew9Elq#f{bnsof/#njp`foobmflvp%ow8,nbwk%dw8spz`kloldj`bojm#sbqwj`vobqfbq`k!#wzsf>!elqn#nfwklg>!bp#lsslpfg#wlPvsqfnf#@lvqwl``bpjlmbooz#Bggjwjlmbooz/Mlqwk#Bnfqj`bs{8ab`hdqlvmglsslqwvmjwjfpFmwfqwbjmnfmw-wlOltfq@bpf+nbmveb`wvqjmdsqlefppjlmbo#`lnajmfg#tjwkElq#jmpwbm`f/`lmpjpwjmd#le!#nb{ofmdwk>!qfwvqm#ebopf8`lmp`jlvpmfppNfgjwfqqbmfbmf{wqblqgjmbqzbppbppjmbwjlmpvapfrvfmwoz#avwwlm#wzsf>!wkf#mvnafq#lewkf#lqjdjmbo#`lnsqfkfmpjufqfefqp#wl#wkf?,vo=	?,gju=	skjolplskj`bool`bwjlm-kqfetbp#svaojpkfgPbm#Eqbm`jp`l+evm`wjlm+*x	?gju#jg>!nbjmplskjpwj`bwfgnbwkfnbwj`bo#,kfbg=	?algzpvddfpwp#wkbwgl`vnfmwbwjlm`lm`fmwqbwjlmqfobwjlmpkjspnbz#kbuf#affm+elq#f{bnsof/Wkjp#bqwj`of#jm#plnf#`bpfpsbqwp#le#wkf#gfejmjwjlm#leDqfbw#Aqjwbjm#`foosbggjmd>frvjubofmw#wlsob`fklogfq>!8#elmw.pjyf9#ivpwjej`bwjlmafojfufg#wkbwpveefqfg#eqlnbwwfnswfg#wl#ofbgfq#le#wkf`qjsw!#pq`>!,+evm`wjlm+*#xbqf#bubjobaof	\n?ojmh#qfo>!#pq`>$kwws9,,jmwfqfpwfg#jm`lmufmwjlmbo#!#bow>!!#,=?,bqf#dfmfqboozkbp#bopl#affmnlpw#slsvobq#`lqqfpslmgjmd`qfgjwfg#tjwkwzof>!alqgfq9?,b=?,psbm=?,-dje!#tjgwk>!?jeqbnf#pq`>!wbaof#`obpp>!jmojmf.aol`h8b``lqgjmd#wl#wldfwkfq#tjwkbssql{jnbwfozsbqojbnfmwbqznlqf#bmg#nlqfgjpsobz9mlmf8wqbgjwjlmboozsqfglnjmbmwoz%maps8%maps8%maps8?,psbm=#`foopsb`jmd>?jmsvw#mbnf>!lq!#`lmwfmw>!`lmwqlufqpjbosqlsfqwz>!ld9,{.pkl`htbuf.gfnlmpwqbwjlmpvqqlvmgfg#azMfufqwkfofpp/tbp#wkf#ejqpw`lmpjgfqbaof#Bowklvdk#wkf#`loobalqbwjlmpklvog#mlw#afsqlslqwjlm#le?psbm#pwzof>!hmltm#bp#wkf#pklqwoz#bewfqelq#jmpwbm`f/gfp`qjafg#bp#,kfbg=	?algz#pwbqwjmd#tjwkjm`qfbpjmdoz#wkf#eb`w#wkbwgjp`vppjlm#lenjggof#le#wkfbm#jmgjujgvbogjeej`vow#wl#sljmw#le#ujftklnlpf{vbojwzb``fswbm`f#le?,psbm=?,gju=nbmveb`wvqfqplqjdjm#le#wkf`lnnlmoz#vpfgjnslqwbm`f#legfmlnjmbwjlmpab`hdqlvmg9# ofmdwk#le#wkfgfwfqnjmbwjlmb#pjdmjej`bmw!#alqgfq>!3!=qfulovwjlmbqzsqjm`jsofp#lejp#`lmpjgfqfgtbp#gfufolsfgJmgl.Fvqlsfbmuvomfqbaof#wlsqlslmfmwp#lebqf#plnfwjnfp`olpfq#wl#wkfMft#Zlqh#@jwz#mbnf>!pfbq`kbwwqjavwfg#wl`lvqpf#le#wkfnbwkfnbwj`jbmaz#wkf#fmg#lebw#wkf#fmg#le!#alqgfq>!3!#wf`kmloldj`bo-qfnluf@obpp+aqbm`k#le#wkffujgfm`f#wkbw"Xfmgje^..=	Jmpwjwvwf#le#jmwl#b#pjmdofqfpsf`wjufoz-bmg#wkfqfelqfsqlsfqwjfp#lejp#ol`bwfg#jmplnf#le#tkj`kWkfqf#jp#bopl`lmwjmvfg#wl#bssfbqbm`f#le#%bns8mgbpk8#gfp`qjafp#wkf`lmpjgfqbwjlmbvwklq#le#wkfjmgfsfmgfmwozfrvjssfg#tjwkglfp#mlw#kbuf?,b=?b#kqfe>!`lmevpfg#tjwk?ojmh#kqfe>!,bw#wkf#bdf#lebssfbq#jm#wkfWkfpf#jm`ovgfqfdbqgofpp#le`lvog#af#vpfg#pwzof>%rvlw8pfufqbo#wjnfpqfsqfpfmw#wkfalgz=	?,kwno=wklvdkw#wl#afslsvobwjlm#leslppjajojwjfpsfq`fmwbdf#leb``fpp#wl#wkfbm#bwwfnsw#wlsqlgv`wjlm#leirvfqz,irvfqzwtl#gjeefqfmwafolmd#wl#wkffpwbaojpknfmwqfsob`jmd#wkfgfp`qjswjlm!#gfwfqnjmf#wkfbubjobaof#elqB``lqgjmd#wl#tjgf#qbmdf#le\n?gju#`obpp>!nlqf#`lnnlmozlqdbmjpbwjlmpevm`wjlmbojwztbp#`lnsofwfg#%bns8ngbpk8#sbqwj`jsbwjlmwkf#`kbqb`wfqbm#bggjwjlmbobssfbqp#wl#afeb`w#wkbw#wkfbm#f{bnsof#lepjdmjej`bmwozlmnlvpflufq>!af`bvpf#wkfz#bpzm`#>#wqvf8sqlaofnp#tjwkpffnp#wl#kbufwkf#qfpvow#le#pq`>!kwws9,,ebnjojbq#tjwkslppfppjlm#leevm`wjlm#+*#xwllh#sob`f#jmbmg#plnfwjnfppvapwbmwjbooz?psbm=?,psbm=jp#lewfm#vpfgjm#bm#bwwfnswdqfbw#gfbo#leFmujqlmnfmwbopv``fppevooz#ujqwvbooz#boo13wk#`fmwvqz/sqlefppjlmbopmf`fppbqz#wl#gfwfqnjmfg#az`lnsbwjajojwzaf`bvpf#jw#jpGj`wjlmbqz#lenlgjej`bwjlmpWkf#elooltjmdnbz#qfefq#wl9@lmpfrvfmwoz/Jmwfqmbwjlmbobowklvdk#plnfwkbw#tlvog#aftlqog$p#ejqpw`obppjejfg#bpalwwln#le#wkf+sbqwj`vobqozbojdm>!ofew!#nlpw#`lnnlmozabpjp#elq#wkfelvmgbwjlm#le`lmwqjavwjlmpslsvobqjwz#le`fmwfq#le#wkfwl#qfgv`f#wkfivqjpgj`wjlmpbssql{jnbwjlm#lmnlvpflvw>!Mft#Wfpwbnfmw`loof`wjlm#le?,psbm=?,b=?,jm#wkf#Vmjwfgejon#gjqf`wlq.pwqj`w-gwg!=kbp#affm#vpfgqfwvqm#wl#wkfbowklvdk#wkjp`kbmdf#jm#wkfpfufqbo#lwkfqavw#wkfqf#bqfvmsqf`fgfmwfgjp#pjnjobq#wlfpsf`jbooz#jmtfjdkw9#alog8jp#`boofg#wkf`lnsvwbwjlmbojmgj`bwf#wkbwqfpwqj`wfg#wl\n?nfwb#mbnf>!bqf#wzsj`booz`lmeoj`w#tjwkKltfufq/#wkf#Bm#f{bnsof#le`lnsbqfg#tjwkrvbmwjwjfp#leqbwkfq#wkbm#b`lmpwfoobwjlmmf`fppbqz#elqqfslqwfg#wkbwpsf`jej`bwjlmslojwj`bo#bmg%maps8%maps8?qfefqfm`fp#wlwkf#pbnf#zfbqDlufqmnfmw#ledfmfqbwjlm#lekbuf#mlw#affmpfufqbo#zfbqp`lnnjwnfmw#wl\n\n?vo#`obpp>!ujpvbojybwjlm2:wk#`fmwvqz/sqb`wjwjlmfqpwkbw#kf#tlvogbmg#`lmwjmvfgl``vsbwjlm#lejp#gfejmfg#bp`fmwqf#le#wkfwkf#bnlvmw#le=?gju#pwzof>!frvjubofmw#legjeefqfmwjbwfaqlvdkw#balvwnbqdjm.ofew9#bvwlnbwj`boozwklvdkw#le#bpPlnf#le#wkfpf	?gju#`obpp>!jmsvw#`obpp>!qfsob`fg#tjwkjp#lmf#le#wkffgv`bwjlm#bmgjmeovfm`fg#azqfsvwbwjlm#bp	?nfwb#mbnf>!b``lnnlgbwjlm?,gju=	?,gju=obqdf#sbqw#leJmpwjwvwf#elqwkf#pl.`boofg#bdbjmpw#wkf#Jm#wkjp#`bpf/tbp#bssljmwfg`objnfg#wl#afKltfufq/#wkjpGfsbqwnfmw#lewkf#qfnbjmjmdfeef`w#lm#wkfsbqwj`vobqoz#gfbo#tjwk#wkf	?gju#pwzof>!bonlpw#botbzpbqf#`vqqfmwozf{sqfppjlm#leskjolplskz#leelq#nlqf#wkbm`jujojybwjlmplm#wkf#jpobmgpfof`wfgJmgf{`bm#qfpvow#jm!#ubovf>!!#,=wkf#pwqv`wvqf#,=?,b=?,gju=Nbmz#le#wkfpf`bvpfg#az#wkfle#wkf#Vmjwfgpsbm#`obpp>!n`bm#af#wqb`fgjp#qfobwfg#wlaf`bnf#lmf#lejp#eqfrvfmwozojujmd#jm#wkfwkflqfwj`boozElooltjmd#wkfQfulovwjlmbqzdlufqmnfmw#jmjp#gfwfqnjmfgwkf#slojwj`bojmwqlgv`fg#jmpveej`jfmw#wlgfp`qjswjlm!=pklqw#pwlqjfppfsbqbwjlm#lebp#wl#tkfwkfqhmltm#elq#jwptbp#jmjwjboozgjpsobz9aol`hjp#bm#f{bnsofwkf#sqjm`jsbo`lmpjpwp#le#bqf`ldmjyfg#bp,algz=?,kwno=b#pvapwbmwjboqf`lmpwqv`wfgkfbg#le#pwbwfqfpjpwbm`f#wlvmgfqdqbgvbwfWkfqf#bqf#wtldqbujwbwjlmbobqf#gfp`qjafgjmwfmwjlmboozpfqufg#bp#wkf`obpp>!kfbgfqlsslpjwjlm#wlevmgbnfmwboozglnjmbwfg#wkfbmg#wkf#lwkfqboojbm`f#tjwktbp#elq`fg#wlqfpsf`wjufoz/bmg#slojwj`bojm#pvsslqw#lesflsof#jm#wkf13wk#`fmwvqz-bmg#svaojpkfgolbg@kbqwafbwwl#vmgfqpwbmgnfnafq#pwbwfpfmujqlmnfmwboejqpw#kboe#le`lvmwqjfp#bmgbq`kjwf`wvqboaf#`lmpjgfqfg`kbqb`wfqjyfg`ofbqJmwfqubobvwklqjwbwjufEfgfqbwjlm#letbp#pv``ffgfgbmg#wkfqf#bqfb#`lmpfrvfm`fwkf#Sqfpjgfmwbopl#jm`ovgfgeqff#plewtbqfpv``fppjlm#legfufolsfg#wkftbp#gfpwqlzfgbtbz#eqln#wkf8	?,p`qjsw=	?bowklvdk#wkfzelooltfg#az#bnlqf#sltfqevoqfpvowfg#jm#bVmjufqpjwz#leKltfufq/#nbmzwkf#sqfpjgfmwKltfufq/#plnfjp#wklvdkw#wlvmwjo#wkf#fmgtbp#bmmlvm`fgbqf#jnslqwbmwbopl#jm`ovgfp=?jmsvw#wzsf>wkf#`fmwfq#le#GL#MLW#BOWFQvpfg#wl#qfefqwkfnfp,<plqw>wkbw#kbg#affmwkf#abpjp#elqkbp#gfufolsfgjm#wkf#pvnnfq`lnsbqbwjufozgfp`qjafg#wkfpv`k#bp#wklpfwkf#qfpvowjmdjp#jnslppjaofubqjlvp#lwkfqPlvwk#Beqj`bmkbuf#wkf#pbnffeef`wjufmfppjm#tkj`k#`bpf8#wf{w.bojdm9pwqv`wvqf#bmg8#ab`hdqlvmg9qfdbqgjmd#wkfpvsslqwfg#wkfjp#bopl#hmltmpwzof>!nbqdjmjm`ovgjmd#wkfabkbpb#Nfobzvmlqph#alhn/Iomlqph#mzmlqphpolufm)M(ajmbjmwfqmb`jlmbo`bojej`b`j/_m`lnvmj`b`j/_m`lmpwqv``j/_m!=?gju#`obpp>!gjpbnajdvbwjlmGlnbjmMbnf$/#$bgnjmjpwqbwjlmpjnvowbmflvpozwqbmpslqwbwjlmJmwfqmbwjlmbo#nbqdjm.alwwln9qfpslmpjajojwz?"Xfmgje^..=	?,=?nfwb#mbnf>!jnsofnfmwbwjlmjmeqbpwqv`wvqfqfsqfpfmwbwjlmalqgfq.alwwln9?,kfbg=	?algz=>kwws&0B&1E&1E?elqn#nfwklg>!nfwklg>!slpw!#,ebuj`lm-j`l!#~*8	?,p`qjsw=	-pfwBwwqjavwf+Bgnjmjpwqbwjlm>#mft#Bqqbz+*8?"Xfmgje^..=	gjpsobz9aol`h8Vmelqwvmbwfoz/!=%maps8?,gju=,ebuj`lm-j`l!=>$pwzofpkffw$#jgfmwjej`bwjlm/#elq#f{bnsof/?oj=?b#kqfe>!,bm#bowfqmbwjufbp#b#qfpvow#lesw!=?,p`qjsw=	wzsf>!pvanjw!#	+evm`wjlm+*#xqf`lnnfmgbwjlmelqn#b`wjlm>!,wqbmpelqnbwjlmqf`lmpwqv`wjlm-pwzof-gjpsobz#B``lqgjmd#wl#kjggfm!#mbnf>!bolmd#tjwk#wkfgl`vnfmw-algz-bssql{jnbwfoz#@lnnvmj`bwjlmpslpw!#b`wjlm>!nfbmjmd#%rvlw8..?"Xfmgje^..=Sqjnf#Njmjpwfq`kbqb`wfqjpwj`?,b=#?b#`obpp>wkf#kjpwlqz#le#lmnlvpflufq>!wkf#dlufqmnfmwkqfe>!kwwsp9,,tbp#lqjdjmbooztbp#jmwqlgv`fg`obppjej`bwjlmqfsqfpfmwbwjufbqf#`lmpjgfqfg?"Xfmgje^..=		gfsfmgp#lm#wkfVmjufqpjwz#le#jm#`lmwqbpw#wl#sob`fklogfq>!jm#wkf#`bpf#lejmwfqmbwjlmbo#`lmpwjwvwjlmbopwzof>!alqgfq.9#evm`wjlm+*#xAf`bvpf#le#wkf.pwqj`w-gwg!=	?wbaof#`obpp>!b``lnsbmjfg#azb``lvmw#le#wkf?p`qjsw#pq`>!,mbwvqf#le#wkf#wkf#sflsof#jm#jm#bggjwjlm#wlp*8#ip-jg#>#jg!#tjgwk>!233&!qfdbqgjmd#wkf#Qlnbm#@bwkloj`bm#jmgfsfmgfmwelooltjmd#wkf#-dje!#tjgwk>!2wkf#elooltjmd#gjp`qjnjmbwjlmbq`kbfloldj`bosqjnf#njmjpwfq-ip!=?,p`qjsw=`lnajmbwjlm#le#nbqdjmtjgwk>!`qfbwfFofnfmw+t-bwwb`kFufmw+?,b=?,wg=?,wq=pq`>!kwwsp9,,bJm#sbqwj`vobq/#bojdm>!ofew!#@yf`k#Qfsvaoj`Vmjwfg#Hjmdgln`lqqfpslmgfm`f`lm`ovgfg#wkbw-kwno!#wjwof>!+evm`wjlm#+*#x`lnfp#eqln#wkfbssoj`bwjlm#le?psbm#`obpp>!pafojfufg#wl#affnfmw+$p`qjsw$?,b=	?,oj=	?ojufqz#gjeefqfmw=?psbm#`obpp>!lswjlm#ubovf>!+bopl#hmltm#bp\n?oj=?b#kqfe>!=?jmsvw#mbnf>!pfsbqbwfg#eqlnqfefqqfg#wl#bp#ubojdm>!wls!=elvmgfq#le#wkfbwwfnswjmd#wl#`bqalm#gjl{jgf		?gju#`obpp>!`obpp>!pfbq`k.,algz=	?,kwno=lsslqwvmjwz#wl`lnnvmj`bwjlmp?,kfbg=	?algz#pwzof>!tjgwk9Wj\rVSmd#Uj\rWkw`kbmdfp#jm#wkfalqgfq.`lolq9 3!#alqgfq>!3!#?,psbm=?,gju=?tbp#gjp`lufqfg!#wzsf>!wf{w!#*8	?,p`qjsw=		Gfsbqwnfmw#le#f``ofpjbpwj`bowkfqf#kbp#affmqfpvowjmd#eqln?,algz=?,kwno=kbp#mfufq#affmwkf#ejqpw#wjnfjm#qfpslmpf#wlbvwlnbwj`booz#?,gju=		?gju#jtbp#`lmpjgfqfgsfq`fmw#le#wkf!#,=?,b=?,gju=`loof`wjlm#le#gfp`fmgfg#eqlnpf`wjlm#le#wkfb``fsw.`kbqpfwwl#af#`lmevpfgnfnafq#le#wkf#sbggjmd.qjdkw9wqbmpobwjlm#lejmwfqsqfwbwjlm#kqfe>$kwws9,,tkfwkfq#lq#mlwWkfqf#bqf#boplwkfqf#bqf#nbmzb#pnboo#mvnafqlwkfq#sbqwp#lejnslppjaof#wl##`obpp>!avwwlmol`bwfg#jm#wkf-#Kltfufq/#wkfbmg#fufmwvboozBw#wkf#fmg#le#af`bvpf#le#jwpqfsqfpfmwp#wkf?elqn#b`wjlm>!#nfwklg>!slpw!jw#jp#slppjaofnlqf#ojhfoz#wlbm#jm`qfbpf#jmkbuf#bopl#affm`lqqfpslmgp#wlbmmlvm`fg#wkbwbojdm>!qjdkw!=nbmz#`lvmwqjfpelq#nbmz#zfbqpfbqojfpw#hmltmaf`bvpf#jw#tbpsw!=?,p`qjsw=#ubojdm>!wls!#jmkbajwbmwp#leelooltjmd#zfbq	?gju#`obpp>!njoojlm#sflsof`lmwqlufqpjbo#`lm`fqmjmd#wkfbqdvf#wkbw#wkfdlufqmnfmw#bmgb#qfefqfm`f#wlwqbmpefqqfg#wlgfp`qjajmd#wkf#pwzof>!`lolq9bowklvdk#wkfqfafpw#hmltm#elqpvanjw!#mbnf>!nvowjsoj`bwjlmnlqf#wkbm#lmf#qf`ldmjwjlm#le@lvm`jo#le#wkffgjwjlm#le#wkf##?nfwb#mbnf>!Fmwfqwbjmnfmw#btbz#eqln#wkf#8nbqdjm.qjdkw9bw#wkf#wjnf#lejmufpwjdbwjlmp`lmmf`wfg#tjwkbmg#nbmz#lwkfqbowklvdk#jw#jpafdjmmjmd#tjwk#?psbm#`obpp>!gfp`fmgbmwp#le?psbm#`obpp>!j#bojdm>!qjdkw!?,kfbg=	?algz#bpsf`wp#le#wkfkbp#pjm`f#affmFvqlsfbm#Vmjlmqfnjmjp`fmw#lenlqf#gjeej`vowUj`f#Sqfpjgfmw`lnslpjwjlm#lesbppfg#wkqlvdknlqf#jnslqwbmwelmw.pjyf922s{f{sobmbwjlm#lewkf#`lm`fsw#letqjwwfm#jm#wkf\n?psbm#`obpp>!jp#lmf#le#wkf#qfpfnaobm`f#wllm#wkf#dqlvmgptkj`k#`lmwbjmpjm`ovgjmd#wkf#gfejmfg#az#wkfsvaoj`bwjlm#lenfbmp#wkbw#wkflvwpjgf#le#wkfpvsslqw#le#wkf?jmsvw#`obpp>!?psbm#`obpp>!w+Nbwk-qbmgln+*nlpw#sqlnjmfmwgfp`qjswjlm#le@lmpwbmwjmlsoftfqf#svaojpkfg?gju#`obpp>!pfbssfbqp#jm#wkf2!#kfjdkw>!2!#nlpw#jnslqwbmwtkj`k#jm`ovgfptkj`k#kbg#affmgfpwqv`wjlm#lewkf#slsvobwjlm	\n?gju#`obpp>!slppjajojwz#leplnfwjnfp#vpfgbssfbq#wl#kbufpv``fpp#le#wkfjmwfmgfg#wl#afsqfpfmw#jm#wkfpwzof>!`ofbq9a	?,p`qjsw=	?tbp#elvmgfg#jmjmwfqujft#tjwk\\jg!#`lmwfmw>!`bsjwbo#le#wkf	?ojmh#qfo>!pqfofbpf#le#wkfsljmw#lvw#wkbw{NOKwwsQfrvfpwbmg#pvapfrvfmwpf`lmg#obqdfpwufqz#jnslqwbmwpsf`jej`bwjlmppvqeb`f#le#wkfbssojfg#wl#wkfelqfjdm#sloj`z\\pfwGlnbjmMbnffpwbaojpkfg#jmjp#afojfufg#wlJm#bggjwjlm#wlnfbmjmd#le#wkfjp#mbnfg#bewfqwl#sqlwf`w#wkfjp#qfsqfpfmwfgGf`obqbwjlm#lenlqf#feej`jfmw@obppjej`bwjlmlwkfq#elqnp#lekf#qfwvqmfg#wl?psbm#`obpp>!`sfqelqnbm`f#le+evm`wjlm+*#xje#bmg#lmoz#jeqfdjlmp#le#wkfofbgjmd#wl#wkfqfobwjlmp#tjwkVmjwfg#Mbwjlmppwzof>!kfjdkw9lwkfq#wkbm#wkfzsf!#`lmwfmw>!Bppl`jbwjlm#le	?,kfbg=	?algzol`bwfg#lm#wkfjp#qfefqqfg#wl+jm`ovgjmd#wkf`lm`fmwqbwjlmpwkf#jmgjujgvbobnlmd#wkf#nlpwwkbm#bmz#lwkfq,=	?ojmh#qfo>!#qfwvqm#ebopf8wkf#svqslpf#lewkf#bajojwz#wl8`lolq9 eee~	-	?psbm#`obpp>!wkf#pvaif`w#legfejmjwjlmp#le=	?ojmh#qfo>!`objn#wkbw#wkfkbuf#gfufolsfg?wbaof#tjgwk>!`fofaqbwjlm#leElooltjmd#wkf#wl#gjpwjmdvjpk?psbm#`obpp>!awbhfp#sob`f#jmvmgfq#wkf#mbnfmlwfg#wkbw#wkf=?"Xfmgje^..=	pwzof>!nbqdjm.jmpwfbg#le#wkfjmwqlgv`fg#wkfwkf#sql`fpp#lejm`qfbpjmd#wkfgjeefqfm`fp#jmfpwjnbwfg#wkbwfpsf`jbooz#wkf,gju=?gju#jg>!tbp#fufmwvboozwkqlvdklvw#kjpwkf#gjeefqfm`fplnfwkjmd#wkbwpsbm=?,psbm=?,pjdmjej`bmwoz#=?,p`qjsw=		fmujqlmnfmwbo#wl#sqfufmw#wkfkbuf#affm#vpfgfpsf`jbooz#elqvmgfqpwbmg#wkfjp#fppfmwjbooztfqf#wkf#ejqpwjp#wkf#obqdfpwkbuf#affm#nbgf!#pq`>!kwws9,,jmwfqsqfwfg#bppf`lmg#kboe#le`qloojmd>!ml!#jp#`lnslpfg#leJJ/#Kloz#Qlnbmjp#f{sf`wfg#wlkbuf#wkfjq#ltmgfejmfg#bp#wkfwqbgjwjlmbooz#kbuf#gjeefqfmwbqf#lewfm#vpfgwl#fmpvqf#wkbwbdqffnfmw#tjwk`lmwbjmjmd#wkfbqf#eqfrvfmwozjmelqnbwjlm#lmf{bnsof#jp#wkfqfpvowjmd#jm#b?,b=?,oj=?,vo=#`obpp>!ellwfqbmg#fpsf`jboozwzsf>!avwwlm!#?,psbm=?,psbm=tkj`k#jm`ovgfg=	?nfwb#mbnf>!`lmpjgfqfg#wkf`bqqjfg#lvw#azKltfufq/#jw#jpaf`bnf#sbqw#lejm#qfobwjlm#wlslsvobq#jm#wkfwkf#`bsjwbo#letbp#leej`jbooztkj`k#kbp#affmwkf#Kjpwlqz#lebowfqmbwjuf#wlgjeefqfmw#eqlnwl#pvsslqw#wkfpvddfpwfg#wkbwjm#wkf#sql`fpp##?gju#`obpp>!wkf#elvmgbwjlmaf`bvpf#le#kjp`lm`fqmfg#tjwkwkf#vmjufqpjwzlsslpfg#wl#wkfwkf#`lmwf{w#le?psbm#`obpp>!swf{w!#mbnf>!r!\n\n?gju#`obpp>!wkf#p`jfmwjej`qfsqfpfmwfg#aznbwkfnbwj`jbmpfof`wfg#az#wkfwkbw#kbuf#affm=?gju#`obpp>!`gju#jg>!kfbgfqjm#sbqwj`vobq/`lmufqwfg#jmwl*8	?,p`qjsw=	?skjolplskj`bo#pqsphlkqubwphjwj\rVSmd#Uj\rWkw<L=o=m=m<V<T<U=l=o=m=m<V<T<Ujmufpwjdb`j/_msbqwj`jsb`j/_m<V<R=n<R=l=g<Y<R<]<W<\\=m=n<T<V<R=n<R=l=g<U=k<Y<W<R<^<Y<V=m<T=m=n<Y<P=g<q<R<^<R=m=n<T<V<R=n<R=l=g=i<R<]<W<\\=m=n=`<^=l<Y<P<Y<Q<T<V<R=n<R=l<\\=c=m<Y<_<R<X<Q=c=m<V<\\=k<\\=n=`<Q<R<^<R=m=n<T<O<V=l<\\<T<Q=g<^<R<S=l<R=m=g<V<R=n<R=l<R<U=m<X<Y<W<\\=n=`<S<R<P<R=e=`=b=m=l<Y<X=m=n<^<R<]=l<\\<[<R<P=m=n<R=l<R<Q=g=o=k<\\=m=n<T<Y=n<Y=k<Y<Q<T<Y<<W<\\<^<Q<\\=c<T=m=n<R=l<T<T=m<T=m=n<Y<P<\\=l<Y=d<Y<Q<T=c<M<V<\\=k<\\=n=`<S<R=a=n<R<P=o=m<W<Y<X=o<Y=n=m<V<\\<[<\\=n=`=n<R<^<\\=l<R<^<V<R<Q<Y=k<Q<R=l<Y=d<Y<Q<T<Y<V<R=n<R=l<R<Y<R=l<_<\\<Q<R<^<V<R=n<R=l<R<P<L<Y<V<W<\\<P<\\4K5h5i5j4F4C5e5i5j4F4C5f4K4F4K5h5i5d4Z5d4U4K5h4D4]4K5i4@4K5h5i5d4K5n4U4K5h4]4_4K4J5h5i4X4K4]5o4K4F4K5h4O4U4Z4K4M4K5h4]5f4K4Z4E4K5h4F4Y5i5f5i4K5h4K4U4Z4K4M4K5h5j4F4K4J4@4K5h4O5h4U4K4D4K5h4F4_4@5f5h4K5h4O5n4_4K5i4K5h4Z4V4[4K4F4K5h5m5f4C5f5d4K5h4F4]4A5f4D4K5h4@4C5f4C4E4K5h4F4U5h5f5i4K5h4O4B4D4K4]4K5h4K5m5h4K5i4K5h4O5m5h4K5i4K5h4F4K4]5f4B4K5h4F5n5j5f4E4K5h4K5h4U4K4D4K5h4B5d4K4[4]4K5h5i4@4F5i4U4K5h4C5f5o5d4]4K5h4_5f4K4A4E4U4D4C4K5h5h5k4K5h4F4]4D5f4E4K5h4]5d4K4D4[4K5h4O4C4D5f4E4K5h4K4B4D4K4]4K5h5i4F4A4C4E4K5h4K4V4K5j5f`vqplq9sljmwfq8?,wjwof=	?nfwb#!#kqfe>!kwws9,,!=?psbm#`obpp>!nfnafqp#le#wkf#tjmglt-ol`bwjlmufqwj`bo.bojdm9,b=##?b#kqfe>!?"gl`wzsf#kwno=nfgjb>!p`qffm!#?lswjlm#ubovf>!ebuj`lm-j`l!#,=	\n\n?gju#`obpp>!`kbqb`wfqjpwj`p!#nfwklg>!dfw!#,algz=	?,kwno=	pklqw`vw#j`lm!#gl`vnfmw-tqjwf+sbggjmd.alwwln9qfsqfpfmwbwjufppvanjw!#ubovf>!bojdm>!`fmwfq!#wkqlvdklvw#wkf#p`jfm`f#ej`wjlm	##?gju#`obpp>!pvanjw!#`obpp>!lmf#le#wkf#nlpw#ubojdm>!wls!=?tbp#fpwbaojpkfg*8	?,p`qjsw=	qfwvqm#ebopf8!=*-pwzof-gjpsobzaf`bvpf#le#wkf#gl`vnfmw-`llhjf?elqn#b`wjlm>!,~algzxnbqdjm938Fm`z`olsfgjb#leufqpjlm#le#wkf#-`qfbwfFofnfmw+mbnf!#`lmwfmw>!?,gju=	?,gju=		bgnjmjpwqbwjuf#?,algz=	?,kwno=kjpwlqz#le#wkf#!=?jmsvw#wzsf>!slqwjlm#le#wkf#bp#sbqw#le#wkf#%maps8?b#kqfe>!lwkfq#`lvmwqjfp!=	?gju#`obpp>!?,psbm=?,psbm=?Jm#lwkfq#tlqgp/gjpsobz9#aol`h8`lmwqlo#le#wkf#jmwqlgv`wjlm#le,=	?nfwb#mbnf>!bp#tfoo#bp#wkf#jm#qf`fmw#zfbqp	\n?gju#`obpp>!?,gju=	\n?,gju=	jmpsjqfg#az#wkfwkf#fmg#le#wkf#`lnsbwjaof#tjwkaf`bnf#hmltm#bp#pwzof>!nbqdjm9-ip!=?,p`qjsw=?#Jmwfqmbwjlmbo#wkfqf#kbuf#affmDfqnbm#obmdvbdf#pwzof>!`lolq9 @lnnvmjpw#Sbqwz`lmpjpwfmw#tjwkalqgfq>!3!#`foo#nbqdjmkfjdkw>!wkf#nbilqjwz#le!#bojdm>!`fmwfqqfobwfg#wl#wkf#nbmz#gjeefqfmw#Lqwklgl{#@kvq`kpjnjobq#wl#wkf#,=	?ojmh#qfo>!ptbp#lmf#le#wkf#vmwjo#kjp#gfbwk~*+*8	?,p`qjsw=lwkfq#obmdvbdfp`lnsbqfg#wl#wkfslqwjlmp#le#wkfwkf#Mfwkfqobmgpwkf#nlpw#`lnnlmab`hdqlvmg9vqo+bqdvfg#wkbw#wkfp`qloojmd>!ml!#jm`ovgfg#jm#wkfMlqwk#Bnfqj`bm#wkf#mbnf#le#wkfjmwfqsqfwbwjlmpwkf#wqbgjwjlmbogfufolsnfmw#le#eqfrvfmwoz#vpfgb#`loof`wjlm#leufqz#pjnjobq#wlpvqqlvmgjmd#wkff{bnsof#le#wkjpbojdm>!`fmwfq!=tlvog#kbuf#affmjnbdf\\`bswjlm#>bwwb`kfg#wl#wkfpvddfpwjmd#wkbwjm#wkf#elqn#le#jmuloufg#jm#wkfjp#gfqjufg#eqlnmbnfg#bewfq#wkfJmwqlgv`wjlm#wlqfpwqj`wjlmp#lm#pwzof>!tjgwk9#`bm#af#vpfg#wl#wkf#`qfbwjlm#lenlpw#jnslqwbmw#jmelqnbwjlm#bmgqfpvowfg#jm#wkf`loobspf#le#wkfWkjp#nfbmp#wkbwfofnfmwp#le#wkftbp#qfsob`fg#azbmbozpjp#le#wkfjmpsjqbwjlm#elqqfdbqgfg#bp#wkfnlpw#pv``fppevohmltm#bp#%rvlw8b#`lnsqfkfmpjufKjpwlqz#le#wkf#tfqf#`lmpjgfqfgqfwvqmfg#wl#wkfbqf#qfefqqfg#wlVmplvq`fg#jnbdf=	\n?gju#`obpp>!`lmpjpwp#le#wkfpwlsSqlsbdbwjlmjmwfqfpw#jm#wkfbubjobajojwz#lebssfbqp#wl#kbuffof`wqlnbdmfwj`fmbaofPfquj`fp+evm`wjlm#le#wkfJw#jp#jnslqwbmw?,p`qjsw=?,gju=evm`wjlm+*xubq#qfobwjuf#wl#wkfbp#b#qfpvow#le#wkf#slpjwjlm#leElq#f{bnsof/#jm#nfwklg>!slpw!#tbp#elooltfg#az%bns8ngbpk8#wkfwkf#bssoj`bwjlmip!=?,p`qjsw=	vo=?,gju=?,gju=bewfq#wkf#gfbwktjwk#qfpsf`w#wlpwzof>!sbggjmd9jp#sbqwj`vobqozgjpsobz9jmojmf8#wzsf>!pvanjw!#jp#gjujgfg#jmwl\bTA\nzk#+\vBl\bQ*qfpslmpbajojgbgbgnjmjpwqb`j/_mjmwfqmb`jlmbofp`lqqfpslmgjfmwf\fHe\fHF\fHC\fIg\fH{\fHF\fIn\fH\\\fIa\fHY\fHU\fHB\fHR\fH\\\fIk\fH^\fIg\fH{\fIg\fHn\fHv\fIm\fHD\fHR\fHY\fH^\fIk\fHy\fHS\fHD\fHT\fH\\\fHy\fHR\fH\\\fHF\fIm\fH^\fHS\fHT\fHz\fIg\fHp\fIk\fHn\fHv\fHR\fHU\fHS\fHc\fHA\fIk\fHp\fIk\fHn\fHZ\fHR\fHB\fHS\fH^\fHU\fHB\fHR\fH\\\fIl\fHp\fHR\fH{\fH\\\fHO\fH@\fHD\fHR\fHD\fIk\fHy\fIm\fHB\fHR\fH\\\fH@\fIa\fH^\fIe\fH{\fHB\fHR\fH^\fHS\fHy\fHB\fHU\fHS\fH^\fHR\fHF\fIo\fH[\fIa\fHL\fH@\fHN\fHP\fHH\fIk\fHA\fHR\fHp\fHF\fHR\fHy\fIa\fH^\fHS\fHy\fHs\fIa\fH\\\fIk\fHD\fHz\fHS\fH^\fHR\fHG\fHJ\fI`\fH\\\fHR\fHD\fHB\fHR\fHB\fH^\fIk\fHB\fHH\fHJ\fHR\fHD\fH@\fHR\fHp\fHR\fH\\\fHY\fHS\fHy\fHR\fHT\fHy\fIa\fHC\fIg\fHn\fHv\fHR\fHU\fHH\fIk\fHF\fHU\fIm\fHm\fHv\fH@\fHH\fHR\fHC\fHR\fHT\fHn\fHY\fHR\fHJ\fHJ\fIk\fHz\fHD\fIk\fHF\fHS\fHw\fH^\fIk\fHY\fHS\fHZ\fIk\fH[\fH\\\fHR\fHp\fIa\fHC\fHe\fHH\fIa\fHH\fH\\\fHB\fIm\fHn\fH@\fHd\fHJ\fIg\fHD\fIg\fHn\fHe\fHF\fHy\fH\\\fHO\fHF\fHN\fHP\fIk\fHn\fHT\fIa\fHI\fHS\fHH\fHG\fHS\fH^\fIa\fHB\fHB\fIm\fHz\fIa\fHC\fHi\fHv\fIa\fHw\fHR\fHw\fIn\fHs\fHH\fIl\fHT\fHn\fH{\fIl\fHH\fHp\fHR\fHc\fH{\fHR\fHY\fHS\fHA\fHR\fH{\fHt\fHO\fIa\fHs\fIk\fHJ\fIn\fHT\fH\\\fIk\fHJ\fHS\fHD\fIg\fHn\fHU\fHH\fIa\fHC\fHR\fHT\fIk\fHy\fIa\fHT\fH{\fHR\fHn\fHK\fIl\fHY\fHS\fHZ\fIa\fHY\fH\\\fHR\fHH\fIk\fHn\fHJ\fId\fHs\fIa\fHT\fHD\fHy\fIa\fHZ\fHR\fHT\fHR\fHB\fHD\fIk\fHi\fHJ\fHR\fH^\fHH\fH@\fHS\fHp\fH^\fIl\fHF\fIm\fH\\\fIn\fH[\fHU\fHS\fHn\fHJ\fIl\fHB\fHS\fHH\fIa\fH\\\fHy\fHY\fHS\fHH\fHR\fH\\\fIm\fHF\fHC\fIk\fHT\fIa\fHI\fHR\fHD\fHy\fH\\\fIg\fHM\fHP\fHB\fIm\fHy\fIa\fHH\fHC\fIg\fHp\fHD\fHR\fHy\fIo\fHF\fHC\fHR\fHF\fIg\fHT\fIa\fHs\fHt\fH\\\fIk\fH^\fIn\fHy\fHR\fH\\\fIa\fHC\fHY\fHS\fHv\fHR\fH\\\fHT\fIn\fHv\fHD\fHR\fHB\fIn\fH^\fIa\fHC\fHJ\fIk\fHz\fIk\fHn\fHU\fHB\fIk\fHZ\fHR\fHT\fIa\fHy\fIn\fH^\fHB\fId\fHn\fHD\fIk\fHH\fId\fHC\fHR\fH\\\fHp\fHS\fHT\fHy\fIkqpp({no!#wjwof>!.wzsf!#`lmwfmw>!wjwof!#`lmwfmw>!bw#wkf#pbnf#wjnf-ip!=?,p`qjsw=	?!#nfwklg>!slpw!#?,psbm=?,b=?,oj=ufqwj`bo.bojdm9w,irvfqz-njm-ip!=-`oj`h+evm`wjlm+#pwzof>!sbggjmd.~*+*8	?,p`qjsw=	?,psbm=?b#kqfe>!?b#kqfe>!kwws9,,*8#qfwvqm#ebopf8wf{w.gf`lqbwjlm9#p`qloojmd>!ml!#alqgfq.`loobspf9bppl`jbwfg#tjwk#Abkbpb#JmglmfpjbFmdojpk#obmdvbdf?wf{w#{no9psb`f>-dje!#alqgfq>!3!?,algz=	?,kwno=	lufqeolt9kjggfm8jnd#pq`>!kwws9,,bggFufmwOjpwfmfqqfpslmpjaof#elq#p-ip!=?,p`qjsw=	,ebuj`lm-j`l!#,=lsfqbwjmd#pzpwfn!#pwzof>!tjgwk92wbqdfw>!\\aobmh!=Pwbwf#Vmjufqpjwzwf{w.bojdm9ofew8	gl`vnfmw-tqjwf+/#jm`ovgjmd#wkf#bqlvmg#wkf#tlqog*8	?,p`qjsw=	?!#pwzof>!kfjdkw98lufqeolt9kjggfmnlqf#jmelqnbwjlmbm#jmwfqmbwjlmbob#nfnafq#le#wkf#lmf#le#wkf#ejqpw`bm#af#elvmg#jm#?,gju=	\n\n?,gju=	gjpsobz9#mlmf8!=!#,=	?ojmh#qfo>!	##+evm`wjlm+*#xwkf#26wk#`fmwvqz-sqfufmwGfebvow+obqdf#mvnafq#le#Azybmwjmf#Fnsjqf-isdwkvnaofewubpw#nbilqjwz#lenbilqjwz#le#wkf##bojdm>!`fmwfq!=Vmjufqpjwz#Sqfppglnjmbwfg#az#wkfPf`lmg#Tlqog#Tbqgjpwqjavwjlm#le#pwzof>!slpjwjlm9wkf#qfpw#le#wkf#`kbqb`wfqjyfg#az#qfo>!mleloolt!=gfqjufp#eqln#wkfqbwkfq#wkbm#wkf#b#`lnajmbwjlm#lepwzof>!tjgwk9233Fmdojpk.psfbhjmd`lnsvwfq#p`jfm`falqgfq>!3!#bow>!wkf#f{jpwfm`f#leGfnl`qbwj`#Sbqwz!#pwzof>!nbqdjm.Elq#wkjp#qfbplm/-ip!=?,p`qjsw=	\npAzWbdMbnf+p*X3^ip!=?,p`qjsw=	?-ip!=?,p`qjsw=	ojmh#qfo>!j`lm!#$#bow>$$#`obpp>$elqnbwjlm#le#wkfufqpjlmp#le#wkf#?,b=?,gju=?,gju=,sbdf=	##?sbdf=	?gju#`obpp>!`lmwaf`bnf#wkf#ejqpwabkbpb#Jmglmfpjbfmdojpk#+pjnsof*"y"W"W"["Q"U"V"@=i=l<^<\\=n=m<V<T<V<R<P<S<\\<Q<T<T=c<^<W=c<Y=n=m=c<x<R<]<\\<^<T=n=`=k<Y<W<R<^<Y<V<\\=l<\\<[<^<T=n<T=c<t<Q=n<Y=l<Q<Y=n<r=n<^<Y=n<T=n=`<Q<\\<S=l<T<P<Y=l<T<Q=n<Y=l<Q<Y=n<V<R=n<R=l<R<_<R=m=n=l<\\<Q<T=j=g<V<\\=k<Y=m=n<^<Y=o=m<W<R<^<T=c=i<S=l<R<]<W<Y<P=g<S<R<W=o=k<T=n=`=c<^<W=c=b=n=m=c<Q<\\<T<]<R<W<Y<Y<V<R<P<S<\\<Q<T=c<^<Q<T<P<\\<Q<T<Y=m=l<Y<X=m=n<^<\\4K5h5i5d4K4Z5f4U4K5h4]4J5f4_5f4E4K5h4K5j4F5n4K5h5i4X4K4]5o4K4F5o4K5h4_5f4K4]4K4F4K5h5i5o4F5d4D4E4K5h4_4U5d4C5f4E4K4A4Y4K4J5f4K4F4K5h4U4K5h5i5f4E4K5h4Y5d4F5f4K4F4K5h4K5j4F4]5j4F4K5h4F4Y4K5i5f5i4K5h4I4_5h4K5i5f4K5h5i4X4K4]5o4E4K5h5i4]4J5f4K4Fqlalwp!#`lmwfmw>!?gju#jg>!ellwfq!=wkf#Vmjwfg#Pwbwfp?jnd#pq`>!kwws9,,-isdqjdkwwkvna-ip!=?,p`qjsw=	?ol`bwjlm-sqlwl`loeqbnfalqgfq>!3!#p!#,=	?nfwb#mbnf>!?,b=?,gju=?,gju=?elmw.tfjdkw9alog8%rvlw8#bmg#%rvlw8gfsfmgjmd#lm#wkf#nbqdjm938sbggjmd9!#qfo>!mleloolt!#Sqfpjgfmw#le#wkf#wtfmwjfwk#`fmwvqzfujpjlm=	##?,sbdfJmwfqmfw#F{solqfqb-bpzm`#>#wqvf8	jmelqnbwjlm#balvw?gju#jg>!kfbgfq!=!#b`wjlm>!kwws9,,?b#kqfe>!kwwsp9,,?gju#jg>!`lmwfmw!?,gju=	?,gju=	?gfqjufg#eqln#wkf#?jnd#pq`>$kwws9,,b``lqgjmd#wl#wkf#	?,algz=	?,kwno=	pwzof>!elmw.pjyf9p`qjsw#obmdvbdf>!Bqjbo/#Kfoufwj`b/?,b=?psbm#`obpp>!?,p`qjsw=?p`qjsw#slojwj`bo#sbqwjfpwg=?,wq=?,wbaof=?kqfe>!kwws9,,ttt-jmwfqsqfwbwjlm#leqfo>!pwzofpkffw!#gl`vnfmw-tqjwf+$?`kbqpfw>!vwe.;!=	afdjmmjmd#le#wkf#qfufbofg#wkbw#wkfwfofujpjlm#pfqjfp!#qfo>!mleloolt!=#wbqdfw>!\\aobmh!=`objnjmd#wkbw#wkfkwws&0B&1E&1Ettt-nbmjefpwbwjlmp#leSqjnf#Njmjpwfq#lejmeovfm`fg#az#wkf`obpp>!`ofbqej{!=,gju=	?,gju=		wkqff.gjnfmpjlmbo@kvq`k#le#Fmdobmgle#Mlqwk#@bqlojmbprvbqf#hjolnfwqfp-bggFufmwOjpwfmfqgjpwjm`w#eqln#wkf`lnnlmoz#hmltm#bpSklmfwj`#Boskbafwgf`obqfg#wkbw#wkf`lmwqloofg#az#wkfAfmibnjm#Eqbmhojmqlof.sobzjmd#dbnfwkf#Vmjufqpjwz#lejm#Tfpwfqm#Fvqlsfsfqplmbo#`lnsvwfqSqlif`w#Dvwfmafqdqfdbqgofpp#le#wkfkbp#affm#sqlslpfgwldfwkfq#tjwk#wkf=?,oj=?oj#`obpp>!jm#plnf#`lvmwqjfpnjm-ip!=?,p`qjsw=le#wkf#slsvobwjlmleej`jbo#obmdvbdf?jnd#pq`>!jnbdfp,jgfmwjejfg#az#wkfmbwvqbo#qfplvq`fp`obppjej`bwjlm#le`bm#af#`lmpjgfqfgrvbmwvn#nf`kbmj`pMfufqwkfofpp/#wkfnjoojlm#zfbqp#bdl?,algz=	?,kwno="y"W"W"["Q"U"V"@	wbhf#bgubmwbdf#lebmg/#b``lqgjmd#wlbwwqjavwfg#wl#wkfNj`qlplew#Tjmgltpwkf#ejqpw#`fmwvqzvmgfq#wkf#`lmwqlogju#`obpp>!kfbgfqpklqwoz#bewfq#wkfmlwbaof#f{`fswjlmwfmp#le#wklvpbmgppfufqbo#gjeefqfmwbqlvmg#wkf#tlqog-qfb`kjmd#njojwbqzjplobwfg#eqln#wkflsslpjwjlm#wl#wkfwkf#Log#WfpwbnfmwBeqj`bm#Bnfqj`bmpjmpfqwfg#jmwl#wkfpfsbqbwf#eqln#wkfnfwqlslojwbm#bqfbnbhfp#jw#slppjaofb`hmltofgdfg#wkbwbqdvbaoz#wkf#nlpwwzsf>!wf{w,`pp!=	wkf#JmwfqmbwjlmboB``lqgjmd#wl#wkf#sf>!wf{w,`pp!#,=	`ljm`jgf#tjwk#wkfwtl.wkjqgp#le#wkfGvqjmd#wkjp#wjnf/gvqjmd#wkf#sfqjlgbmmlvm`fg#wkbw#kfwkf#jmwfqmbwjlmbobmg#nlqf#qf`fmwozafojfufg#wkbw#wkf`lmp`jlvpmfpp#bmgelqnfqoz#hmltm#bppvqqlvmgfg#az#wkfejqpw#bssfbqfg#jml``bpjlmbooz#vpfgslpjwjlm9baplovwf8!#wbqdfw>!\\aobmh!#slpjwjlm9qfobwjuf8wf{w.bojdm9`fmwfq8ib{,ojap,irvfqz,2-ab`hdqlvmg.`lolq9 wzsf>!bssoj`bwjlm,bmdvbdf!#`lmwfmw>!?nfwb#kwws.frvju>!Sqjub`z#Sloj`z?,b=f+!&0@p`qjsw#pq`>$!#wbqdfw>!\\aobmh!=Lm#wkf#lwkfq#kbmg/-isdwkvnaqjdkw1?,gju=?gju#`obpp>!?gju#pwzof>!eolbw9mjmfwffmwk#`fmwvqz?,algz=	?,kwno=	?jnd#pq`>!kwws9,,p8wf{w.bojdm9`fmwfqelmw.tfjdkw9#alog8#B``lqgjmd#wl#wkf#gjeefqfm`f#afwtffm!#eqbnfalqgfq>!3!#!#pwzof>!slpjwjlm9ojmh#kqfe>!kwws9,,kwno7,ollpf-gwg!=	gvqjmd#wkjp#sfqjlg?,wg=?,wq=?,wbaof=`olpfoz#qfobwfg#wlelq#wkf#ejqpw#wjnf8elmw.tfjdkw9alog8jmsvw#wzsf>!wf{w!#?psbm#pwzof>!elmw.lmqfbgzpwbwf`kbmdf\n?gju#`obpp>!`ofbqgl`vnfmw-ol`bwjlm-#Elq#f{bnsof/#wkf#b#tjgf#ubqjfwz#le#?"GL@WZSF#kwno=	?%maps8%maps8%maps8!=?b#kqfe>!kwws9,,pwzof>!eolbw9ofew8`lm`fqmfg#tjwk#wkf>kwws&0B&1E&1Ettt-jm#slsvobq#`vowvqfwzsf>!wf{w,`pp!#,=jw#jp#slppjaof#wl#Kbqubqg#Vmjufqpjwzwzofpkffw!#kqfe>!,wkf#nbjm#`kbqb`wfqL{elqg#Vmjufqpjwz##mbnf>!hfztlqgp!#`pwzof>!wf{w.bojdm9wkf#Vmjwfg#Hjmdglnefgfqbo#dlufqmnfmw?gju#pwzof>!nbqdjm#gfsfmgjmd#lm#wkf#gfp`qjswjlm#le#wkf?gju#`obpp>!kfbgfq-njm-ip!=?,p`qjsw=gfpwqv`wjlm#le#wkfpojdkwoz#gjeefqfmwjm#b``lqgbm`f#tjwkwfof`lnnvmj`bwjlmpjmgj`bwfp#wkbw#wkfpklqwoz#wkfqfbewfqfpsf`jbooz#jm#wkf#Fvqlsfbm#`lvmwqjfpKltfufq/#wkfqf#bqfpq`>!kwws9,,pwbwj`pvddfpwfg#wkbw#wkf!#pq`>!kwws9,,ttt-b#obqdf#mvnafq#le#Wfof`lnnvmj`bwjlmp!#qfo>!mleloolt!#wKloz#Qlnbm#Fnsfqlqbonlpw#f{`ovpjufoz!#alqgfq>!3!#bow>!Pf`qfwbqz#le#Pwbwf`vonjmbwjmd#jm#wkf@JB#Tlqog#Eb`wallhwkf#nlpw#jnslqwbmwbmmjufqpbqz#le#wkfpwzof>!ab`hdqlvmg.?oj=?fn=?b#kqfe>!,wkf#Bwobmwj`#L`fbmpwqj`woz#psfbhjmd/pklqwoz#afelqf#wkfgjeefqfmw#wzsfp#lewkf#Lwwlnbm#Fnsjqf=?jnd#pq`>!kwws9,,Bm#Jmwqlgv`wjlm#wl`lmpfrvfm`f#le#wkfgfsbqwvqf#eqln#wkf@lmefgfqbwf#Pwbwfpjmgjdfmlvp#sflsofpSql`ffgjmdp#le#wkfjmelqnbwjlm#lm#wkfwkflqjfp#kbuf#affmjmuloufnfmw#jm#wkfgjujgfg#jmwl#wkqffbgib`fmw#`lvmwqjfpjp#qfpslmpjaof#elqgjpplovwjlm#le#wkf`loobalqbwjlm#tjwktjgfoz#qfdbqgfg#bpkjp#`lmwfnslqbqjfpelvmgjmd#nfnafq#leGlnjmj`bm#Qfsvaoj`dfmfqbooz#b``fswfgwkf#slppjajojwz#lebqf#bopl#bubjobaofvmgfq#`lmpwqv`wjlmqfpwlqbwjlm#le#wkfwkf#dfmfqbo#svaoj`jp#bonlpw#fmwjqfozsbppfp#wkqlvdk#wkfkbp#affm#pvddfpwfg`lnsvwfq#bmg#ujgflDfqnbmj`#obmdvbdfp#b``lqgjmd#wl#wkf#gjeefqfmw#eqln#wkfpklqwoz#bewfqtbqgpkqfe>!kwwsp9,,ttt-qf`fmw#gfufolsnfmwAlbqg#le#Gjqf`wlqp?gju#`obpp>!pfbq`k#?b#kqfe>!kwws9,,Jm#sbqwj`vobq/#wkfNvowjsof#ellwmlwfplq#lwkfq#pvapwbm`fwklvpbmgp#le#zfbqpwqbmpobwjlm#le#wkf?,gju=	?,gju=		?b#kqfe>!jmgf{-skstbp#fpwbaojpkfg#jmnjm-ip!=?,p`qjsw=	sbqwj`jsbwf#jm#wkfb#pwqlmd#jmeovfm`fpwzof>!nbqdjm.wls9qfsqfpfmwfg#az#wkfdqbgvbwfg#eqln#wkfWqbgjwjlmbooz/#wkfFofnfmw+!p`qjsw!*8Kltfufq/#pjm`f#wkf,gju=	?,gju=	?gju#ofew8#nbqdjm.ofew9sqlwf`wjlm#bdbjmpw38#ufqwj`bo.bojdm9Vmelqwvmbwfoz/#wkfwzsf>!jnbdf,{.j`lm,gju=	?gju#`obpp>!#`obpp>!`ofbqej{!=?gju#`obpp>!ellwfq\n\n?,gju=	\n\n?,gju=	wkf#nlwjlm#sj`wvqf<}=f<W<_<\\=l=m<V<T<]=f<W<_<\\=l=m<V<T<H<Y<X<Y=l<\\=j<T<T<Q<Y=m<V<R<W=`<V<R=m<R<R<]=e<Y<Q<T<Y=m<R<R<]=e<Y<Q<T=c<S=l<R<_=l<\\<P<P=g<r=n<S=l<\\<^<T=n=`<]<Y=m<S<W<\\=n<Q<R<P<\\=n<Y=l<T<\\<W=g<S<R<[<^<R<W=c<Y=n<S<R=m<W<Y<X<Q<T<Y=l<\\<[<W<T=k<Q=g=i<S=l<R<X=o<V=j<T<T<S=l<R<_=l<\\<P<P<\\<S<R<W<Q<R=m=n=`=b<Q<\\=i<R<X<T=n=m=c<T<[<]=l<\\<Q<Q<R<Y<Q<\\=m<Y<W<Y<Q<T=c<T<[<P<Y<Q<Y<Q<T=c<V<\\=n<Y<_<R=l<T<T<|<W<Y<V=m<\\<Q<X=l\fHJ\fIa\fHY\fHR\fH\\\fHR\fHB\fId\fHD\fIm\fHi\fH^\fHF\fIa\fH\\\fHJ\fHR\fHD\fHA\fHR\fH\\\fHH\fIl\fHC\fHi\fHD\fIm\fHJ\fIk\fHZ\fHU\fHS\fHD\fIa\fHJ\fIl\fHk\fHn\fHM\fHS\fHC\fHR\fHJ\fHS\fH^\fIa\fH^\fIl\fHi\fHK\fHS\fHy\fHR\fH\\\fHY\fIl\fHM\fHS\fHC\fIg\fHv\fHS\fHs\fIa\fHL\fIk\fHT\fHB\fHR\fHv\fHR\fH\\\fHp\fHn\fHy\fIa\fHZ\fHD\fHJ\fIm\fHD\fHS\fHC\fHR\fHF\fIa\fH\\\fHC\fIg\fH{\fHi\fHD\fIm\fHT\fHR\fH\\\fH}\fHD\fH^\fHR\fHk\fHD\fHF\fHR\fH\\\fIa\fHs\fIl\fHZ\fH\\\fIa\fHH\fIg\fHn\fH^\fIg\fHy\fHT\fHA\fHR\fHG\fHP\fIa\fH^\fId\fHZ\fHZ\fH\\\fIa\fHH\fIk\fHn\fHF\fIa\fH\\\fHJ\fIk\fHZ\fHF\fIa\fH^\fIk\fHC\fH\\\fHy\fIk\fHn\fHJ\fIa\fH\\\fHT\fIa\fHI\fHS\fHH\fHS\fHe\fHH\fIa\fHF\fHR\fHJ\fHe\fHD\fIa\fHU\fIk\fHn\fHv\fHS\fHs\fIa\fHL\fHR\fHC\fHR\fHH\fIa\fH\\\fHR\fHp\fIa\fHC\fHR\fHJ\fHR\fHF\fIm\fH\\\fHR\fHD\fIk\fHp\fIg\fHM\fHP\fIk\fHn\fHi\fHD\fIm\fHY\fHR\fHJ\fHZ\fIa\fH\\\fIk\fHO\fIl\fHZ\fHS\fHy\fIa\fH[\fHR\fHT\fH\\\fHy\fHR\fH\\\fIl\fHT\fHn\fH{\fIa\fH\\\fHU\fHF\fH\\\fHS\fHO\fHR\fHB\fH@\fIa\fH\\\fHR\fHn\fHM\fH@\fHv\fIa\fHv\fIg\fHn\fHe\fHF\fH^\fH@\fIa\fHK\fHB\fHn\fHH\fIa\fH\\\fIl\fHT\fHn\fHF\fH\\\fIa\fHy\fHe\fHB\fIa\fHB\fIl\fHJ\fHB\fHR\fHK\fIa\fHC\fHB\fHT\fHU\fHR\fHC\fHH\fHR\fHZ\fH@\fIa\fHJ\fIg\fHn\fHB\fIl\fHM\fHS\fHC\fHR\fHj\fHd\fHF\fIl\fHc\fH^\fHB\fIg\fH@\fHR\fHk\fH^\fHT\fHn\fHz\fIa\fHC\fHR\fHj\fHF\fH\\\fIk\fHZ\fHD\fHi\fHD\fIm\fH@\fHn\fHK\fH@\fHR\fHp\fHP\fHR\fH\\\fHD\fHY\fIl\fHD\fHH\fHB\fHF\fIa\fH\\\fHB\fIm\fHz\fHF\fIa\fH\\\fHZ\fIa\fHD\fHF\fH\\\fHS\fHY\fHR\fH\\\fHD\fIm\fHy\fHT\fHR\fHD\fHT\fHB\fH\\\fIa\fHI\fHD\fHj\fHC\fIg\fHp\fHS\fHH\fHT\fIg\fHB\fHY\fHR\fH\\4K5h5i4X4K4]5o4K4F4K5h5i5j4F4C5f4K4F4K5h5o5i4D5f5d4F4]4K5h5i4X4K5k4C4K4F4U4C4C4K5h4^5d4K4]4U4C4C4K5h4]4C5d4C4K5h4I4_5h4K5i5f4E4K5h5m5d4F5d4X5d4D4K5h5i4_4K4D5n4K4F4K5h5i4U5h5d5i4K4F4K5h5i4_5h4_5h4K4F4K5h4@4]4K5m5f5o4_4K5h4K4_5h4K5i5f4E4K5h4K4F4Y4K5h4K4Fhfztlqgp!#`lmwfmw>!t0-lqd,2:::,{kwno!=?b#wbqdfw>!\\aobmh!#wf{w,kwno8#`kbqpfw>!#wbqdfw>!\\aobmh!=?wbaof#`foosbggjmd>!bvwl`lnsofwf>!lee!#wf{w.bojdm9#`fmwfq8wl#obpw#ufqpjlm#az#ab`hdqlvmg.`lolq9# !#kqfe>!kwws9,,ttt-,gju=?,gju=?gju#jg>?b#kqfe>! !#`obpp>!!=?jnd#pq`>!kwws9,,`qjsw!#pq`>!kwws9,,	?p`qjsw#obmdvbdf>!,,FM!#!kwws9,,ttt-tfm`lgfVQJ@lnslmfmw+!#kqfe>!ibubp`qjsw9?gju#`obpp>!`lmwfmwgl`vnfmw-tqjwf+$?p`slpjwjlm9#baplovwf8p`qjsw#pq`>!kwws9,,#pwzof>!nbqdjm.wls9-njm-ip!=?,p`qjsw=	?,gju=	?gju#`obpp>!t0-lqd,2:::,{kwno!#		?,algz=	?,kwno=gjpwjm`wjlm#afwtffm,!#wbqdfw>!\\aobmh!=?ojmh#kqfe>!kwws9,,fm`lgjmd>!vwe.;!<=	t-bggFufmwOjpwfmfq<b`wjlm>!kwws9,,ttt-j`lm!#kqfe>!kwws9,,#pwzof>!ab`hdqlvmg9wzsf>!wf{w,`pp!#,=	nfwb#sqlsfqwz>!ld9w?jmsvw#wzsf>!wf{w!##pwzof>!wf{w.bojdm9wkf#gfufolsnfmw#le#wzofpkffw!#wzsf>!wfkwno8#`kbqpfw>vwe.;jp#`lmpjgfqfg#wl#afwbaof#tjgwk>!233&!#Jm#bggjwjlm#wl#wkf#`lmwqjavwfg#wl#wkf#gjeefqfm`fp#afwtffmgfufolsnfmw#le#wkf#Jw#jp#jnslqwbmw#wl#?,p`qjsw=		?p`qjsw##pwzof>!elmw.pjyf92=?,psbm=?psbm#jg>daOjaqbqz#le#@lmdqfpp?jnd#pq`>!kwws9,,jnFmdojpk#wqbmpobwjlmB`bgfnz#le#P`jfm`fpgju#pwzof>!gjpsobz9`lmpwqv`wjlm#le#wkf-dfwFofnfmwAzJg+jg*jm#`lmivm`wjlm#tjwkFofnfmw+$p`qjsw$*8#?nfwb#sqlsfqwz>!ld9<}=f<W<_<\\=l=m<V<T	#wzsf>!wf{w!#mbnf>!=Sqjub`z#Sloj`z?,b=bgnjmjpwfqfg#az#wkffmbaofPjmdofQfrvfpwpwzof>%rvlw8nbqdjm9?,gju=?,gju=?,gju=?=?jnd#pq`>!kwws9,,j#pwzof>%rvlw8eolbw9qfefqqfg#wl#bp#wkf#wlwbo#slsvobwjlm#lejm#Tbpkjmdwlm/#G-@-#pwzof>!ab`hdqlvmg.bnlmd#lwkfq#wkjmdp/lqdbmjybwjlm#le#wkfsbqwj`jsbwfg#jm#wkfwkf#jmwqlgv`wjlm#lejgfmwjejfg#tjwk#wkfej`wjlmbo#`kbqb`wfq#L{elqg#Vmjufqpjwz#njpvmgfqpwbmgjmd#leWkfqf#bqf/#kltfufq/pwzofpkffw!#kqfe>!,@lovnajb#Vmjufqpjwzf{sbmgfg#wl#jm`ovgfvpvbooz#qfefqqfg#wljmgj`bwjmd#wkbw#wkfkbuf#pvddfpwfg#wkbwbeejojbwfg#tjwk#wkf`lqqfobwjlm#afwtffmmvnafq#le#gjeefqfmw=?,wg=?,wq=?,wbaof=Qfsvaoj`#le#Jqfobmg	?,p`qjsw=	?p`qjsw#vmgfq#wkf#jmeovfm`f`lmwqjavwjlm#wl#wkfLeej`jbo#tfapjwf#lekfbgrvbqwfqp#le#wkf`fmwfqfg#bqlvmg#wkfjnsoj`bwjlmp#le#wkfkbuf#affm#gfufolsfgEfgfqbo#Qfsvaoj`#leaf`bnf#jm`qfbpjmdoz`lmwjmvbwjlm#le#wkfMlwf/#kltfufq/#wkbwpjnjobq#wl#wkbw#le#`bsbajojwjfp#le#wkfb``lqgbm`f#tjwk#wkfsbqwj`jsbmwp#jm#wkfevqwkfq#gfufolsnfmwvmgfq#wkf#gjqf`wjlmjp#lewfm#`lmpjgfqfgkjp#zlvmdfq#aqlwkfq?,wg=?,wq=?,wbaof=?b#kwws.frvju>![.VB.skzpj`bo#sqlsfqwjfple#Aqjwjpk#@lovnajbkbp#affm#`qjwj`jyfg+tjwk#wkf#f{`fswjlmrvfpwjlmp#balvw#wkfsbppjmd#wkqlvdk#wkf3!#`foosbggjmd>!3!#wklvpbmgp#le#sflsofqfgjqf`wp#kfqf-#Elqkbuf#`kjogqfm#vmgfq&0F&0@,p`qjsw&0F!**8?b#kqfe>!kwws9,,ttt-?oj=?b#kqfe>!kwws9,,pjwf\\mbnf!#`lmwfmw>!wf{w.gf`lqbwjlm9mlmfpwzof>!gjpsobz9#mlmf?nfwb#kwws.frvju>![.mft#Gbwf+*-dfwWjnf+*#wzsf>!jnbdf,{.j`lm!?,psbm=?psbm#`obpp>!obmdvbdf>!ibubp`qjswtjmglt-ol`bwjlm-kqfe?b#kqfe>!ibubp`qjsw9..=	?p`qjsw#wzsf>!w?b#kqfe>$kwws9,,ttt-klqw`vw#j`lm!#kqfe>!?,gju=	?gju#`obpp>!?p`qjsw#pq`>!kwws9,,!#qfo>!pwzofpkffw!#w?,gju=	?p`qjsw#wzsf>,b=#?b#kqfe>!kwws9,,#booltWqbmpsbqfm`z>![.VB.@lnsbwjaof!#`lmqfobwjlmpkjs#afwtffm	?,p`qjsw=	?p`qjsw#?,b=?,oj=?,vo=?,gju=bppl`jbwfg#tjwk#wkf#sqldqbnnjmd#obmdvbdf?,b=?b#kqfe>!kwws9,,?,b=?,oj=?oj#`obpp>!elqn#b`wjlm>!kwws9,,?gju#pwzof>!gjpsobz9wzsf>!wf{w!#mbnf>!r!?wbaof#tjgwk>!233&!#ab`hdqlvmg.slpjwjlm9!#alqgfq>!3!#tjgwk>!qfo>!pklqw`vw#j`lm!#k5=?vo=?oj=?b#kqfe>!##?nfwb#kwws.frvju>!`pp!#nfgjb>!p`qffm!#qfpslmpjaof#elq#wkf#!#wzsf>!bssoj`bwjlm,!#pwzof>!ab`hdqlvmg.kwno8#`kbqpfw>vwe.;!#booltwqbmpsbqfm`z>!pwzofpkffw!#wzsf>!wf	?nfwb#kwws.frvju>!=?,psbm=?psbm#`obpp>!3!#`foopsb`jmd>!3!=8	?,p`qjsw=	?p`qjsw#plnfwjnfp#`boofg#wkfglfp#mlw#mf`fppbqjozElq#nlqf#jmelqnbwjlmbw#wkf#afdjmmjmd#le#?"GL@WZSF#kwno=?kwnosbqwj`vobqoz#jm#wkf#wzsf>!kjggfm!#mbnf>!ibubp`qjsw9uljg+3*8!feef`wjufmfpp#le#wkf#bvwl`lnsofwf>!lee!#dfmfqbooz#`lmpjgfqfg=?jmsvw#wzsf>!wf{w!#!=?,p`qjsw=	?p`qjswwkqlvdklvw#wkf#tlqog`lnnlm#njp`lm`fswjlmbppl`jbwjlm#tjwk#wkf?,gju=	?,gju=	?gju#`gvqjmd#kjp#ojefwjnf/`lqqfpslmgjmd#wl#wkfwzsf>!jnbdf,{.j`lm!#bm#jm`qfbpjmd#mvnafqgjsolnbwj`#qfobwjlmpbqf#lewfm#`lmpjgfqfgnfwb#`kbqpfw>!vwe.;!#?jmsvw#wzsf>!wf{w!#f{bnsofp#jm`ovgf#wkf!=?jnd#pq`>!kwws9,,jsbqwj`jsbwjlm#jm#wkfwkf#fpwbaojpknfmw#le	?,gju=	?gju#`obpp>!%bns8maps8%bns8maps8wl#gfwfqnjmf#tkfwkfqrvjwf#gjeefqfmw#eqlnnbqhfg#wkf#afdjmmjmdgjpwbm`f#afwtffm#wkf`lmwqjavwjlmp#wl#wkf`lmeoj`w#afwtffm#wkftjgfoz#`lmpjgfqfg#wltbp#lmf#le#wkf#ejqpwtjwk#ubqzjmd#gfdqffpkbuf#psf`vobwfg#wkbw+gl`vnfmw-dfwFofnfmwsbqwj`jsbwjmd#jm#wkflqjdjmbooz#gfufolsfgfwb#`kbqpfw>!vwe.;!=#wzsf>!wf{w,`pp!#,=	jmwfq`kbmdfbaoz#tjwknlqf#`olpfoz#qfobwfgpl`jbo#bmg#slojwj`bowkbw#tlvog#lwkfqtjpfsfqsfmgj`vobq#wl#wkfpwzof#wzsf>!wf{w,`ppwzsf>!pvanjw!#mbnf>!ebnjojfp#qfpjgjmd#jmgfufolsjmd#`lvmwqjfp`lnsvwfq#sqldqbnnjmdf`lmlnj`#gfufolsnfmwgfwfqnjmbwjlm#le#wkfelq#nlqf#jmelqnbwjlmlm#pfufqbo#l``bpjlmpslqwvdv/Fp#+Fvqlsfv*<O<V=l<\\={<Q=m=`<V<\\=o<V=l<\\={<Q=m=`<V<\\<L<R=m=m<T<U=m<V<R<U<P<\\=n<Y=l<T<\\<W<R<^<T<Q=h<R=l<P<\\=j<T<T=o<S=l<\\<^<W<Y<Q<T=c<Q<Y<R<]=i<R<X<T<P<R<T<Q=h<R=l<P<\\=j<T=c<t<Q=h<R=l<P<\\=j<T=c<L<Y=m<S=o<]<W<T<V<T<V<R<W<T=k<Y=m=n<^<R<T<Q=h<R=l<P<\\=j<T=b=n<Y=l=l<T=n<R=l<T<T<X<R=m=n<\\=n<R=k<Q<R4K5h5i4F5d4K4@4C5d5j4K5h4K4X4F4]4K5o4K4F4K5h4K5n4F4]4K4A4K4Fkwno8#`kbqpfw>VWE.;!#pfwWjnflvw+evm`wjlm+*gjpsobz9jmojmf.aol`h8?jmsvw#wzsf>!pvanjw!#wzsf#>#$wf{w,ibubp`qj?jnd#pq`>!kwws9,,ttt-!#!kwws9,,ttt-t0-lqd,pklqw`vw#j`lm!#kqfe>!!#bvwl`lnsofwf>!lee!#?,b=?,gju=?gju#`obpp>?,b=?,oj=	?oj#`obpp>!`pp!#wzsf>!wf{w,`pp!#?elqn#b`wjlm>!kwws9,,{w,`pp!#kqfe>!kwws9,,ojmh#qfo>!bowfqmbwf!#	?p`qjsw#wzsf>!wf{w,#lm`oj`h>!ibubp`qjsw9+mft#Gbwf*-dfwWjnf+*~kfjdkw>!2!#tjgwk>!2!#Sflsof$p#Qfsvaoj`#le##?b#kqfe>!kwws9,,ttt-wf{w.gf`lqbwjlm9vmgfqwkf#afdjmmjmd#le#wkf#?,gju=	?,gju=	?,gju=	fpwbaojpknfmw#le#wkf#?,gju=?,gju=?,gju=?,g ujftslqwxnjm.kfjdkw9	?p`qjsw#pq`>!kwws9,,lswjlm=?lswjlm#ubovf>lewfm#qfefqqfg#wl#bp#,lswjlm=	?lswjlm#ubov?"GL@WZSF#kwno=	?"..XJmwfqmbwjlmbo#Bjqslqw=	?b#kqfe>!kwws9,,ttt?,b=?b#kqfe>!kwws9,,t\fTL\fT^\fTE\fT^\fUh\fT{\fTN\roI\ro|\roL\ro{\roO\rov\rot\nAOGx\bTA\nzk#+\vUmGx*\fHD\fHS\fH\\\fIa\fHJ\fIk\fHZ\fHM\fHR\fHe\fHD\fH^\fIg\fHM\fHy\fIa\fH[\fIk\fHH\fIa\fH\\\fHp\fHR\fHD\fHy\fHR\fH\\\fIl\fHT\fHn\fH@\fHn\fHK\fHS\fHH\fHT\fIa\fHI\fHR\fHF\fHD\fHR\fHT\fIa\fHY\fIl\fHy\fHR\fH\\\fHT\fHn\fHT\fIa\fHy\fH\\\fHO\fHT\fHR\fHB\fH{\fIa\fH\\\fIl\fHv\fHS\fHs\fIa\fHL\fIg\fHn\fHY\fHS\fHp\fIa\fHr\fHR\fHD\fHi\fHB\fIk\fH\\\fHS\fHy\fHR\fHY\fHS\fHA\fHS\fHD\fIa\fHD\fH{\fHR\fHM\fHS\fHC\fHR\fHm\fHy\fIa\fHC\fIg\fHn\fHy\fHS\fHT\fIm\fH\\\fHy\fIa\fH[\fHR\fHF\fHU\fIm\fHm\fHv\fHH\fIl\fHF\fIa\fH\\\fH@\fHn\fHK\fHD\fHs\fHS\fHF\fIa\fHF\fHO\fIl\fHy\fIa\fH\\\fHS\fHy\fIk\fHs\fHF\fIa\fH\\\fHR\fH\\\fHn\fHA\fHF\fIa\fH\\\fHR\fHF\fIa\fHH\fHB\fHR\fH^\fHS\fHy\fIg\fHn\fH\\\fHG\fHP\fIa\fHH\fHR\fH\\\fHD\fHS\fH\\\fIa\fHB\fHR\fHO\fH^\fHS\fHB\fHS\fHs\fIk\fHMgfp`qjswjlm!#`lmwfmw>!gl`vnfmw-ol`bwjlm-sqlw-dfwFofnfmwpAzWbdMbnf+?"GL@WZSF#kwno=	?kwno#?nfwb#`kbqpfw>!vwe.;!=9vqo!#`lmwfmw>!kwws9,,-`pp!#qfo>!pwzofpkffw!pwzof#wzsf>!wf{w,`pp!=wzsf>!wf{w,`pp!#kqfe>!t0-lqd,2:::,{kwno!#{nowzsf>!wf{w,ibubp`qjsw!#nfwklg>!dfw!#b`wjlm>!ojmh#qfo>!pwzofpkffw!##>#gl`vnfmw-dfwFofnfmwwzsf>!jnbdf,{.j`lm!#,=`foosbggjmd>!3!#`foops-`pp!#wzsf>!wf{w,`pp!#?,b=?,oj=?oj=?b#kqfe>!!#tjgwk>!2!#kfjdkw>!2!!=?b#kqfe>!kwws9,,ttt-pwzof>!gjpsobz9mlmf8!=bowfqmbwf!#wzsf>!bssoj.,,T0@,,GWG#[KWNO#2-3#foopsb`jmd>!3!#`foosbg#wzsf>!kjggfm!#ubovf>!,b=%maps8?psbm#qlof>!p	?jmsvw#wzsf>!kjggfm!#obmdvbdf>!IbubP`qjsw!##gl`vnfmw-dfwFofnfmwpAd>!3!#`foopsb`jmd>!3!#zsf>!wf{w,`pp!#nfgjb>!wzsf>$wf{w,ibubp`qjsw$tjwk#wkf#f{`fswjlm#le#zsf>!wf{w,`pp!#qfo>!pw#kfjdkw>!2!#tjgwk>!2!#>$(fm`lgfVQJ@lnslmfmw+?ojmh#qfo>!bowfqmbwf!#	algz/#wq/#jmsvw/#wf{wnfwb#mbnf>!qlalwp!#`lmnfwklg>!slpw!#b`wjlm>!=	?b#kqfe>!kwws9,,ttt-`pp!#qfo>!pwzofpkffw!#?,gju=?,gju=?gju#`obppobmdvbdf>!ibubp`qjsw!=bqjb.kjggfm>!wqvf!=.[?qjsw!#wzsf>!wf{w,ibubpo>38~*+*8	+evm`wjlm+*xab`hdqlvmg.jnbdf9#vqo+,b=?,oj=?oj=?b#kqfe>!k\n\n?oj=?b#kqfe>!kwws9,,bwlq!#bqjb.kjggfm>!wqv=#?b#kqfe>!kwws9,,ttt-obmdvbdf>!ibubp`qjsw!#,lswjlm=	?lswjlm#ubovf,gju=?,gju=?gju#`obpp>qbwlq!#bqjb.kjggfm>!wqf>+mft#Gbwf*-dfwWjnf+*slqwvdv/Fp#+gl#Aqbpjo*<R=l<_<\\<Q<T<[<\\=j<T<T<^<R<[<P<R<Z<Q<R=m=n=`<R<]=l<\\<[<R<^<\\<Q<T=c=l<Y<_<T=m=n=l<\\=j<T<T<^<R<[<P<R<Z<Q<R=m=n<T<R<]=c<[<\\=n<Y<W=`<Q<\\?"GL@WZSF#kwno#SVAOJ@#!mw.Wzsf!#`lmwfmw>!wf{w,?nfwb#kwws.frvju>!@lmwfqbmpjwjlmbo,,FM!#!kwws9?kwno#{nomp>!kwws9,,ttt.,,T0@,,GWG#[KWNO#2-3#WGWG,{kwno2.wqbmpjwjlmbo,,ttt-t0-lqd,WQ,{kwno2,sf#>#$wf{w,ibubp`qjsw$8?nfwb#mbnf>!gfp`qjswjlmsbqfmwMlgf-jmpfqwAfelqf?jmsvw#wzsf>!kjggfm!#mbip!#wzsf>!wf{w,ibubp`qj+gl`vnfmw*-qfbgz+evm`wjp`qjsw#wzsf>!wf{w,ibubpjnbdf!#`lmwfmw>!kwws9,,VB.@lnsbwjaof!#`lmwfmw>wno8#`kbqpfw>vwe.;!#,=	ojmh#qfo>!pklqw`vw#j`lm?ojmh#qfo>!pwzofpkffw!#?,p`qjsw=	?p`qjsw#wzsf>>#gl`vnfmw-`qfbwfFofnfm?b#wbqdfw>!\\aobmh!#kqfe>#gl`vnfmw-dfwFofnfmwpAjmsvw#wzsf>!wf{w!#mbnf>b-wzsf#>#$wf{w,ibubp`qjmsvw#wzsf>!kjggfm!#mbnfkwno8#`kbqpfw>vwe.;!#,=gwg!=	?kwno#{nomp>!kwws.,,T0@,,GWG#KWNO#7-32#WfmwpAzWbdMbnf+$p`qjsw$*jmsvw#wzsf>!kjggfm!#mbn?p`qjsw#wzsf>!wf{w,ibubp!#pwzof>!gjpsobz9mlmf8!=gl`vnfmw-dfwFofnfmwAzJg+>gl`vnfmw-`qfbwfFofnfmw+$#wzsf>$wf{w,ibubp`qjsw$jmsvw#wzsf>!wf{w!#mbnf>!g-dfwFofnfmwpAzWbdMbnf+pmj`bo!#kqfe>!kwws9,,ttt-@,,GWG#KWNO#7-32#Wqbmpjw?pwzof#wzsf>!wf{w,`pp!=		?pwzof#wzsf>!wf{w,`pp!=jlmbo-gwg!=	?kwno#{nomp>kwws.frvju>!@lmwfmw.Wzsfgjmd>!3!#`foopsb`jmd>!3!kwno8#`kbqpfw>vwe.;!#,=	#pwzof>!gjpsobz9mlmf8!=??oj=?b#kqfe>!kwws9,,ttt-#wzsf>$wf{w,ibubp`qjsw$=<X<Y=c=n<Y<W=`<Q<R=m=n<T=m<R<R=n<^<Y=n=m=n<^<T<T<S=l<R<T<[<^<R<X=m=n<^<\\<]<Y<[<R<S<\\=m<Q<R=m=n<T\fHF\fIm\fHT\fIa\fHH\fHS\fHy\fHR\fHy\fHR\fHn\fH{\fIa\fH\\\fIk\fHT\fHe\fHD\fIa\fHU\fIg\fHn\fHD\fIk\fHY\fHS\fHK\fHR\fHD\fHT\fHA\fHR\fHG\fHS\fHy\fIa\fHT\fHS\fHn\fH{\fHT\fIm\fH\\\fHy\fIa\fH[\fHS\fHH\fHy\fIe\fHF\fIl\fH\\\fHR\fHk\fHs\fHY\fHS\fHp\fIa\fHr\fHR\fHF\fHD\fHy\fHR\fH\\\fIa\fH\\\fHY\fHR\fHd\fHT\fHy\fIa\fH\\\fHS\fHC\fHH\fHR', "۷%ƌ'T%'W%×%O%g%¦&Ɠ%ǥ&>&*&'&^&Ÿా&ƭ&ƒ&)&^&%&'&&P&1&±&3&]&m&u&E&t&C&Ï&V&V&/&>&6&ྲྀ᝼o&p&@&E&M&P&x&@&F&e&Ì&7&:&(&D&0&C&)&.&F&-&1&(&L&F&1ɞ*Ϫ⇳&፲&K&;&)&E&H&P&0&?&9&V&&-&v&a&,&E&)&?&=&'&'&B&മ&ԃ&̖*&*8&%&%&&&%,)&&>&&7&]&F&2&>&J&6&n&2&%&?&&2&6&J&g&-&0&,&*&J&*&O&)&6&(&<&B&N&.&P&@&2&.&W&M&%Լ(,(<&,&Ϛ&ᣇ&-&,(%&(&%&(Ļ0&X&D&&j&'&J&(&.&B&3&Z&R&h&3&E&E&<Æ-͠ỳ&%8?&@&,&Z&@&0&J&,&^&x&_&6&C&6&Cܬ⨥&f&-&-&-&-&,&J&2&8&z&8&C&Y&8&-&d&ṸÌ-&7&1&F&7&t&W&7&I&.&.&^&=ྜ᧓&8(>&/&/&ݻ')'ၥ')'%@/&0&%оী*&*@&CԽהɴ׫4෗ܚӑ6඄&/Ÿ̃Z&*%ɆϿ&Ĵ&1¨ҴŴ", dictionarySizeBits, "AAAAKKLLKKKKKJJIHHIHHGGFF");
    flipBuffer(dictionaryData);
    setData(asReadOnlyBuffer(dictionaryData), dictionarySizeBits);
  }
  function min3(a3, b3) {
    return a3 <= b3 ? a3 : b3;
  }
  function copyBytes(dst, target, src, start, end) {
    dst.set(src.slice(start, end), target);
  }
  function readInput(src, dst, offset, length5) {
    if (src == null)
      return -1;
    let end = min3(src.offset + length5, src.data.length);
    let bytesRead = end - src.offset;
    dst.set(src.data.subarray(src.offset, end), offset);
    src.offset += bytesRead;
    return bytesRead;
  }
  function closeInput(src) {
    return 0;
  }
  function asReadOnlyBuffer(src) {
    return src;
  }
  function isReadOnly(src) {
    return 1;
  }
  function isDirect(src) {
    return 1;
  }
  function flipBuffer(buffer) {
  }
  function toUsAsciiBytes(src) {
    let n = src.length;
    let result = new Int8Array(n);
    for (let i = 0; i < n; ++i) {
      result[i] = src.charCodeAt(i);
    }
    return result;
  }
  function decode12(bytes, options) {
    let s = new State();
    initState(s, new InputStream(bytes));
    if (options) {
      let customDictionary = (
        /** @type {?Int8Array} */
        options["customDictionary"]
      );
      if (customDictionary)
        attachDictionaryChunk(s, customDictionary);
    }
    let totalOutput = 0;
    let chunks = [];
    while (true) {
      let chunk = new Int8Array(16384);
      chunks.push(chunk);
      s.output = chunk;
      s.outputOffset = 0;
      s.outputLength = 16384;
      s.outputUsed = 0;
      decompress(s);
      totalOutput += s.outputUsed;
      if (s.outputUsed < 16384)
        break;
    }
    close(s);
    let result = new Int8Array(totalOutput);
    let offset = 0;
    for (let i = 0; i < chunks.length; ++i) {
      let chunk = chunks[i];
      let end = min3(totalOutput, offset + 16384);
      let len4 = end - offset;
      if (len4 < 16384) {
        result.set(chunk.subarray(0, len4), offset);
      } else {
        result.set(chunk, offset);
      }
      offset += len4;
    }
    return result;
  }
  return decode12;
};
var BrotliDecode = makeBrotliDecode();

// node_modules/@loaders.gl/compression/dist/lib/brotli-compression.js
var import_zlib2 = __toESM(require_zlib(), 1);

// node_modules/@loaders.gl/compression/dist/lib/snappy-compression.js
var import_snappyjs = __toESM(require_snappyjs(), 1);

// node_modules/@deck.gl/geo-layers/dist/tile-3d-layer/tile-3d-layer.js
var SINGLE_DATA = [0];
var defaultProps14 = {
  getPointColor: { type: "accessor", value: [0, 0, 0, 255] },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: Tiles3DLoader,
  onTilesetLoad: { type: "function", value: (tileset3d) => {
  } },
  onTileLoad: { type: "function", value: (tileHeader) => {
  } },
  onTileUnload: { type: "function", value: (tileHeader) => {
  } },
  onTileError: { type: "function", value: (tile, message, url) => {
  } },
  _getMeshColor: { type: "function", value: (tileHeader) => [255, 255, 255] }
};
var Tile3DLayer = class extends composite_layer_default {
  initializeState() {
    if ("onTileLoadFail" in this.props) {
      log_default.removed("onTileLoadFail", "onTileError")();
    }
    this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    var _a, _b;
    return Boolean(((_b = (_a = this.state) == null ? void 0 : _a.tileset3d) == null ? void 0 : _b.isLoaded()) && super.isLoaded);
  }
  shouldUpdateState({ changeFlags }) {
    return changeFlags.somethingChanged;
  }
  updateState({ props, oldProps, changeFlags }) {
    if (props.data && props.data !== oldProps.data) {
      this._loadTileset(props.data);
    }
    if (changeFlags.viewportChanged) {
      const { activeViewports } = this.state;
      const viewportsNumber = Object.keys(activeViewports).length;
      if (viewportsNumber) {
        this._updateTileset(activeViewports);
        this.state.lastUpdatedViewports = activeViewports;
        this.state.activeViewports = {};
      }
    }
    if (changeFlags.propsChanged) {
      const { layerMap } = this.state;
      for (const key in layerMap) {
        layerMap[key].needsUpdate = true;
      }
    }
  }
  activateViewport(viewport) {
    const { activeViewports, lastUpdatedViewports } = this.state;
    this.internalState.viewport = viewport;
    activeViewports[viewport.id] = viewport;
    const lastViewport = lastUpdatedViewports == null ? void 0 : lastUpdatedViewports[viewport.id];
    if (!lastViewport || !viewport.equals(lastViewport)) {
      this.setChangeFlags({ viewportChanged: true });
      this.setNeedsUpdate();
    }
  }
  getPickingInfo({ info, sourceLayer }) {
    const sourceTile = sourceLayer && sourceLayer.props.tile;
    if (info.picked) {
      info.object = sourceTile;
    }
    info.sourceTile = sourceTile;
    return info;
  }
  filterSubLayer({ layer, viewport }) {
    const { tile } = layer.props;
    const { id: viewportId } = viewport;
    return tile.selected && tile.viewportIds.includes(viewportId);
  }
  _updateAutoHighlight(info) {
    const sourceTile = info.sourceTile;
    const layerCache = this.state.layerMap[sourceTile == null ? void 0 : sourceTile.id];
    if (layerCache && layerCache.layer) {
      layerCache.layer.updateAutoHighlight(info);
    }
  }
  async _loadTileset(tilesetUrl) {
    const { loadOptions = {} } = this.props;
    const loaders = this.props.loader || this.props.loaders;
    const loader = Array.isArray(loaders) ? loaders[0] : loaders;
    const options = { loadOptions: { ...loadOptions } };
    let actualTilesetUrl = tilesetUrl;
    if (loader.preload) {
      const preloadOptions = await loader.preload(tilesetUrl, loadOptions);
      if (preloadOptions.url) {
        actualTilesetUrl = preloadOptions.url;
      }
      if (preloadOptions.headers) {
        options.loadOptions.fetch = {
          ...options.loadOptions.fetch,
          headers: preloadOptions.headers
        };
      }
      Object.assign(options, preloadOptions);
    }
    const tilesetJson = await load(actualTilesetUrl, loader, options.loadOptions);
    const tileset3d = new Tileset3D(tilesetJson, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...options
    });
    this.setState({
      tileset3d,
      layerMap: {}
    });
    this._updateTileset(this.state.activeViewports);
    this.props.onTilesetLoad(tileset3d);
  }
  _onTileLoad(tileHeader) {
    const { lastUpdatedViewports } = this.state;
    this.props.onTileLoad(tileHeader);
    this._updateTileset(lastUpdatedViewports);
    this.setNeedsUpdate();
  }
  _onTileUnload(tileHeader) {
    delete this.state.layerMap[tileHeader.id];
    this.props.onTileUnload(tileHeader);
  }
  _updateTileset(viewports) {
    if (!viewports) {
      return;
    }
    const { tileset3d } = this.state;
    const { timeline } = this.context;
    const viewportsNumber = Object.keys(viewports).length;
    if (!timeline || !viewportsNumber || !tileset3d) {
      return;
    }
    tileset3d.selectTiles(Object.values(viewports)).then((frameNumber) => {
      const tilesetChanged = this.state.frameNumber !== frameNumber;
      if (tilesetChanged) {
        this.setState({ frameNumber });
      }
    });
  }
  _getSubLayer(tileHeader, oldLayer) {
    if (!tileHeader.content) {
      return null;
    }
    switch (tileHeader.type) {
      case TILE_TYPE.POINTCLOUD:
        return this._makePointCloudLayer(tileHeader, oldLayer);
      case TILE_TYPE.SCENEGRAPH:
        return this._make3DModelLayer(tileHeader);
      case TILE_TYPE.MESH:
        return this._makeSimpleMeshLayer(tileHeader, oldLayer);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${tileHeader.content.type}`);
    }
  }
  _makePointCloudLayer(tileHeader, oldLayer) {
    const { attributes, pointCount, constantRGBA, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
    const { positions, normals, colors } = attributes;
    if (!positions) {
      return null;
    }
    const data = oldLayer && oldLayer.props.data || {
      header: {
        vertexCount: pointCount
      },
      attributes: {
        POSITION: positions,
        NORMAL: normals,
        COLOR_0: colors
      }
    };
    const { pointSize, getPointColor } = this.props;
    const SubLayerClass = this.getSubLayerClass("pointcloud", point_cloud_layer_default);
    return new SubLayerClass({
      pointSize
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${tileHeader.id}`,
      tile: tileHeader,
      data,
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix: modelMatrix2,
      getColor: constantRGBA || getPointColor,
      _offset: 0
    });
  }
  _make3DModelLayer(tileHeader) {
    const { gltf, instances, cartographicOrigin, modelMatrix: modelMatrix2 } = tileHeader.content;
    const SubLayerClass = this.getSubLayerClass("scenegraph", scenegraph_layer_default);
    return new SubLayerClass({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${tileHeader.id}`,
      tile: tileHeader,
      data: instances || SINGLE_DATA,
      scenegraph: gltf,
      coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
      coordinateOrigin: cartographicOrigin,
      modelMatrix: modelMatrix2,
      getTransformMatrix: (instance) => instance.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(tileHeader, oldLayer) {
    const content = tileHeader.content;
    const { attributes, indices, modelMatrix: modelMatrix2, cartographicOrigin, coordinateSystem = COORDINATE_SYSTEM.METER_OFFSETS, material, featureIds } = content;
    const { _getMeshColor } = this.props;
    const geometry = oldLayer && oldLayer.props.mesh || new Geometry({
      topology: "triangle-list",
      attributes: getMeshGeometry(attributes),
      indices
    });
    const SubLayerClass = this.getSubLayerClass("mesh", mesh_layer_default);
    return new SubLayerClass(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${tileHeader.id}`,
      tile: tileHeader,
      mesh: geometry,
      data: SINGLE_DATA,
      getColor: _getMeshColor(tileHeader),
      pbrMaterial: material,
      modelMatrix: modelMatrix2,
      coordinateOrigin: cartographicOrigin,
      coordinateSystem,
      featureIds,
      _offset: 0
    });
  }
  renderLayers() {
    const { tileset3d, layerMap } = this.state;
    if (!tileset3d) {
      return null;
    }
    return tileset3d.tiles.map((tile) => {
      const layerCache = layerMap[tile.id] = layerMap[tile.id] || { tile };
      let { layer } = layerCache;
      if (tile.selected) {
        if (!layer) {
          layer = this._getSubLayer(tile);
        } else if (layerCache.needsUpdate) {
          layer = this._getSubLayer(tile, layer);
          layerCache.needsUpdate = false;
        }
      }
      layerCache.layer = layer;
      return layer;
    }).filter(Boolean);
  }
};
Tile3DLayer.defaultProps = defaultProps14;
Tile3DLayer.layerName = "Tile3DLayer";
var tile_3d_layer_default = Tile3DLayer;
function getMeshGeometry(contentAttributes) {
  const attributes = {};
  attributes.positions = {
    ...contentAttributes.positions,
    value: new Float32Array(contentAttributes.positions.value)
  };
  if (contentAttributes.normals) {
    attributes.normals = contentAttributes.normals;
  }
  if (contentAttributes.texCoords) {
    attributes.texCoords = contentAttributes.texCoords;
  }
  if (contentAttributes.colors) {
    attributes.colors = contentAttributes.colors;
  }
  if (contentAttributes.uvRegions) {
    attributes.uvRegions = contentAttributes.uvRegions;
  }
  return attributes;
}

// node_modules/@loaders.gl/terrain/dist/lib/decode-quantized-mesh.js
var QUANTIZED_MESH_HEADER = /* @__PURE__ */ new Map([
  ["centerX", Float64Array.BYTES_PER_ELEMENT],
  ["centerY", Float64Array.BYTES_PER_ELEMENT],
  ["centerZ", Float64Array.BYTES_PER_ELEMENT],
  ["minHeight", Float32Array.BYTES_PER_ELEMENT],
  ["maxHeight", Float32Array.BYTES_PER_ELEMENT],
  ["boundingSphereCenterX", Float64Array.BYTES_PER_ELEMENT],
  ["boundingSphereCenterY", Float64Array.BYTES_PER_ELEMENT],
  ["boundingSphereCenterZ", Float64Array.BYTES_PER_ELEMENT],
  ["boundingSphereRadius", Float64Array.BYTES_PER_ELEMENT],
  ["horizonOcclusionPointX", Float64Array.BYTES_PER_ELEMENT],
  ["horizonOcclusionPointY", Float64Array.BYTES_PER_ELEMENT],
  ["horizonOcclusionPointZ", Float64Array.BYTES_PER_ELEMENT]
]);
function decodeZigZag(value) {
  return value >> 1 ^ -(value & 1);
}
function decodeHeader(dataView) {
  let position = 0;
  const header = {};
  for (const [key, bytesCount] of QUANTIZED_MESH_HEADER) {
    const getter = bytesCount === 8 ? dataView.getFloat64 : dataView.getFloat32;
    header[key] = getter.call(dataView, position, true);
    position += bytesCount;
  }
  return { header, headerEndPosition: position };
}
function decodeVertexData(dataView, headerEndPosition) {
  let position = headerEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = dataView.getUint32(position, true);
  const vertexData = new Uint16Array(vertexCount * elementsPerVertex);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const bytesPerArrayElement = Uint16Array.BYTES_PER_ELEMENT;
  const elementArrayLength = vertexCount * bytesPerArrayElement;
  const uArrayStartPosition = position;
  const vArrayStartPosition = uArrayStartPosition + elementArrayLength;
  const heightArrayStartPosition = vArrayStartPosition + elementArrayLength;
  let u2 = 0;
  let v2 = 0;
  let height = 0;
  for (let i = 0; i < vertexCount; i++) {
    u2 += decodeZigZag(dataView.getUint16(uArrayStartPosition + bytesPerArrayElement * i, true));
    v2 += decodeZigZag(dataView.getUint16(vArrayStartPosition + bytesPerArrayElement * i, true));
    height += decodeZigZag(dataView.getUint16(heightArrayStartPosition + bytesPerArrayElement * i, true));
    vertexData[i] = u2;
    vertexData[i + vertexCount] = v2;
    vertexData[i + vertexCount * 2] = height;
  }
  position += elementArrayLength * 3;
  return { vertexData, vertexDataEndPosition: position };
}
function decodeIndex(buffer, position, indicesCount, bytesPerIndex, encoded = true) {
  let indices;
  if (bytesPerIndex === 2) {
    indices = new Uint16Array(buffer, position, indicesCount);
  } else {
    indices = new Uint32Array(buffer, position, indicesCount);
  }
  if (!encoded) {
    return indices;
  }
  let highest = 0;
  for (let i = 0; i < indices.length; ++i) {
    const code = indices[i];
    indices[i] = highest - code;
    if (code === 0) {
      ++highest;
    }
  }
  return indices;
}
function decodeTriangleIndices(dataView, vertexData, vertexDataEndPosition) {
  let position = vertexDataEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  if (position % bytesPerIndex !== 0) {
    position += bytesPerIndex - position % bytesPerIndex;
  }
  const triangleCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const triangleIndicesCount = triangleCount * 3;
  const triangleIndices = decodeIndex(dataView.buffer, position, triangleIndicesCount, bytesPerIndex);
  position += triangleIndicesCount * bytesPerIndex;
  return {
    triangleIndicesEndPosition: position,
    triangleIndices
  };
}
function decodeEdgeIndices(dataView, vertexData, triangleIndicesEndPosition) {
  let position = triangleIndicesEndPosition;
  const elementsPerVertex = 3;
  const vertexCount = vertexData.length / elementsPerVertex;
  const bytesPerIndex = vertexCount > 65536 ? Uint32Array.BYTES_PER_ELEMENT : Uint16Array.BYTES_PER_ELEMENT;
  const westVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const westIndices = decodeIndex(dataView.buffer, position, westVertexCount, bytesPerIndex, false);
  position += westVertexCount * bytesPerIndex;
  const southVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const southIndices = decodeIndex(dataView.buffer, position, southVertexCount, bytesPerIndex, false);
  position += southVertexCount * bytesPerIndex;
  const eastVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const eastIndices = decodeIndex(dataView.buffer, position, eastVertexCount, bytesPerIndex, false);
  position += eastVertexCount * bytesPerIndex;
  const northVertexCount = dataView.getUint32(position, true);
  position += Uint32Array.BYTES_PER_ELEMENT;
  const northIndices = decodeIndex(dataView.buffer, position, northVertexCount, bytesPerIndex, false);
  position += northVertexCount * bytesPerIndex;
  return {
    edgeIndicesEndPosition: position,
    westIndices,
    southIndices,
    eastIndices,
    northIndices
  };
}
function decodeVertexNormalsExtension(extensionDataView) {
  return new Uint8Array(extensionDataView.buffer, extensionDataView.byteOffset, extensionDataView.byteLength);
}
function decodeWaterMaskExtension(extensionDataView) {
  return extensionDataView.buffer.slice(extensionDataView.byteOffset, extensionDataView.byteOffset + extensionDataView.byteLength);
}
function decodeExtensions2(dataView, indicesEndPosition) {
  const extensions = {};
  if (dataView.byteLength <= indicesEndPosition) {
    return { extensions, extensionsEndPosition: indicesEndPosition };
  }
  let position = indicesEndPosition;
  while (position < dataView.byteLength) {
    const extensionId = dataView.getUint8(position, true);
    position += Uint8Array.BYTES_PER_ELEMENT;
    const extensionLength = dataView.getUint32(position, true);
    position += Uint32Array.BYTES_PER_ELEMENT;
    const extensionView = new DataView(dataView.buffer, position, extensionLength);
    switch (extensionId) {
      case 1: {
        extensions.vertexNormals = decodeVertexNormalsExtension(extensionView);
        break;
      }
      case 2: {
        extensions.waterMask = decodeWaterMaskExtension(extensionView);
        break;
      }
      default: {
      }
    }
    position += extensionLength;
  }
  return { extensions, extensionsEndPosition: position };
}
var DECODING_STEPS = {
  header: 0,
  vertices: 1,
  triangleIndices: 2,
  edgeIndices: 3,
  extensions: 4
};
var DEFAULT_OPTIONS = {
  maxDecodingStep: DECODING_STEPS.extensions
};
function decode11(data, userOptions) {
  const options = Object.assign({}, DEFAULT_OPTIONS, userOptions);
  const view = new DataView(data);
  const { header, headerEndPosition } = decodeHeader(view);
  if (options.maxDecodingStep < DECODING_STEPS.vertices) {
    return { header };
  }
  const { vertexData, vertexDataEndPosition } = decodeVertexData(view, headerEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.triangleIndices) {
    return { header, vertexData };
  }
  const { triangleIndices, triangleIndicesEndPosition } = decodeTriangleIndices(view, vertexData, vertexDataEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.edgeIndices) {
    return { header, vertexData, triangleIndices };
  }
  const { westIndices, southIndices, eastIndices, northIndices, edgeIndicesEndPosition } = decodeEdgeIndices(view, vertexData, triangleIndicesEndPosition);
  if (options.maxDecodingStep < DECODING_STEPS.extensions) {
    return {
      header,
      vertexData,
      triangleIndices,
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    };
  }
  const { extensions } = decodeExtensions2(view, edgeIndicesEndPosition);
  return {
    header,
    vertexData,
    triangleIndices,
    westIndices,
    northIndices,
    eastIndices,
    southIndices,
    extensions
  };
}

// node_modules/@loaders.gl/terrain/dist/lib/helpers/skirt.js
function addSkirt(attributes, triangles, skirtHeight, outsideIndices) {
  const outsideEdges = outsideIndices ? getOutsideEdgesFromIndices(outsideIndices, attributes.POSITION.value) : getOutsideEdgesFromTriangles(triangles);
  const newPosition = new attributes.POSITION.value.constructor(outsideEdges.length * 6);
  const newTexcoord0 = new attributes.TEXCOORD_0.value.constructor(outsideEdges.length * 4);
  const newTriangles = new triangles.constructor(outsideEdges.length * 6);
  for (let i = 0; i < outsideEdges.length; i++) {
    const edge = outsideEdges[i];
    updateAttributesForNewEdge({
      edge,
      edgeIndex: i,
      attributes,
      skirtHeight,
      newPosition,
      newTexcoord0,
      newTriangles
    });
  }
  attributes.POSITION.value = concatenateTypedArrays(attributes.POSITION.value, newPosition);
  attributes.TEXCOORD_0.value = concatenateTypedArrays(attributes.TEXCOORD_0.value, newTexcoord0);
  const resultTriangles = triangles instanceof Array ? triangles.concat(newTriangles) : concatenateTypedArrays(triangles, newTriangles);
  return {
    attributes,
    triangles: resultTriangles
  };
}
function getOutsideEdgesFromTriangles(triangles) {
  var _a, _b;
  const edges = [];
  for (let i = 0; i < triangles.length; i += 3) {
    edges.push([triangles[i], triangles[i + 1]]);
    edges.push([triangles[i + 1], triangles[i + 2]]);
    edges.push([triangles[i + 2], triangles[i]]);
  }
  edges.sort((a3, b3) => Math.min(...a3) - Math.min(...b3) || Math.max(...a3) - Math.max(...b3));
  const outsideEdges = [];
  let index = 0;
  while (index < edges.length) {
    if (edges[index][0] === ((_a = edges[index + 1]) == null ? void 0 : _a[1]) && edges[index][1] === ((_b = edges[index + 1]) == null ? void 0 : _b[0])) {
      index += 2;
    } else {
      outsideEdges.push(edges[index]);
      index++;
    }
  }
  return outsideEdges;
}
function getOutsideEdgesFromIndices(indices, position) {
  indices.westIndices.sort((a3, b3) => position[3 * a3 + 1] - position[3 * b3 + 1]);
  indices.eastIndices.sort((a3, b3) => position[3 * b3 + 1] - position[3 * a3 + 1]);
  indices.southIndices.sort((a3, b3) => position[3 * b3] - position[3 * a3]);
  indices.northIndices.sort((a3, b3) => position[3 * a3] - position[3 * b3]);
  const edges = [];
  for (const index in indices) {
    const indexGroup = indices[index];
    for (let i = 0; i < indexGroup.length - 1; i++) {
      edges.push([indexGroup[i], indexGroup[i + 1]]);
    }
  }
  return edges;
}
function updateAttributesForNewEdge({ edge, edgeIndex, attributes, skirtHeight, newPosition, newTexcoord0, newTriangles }) {
  const positionsLength = attributes.POSITION.value.length;
  const vertex1Offset = edgeIndex * 2;
  const vertex2Offset = edgeIndex * 2 + 1;
  newPosition.set(attributes.POSITION.value.subarray(edge[0] * 3, edge[0] * 3 + 3), vertex1Offset * 3);
  newPosition[vertex1Offset * 3 + 2] = newPosition[vertex1Offset * 3 + 2] - skirtHeight;
  newPosition.set(attributes.POSITION.value.subarray(edge[1] * 3, edge[1] * 3 + 3), vertex2Offset * 3);
  newPosition[vertex2Offset * 3 + 2] = newPosition[vertex2Offset * 3 + 2] - skirtHeight;
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[0] * 2, edge[0] * 2 + 2), vertex1Offset * 2);
  newTexcoord0.set(attributes.TEXCOORD_0.value.subarray(edge[1] * 2, edge[1] * 2 + 2), vertex2Offset * 2);
  const triangle1Offset = edgeIndex * 2 * 3;
  newTriangles[triangle1Offset] = edge[0];
  newTriangles[triangle1Offset + 1] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 2] = edge[1];
  newTriangles[triangle1Offset + 3] = positionsLength / 3 + vertex2Offset;
  newTriangles[triangle1Offset + 4] = edge[0];
  newTriangles[triangle1Offset + 5] = positionsLength / 3 + vertex1Offset;
}

// node_modules/@loaders.gl/terrain/dist/lib/parse-quantized-mesh.js
function parseQuantizedMesh(arrayBuffer, options = {}) {
  const { bounds } = options;
  const { header, vertexData, triangleIndices: originalTriangleIndices, westIndices, northIndices, eastIndices, southIndices } = decode11(arrayBuffer, DECODING_STEPS.triangleIndices);
  let triangleIndices = originalTriangleIndices;
  let attributes = getMeshAttributes(vertexData, header, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (options == null ? void 0 : options.skirtHeight) {
    const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangleIndices, options.skirtHeight, {
      westIndices,
      northIndices,
      eastIndices,
      southIndices
    });
    attributes = newAttributes;
    triangleIndices = newTriangles;
  }
  return {
    // Data return by this loader implementation
    loaderData: {
      header: {}
    },
    header: {
      // @ts-ignore
      vertexCount: triangleIndices.length,
      boundingBox
    },
    // TODO
    schema: void 0,
    topology: "triangle-list",
    mode: 4,
    // TRIANGLES
    indices: { value: triangleIndices, size: 1 },
    attributes
  };
}
function getMeshAttributes(vertexData, header, bounds) {
  const { minHeight, maxHeight } = header;
  const [minX, minY, maxX, maxY] = bounds || [0, 0, 1, 1];
  const xScale = maxX - minX;
  const yScale = maxY - minY;
  const zScale = maxHeight - minHeight;
  const nCoords = vertexData.length / 3;
  const positions = new Float32Array(nCoords * 3);
  const texCoords = new Float32Array(nCoords * 2);
  for (let i = 0; i < nCoords; i++) {
    const x = vertexData[i] / 32767;
    const y = vertexData[i + nCoords] / 32767;
    const z = vertexData[i + nCoords * 2] / 32767;
    positions[3 * i + 0] = x * xScale + minX;
    positions[3 * i + 1] = y * yScale + minY;
    positions[3 * i + 2] = z * zScale + minHeight;
    texCoords[2 * i + 0] = x;
    texCoords[2 * i + 1] = y;
  }
  return {
    POSITION: { value: positions, size: 3 },
    TEXCOORD_0: { value: texCoords, size: 2 }
    // TODO: Parse normals if they exist in the file
    // NORMAL: {}, - optional, but creates the high poly look with lighting
  };
}

// node_modules/@mapbox/martini/index.js
var Martini = class {
  constructor(gridSize = 257) {
    this.gridSize = gridSize;
    const tileSize = gridSize - 1;
    if (tileSize & tileSize - 1) throw new Error(
      `Expected grid size to be 2^n+1, got ${gridSize}.`
    );
    this.numTriangles = tileSize * tileSize * 2 - 2;
    this.numParentTriangles = this.numTriangles - tileSize * tileSize;
    this.indices = new Uint32Array(this.gridSize * this.gridSize);
    this.coords = new Uint16Array(this.numTriangles * 4);
    for (let i = 0; i < this.numTriangles; i++) {
      let id = i + 2;
      let ax = 0, ay = 0, bx = 0, by = 0, cx = 0, cy = 0;
      if (id & 1) {
        bx = by = cx = tileSize;
      } else {
        ax = ay = cy = tileSize;
      }
      while ((id >>= 1) > 1) {
        const mx = ax + bx >> 1;
        const my = ay + by >> 1;
        if (id & 1) {
          bx = ax;
          by = ay;
          ax = cx;
          ay = cy;
        } else {
          ax = bx;
          ay = by;
          bx = cx;
          by = cy;
        }
        cx = mx;
        cy = my;
      }
      const k = i * 4;
      this.coords[k + 0] = ax;
      this.coords[k + 1] = ay;
      this.coords[k + 2] = bx;
      this.coords[k + 3] = by;
    }
  }
  createTile(terrain) {
    return new Tile(terrain, this);
  }
};
var Tile = class {
  constructor(terrain, martini) {
    const size = martini.gridSize;
    if (terrain.length !== size * size) throw new Error(
      `Expected terrain data of length ${size * size} (${size} x ${size}), got ${terrain.length}.`
    );
    this.terrain = terrain;
    this.martini = martini;
    this.errors = new Float32Array(terrain.length);
    this.update();
  }
  update() {
    const { numTriangles, numParentTriangles, coords, gridSize: size } = this.martini;
    const { terrain, errors } = this;
    for (let i = numTriangles - 1; i >= 0; i--) {
      const k = i * 4;
      const ax = coords[k + 0];
      const ay = coords[k + 1];
      const bx = coords[k + 2];
      const by = coords[k + 3];
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      const cx = mx + my - ay;
      const cy = my + ax - mx;
      const interpolatedHeight = (terrain[ay * size + ax] + terrain[by * size + bx]) / 2;
      const middleIndex = my * size + mx;
      const middleError = Math.abs(interpolatedHeight - terrain[middleIndex]);
      errors[middleIndex] = Math.max(errors[middleIndex], middleError);
      if (i < numParentTriangles) {
        const leftChildIndex = (ay + cy >> 1) * size + (ax + cx >> 1);
        const rightChildIndex = (by + cy >> 1) * size + (bx + cx >> 1);
        errors[middleIndex] = Math.max(errors[middleIndex], errors[leftChildIndex], errors[rightChildIndex]);
      }
    }
  }
  getMesh(maxError = 0) {
    const { gridSize: size, indices } = this.martini;
    const { errors } = this;
    let numVertices = 0;
    let numTriangles = 0;
    const max3 = size - 1;
    indices.fill(0);
    function countElements(ax, ay, bx, by, cx, cy) {
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
        countElements(cx, cy, ax, ay, mx, my);
        countElements(bx, by, cx, cy, mx, my);
      } else {
        indices[ay * size + ax] = indices[ay * size + ax] || ++numVertices;
        indices[by * size + bx] = indices[by * size + bx] || ++numVertices;
        indices[cy * size + cx] = indices[cy * size + cx] || ++numVertices;
        numTriangles++;
      }
    }
    countElements(0, 0, max3, max3, max3, 0);
    countElements(max3, max3, 0, 0, 0, max3);
    const vertices = new Uint16Array(numVertices * 2);
    const triangles = new Uint32Array(numTriangles * 3);
    let triIndex = 0;
    function processTriangle(ax, ay, bx, by, cx, cy) {
      const mx = ax + bx >> 1;
      const my = ay + by >> 1;
      if (Math.abs(ax - cx) + Math.abs(ay - cy) > 1 && errors[my * size + mx] > maxError) {
        processTriangle(cx, cy, ax, ay, mx, my);
        processTriangle(bx, by, cx, cy, mx, my);
      } else {
        const a3 = indices[ay * size + ax] - 1;
        const b3 = indices[by * size + bx] - 1;
        const c2 = indices[cy * size + cx] - 1;
        vertices[2 * a3] = ax;
        vertices[2 * a3 + 1] = ay;
        vertices[2 * b3] = bx;
        vertices[2 * b3 + 1] = by;
        vertices[2 * c2] = cx;
        vertices[2 * c2 + 1] = cy;
        triangles[triIndex++] = a3;
        triangles[triIndex++] = b3;
        triangles[triIndex++] = c2;
      }
    }
    processTriangle(0, 0, max3, max3, max3, 0);
    processTriangle(max3, max3, 0, 0, 0, max3);
    return { vertices, triangles };
  }
};

// node_modules/@loaders.gl/terrain/dist/lib/delatin/index.js
var Delatin = class {
  constructor(data, width, height = width) {
    this.data = data;
    this.width = width;
    this.height = height;
    this.coords = [];
    this.triangles = [];
    this._halfedges = [];
    this._candidates = [];
    this._queueIndices = [];
    this._queue = [];
    this._errors = [];
    this._rms = [];
    this._pending = [];
    this._pendingLen = 0;
    this._rmsSum = 0;
    const x1 = width - 1;
    const y1 = height - 1;
    const p0 = this._addPoint(0, 0);
    const p1 = this._addPoint(x1, 0);
    const p2 = this._addPoint(0, y1);
    const p3 = this._addPoint(x1, y1);
    const t0 = this._addTriangle(p3, p0, p2, -1, -1, -1);
    this._addTriangle(p0, p3, p1, t0, -1, -1);
    this._flush();
  }
  // refine the mesh until its maximum error gets below the given one
  run(maxError = 1) {
    while (this.getMaxError() > maxError) {
      this.refine();
    }
  }
  // refine the mesh with a single point
  refine() {
    this._step();
    this._flush();
  }
  // max error of the current mesh
  getMaxError() {
    return this._errors[0];
  }
  // root-mean-square deviation of the current mesh
  getRMSD() {
    return this._rmsSum > 0 ? Math.sqrt(this._rmsSum / (this.width * this.height)) : 0;
  }
  // height value at a given position
  heightAt(x, y) {
    return this.data[this.width * y + x];
  }
  // rasterize and queue all triangles that got added or updated in _step
  _flush() {
    const coords = this.coords;
    for (let i = 0; i < this._pendingLen; i++) {
      const t = this._pending[i];
      const a3 = 2 * this.triangles[t * 3 + 0];
      const b3 = 2 * this.triangles[t * 3 + 1];
      const c2 = 2 * this.triangles[t * 3 + 2];
      this._findCandidate(coords[a3], coords[a3 + 1], coords[b3], coords[b3 + 1], coords[c2], coords[c2 + 1], t);
    }
    this._pendingLen = 0;
  }
  // rasterize a triangle, find its max error, and queue it for processing
  _findCandidate(p0x, p0y, p1x, p1y, p2x, p2y, t) {
    const minX = Math.min(p0x, p1x, p2x);
    const minY = Math.min(p0y, p1y, p2y);
    const maxX = Math.max(p0x, p1x, p2x);
    const maxY = Math.max(p0y, p1y, p2y);
    let w00 = orient(p1x, p1y, p2x, p2y, minX, minY);
    let w01 = orient(p2x, p2y, p0x, p0y, minX, minY);
    let w02 = orient(p0x, p0y, p1x, p1y, minX, minY);
    const a01 = p1y - p0y;
    const b01 = p0x - p1x;
    const a12 = p2y - p1y;
    const b12 = p1x - p2x;
    const a20 = p0y - p2y;
    const b20 = p2x - p0x;
    const a3 = orient(p0x, p0y, p1x, p1y, p2x, p2y);
    const z0 = this.heightAt(p0x, p0y) / a3;
    const z1 = this.heightAt(p1x, p1y) / a3;
    const z2 = this.heightAt(p2x, p2y) / a3;
    let maxError = 0;
    let mx = 0;
    let my = 0;
    let rms = 0;
    for (let y = minY; y <= maxY; y++) {
      let dx = 0;
      if (w00 < 0 && a12 !== 0) {
        dx = Math.max(dx, Math.floor(-w00 / a12));
      }
      if (w01 < 0 && a20 !== 0) {
        dx = Math.max(dx, Math.floor(-w01 / a20));
      }
      if (w02 < 0 && a01 !== 0) {
        dx = Math.max(dx, Math.floor(-w02 / a01));
      }
      let w0 = w00 + a12 * dx;
      let w1 = w01 + a20 * dx;
      let w2 = w02 + a01 * dx;
      let wasInside = false;
      for (let x = minX + dx; x <= maxX; x++) {
        if (w0 >= 0 && w1 >= 0 && w2 >= 0) {
          wasInside = true;
          const z = z0 * w0 + z1 * w1 + z2 * w2;
          const dz = Math.abs(z - this.heightAt(x, y));
          rms += dz * dz;
          if (dz > maxError) {
            maxError = dz;
            mx = x;
            my = y;
          }
        } else if (wasInside) {
          break;
        }
        w0 += a12;
        w1 += a20;
        w2 += a01;
      }
      w00 += b12;
      w01 += b20;
      w02 += b01;
    }
    if (mx === p0x && my === p0y || mx === p1x && my === p1y || mx === p2x && my === p2y) {
      maxError = 0;
    }
    this._candidates[2 * t] = mx;
    this._candidates[2 * t + 1] = my;
    this._rms[t] = rms;
    this._queuePush(t, maxError, rms);
  }
  // process the next triangle in the queue, splitting it with a new point
  _step() {
    const t = this._queuePop();
    const e0 = t * 3 + 0;
    const e1 = t * 3 + 1;
    const e2 = t * 3 + 2;
    const p0 = this.triangles[e0];
    const p1 = this.triangles[e1];
    const p2 = this.triangles[e2];
    const ax = this.coords[2 * p0];
    const ay = this.coords[2 * p0 + 1];
    const bx = this.coords[2 * p1];
    const by = this.coords[2 * p1 + 1];
    const cx = this.coords[2 * p2];
    const cy = this.coords[2 * p2 + 1];
    const px = this._candidates[2 * t];
    const py = this._candidates[2 * t + 1];
    const pn = this._addPoint(px, py);
    if (orient(ax, ay, bx, by, px, py) === 0) {
      this._handleCollinear(pn, e0);
    } else if (orient(bx, by, cx, cy, px, py) === 0) {
      this._handleCollinear(pn, e1);
    } else if (orient(cx, cy, ax, ay, px, py) === 0) {
      this._handleCollinear(pn, e2);
    } else {
      const h0 = this._halfedges[e0];
      const h1 = this._halfedges[e1];
      const h2 = this._halfedges[e2];
      const t0 = this._addTriangle(p0, p1, pn, h0, -1, -1, e0);
      const t1 = this._addTriangle(p1, p2, pn, h1, -1, t0 + 1);
      const t2 = this._addTriangle(p2, p0, pn, h2, t0 + 2, t1 + 1);
      this._legalize(t0);
      this._legalize(t1);
      this._legalize(t2);
    }
  }
  // add coordinates for a new vertex
  _addPoint(x, y) {
    const i = this.coords.length >> 1;
    this.coords.push(x, y);
    return i;
  }
  // add or update a triangle in the mesh
  _addTriangle(a3, b3, c2, ab, bc, ca, e2 = this.triangles.length) {
    const t = e2 / 3;
    this.triangles[e2 + 0] = a3;
    this.triangles[e2 + 1] = b3;
    this.triangles[e2 + 2] = c2;
    this._halfedges[e2 + 0] = ab;
    this._halfedges[e2 + 1] = bc;
    this._halfedges[e2 + 2] = ca;
    if (ab >= 0) {
      this._halfedges[ab] = e2 + 0;
    }
    if (bc >= 0) {
      this._halfedges[bc] = e2 + 1;
    }
    if (ca >= 0) {
      this._halfedges[ca] = e2 + 2;
    }
    this._candidates[2 * t + 0] = 0;
    this._candidates[2 * t + 1] = 0;
    this._queueIndices[t] = -1;
    this._rms[t] = 0;
    this._pending[this._pendingLen++] = t;
    return e2;
  }
  _legalize(a3) {
    const b3 = this._halfedges[a3];
    if (b3 < 0) {
      return;
    }
    const a0 = a3 - a3 % 3;
    const b0 = b3 - b3 % 3;
    const al = a0 + (a3 + 1) % 3;
    const ar = a0 + (a3 + 2) % 3;
    const bl = b0 + (b3 + 2) % 3;
    const br = b0 + (b3 + 1) % 3;
    const p0 = this.triangles[ar];
    const pr = this.triangles[a3];
    const pl = this.triangles[al];
    const p1 = this.triangles[bl];
    const coords = this.coords;
    if (!inCircle(coords[2 * p0], coords[2 * p0 + 1], coords[2 * pr], coords[2 * pr + 1], coords[2 * pl], coords[2 * pl + 1], coords[2 * p1], coords[2 * p1 + 1])) {
      return;
    }
    const hal = this._halfedges[al];
    const har = this._halfedges[ar];
    const hbl = this._halfedges[bl];
    const hbr = this._halfedges[br];
    this._queueRemove(a0 / 3);
    this._queueRemove(b0 / 3);
    const t0 = this._addTriangle(p0, p1, pl, -1, hbl, hal, a0);
    const t1 = this._addTriangle(p1, p0, pr, t0, har, hbr, b0);
    this._legalize(t0 + 1);
    this._legalize(t1 + 2);
  }
  // handle a case where new vertex is on the edge of a triangle
  _handleCollinear(pn, a3) {
    const a0 = a3 - a3 % 3;
    const al = a0 + (a3 + 1) % 3;
    const ar = a0 + (a3 + 2) % 3;
    const p0 = this.triangles[ar];
    const pr = this.triangles[a3];
    const pl = this.triangles[al];
    const hal = this._halfedges[al];
    const har = this._halfedges[ar];
    const b3 = this._halfedges[a3];
    if (b3 < 0) {
      const t02 = this._addTriangle(pn, p0, pr, -1, har, -1, a0);
      const t12 = this._addTriangle(p0, pn, pl, t02, -1, hal);
      this._legalize(t02 + 1);
      this._legalize(t12 + 2);
      return;
    }
    const b0 = b3 - b3 % 3;
    const bl = b0 + (b3 + 2) % 3;
    const br = b0 + (b3 + 1) % 3;
    const p1 = this.triangles[bl];
    const hbl = this._halfedges[bl];
    const hbr = this._halfedges[br];
    this._queueRemove(b0 / 3);
    const t0 = this._addTriangle(p0, pr, pn, har, -1, -1, a0);
    const t1 = this._addTriangle(pr, p1, pn, hbr, -1, t0 + 1, b0);
    const t2 = this._addTriangle(p1, pl, pn, hbl, -1, t1 + 1);
    const t3 = this._addTriangle(pl, p0, pn, hal, t0 + 2, t2 + 1);
    this._legalize(t0);
    this._legalize(t1);
    this._legalize(t2);
    this._legalize(t3);
  }
  // priority queue methods
  _queuePush(t, error, rms) {
    const i = this._queue.length;
    this._queueIndices[t] = i;
    this._queue.push(t);
    this._errors.push(error);
    this._rmsSum += rms;
    this._queueUp(i);
  }
  _queuePop() {
    const n = this._queue.length - 1;
    this._queueSwap(0, n);
    this._queueDown(0, n);
    return this._queuePopBack();
  }
  _queuePopBack() {
    const t = this._queue.pop();
    this._errors.pop();
    this._rmsSum -= this._rms[t];
    this._queueIndices[t] = -1;
    return t;
  }
  _queueRemove(t) {
    const i = this._queueIndices[t];
    if (i < 0) {
      const it = this._pending.indexOf(t);
      if (it !== -1) {
        this._pending[it] = this._pending[--this._pendingLen];
      } else {
        throw new Error("Broken triangulation (something went wrong).");
      }
      return;
    }
    const n = this._queue.length - 1;
    if (n !== i) {
      this._queueSwap(i, n);
      if (!this._queueDown(i, n)) {
        this._queueUp(i);
      }
    }
    this._queuePopBack();
  }
  _queueLess(i, j) {
    return this._errors[i] > this._errors[j];
  }
  _queueSwap(i, j) {
    const pi = this._queue[i];
    const pj = this._queue[j];
    this._queue[i] = pj;
    this._queue[j] = pi;
    this._queueIndices[pi] = j;
    this._queueIndices[pj] = i;
    const e2 = this._errors[i];
    this._errors[i] = this._errors[j];
    this._errors[j] = e2;
  }
  _queueUp(j0) {
    let j = j0;
    while (true) {
      const i = j - 1 >> 1;
      if (i === j || !this._queueLess(j, i)) {
        break;
      }
      this._queueSwap(i, j);
      j = i;
    }
  }
  _queueDown(i0, n) {
    let i = i0;
    while (true) {
      const j1 = 2 * i + 1;
      if (j1 >= n || j1 < 0) {
        break;
      }
      const j2 = j1 + 1;
      let j = j1;
      if (j2 < n && this._queueLess(j2, j1)) {
        j = j2;
      }
      if (!this._queueLess(j, i)) {
        break;
      }
      this._queueSwap(i, j);
      i = j;
    }
    return i > i0;
  }
};
function orient(ax, ay, bx, by, cx, cy) {
  return (bx - cx) * (ay - cy) - (by - cy) * (ax - cx);
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}

// node_modules/@loaders.gl/terrain/dist/lib/parse-terrain.js
function makeTerrainMeshFromImage(terrainImage, terrainOptions) {
  const { meshMaxError, bounds, elevationDecoder } = terrainOptions;
  const { data, width, height } = terrainImage;
  let terrain;
  let mesh;
  switch (terrainOptions.tesselator) {
    case "martini":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      break;
    case "delatin":
      terrain = getTerrain(data, width, height, elevationDecoder, terrainOptions.tesselator);
      mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      break;
    default:
      if (width === height && !(height & width - 1)) {
        terrain = getTerrain(data, width, height, elevationDecoder, "martini");
        mesh = getMartiniTileMesh(meshMaxError, width, terrain);
      } else {
        terrain = getTerrain(data, width, height, elevationDecoder, "delatin");
        mesh = getDelatinTileMesh(meshMaxError, width, height, terrain);
      }
      break;
  }
  const { vertices } = mesh;
  let { triangles } = mesh;
  let attributes = getMeshAttributes2(vertices, terrain, width, height, bounds);
  const boundingBox = getMeshBoundingBox(attributes);
  if (terrainOptions.skirtHeight) {
    const { attributes: newAttributes, triangles: newTriangles } = addSkirt(attributes, triangles, terrainOptions.skirtHeight);
    attributes = newAttributes;
    triangles = newTriangles;
  }
  return {
    // Data return by this loader implementation
    loaderData: {
      header: {}
    },
    header: {
      vertexCount: triangles.length,
      boundingBox
    },
    mode: 4,
    // TRIANGLES
    indices: { value: Uint32Array.from(triangles), size: 1 },
    attributes
  };
}
function getMartiniTileMesh(meshMaxError, width, terrain) {
  const gridSize = width + 1;
  const martini = new Martini(gridSize);
  const tile = martini.createTile(terrain);
  const { vertices, triangles } = tile.getMesh(meshMaxError);
  return { vertices, triangles };
}
function getDelatinTileMesh(meshMaxError, width, height, terrain) {
  const tin = new Delatin(terrain, width + 1, height + 1);
  tin.run(meshMaxError);
  const { coords, triangles } = tin;
  const vertices = coords;
  return { vertices, triangles };
}
function getTerrain(imageData, width, height, elevationDecoder, tesselator) {
  const { rScaler, bScaler, gScaler, offset } = elevationDecoder;
  const terrain = new Float32Array((width + 1) * (height + 1));
  for (let i = 0, y = 0; y < height; y++) {
    for (let x = 0; x < width; x++, i++) {
      const k = i * 4;
      const r = imageData[k + 0];
      const g = imageData[k + 1];
      const b3 = imageData[k + 2];
      terrain[i + y] = r * rScaler + g * gScaler + b3 * bScaler + offset;
    }
  }
  if (tesselator === "martini") {
    for (let i = (width + 1) * width, x = 0; x < width; x++, i++) {
      terrain[i] = terrain[i - width - 1];
    }
    for (let i = height, y = 0; y < height + 1; y++, i += height + 1) {
      terrain[i] = terrain[i - 1];
    }
  }
  return terrain;
}
function getMeshAttributes2(vertices, terrain, width, height, bounds) {
  const gridSize = width + 1;
  const numOfVerticies = vertices.length / 2;
  const positions = new Float32Array(numOfVerticies * 3);
  const texCoords = new Float32Array(numOfVerticies * 2);
  const [minX, minY, maxX, maxY] = bounds || [0, 0, width, height];
  const xScale = (maxX - minX) / width;
  const yScale = (maxY - minY) / height;
  for (let i = 0; i < numOfVerticies; i++) {
    const x = vertices[i * 2];
    const y = vertices[i * 2 + 1];
    const pixelIdx = y * gridSize + x;
    positions[3 * i + 0] = x * xScale + minX;
    positions[3 * i + 1] = -y * yScale + maxY;
    positions[3 * i + 2] = terrain[pixelIdx];
    texCoords[2 * i + 0] = x / width;
    texCoords[2 * i + 1] = y / height;
  }
  return {
    POSITION: { value: positions, size: 3 },
    TEXCOORD_0: { value: texCoords, size: 2 }
    // NORMAL: {}, - optional, but creates the high poly look with lighting
  };
}

// node_modules/@loaders.gl/terrain/dist/lib/utils/version.js
var VERSION8 = true ? "4.3.3" : "latest";

// node_modules/@loaders.gl/terrain/dist/terrain-loader.js
var TerrainLoader = {
  dataType: null,
  batchType: null,
  name: "Terrain",
  id: "terrain",
  module: "terrain",
  version: VERSION8,
  worker: true,
  extensions: ["png", "pngraw", "jpg", "jpeg", "gif", "webp", "bmp"],
  mimeTypes: ["image/png", "image/jpeg", "image/gif", "image/webp", "image/bmp"],
  options: {
    terrain: {
      tesselator: "auto",
      bounds: void 0,
      meshMaxError: 10,
      elevationDecoder: {
        rScaler: 1,
        gScaler: 0,
        bScaler: 0,
        offset: 0
      },
      skirtHeight: void 0
    }
  }
};

// node_modules/@loaders.gl/terrain/dist/quantized-mesh-loader.js
var QuantizedMeshLoader = {
  dataType: null,
  // Mesh,
  batchType: null,
  name: "Quantized Mesh",
  id: "quantized-mesh",
  module: "terrain",
  version: VERSION8,
  worker: true,
  extensions: ["terrain"],
  mimeTypes: ["application/vnd.quantized-mesh"],
  options: {
    "quantized-mesh": {
      bounds: [0, 0, 1, 1],
      skirtHeight: null
    }
  }
};

// node_modules/@loaders.gl/terrain/dist/index.js
var TerrainLoader2 = {
  ...TerrainLoader,
  parse: parseTerrain
};
async function parseTerrain(arrayBuffer, options, context) {
  const loadImageOptions = {
    ...options,
    mimeType: "application/x.image",
    image: { ...options == null ? void 0 : options.image, type: "data" }
  };
  const image = await parseFromContext(arrayBuffer, [], loadImageOptions, context);
  const terrainOptions = { ...TerrainLoader2.options.terrain, ...options == null ? void 0 : options.terrain };
  return makeTerrainMeshFromImage(image, terrainOptions);
}
var QuantizedMeshLoader2 = {
  ...QuantizedMeshLoader,
  parseSync: (arrayBuffer, options) => parseQuantizedMesh(arrayBuffer, options == null ? void 0 : options["quantized-mesh"]),
  parse: async (arrayBuffer, options) => parseQuantizedMesh(arrayBuffer, options == null ? void 0 : options["quantized-mesh"])
};

// node_modules/@deck.gl/geo-layers/dist/terrain-layer/terrain-layer.js
var DUMMY_DATA = [1];
var defaultProps15 = {
  ...tile_layer_default.defaultProps,
  // Image url that encodes height data
  elevationData: urlType,
  // Image url to use as texture
  texture: { ...urlType, optional: true },
  // Martini error tolerance in meters, smaller number -> more detailed mesh
  meshMaxError: { type: "number", value: 4 },
  // Bounding box of the terrain image, [minX, minY, maxX, maxY] in world coordinates
  bounds: { type: "array", value: null, optional: true, compare: true },
  // Color to use if texture is unavailable
  color: { type: "color", value: [255, 255, 255] },
  // Object to decode height data, from (r, g, b) to height in meters
  elevationDecoder: {
    type: "object",
    value: {
      rScaler: 1,
      gScaler: 0,
      bScaler: 0,
      offset: 0
    }
  },
  // Supply url to local terrain worker bundle. Only required if running offline and cannot access CDN.
  workerUrl: "",
  // Same as SimpleMeshLayer wireframe
  wireframe: false,
  material: true,
  loaders: [TerrainLoader]
};
function urlTemplateToUpdateTrigger(template) {
  if (Array.isArray(template)) {
    return template.join(";");
  }
  return template || "";
}
var TerrainLayer = class extends composite_layer_default {
  updateState({ props, oldProps }) {
    const elevationDataChanged = props.elevationData !== oldProps.elevationData;
    if (elevationDataChanged) {
      const { elevationData } = props;
      const isTiled = elevationData && (Array.isArray(elevationData) || isTileSetURL(elevationData));
      this.setState({ isTiled });
    }
    const shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;
    if (!this.state.isTiled && shouldReload) {
      const terrain = this.loadTerrain(props);
      this.setState({ terrain });
    }
    if (props.workerUrl) {
      log_default.removed("workerUrl", "loadOptions.terrain.workerUrl")();
    }
  }
  loadTerrain({ elevationData, bounds, elevationDecoder, meshMaxError, signal }) {
    if (!elevationData) {
      return null;
    }
    let loadOptions = this.getLoadOptions();
    loadOptions = {
      ...loadOptions,
      terrain: {
        skirtHeight: this.state.isTiled ? meshMaxError * 2 : 0,
        ...loadOptions == null ? void 0 : loadOptions.terrain,
        bounds,
        meshMaxError,
        elevationDecoder
      }
    };
    const { fetch: fetch2 } = this.props;
    return fetch2(elevationData, { propName: "elevationData", layer: this, loadOptions, signal });
  }
  getTiledTerrainData(tile) {
    const { elevationData, fetch: fetch2, texture, elevationDecoder, meshMaxError } = this.props;
    const { viewport } = this.context;
    const dataUrl = getURLFromTemplate(elevationData, tile);
    const textureUrl = texture && getURLFromTemplate(texture, tile);
    const { signal } = tile;
    let bottomLeft = [0, 0];
    let topRight = [0, 0];
    if (viewport.isGeospatial) {
      const bbox = tile.bbox;
      bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
      topRight = viewport.projectFlat([bbox.east, bbox.north]);
    } else {
      const bbox = tile.bbox;
      bottomLeft = [bbox.left, bbox.bottom];
      topRight = [bbox.right, bbox.top];
    }
    const bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
    const terrain = this.loadTerrain({
      elevationData: dataUrl,
      bounds,
      elevationDecoder,
      meshMaxError,
      signal
    });
    const surface = textureUrl ? (
      // If surface image fails to load, the tile should still be displayed
      fetch2(textureUrl, { propName: "texture", layer: this, loaders: [], signal }).catch((_) => null)
    ) : Promise.resolve(null);
    return Promise.all([terrain, surface]);
  }
  renderSubLayers(props) {
    const SubLayerClass = this.getSubLayerClass("mesh", simple_mesh_layer_default);
    const { color, wireframe, material } = this.props;
    const { data } = props;
    if (!data) {
      return null;
    }
    const [mesh, texture] = data;
    return new SubLayerClass(props, {
      data: DUMMY_DATA,
      mesh,
      texture,
      _instanced: false,
      coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
      getPosition: (d2) => [0, 0, 0],
      getColor: color,
      wireframe,
      material
    });
  }
  // Update zRange of viewport
  onViewportLoad(tiles) {
    if (!tiles) {
      return;
    }
    const { zRange } = this.state;
    const ranges = tiles.map((tile) => tile.content).filter(Boolean).map((arr) => {
      const bounds = arr[0].header.boundingBox;
      return bounds.map((bound) => bound[2]);
    });
    if (ranges.length === 0) {
      return;
    }
    const minZ = Math.min(...ranges.map((x) => x[0]));
    const maxZ = Math.max(...ranges.map((x) => x[1]));
    if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
      this.setState({ zRange: [minZ, maxZ] });
    }
  }
  renderLayers() {
    const { color, material, elevationData, texture, wireframe, meshMaxError, elevationDecoder, tileSize, maxZoom, minZoom, extent, maxRequests, onTileLoad, onTileUnload, onTileError, maxCacheSize, maxCacheByteSize, refinementStrategy } = this.props;
    if (this.state.isTiled) {
      return new tile_layer_default(this.getSubLayerProps({
        id: "tiles"
      }), {
        getTileData: this.getTiledTerrainData.bind(this),
        renderSubLayers: this.renderSubLayers.bind(this),
        updateTriggers: {
          getTileData: {
            elevationData: urlTemplateToUpdateTrigger(elevationData),
            texture: urlTemplateToUpdateTrigger(texture),
            meshMaxError,
            elevationDecoder
          }
        },
        onViewportLoad: this.onViewportLoad.bind(this),
        zRange: this.state.zRange || null,
        tileSize,
        maxZoom,
        minZoom,
        extent,
        maxRequests,
        onTileLoad,
        onTileUnload,
        onTileError,
        maxCacheSize,
        maxCacheByteSize,
        refinementStrategy
      });
    }
    if (!elevationData) {
      return null;
    }
    const SubLayerClass = this.getSubLayerClass("mesh", simple_mesh_layer_default);
    return new SubLayerClass(this.getSubLayerProps({
      id: "mesh"
    }), {
      data: DUMMY_DATA,
      mesh: this.state.terrain,
      texture,
      _instanced: false,
      getPosition: (d2) => [0, 0, 0],
      getColor: color,
      material,
      wireframe
    });
  }
};
TerrainLayer.defaultProps = defaultProps15;
TerrainLayer.layerName = "TerrainLayer";
var terrain_layer_default = TerrainLayer;
var isTileSetURL = (url) => url.includes("{x}") && (url.includes("{y}") || url.includes("{-y}"));

// node_modules/@deck.gl/extensions/dist/brushing/shader-module.js
var uniformBlock5 = (
  /* glsl */
  `uniform brushingUniforms {
  bool enabled;
  highp int target;
  vec2 mousePos;
  float radius;
} brushing;
`
);
var vertex = (
  /* glsl */
  `
  in vec2 brushingTargets;

  out float brushing_isVisible;

  bool brushing_isPointInRange(vec2 position) {
    if (!brushing.enabled) {
      return true;
    }
    vec2 source_commonspace = project_position(position);
    vec2 target_commonspace = project_position(brushing.mousePos);
    float distance = length((target_commonspace - source_commonspace) / project.commonUnitsPerMeter.xy);

    return distance <= brushing.radius;
  }

  bool brushing_arePointsInRange(vec2 sourcePos, vec2 targetPos) {
    return brushing_isPointInRange(sourcePos) || brushing_isPointInRange(targetPos);
  }

  void brushing_setVisible(bool visible) {
    brushing_isVisible = float(visible);
  }
`
);
var vs2 = `
${uniformBlock5}
${vertex}
`;
var fragment = (
  /* glsl */
  `
  in float brushing_isVisible;
`
);
var fs2 = `
${uniformBlock5}
${fragment}
`;
var TARGET = {
  source: 0,
  target: 1,
  custom: 2,
  source_target: 3
};
var inject = {
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
    vec2 brushingTarget;
    vec2 brushingSource;
    if (brushing.target == 3) {
      brushingTarget = geometry.worldPositionAlt.xy;
      brushingSource = geometry.worldPosition.xy;
    } else if (brushing.target == 0) {
      brushingTarget = geometry.worldPosition.xy;
    } else if (brushing.target == 1) {
      brushingTarget = geometry.worldPositionAlt.xy;
    } else {
      brushingTarget = brushingTargets;
    }
    bool visible;
    if (brushing.target == 3) {
      visible = brushing_arePointsInRange(brushingSource, brushingTarget);
    } else {
      visible = brushing_isPointInRange(brushingTarget);
    }
    brushing_setVisible(visible);
  `
  ),
  "fs:DECKGL_FILTER_COLOR": `
    if (brushing.enabled && brushing_isVisible < 0.5) {
      discard;
    }
  `
};
var shader_module_default = {
  name: "brushing",
  dependencies: [project_default],
  vs: vs2,
  fs: fs2,
  inject,
  getUniforms: (opts) => {
    if (!opts || !("viewport" in opts)) {
      return {};
    }
    const { brushingEnabled = true, brushingRadius = 1e4, brushingTarget = "source", mousePosition, viewport } = opts;
    return {
      enabled: Boolean(brushingEnabled && mousePosition && viewport.containsPixel(mousePosition)),
      radius: brushingRadius,
      target: TARGET[brushingTarget] || 0,
      mousePos: mousePosition ? viewport.unproject([mousePosition.x - viewport.x, mousePosition.y - viewport.y]) : [0, 0]
    };
  },
  uniformTypes: {
    enabled: "i32",
    target: "i32",
    mousePos: "vec2<f32>",
    radius: "f32"
  }
};

// node_modules/@deck.gl/extensions/dist/brushing/brushing-extension.js
var defaultProps16 = {
  getBrushingTarget: { type: "accessor", value: [0, 0] },
  brushingTarget: "source",
  brushingEnabled: true,
  brushingRadius: 1e4
};
var BrushingExtension = class extends layer_extension_default {
  getShaders() {
    return {
      modules: [shader_module_default]
    };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (attributeManager) {
      attributeManager.add({
        brushingTargets: {
          size: 2,
          stepMode: "dynamic",
          accessor: "getBrushingTarget"
        }
      });
    }
    const onMouseMove = () => {
      var _a;
      (_a = this.getCurrentLayer()) == null ? void 0 : _a.setNeedsRedraw();
    };
    this.state.onMouseMove = onMouseMove;
    if (context.deck) {
      context.deck.eventManager.on({
        pointermove: onMouseMove,
        pointerleave: onMouseMove
      });
    }
  }
  finalizeState(context, extension) {
    if (context.deck) {
      const onMouseMove = this.state.onMouseMove;
      context.deck.eventManager.off({
        pointermove: onMouseMove,
        pointerleave: onMouseMove
      });
    }
  }
  draw(params, extension) {
    const { viewport, mousePosition } = params.context;
    const { brushingEnabled, brushingRadius, brushingTarget } = this.props;
    const brushingProps = {
      viewport,
      mousePosition,
      brushingEnabled,
      brushingRadius,
      brushingTarget
    };
    this.setShaderModuleProps({ brushing: brushingProps });
  }
};
BrushingExtension.defaultProps = defaultProps16;
BrushingExtension.extensionName = "BrushingExtension";

// node_modules/@deck.gl/extensions/dist/data-filter/shader-module.js
var uniformBlock6 = (
  /* glsl */
  `uniform dataFilterUniforms {
  bool useSoftMargin;
  bool enabled;
  bool transformSize;
  bool transformColor;
#ifdef DATAFILTER_TYPE
  DATAFILTER_TYPE min;
  DATAFILTER_TYPE softMin;
  DATAFILTER_TYPE softMax;
  DATAFILTER_TYPE max;
#ifdef DATAFILTER_DOUBLE
  DATAFILTER_TYPE min64High;
  DATAFILTER_TYPE max64High;
#endif
#endif
#ifdef DATACATEGORY_TYPE
  highp uvec4 categoryBitMask;
#endif
} dataFilter;
`
);
var vertex2 = (
  /* glsl */
  `
#ifdef DATAFILTER_TYPE
  in DATAFILTER_TYPE filterValues;
#ifdef DATAFILTER_DOUBLE
  in DATAFILTER_TYPE filterValues64Low;
#endif
#endif

#ifdef DATACATEGORY_TYPE
  in DATACATEGORY_TYPE filterCategoryValues;
#endif

out float dataFilter_value;

float dataFilter_reduceValue(float value) {
  return value;
}
float dataFilter_reduceValue(vec2 value) {
  return min(value.x, value.y);
}
float dataFilter_reduceValue(vec3 value) {
  return min(min(value.x, value.y), value.z);
}
float dataFilter_reduceValue(vec4 value) {
  return min(min(value.x, value.y), min(value.z, value.w));
}

#ifdef DATAFILTER_TYPE
  void dataFilter_setValue(DATAFILTER_TYPE valueFromMin, DATAFILTER_TYPE valueFromMax) {
    if (dataFilter.useSoftMargin) {
      // smoothstep results are undefined if edge0 ≥ edge1
      // Fallback to ignore filterSoftRange if it is truncated by filterRange
      DATAFILTER_TYPE leftInRange = mix(
        smoothstep(dataFilter.min, dataFilter.softMin, valueFromMin),
        step(dataFilter.min, valueFromMin),
        step(dataFilter.softMin, dataFilter.min)
      );
      DATAFILTER_TYPE rightInRange = mix(
        1.0 - smoothstep(dataFilter.softMax, dataFilter.max, valueFromMax),
        step(valueFromMax, dataFilter.max),
        step(dataFilter.max, dataFilter.softMax)
      );
      dataFilter_value = dataFilter_reduceValue(leftInRange * rightInRange);
    } else {
      dataFilter_value = dataFilter_reduceValue(
        step(dataFilter.min, valueFromMin) * step(valueFromMax, dataFilter.max)
      );
    }
  }
#endif

#ifdef DATACATEGORY_TYPE
  void dataFilter_setCategoryValue(DATACATEGORY_TYPE category) {
    #if DATACATEGORY_CHANNELS == 1 // One 128-bit mask
    uint dataFilter_masks = dataFilter.categoryBitMask[category / 32u];
    #elif DATACATEGORY_CHANNELS == 2 // Two 64-bit masks
    uvec2 dataFilter_masks = uvec2(
      dataFilter.categoryBitMask[category.x / 32u],
      dataFilter.categoryBitMask[category.y / 32u + 2u]
    );
    #elif DATACATEGORY_CHANNELS == 3 // Three 32-bit masks
    uvec3 dataFilter_masks = dataFilter.categoryBitMask.xyz;
    #else // Four 32-bit masks
    uvec4 dataFilter_masks = dataFilter.categoryBitMask;
    #endif

    // Shift mask and extract relevant bits
    DATACATEGORY_TYPE dataFilter_bits = DATACATEGORY_TYPE(dataFilter_masks) >> (category & 31u);
    dataFilter_bits &= 1u;

    #if DATACATEGORY_CHANNELS == 1
    if(dataFilter_bits == 0u) dataFilter_value = 0.0;
    #else
    if(any(equal(dataFilter_bits, DATACATEGORY_TYPE(0u)))) dataFilter_value = 0.0;
    #endif
  }
#endif
`
);
var vs3 = `
${uniformBlock6}
${vertex2}
`;
var fragment2 = (
  /* glsl */
  `
in float dataFilter_value;
`
);
var fs3 = `
${uniformBlock6}
${fragment2}
`;
function getUniforms(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const { filterRange = [-1, 1], filterEnabled = true, filterTransformSize = true, filterTransformColor = true, categoryBitMask } = opts;
  const filterSoftRange = opts.filterSoftRange || filterRange;
  return {
    ...Number.isFinite(filterRange[0]) ? {
      min: filterRange[0],
      softMin: filterSoftRange[0],
      softMax: filterSoftRange[1],
      max: filterRange[1]
    } : {
      min: filterRange.map((r) => r[0]),
      softMin: filterSoftRange.map((r) => r[0]),
      softMax: filterSoftRange.map((r) => r[1]),
      max: filterRange.map((r) => r[1])
    },
    enabled: filterEnabled,
    useSoftMargin: Boolean(opts.filterSoftRange),
    transformSize: filterEnabled && filterTransformSize,
    transformColor: filterEnabled && filterTransformColor,
    ...categoryBitMask && { categoryBitMask }
  };
}
function getUniforms64(opts) {
  if (!opts || !("extensions" in opts)) {
    return {};
  }
  const uniforms = getUniforms(opts);
  if (Number.isFinite(uniforms.min)) {
    const min64High = Math.fround(uniforms.min);
    uniforms.min -= min64High;
    uniforms.softMin -= min64High;
    uniforms.min64High = min64High;
    const max64High = Math.fround(uniforms.max);
    uniforms.max -= max64High;
    uniforms.softMax -= max64High;
    uniforms.max64High = max64High;
  } else {
    const min64High = uniforms.min.map(Math.fround);
    uniforms.min = uniforms.min.map((x, i) => x - min64High[i]);
    uniforms.softMin = uniforms.softMin.map((x, i) => x - min64High[i]);
    uniforms.min64High = min64High;
    const max64High = uniforms.max.map(Math.fround);
    uniforms.max = uniforms.max.map((x, i) => x - max64High[i]);
    uniforms.softMax = uniforms.softMax.map((x, i) => x - max64High[i]);
    uniforms.max64High = max64High;
  }
  return uniforms;
}
var inject2 = {
  "vs:#main-start": (
    /* glsl */
    `
    dataFilter_value = 1.0;
    if (dataFilter.enabled) {
      #ifdef DATAFILTER_TYPE
        #ifdef DATAFILTER_DOUBLE
          dataFilter_setValue(
            filterValues - dataFilter.min64High + filterValues64Low,
            filterValues - dataFilter.max64High + filterValues64Low
          );
        #else
          dataFilter_setValue(filterValues, filterValues);
        #endif
      #endif

      #ifdef DATACATEGORY_TYPE
        dataFilter_setCategoryValue(filterCategoryValues);
      #endif
    }
  `
  ),
  "vs:#main-end": (
    /* glsl */
    `
    if (dataFilter_value == 0.0) {
      gl_Position = vec4(0.);
    }
  `
  ),
  "vs:DECKGL_FILTER_SIZE": (
    /* glsl */
    `
    if (dataFilter.transformSize) {
      size = size * dataFilter_value;
    }
  `
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
    if (dataFilter_value == 0.0) discard;
    if (dataFilter.transformColor) {
      color.a *= dataFilter_value;
    }
  `
  )
};
function uniformTypesFromOptions(opts) {
  const { categorySize, filterSize, fp64: fp642 } = opts;
  const uniformTypes = {
    useSoftMargin: "i32",
    enabled: "i32",
    transformSize: "i32",
    transformColor: "i32"
  };
  if (filterSize) {
    const uniformFormat = filterSize === 1 ? "f32" : `vec${filterSize}<f32>`;
    uniformTypes.min = uniformFormat;
    uniformTypes.softMin = uniformFormat;
    uniformTypes.softMax = uniformFormat;
    uniformTypes.max = uniformFormat;
    if (fp642) {
      uniformTypes.min64High = uniformFormat;
      uniformTypes.max64High = uniformFormat;
    }
  }
  if (categorySize) {
    uniformTypes.categoryBitMask = "vec4<i32>";
  }
  return uniformTypes;
}
var dataFilter = {
  name: "dataFilter",
  vs: vs3,
  fs: fs3,
  inject: inject2,
  getUniforms,
  uniformTypesFromOptions
};
var dataFilter64 = {
  name: "dataFilter",
  vs: vs3,
  fs: fs3,
  inject: inject2,
  getUniforms: getUniforms64,
  uniformTypesFromOptions
};

// node_modules/@deck.gl/extensions/dist/data-filter/aggregator.js
var AGGREGATE_VS = `#version 300 es
#define SHADER_NAME data-filter-vertex-shader

#ifdef FLOAT_TARGET
  in float filterIndices;
  in float filterPrevIndices;
#else
  in vec2 filterIndices;
  in vec2 filterPrevIndices;
#endif

out vec4 vColor;
const float component = 1.0 / 255.0;

void main() {
  #ifdef FLOAT_TARGET
    dataFilter_value *= float(filterIndices != filterPrevIndices);
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    vColor = vec4(0.0, 0.0, 0.0, 1.0);
  #else
    // Float texture is not supported: pack result into 4 channels x 256 px x 64px
    dataFilter_value *= float(filterIndices.x != filterPrevIndices.x);
    float col = filterIndices.x;
    float row = filterIndices.y * 4.0;
    float channel = floor(row);
    row = fract(row);
    vColor = component * vec4(bvec4(channel == 0.0, channel == 1.0, channel == 2.0, channel == 3.0));
    gl_Position = vec4(col * 2.0 - 1.0, row * 2.0 - 1.0, 0.0, 1.0);
  #endif
  gl_PointSize = 1.0;
}
`;
var AGGREGATE_FS = `#version 300 es
#define SHADER_NAME data-filter-fragment-shader
precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main() {
  if (dataFilter_value < 0.5) {
    discard;
  }
  fragColor = vColor;
}
`;
var FLOAT_TARGET_FEATURES = [
  "float32-renderable-webgl",
  // ability to render to float texture
  "texture-blend-float-webgl"
  // ability to blend when rendering to float texture
];
function supportsFloatTarget(device) {
  return FLOAT_TARGET_FEATURES.every((feature2) => device.features.has(feature2));
}
function getFramebuffer(device, useFloatTarget) {
  if (useFloatTarget) {
    return device.createFramebuffer({
      width: 1,
      height: 1,
      colorAttachments: [
        device.createTexture({
          format: "rgba32float",
          dimension: "2d",
          width: 1,
          height: 1
        })
      ]
    });
  }
  return device.createFramebuffer({
    width: 256,
    height: 64,
    colorAttachments: [
      device.createTexture({ format: "rgba8unorm", dimension: "2d", width: 256, height: 64 })
    ]
  });
}
function getModel(device, bufferLayout, shaderOptions, useFloatTarget) {
  shaderOptions.defines.NON_INSTANCED_MODEL = 1;
  if (useFloatTarget) {
    shaderOptions.defines.FLOAT_TARGET = 1;
  }
  return new Model(device, {
    id: "data-filter-aggregation-model",
    vertexCount: 1,
    isInstanced: false,
    topology: "point-list",
    disableWarnings: true,
    vs: AGGREGATE_VS,
    fs: AGGREGATE_FS,
    bufferLayout,
    ...shaderOptions
  });
}
var parameters = {
  blend: true,
  blendColorSrcFactor: "one",
  blendColorDstFactor: "one",
  blendAlphaSrcFactor: "one",
  blendAlphaDstFactor: "one",
  blendColorOperation: "add",
  blendAlphaOperation: "add",
  depthCompare: "never"
};

// node_modules/@deck.gl/extensions/dist/data-filter/data-filter-extension.js
var defaultProps17 = {
  getFilterValue: { type: "accessor", value: 0 },
  getFilterCategory: { type: "accessor", value: 0 },
  onFilteredItemsChange: { type: "function", value: null, optional: true },
  filterEnabled: true,
  filterRange: [-1, 1],
  filterSoftRange: null,
  filterCategories: [0],
  filterTransformSize: true,
  filterTransformColor: true
};
var defaultOptions2 = {
  categorySize: 0,
  filterSize: 1,
  fp64: false,
  countItems: false
};
var CATEGORY_TYPE_FROM_SIZE = {
  1: "uint",
  2: "uvec2",
  3: "uvec3",
  4: "uvec4"
};
var DATA_TYPE_FROM_SIZE = {
  1: "float",
  2: "vec2",
  3: "vec3",
  4: "vec4"
};
var DataFilterExtension = class extends layer_extension_default {
  constructor(opts = {}) {
    super({ ...defaultOptions2, ...opts });
  }
  getShaders(extension) {
    const { categorySize, filterSize, fp64: fp642 } = extension.opts;
    const defines = {};
    if (categorySize) {
      defines.DATACATEGORY_TYPE = CATEGORY_TYPE_FROM_SIZE[categorySize];
      defines.DATACATEGORY_CHANNELS = categorySize;
    }
    if (filterSize) {
      defines.DATAFILTER_TYPE = DATA_TYPE_FROM_SIZE[filterSize];
      defines.DATAFILTER_DOUBLE = Boolean(fp642);
    }
    const module = fp642 ? dataFilter64 : dataFilter;
    module.uniformTypes = module.uniformTypesFromOptions(extension.opts);
    return { modules: [module], defines };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    const { categorySize, filterSize, fp64: fp642 } = extension.opts;
    if (attributeManager) {
      if (filterSize) {
        attributeManager.add({
          filterValues: {
            size: filterSize,
            type: fp642 ? "float64" : "float32",
            stepMode: "dynamic",
            accessor: "getFilterValue"
          }
        });
      }
      if (categorySize) {
        attributeManager.add({
          filterCategoryValues: {
            size: categorySize,
            stepMode: "dynamic",
            accessor: "getFilterCategory",
            type: "uint32",
            transform: categorySize === 1 ? (d2) => extension._getCategoryKey.call(this, d2, 0) : (d2) => d2.map((x, i) => extension._getCategoryKey.call(this, x, i))
          }
        });
      }
    }
    const { device } = this.context;
    if (attributeManager && extension.opts.countItems) {
      const useFloatTarget = supportsFloatTarget(device);
      attributeManager.add({
        filterVertexIndices: {
          size: useFloatTarget ? 1 : 2,
          vertexOffset: 1,
          type: "unorm8",
          accessor: (object, { index }) => {
            const i = object && object.__source ? object.__source.index : index;
            return useFloatTarget ? (i + 1) % 255 : [(i + 1) % 255, Math.floor(i / 255) % 255];
          },
          shaderAttributes: {
            filterPrevIndices: {
              vertexOffset: 0
            },
            filterIndices: {
              vertexOffset: 1
            }
          }
        }
      });
      const filterFBO = getFramebuffer(device, useFloatTarget);
      const filterModel = getModel(device, attributeManager.getBufferLayouts({ isInstanced: false }), extension.getShaders.call(this, extension), useFloatTarget);
      this.setState({ filterFBO, filterModel });
    }
  }
  // eslint-disable-next-line complexity
  updateState({ props, oldProps, changeFlags }, extension) {
    var _a, _b;
    const attributeManager = this.getAttributeManager();
    const { categorySize } = extension.opts;
    if (this.state.filterModel) {
      const filterNeedsUpdate = (
        // attributeManager must be defined for filterModel to be set
        ((_a = attributeManager.attributes.filterValues) == null ? void 0 : _a.needsUpdate()) || ((_b = attributeManager.attributes.filterCategoryValues) == null ? void 0 : _b.needsUpdate()) || props.filterEnabled !== oldProps.filterEnabled || props.filterRange !== oldProps.filterRange || props.filterSoftRange !== oldProps.filterSoftRange || props.filterCategories !== oldProps.filterCategories
      );
      if (filterNeedsUpdate) {
        this.setState({ filterNeedsUpdate });
      }
    }
    if (attributeManager == null ? void 0 : attributeManager.attributes.filterCategoryValues) {
      const categoryBitMaskNeedsUpdate = attributeManager.attributes.filterCategoryValues.needsUpdate() || !deepEqual(props.filterCategories, oldProps.filterCategories, 2);
      if (categoryBitMaskNeedsUpdate) {
        this.setState({ categoryBitMask: null });
      }
      const resetCategories = changeFlags.dataChanged;
      if (resetCategories) {
        this.setState({
          categoryMap: Array(categorySize).fill(0).map(() => ({}))
        });
        attributeManager.attributes.filterCategoryValues.setNeedsUpdate("categoryMap");
      }
    }
  }
  // eslint-disable-next-line max-statements
  draw(params, extension) {
    const filterFBO = this.state.filterFBO;
    const filterModel = this.state.filterModel;
    const filterNeedsUpdate = this.state.filterNeedsUpdate;
    if (!this.state.categoryBitMask) {
      extension._updateCategoryBitMask.call(this, params, extension);
    }
    const { onFilteredItemsChange, extensions, filterEnabled, filterRange, filterSoftRange, filterTransformSize, filterTransformColor, filterCategories } = this.props;
    const dataFilterProps = {
      extensions,
      filterEnabled,
      filterRange,
      filterSoftRange,
      filterTransformSize,
      filterTransformColor,
      filterCategories
    };
    if (this.state.categoryBitMask) {
      dataFilterProps.categoryBitMask = this.state.categoryBitMask;
    }
    this.setShaderModuleProps({ dataFilter: dataFilterProps });
    if (filterNeedsUpdate && onFilteredItemsChange && filterModel) {
      const attributeManager = this.getAttributeManager();
      const { attributes: { filterValues, filterCategoryValues, filterVertexIndices } } = attributeManager;
      filterModel.setVertexCount(this.getNumInstances());
      const attributes = {
        ...filterValues == null ? void 0 : filterValues.getValue(),
        ...filterCategoryValues == null ? void 0 : filterCategoryValues.getValue(),
        ...filterVertexIndices == null ? void 0 : filterVertexIndices.getValue()
      };
      filterModel.setAttributes(attributes);
      filterModel.shaderInputs.setProps({
        dataFilter: dataFilterProps
      });
      const viewport = [0, 0, filterFBO.width, filterFBO.height];
      const renderPass = filterModel.device.beginRenderPass({
        id: "data-filter-aggregation",
        framebuffer: filterFBO,
        parameters: { viewport },
        clearColor: [0, 0, 0, 0]
      });
      filterModel.setParameters(parameters);
      filterModel.draw(renderPass);
      renderPass.end();
      const color = filterModel.device.readPixelsToArrayWebGL(filterFBO);
      let count = 0;
      for (let i = 0; i < color.length; i++) {
        count += color[i];
      }
      onFilteredItemsChange({ id: this.id, count });
      this.state.filterNeedsUpdate = false;
    }
  }
  finalizeState() {
    const filterFBO = this.state.filterFBO;
    const filterModel = this.state.filterModel;
    filterFBO == null ? void 0 : filterFBO.destroy();
    filterModel == null ? void 0 : filterModel.destroy();
  }
  /**
   * Updates the bitmask used on the GPU to perform the filter based on the
   * `filterCategories` prop. The mapping between categories and bit in the bitmask
   * is performed by `_getCategoryKey()`
   */
  _updateCategoryBitMask(params, extension) {
    const { categorySize } = extension.opts;
    if (!categorySize)
      return;
    const { filterCategories } = this.props;
    const categoryBitMask = new Uint32Array([0, 0, 0, 0]);
    const categoryFilters = categorySize === 1 ? [filterCategories] : filterCategories;
    const maxCategories = categorySize === 1 ? 128 : categorySize === 2 ? 64 : 32;
    for (let c2 = 0; c2 < categoryFilters.length; c2++) {
      const categoryFilter = categoryFilters[c2];
      for (const category of categoryFilter) {
        const key = extension._getCategoryKey.call(this, category, c2);
        if (key < maxCategories) {
          const channel = c2 * (maxCategories / 32) + Math.floor(key / 32);
          categoryBitMask[channel] += Math.pow(2, key % 32);
        } else {
          log_default.warn(`Exceeded maximum number of categories (${maxCategories})`)();
        }
      }
    }
    this.state.categoryBitMask = categoryBitMask;
  }
  /**
   * Returns an index of bit in the bitmask for a given category. If the category has
   * not yet been assigned a bit, a new one is assigned.
   */
  _getCategoryKey(category, channel) {
    const categoryMap = this.state.categoryMap[channel];
    if (!(category in categoryMap)) {
      categoryMap[category] = Object.keys(categoryMap).length;
    }
    return categoryMap[category];
  }
};
DataFilterExtension.defaultProps = defaultProps17;
DataFilterExtension.extensionName = "DataFilterExtension";

// node_modules/@deck.gl/extensions/dist/fp64/project64.glsl.js
var project64_glsl_default = `const vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);
uniform project64Uniforms {
vec2 scale;
mat4 viewProjectionMatrix;
mat4 viewProjectionMatrix64Low;
} project64;
void mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {
#if defined(NVIDIA_FP64_WORKAROUND)
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);
#else
out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);
#endif
out_val[1] = sum_fp64(PI_FP64,
log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));
return;
}
void project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {
vec2 pos_fp64[2];
mercatorProject_fp64(position_fp64, pos_fp64);
out_val[0] = mul_fp64(pos_fp64[0], WORLD_SCALE_FP64);
out_val[1] = mul_fp64(pos_fp64[1], WORLD_SCALE_FP64);
return;
}
void project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {
vec4 position64xy = vec4(
position.x, position64xyLow.x,
position.y, position64xyLow.y);
project_position_fp64(position64xy, out_val);
}
vec4 project_common_position_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {
vec2 vertex_pos_clipspace[4];
vec2 viewProjectionMatrixFP64[16];
for (int i = 0; i < 4; i++) {
for (int j = 0; j < 4; j++) {
viewProjectionMatrixFP64[4 * i + j] = vec2(
project64.viewProjectionMatrix[j][i],
project64.viewProjectionMatrix64Low[j][i]
);
}
}
mat4_vec4_mul_fp64(viewProjectionMatrixFP64, vertex_pos_modelspace,
vertex_pos_clipspace);
return vec4(
vertex_pos_clipspace[0].x,
vertex_pos_clipspace[1].x,
vertex_pos_clipspace[2].x,
vertex_pos_clipspace[3].x
);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset, out vec4 commonPosition
) {
vec2 offset64[4];
vec4_fp64(vec4(offset, 0.0), offset64);
float z = project_size(position.z);
vec2 projectedPosition64xy[2];
project_position_fp64(position.xy, position64xyLow.xy, projectedPosition64xy);
vec2 commonPosition64[4];
commonPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);
commonPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);
commonPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));
commonPosition64[3] = vec2(1.0, 0.0);
commonPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);
return project_common_position_to_clipspace_fp64(commonPosition64);
}
vec4 project_position_to_clipspace(
vec3 position, vec3 position64xyLow, vec3 offset
) {
vec4 commonPosition;
return project_position_to_clipspace(
position, position64xyLow, offset, commonPosition
);
}
`;

// node_modules/@deck.gl/extensions/dist/fp64/project64.js
var { fp64ify, fp64ifyMatrix4 } = fp64;
var project64_default = {
  name: "project64",
  dependencies: [project_default, fp64],
  vs: project64_glsl_default,
  getUniforms: getUniforms2,
  uniformTypes: {
    scale: "vec2<f32>",
    // Cannot pass as vec2[16], so instead split into 2 mat4x4
    viewProjectionMatrix: "mat4x4<f32>",
    viewProjectionMatrix64Low: "mat4x4<f32>"
  }
};
var getMemoizedUniforms = memoize(calculateUniforms);
function getUniforms2(opts) {
  if (opts && "viewport" in opts) {
    const { viewProjectionMatrix, scale: scale7 } = opts.viewport;
    return getMemoizedUniforms({ viewProjectionMatrix, scale: scale7 });
  }
  return {};
}
function calculateUniforms({ viewProjectionMatrix, scale: scale7 }) {
  const glViewProjectionMatrixFP64 = fp64ifyMatrix4(viewProjectionMatrix);
  const viewProjectionMatrix64High = new Float32Array(16);
  const viewProjectionMatrix64Low = new Float32Array(16);
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      const from = 4 * i + j;
      const to = 4 * j + i;
      viewProjectionMatrix64High[to] = glViewProjectionMatrixFP64[2 * from];
      viewProjectionMatrix64Low[to] = glViewProjectionMatrixFP64[2 * from + 1];
    }
  }
  return {
    scale: fp64ify(scale7),
    viewProjectionMatrix: [...viewProjectionMatrix64High],
    viewProjectionMatrix64Low: [...viewProjectionMatrix64Low]
  };
}

// node_modules/@deck.gl/extensions/dist/fp64/fp64-extension.js
var Fp64Extension = class extends layer_extension_default {
  getShaders() {
    const { coordinateSystem } = this.props;
    if (coordinateSystem !== COORDINATE_SYSTEM.LNGLAT && coordinateSystem !== COORDINATE_SYSTEM.DEFAULT) {
      throw new Error("fp64: coordinateSystem must be LNGLAT");
    }
    return {
      modules: [project64_default]
    };
  }
  draw(params, extension) {
    const { viewport } = params.context;
    this.setShaderModuleProps({ project64: { viewport } });
  }
};
Fp64Extension.extensionName = "Fp64Extension";

// node_modules/@deck.gl/extensions/dist/path-style/shaders.glsl.js
var dashShaders = {
  inject: {
    "vs:#decl": `
in vec2 instanceDashArrays;
in float instanceDashOffsets;
out vec2 vDashArray;
out float vDashOffset;
`,
    "vs:#main-end": `
vDashArray = instanceDashArrays;
vDashOffset = instanceDashOffsets / width.x;
`,
    "fs:#decl": `
uniform pathStyleUniforms {
float dashAlignMode;
bool dashGapPickable;
} pathStyle;
in vec2 vDashArray;
in float vDashOffset;
`,
    // if given position is in the gap part of the dashed line
    // dashArray.x: solid stroke length, relative to width
    // dashArray.y: gap length, relative to width
    // alignMode:
    // 0 - no adjustment
    // o----     ----     ----     ---- o----     -o----     ----     o
    // 1 - stretch to fit, draw half dash at each end for nicer joints
    // o--    ----    ----    ----    --o--      --o--     ----     --o
    "fs:#main-start": `
float solidLength = vDashArray.x;
float gapLength = vDashArray.y;
float unitLength = solidLength + gapLength;
float offset;
if (unitLength > 0.0) {
if (pathStyle.dashAlignMode == 0.0) {
offset = vDashOffset;
} else {
unitLength = vPathLength / round(vPathLength / unitLength);
offset = solidLength / 2.0;
}
float unitOffset = mod(vPathPosition.y + offset, unitLength);
if (gapLength > 0.0 && unitOffset > solidLength) {
if (path.capType <= 0.5) {
if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {
discard;
}
} else {
float distToEnd = length(vec2(
min(unitOffset - solidLength, unitLength - unitOffset),
vPathPosition.x
));
if (distToEnd > 1.0) {
if (!(pathStyle.dashGapPickable && bool(picking.isActive))) {
discard;
}
}
}
}
}
`
  }
};
var offsetShaders = {
  inject: {
    "vs:#decl": `
in float instanceOffsets;
`,
    "vs:DECKGL_FILTER_SIZE": `
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
size *= offsetWidth;
`,
    "vs:#main-end": `
float offsetWidth = abs(instanceOffsets * 2.0) + 1.0;
float offsetDir = sign(instanceOffsets);
vPathPosition.x = (vPathPosition.x + offsetDir) * offsetWidth - offsetDir;
vPathPosition.y *= offsetWidth;
vPathLength *= offsetWidth;
`,
    "fs:#main-start": `
float isInside;
isInside = step(-1.0, vPathPosition.x) * step(vPathPosition.x, 1.0);
if (isInside == 0.0) {
discard;
}
`
  }
};

// node_modules/@deck.gl/extensions/dist/path-style/path-style-extension.js
var defaultProps18 = {
  getDashArray: { type: "accessor", value: [0, 0] },
  getOffset: { type: "accessor", value: 0 },
  dashJustified: false,
  dashGapPickable: false
};
var PathStyleExtension = class extends layer_extension_default {
  constructor({ dash = false, offset = false, highPrecisionDash = false } = {}) {
    super({ dash: dash || highPrecisionDash, offset, highPrecisionDash });
  }
  isEnabled(layer) {
    return "pathTesselator" in layer.state;
  }
  getShaders(extension) {
    if (!extension.isEnabled(this)) {
      return null;
    }
    let result = {};
    if (extension.opts.dash) {
      result = mergeShaders(result, dashShaders);
    }
    if (extension.opts.offset) {
      result = mergeShaders(result, offsetShaders);
    }
    const { inject: inject6 } = result;
    const pathStyle = {
      name: "pathStyle",
      inject: inject6,
      uniformTypes: {
        dashAlignMode: "f32",
        dashGapPickable: "i32"
      }
    };
    return {
      modules: [pathStyle]
    };
  }
  initializeState(context, extension) {
    const attributeManager = this.getAttributeManager();
    if (!attributeManager || !extension.isEnabled(this)) {
      return;
    }
    if (extension.opts.dash) {
      attributeManager.addInstanced({
        instanceDashArrays: { size: 2, accessor: "getDashArray" },
        instanceDashOffsets: extension.opts.highPrecisionDash ? {
          size: 1,
          accessor: "getPath",
          transform: extension.getDashOffsets.bind(this)
        } : {
          size: 1,
          update: (attribute) => {
            attribute.constant = true;
            attribute.value = [0];
          }
        }
      });
    }
    if (extension.opts.offset) {
      attributeManager.addInstanced({
        instanceOffsets: { size: 1, accessor: "getOffset" }
      });
    }
  }
  updateState(params, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    if (extension.opts.dash) {
      const pathStyleProps = {
        dashAlignMode: this.props.dashJustified ? 1 : 0,
        dashGapPickable: Boolean(this.props.dashGapPickable)
      };
      this.setShaderModuleProps({ pathStyle: pathStyleProps });
    }
  }
  getDashOffsets(path) {
    const result = [0];
    const positionSize = this.props.positionFormat === "XY" ? 2 : 3;
    const isNested = Array.isArray(path[0]);
    const geometrySize = isNested ? path.length : path.length / positionSize;
    let p;
    let prevP;
    for (let i = 0; i < geometrySize - 1; i++) {
      p = isNested ? path[i] : path.slice(i * positionSize, i * positionSize + positionSize);
      p = this.projectPosition(p);
      if (i > 0) {
        result[i] = result[i - 1] + vec3_exports.dist(prevP, p);
      }
      prevP = p;
    }
    result[geometrySize - 1] = 0;
    return result;
  }
};
PathStyleExtension.defaultProps = defaultProps18;
PathStyleExtension.extensionName = "PathStyleExtension";

// node_modules/@deck.gl/extensions/dist/fill-style/shader-module.js
var uniformBlock7 = (
  /* glsl */
  `uniform fillUniforms {
  vec2 patternTextureSize;
  bool patternEnabled;
  bool patternMask;
  vec2 uvCoordinateOrigin;
  vec2 uvCoordinateOrigin64Low;
} fill;
`
);
var patternVs = (
  /* glsl */
  `
in vec4 fillPatternFrames;
in float fillPatternScales;
in vec2 fillPatternOffsets;

out vec2 fill_uv;
out vec4 fill_patternBounds;
out vec4 fill_patternPlacement;
`
);
var vs4 = `
${uniformBlock7}
${patternVs}
`;
var patternFs = (
  /* glsl */
  `
uniform sampler2D fill_patternTexture;

in vec4 fill_patternBounds;
in vec4 fill_patternPlacement;
in vec2 fill_uv;

const float FILL_UV_SCALE = 512.0 / 40000000.0;
`
);
var fs4 = `
${uniformBlock7}
${patternFs}
`;
var inject3 = {
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
    fill_uv = geometry.position.xy;
  `
  ),
  "vs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
    if (fill.patternEnabled) {
      fill_patternBounds = fillPatternFrames / vec4(fill.patternTextureSize, fill.patternTextureSize);
      fill_patternPlacement.xy = fillPatternOffsets;
      fill_patternPlacement.zw = fillPatternScales * fillPatternFrames.zw;
    }
  `
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
    if (fill.patternEnabled) {
      vec2 scale = FILL_UV_SCALE * fill_patternPlacement.zw;
      vec2 patternUV = mod(mod(fill.uvCoordinateOrigin, scale) + fill.uvCoordinateOrigin64Low + fill_uv, scale) / scale;
      patternUV = mod(fill_patternPlacement.xy + patternUV, 1.0);

      vec2 texCoords = fill_patternBounds.xy + fill_patternBounds.zw * patternUV;

      vec4 patternColor = texture(fill_patternTexture, texCoords);
      color.a *= patternColor.a;
      if (!fill.patternMask) {
        color.rgb = patternColor.rgb;
      }
    }
  `
  )
};
function getPatternUniforms(opts) {
  if (!opts) {
    return {};
  }
  const uniforms = {};
  if ("fillPatternTexture" in opts) {
    const { fillPatternTexture } = opts;
    uniforms.fill_patternTexture = fillPatternTexture;
    uniforms.patternTextureSize = [fillPatternTexture.width, fillPatternTexture.height];
  }
  if ("project" in opts) {
    const { fillPatternMask = true, fillPatternEnabled = true } = opts;
    const projectUniforms = project_default.getUniforms(opts.project);
    const { commonOrigin: coordinateOriginCommon } = projectUniforms;
    const coordinateOriginCommon64Low = [
      fp64LowPart(coordinateOriginCommon[0]),
      fp64LowPart(coordinateOriginCommon[1])
    ];
    uniforms.uvCoordinateOrigin = coordinateOriginCommon.slice(0, 2);
    uniforms.uvCoordinateOrigin64Low = coordinateOriginCommon64Low;
    uniforms.patternMask = fillPatternMask;
    uniforms.patternEnabled = fillPatternEnabled;
  }
  return uniforms;
}
var patternShaders = {
  name: "fill",
  vs: vs4,
  fs: fs4,
  inject: inject3,
  dependencies: [project_default],
  getUniforms: getPatternUniforms,
  uniformTypes: {
    patternTextureSize: "vec2<f32>",
    patternEnabled: "i32",
    patternMask: "i32",
    uvCoordinateOrigin: "vec2<f32>",
    uvCoordinateOrigin64Low: "vec2<f32>"
  }
};

// node_modules/@deck.gl/extensions/dist/fill-style/fill-style-extension.js
var defaultProps19 = {
  fillPatternEnabled: true,
  fillPatternAtlas: {
    type: "image",
    value: null,
    async: true,
    parameters: { lodMaxClamp: 0 }
  },
  fillPatternMapping: { type: "object", value: {}, async: true },
  fillPatternMask: true,
  getFillPattern: { type: "accessor", value: (d2) => d2.pattern },
  getFillPatternScale: { type: "accessor", value: 1 },
  getFillPatternOffset: { type: "accessor", value: [0, 0] }
};
var FillStyleExtension = class extends layer_extension_default {
  constructor({ pattern = false } = {}) {
    super({ pattern });
  }
  isEnabled(layer) {
    return layer.getAttributeManager() !== null && !("pathTesselator" in layer.state);
  }
  getShaders(extension) {
    if (!extension.isEnabled(this)) {
      return null;
    }
    return {
      modules: [extension.opts.pattern && patternShaders].filter(Boolean)
    };
  }
  initializeState(context, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    const attributeManager = this.getAttributeManager();
    if (extension.opts.pattern) {
      attributeManager.add({
        fillPatternFrames: {
          size: 4,
          stepMode: "dynamic",
          accessor: "getFillPattern",
          transform: extension.getPatternFrame.bind(this)
        },
        fillPatternScales: {
          size: 1,
          stepMode: "dynamic",
          accessor: "getFillPatternScale",
          defaultValue: 1
        },
        fillPatternOffsets: {
          size: 2,
          stepMode: "dynamic",
          accessor: "getFillPatternOffset"
        }
      });
    }
    this.setState({
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState({ props, oldProps }, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    if (props.fillPatternMapping && props.fillPatternMapping !== oldProps.fillPatternMapping) {
      this.getAttributeManager().invalidate("getFillPattern");
    }
  }
  draw(params, extension) {
    if (!extension.isEnabled(this)) {
      return;
    }
    const { fillPatternAtlas, fillPatternEnabled, fillPatternMask } = this.props;
    const fillProps = {
      project: params.shaderModuleProps.project,
      fillPatternEnabled,
      fillPatternMask,
      fillPatternTexture: fillPatternAtlas || this.state.emptyTexture
    };
    this.setShaderModuleProps({ fill: fillProps });
  }
  finalizeState() {
    const emptyTexture = this.state.emptyTexture;
    emptyTexture == null ? void 0 : emptyTexture.delete();
  }
  getPatternFrame(name12) {
    const { fillPatternMapping } = this.getCurrentLayer().props;
    const def = fillPatternMapping && fillPatternMapping[name12];
    return def ? [def.x, def.y, def.width, def.height] : [0, 0, 0, 0];
  }
};
FillStyleExtension.defaultProps = defaultProps19;
FillStyleExtension.extensionName = "FillStyleExtension";

// node_modules/@deck.gl/extensions/dist/clip/clip-extension.js
var defaultProps20 = {
  clipBounds: [0, 0, 1, 1],
  clipByInstance: void 0
};
var shaderFunction = (
  /* glsl */
  `
uniform clipUniforms {
  vec4 bounds;
} clip;

bool clip_isInBounds(vec2 position) {
  return position.x >= clip.bounds[0] && position.y >= clip.bounds[1] && position.x < clip.bounds[2] && position.y < clip.bounds[3];
}
`
);
var shaderModuleVs = {
  name: "clip",
  vs: shaderFunction,
  uniformTypes: {
    bounds: "vec4<f32>"
  }
};
var injectionVs = {
  "vs:#decl": (
    /* glsl */
    `
out float clip_isVisible;
`
  ),
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
  clip_isVisible = float(clip_isInBounds(geometry.worldPosition.xy));
`
  ),
  "fs:#decl": (
    /* glsl */
    `
in float clip_isVisible;
`
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
  if (clip_isVisible < 0.5) discard;
`
  )
};
var shaderModuleFs = {
  name: "clip",
  fs: shaderFunction,
  uniformTypes: {
    bounds: "vec4<f32>"
  }
};
var injectionFs = {
  "vs:#decl": (
    /* glsl */
    `
out vec2 clip_commonPosition;
`
  ),
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
  clip_commonPosition = geometry.position.xy;
`
  ),
  "fs:#decl": (
    /* glsl */
    `
in vec2 clip_commonPosition;
`
  ),
  "fs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
  if (!clip_isInBounds(clip_commonPosition)) discard;
`
  )
};
var ClipExtension = class extends layer_extension_default {
  getShaders() {
    let clipByInstance = "instancePositions" in this.getAttributeManager().attributes;
    if (this.props.clipByInstance !== void 0) {
      clipByInstance = Boolean(this.props.clipByInstance);
    }
    this.state.clipByInstance = clipByInstance;
    return clipByInstance ? {
      modules: [shaderModuleVs],
      inject: injectionVs
    } : {
      modules: [shaderModuleFs],
      inject: injectionFs
    };
  }
  /* eslint-disable camelcase */
  draw() {
    const { clipBounds } = this.props;
    const clipProps = {};
    if (this.state.clipByInstance) {
      clipProps.bounds = clipBounds;
    } else {
      const corner0 = this.projectPosition([clipBounds[0], clipBounds[1], 0]);
      const corner1 = this.projectPosition([clipBounds[2], clipBounds[3], 0]);
      clipProps.bounds = [
        Math.min(corner0[0], corner1[0]),
        Math.min(corner0[1], corner1[1]),
        Math.max(corner0[0], corner1[0]),
        Math.max(corner0[1], corner1[1])
      ];
    }
    this.setShaderModuleProps({ clip: clipProps });
  }
};
ClipExtension.defaultProps = defaultProps20;
ClipExtension.extensionName = "ClipExtension";
var clip_extension_default = ClipExtension;

// node_modules/@deck.gl/extensions/dist/collision-filter/shader-module.js
var vs5 = (
  /* glsl */
  `
in float collisionPriorities;

uniform sampler2D collision_texture;

uniform collisionUniforms {
  bool sort;
  bool enabled;
} collision;

vec2 collision_getCoords(vec4 position) {
  vec4 collision_clipspace = project_common_position_to_clipspace(position);
  return (1.0 + collision_clipspace.xy / collision_clipspace.w) / 2.0;
}

float collision_match(vec2 tex, vec3 pickingColor) {
  vec4 collision_pickingColor = texture(collision_texture, tex);
  float delta = dot(abs(collision_pickingColor.rgb - pickingColor), vec3(1.0));
  float e = 0.001;
  return step(delta, e);
}

float collision_isVisible(vec2 texCoords, vec3 pickingColor) {
  if (!collision.enabled) {
    return 1.0;
  }

  // Visibility test, sample area of 5x5 pixels in order to fade in/out.
  // Due to the locality, the lookups will be cached
  // This reduces the flicker present when objects are shown/hidden
  const int N = 2;
  float accumulator = 0.0;
  vec2 step = vec2(1.0 / project.viewportSize);

  const float floatN = float(N);
  vec2 delta = -floatN * step;
  for(int i = -N; i <= N; i++) {
    delta.x = -step.x * floatN;
    for(int j = -N; j <= N; j++) {
      accumulator += collision_match(texCoords + delta, pickingColor);
      delta.x += step.x;
    }
    delta.y += step.y;
  }

  float W = 2.0 * floatN + 1.0;
  return pow(accumulator / (W * W), 2.2);
}
`
);
var inject4 = {
  "vs:#decl": (
    /* glsl */
    `
  float collision_fade = 1.0;
`
  ),
  "vs:DECKGL_FILTER_GL_POSITION": (
    /* glsl */
    `
  if (collision.sort) {
    float collisionPriority = collisionPriorities;
    position.z = -0.001 * collisionPriority * position.w; // Support range -1000 -> 1000
  }

  if (collision.enabled) {
    vec4 collision_common_position = project_position(vec4(geometry.worldPosition, 1.0));
    vec2 collision_texCoords = collision_getCoords(collision_common_position);
    collision_fade = collision_isVisible(collision_texCoords, geometry.pickingColor / 255.0);
    if (collision_fade < 0.0001) {
      // Position outside clip space bounds to discard
      position = vec4(0.0, 0.0, 2.0, 1.0);
    }
  }
  `
  ),
  "vs:DECKGL_FILTER_COLOR": (
    /* glsl */
    `
  color.a *= collision_fade;
  `
  )
};
var getCollisionUniforms = (opts) => {
  if (!opts || !("dummyCollisionMap" in opts)) {
    return {};
  }
  const { enabled, collisionFBO, drawToCollisionMap, dummyCollisionMap } = opts;
  return {
    enabled: enabled && !drawToCollisionMap,
    sort: Boolean(drawToCollisionMap),
    collision_texture: !drawToCollisionMap && collisionFBO ? collisionFBO.colorAttachments[0] : dummyCollisionMap
  };
};
var shader_module_default2 = {
  name: "collision",
  dependencies: [project_default],
  vs: vs5,
  inject: inject4,
  getUniforms: getCollisionUniforms,
  uniformTypes: {
    sort: "i32",
    enabled: "i32"
  }
};

// node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-pass.js
var CollisionFilterPass = class extends LayersPass {
  renderCollisionMap(target, options) {
    const padding = 1;
    const clearColor = [0, 0, 0, 0];
    const scissorRect = [padding, padding, target.width - 2 * padding, target.height - 2 * padding];
    this.render({ ...options, clearColor, scissorRect, target, pass: "collision" });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: false,
      depthWriteEnabled: true,
      depthCompare: "less-equal"
    };
  }
  getShaderModuleProps() {
    return {
      collision: {
        drawToCollisionMap: true
      },
      picking: {
        isActive: 1,
        isAttribute: false
      },
      lighting: { enabled: false }
    };
  }
};

// node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-effect.js
var DOWNSCALE = 2;
var CollisionFilterEffect = class {
  constructor() {
    this.id = "collision-filter-effect";
    this.props = null;
    this.useInPicking = true;
    this.order = 1;
    this.channels = {};
    this.collisionFBOs = {};
  }
  setup(context) {
    this.context = context;
    const { device } = context;
    this.dummyCollisionMap = device.createTexture({ width: 1, height: 1 });
    this.collisionFilterPass = new CollisionFilterPass(device, { id: "default-collision-filter" });
  }
  preRender({ effects: allEffects, layers, layerFilter, viewports, onViewportActive, views, isPicking, preRenderStats = {} }) {
    var _a;
    const { device } = this.context;
    if (isPicking) {
      return;
    }
    const collisionLayers = layers.filter(
      // @ts-ignore
      ({ props: { visible, collisionEnabled } }) => visible && collisionEnabled
    );
    if (collisionLayers.length === 0) {
      this.channels = {};
      return;
    }
    const effects = allEffects == null ? void 0 : allEffects.filter((e2) => e2.useInPicking && preRenderStats[e2.id]);
    const maskEffectRendered = (_a = preRenderStats["mask-effect"]) == null ? void 0 : _a.didRender;
    const channels = this._groupByCollisionGroup(device, collisionLayers);
    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport) || maskEffectRendered;
    for (const collisionGroup in channels) {
      const collisionFBO = this.collisionFBOs[collisionGroup];
      const renderInfo = channels[collisionGroup];
      const [width, height] = device.canvasContext.getPixelSize();
      collisionFBO.resize({
        width: width / DOWNSCALE,
        height: height / DOWNSCALE
      });
      this._render(renderInfo, {
        effects,
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
    }
  }
  _render(renderInfo, { effects, layerFilter, onViewportActive, views, viewport, viewportChanged }) {
    const { collisionGroup } = renderInfo;
    const oldRenderInfo = this.channels[collisionGroup];
    if (!oldRenderInfo) {
      return;
    }
    const needsRender = viewportChanged || // If render info is new
    renderInfo === oldRenderInfo || // If sublayers have changed
    !deepEqual(oldRenderInfo.layers, renderInfo.layers, 1) || // If a sublayer's bounds have been updated
    renderInfo.layerBounds.some((b3, i) => !equals(b3, oldRenderInfo.layerBounds[i])) || // If a sublayer's isLoaded state has been updated
    renderInfo.allLayersLoaded !== oldRenderInfo.allLayersLoaded || // Some prop is in transition
    renderInfo.layers.some((layer) => layer.props.transitions);
    this.channels[collisionGroup] = renderInfo;
    if (needsRender) {
      this.lastViewport = viewport;
      const collisionFBO = this.collisionFBOs[collisionGroup];
      this.collisionFilterPass.renderCollisionMap(collisionFBO, {
        pass: "collision-filter",
        isPicking: true,
        layers: renderInfo.layers,
        effects,
        layerFilter,
        viewports: viewport ? [viewport] : [],
        onViewportActive,
        views,
        shaderModuleProps: {
          collision: {
            enabled: true,
            // To avoid feedback loop forming between Framebuffer and active Texture.
            dummyCollisionMap: this.dummyCollisionMap
          },
          project: {
            // @ts-expect-error TODO - assuming WebGL context
            devicePixelRatio: collisionFBO.device.canvasContext.getDevicePixelRatio() / DOWNSCALE
          }
        }
      });
    }
  }
  /**
   * Group layers by collisionGroup
   * Returns a map from collisionGroup to render info
   */
  _groupByCollisionGroup(device, collisionLayers) {
    const channelMap = {};
    for (const layer of collisionLayers) {
      const collisionGroup = layer.props.collisionGroup;
      let channelInfo = channelMap[collisionGroup];
      if (!channelInfo) {
        channelInfo = { collisionGroup, layers: [], layerBounds: [], allLayersLoaded: true };
        channelMap[collisionGroup] = channelInfo;
      }
      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
      if (!layer.isLoaded) {
        channelInfo.allLayersLoaded = false;
      }
    }
    for (const collisionGroup of Object.keys(channelMap)) {
      if (!this.collisionFBOs[collisionGroup]) {
        this.createFBO(device, collisionGroup);
      }
      if (!this.channels[collisionGroup]) {
        this.channels[collisionGroup] = channelMap[collisionGroup];
      }
    }
    for (const collisionGroup of Object.keys(this.collisionFBOs)) {
      if (!channelMap[collisionGroup]) {
        this.destroyFBO(collisionGroup);
      }
    }
    return channelMap;
  }
  getShaderModuleProps(layer) {
    const { collisionGroup, collisionEnabled } = layer.props;
    const { collisionFBOs, dummyCollisionMap } = this;
    const collisionFBO = collisionFBOs[collisionGroup];
    const enabled = collisionEnabled && Boolean(collisionFBO);
    return {
      collision: {
        enabled,
        collisionFBO,
        dummyCollisionMap
      }
    };
  }
  cleanup() {
    if (this.dummyCollisionMap) {
      this.dummyCollisionMap.delete();
      this.dummyCollisionMap = void 0;
    }
    this.channels = {};
    for (const collisionGroup of Object.keys(this.collisionFBOs)) {
      this.destroyFBO(collisionGroup);
    }
    this.collisionFBOs = {};
    this.lastViewport = void 0;
  }
  createFBO(device, collisionGroup) {
    const { width, height } = device.getDefaultCanvasContext().canvas;
    const collisionMap = device.createTexture({
      format: "rgba8unorm",
      width,
      height,
      sampler: {
        minFilter: "nearest",
        magFilter: "nearest",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    });
    const depthStencilAttachment = device.createTexture({
      format: "depth16unorm",
      width,
      height
    });
    this.collisionFBOs[collisionGroup] = device.createFramebuffer({
      id: `collision-${collisionGroup}`,
      width,
      height,
      colorAttachments: [collisionMap],
      depthStencilAttachment
    });
  }
  destroyFBO(collisionGroup) {
    var _a, _b;
    const fbo = this.collisionFBOs[collisionGroup];
    (_a = fbo.colorAttachments[0]) == null ? void 0 : _a.destroy();
    (_b = fbo.depthStencilAttachment) == null ? void 0 : _b.destroy();
    fbo.destroy();
    delete this.collisionFBOs[collisionGroup];
  }
};

// node_modules/@deck.gl/extensions/dist/collision-filter/collision-filter-extension.js
var defaultProps21 = {
  getCollisionPriority: { type: "accessor", value: 0 },
  collisionEnabled: true,
  collisionGroup: { type: "string", value: "default" },
  collisionTestProps: {}
};
var CollisionFilterExtension = class extends layer_extension_default {
  getShaders() {
    return { modules: [shader_module_default2] };
  }
  /* eslint-disable camelcase */
  draw({ shaderModuleProps }) {
    var _a;
    if ((_a = shaderModuleProps.collision) == null ? void 0 : _a.drawToCollisionMap) {
      this.props = this.clone(this.props.collisionTestProps).props;
    }
  }
  initializeState(context, extension) {
    var _a;
    if (this.getAttributeManager() === null) {
      return;
    }
    (_a = this.context.deck) == null ? void 0 : _a._addDefaultEffect(new CollisionFilterEffect());
    const attributeManager = this.getAttributeManager();
    attributeManager.add({
      collisionPriorities: {
        size: 1,
        stepMode: "dynamic",
        accessor: "getCollisionPriority"
      }
    });
  }
  getNeedsPickingBuffer() {
    return this.props.collisionEnabled;
  }
};
CollisionFilterExtension.defaultProps = defaultProps21;
CollisionFilterExtension.extensionName = "CollisionFilterExtension";

// node_modules/@deck.gl/extensions/dist/mask/shader-module.js
var uniformBlock8 = (
  /* glsl */
  `uniform maskUniforms {
  vec4 bounds;
  highp int channel;
  bool enabled;
  bool inverted;
  bool maskByInstance;
} mask;
`
);
var vertex3 = (
  /* glsl */
  `
vec2 mask_getCoords(vec4 position) {
  return (position.xy - mask.bounds.xy) / (mask.bounds.zw - mask.bounds.xy);
}
`
);
var vs6 = `
${uniformBlock8}
${vertex3}
`;
var fragment3 = (
  /* glsl */
  `
uniform sampler2D mask_texture;

bool mask_isInBounds(vec2 texCoords) {
  if (!mask.enabled) {
    return true;
  }
  vec4 maskColor = texture(mask_texture, texCoords);
  float maskValue = 1.0;
  if (mask.channel == 0) {
    maskValue = maskColor.r;
  } else if (mask.channel == 1) {
    maskValue = maskColor.g;
  } else if (mask.channel == 2) {
    maskValue = maskColor.b;
  } else if (mask.channel == 3) {
    maskValue = maskColor.a;
  }

  if (mask.inverted) {
    return maskValue >= 0.5;
  } else {
    return maskValue < 0.5;
  }
}
`
);
var fs5 = `
${uniformBlock8}
${fragment3}
`;
var inject5 = {
  "vs:#decl": (
    /* glsl */
    `
out vec2 mask_texCoords;
`
  ),
  "vs:#main-end": (
    /* glsl */
    `
   vec4 mask_common_position;
   if (mask.maskByInstance) {
     mask_common_position = project_position(vec4(geometry.worldPosition, 1.0));
   } else {
     mask_common_position = geometry.position;
   }
   mask_texCoords = mask_getCoords(mask_common_position);
`
  ),
  "fs:#decl": (
    /* glsl */
    `
in vec2 mask_texCoords;
`
  ),
  "fs:#main-start": (
    /* glsl */
    `
  if (mask.enabled) {
    bool mask = mask_isInBounds(mask_texCoords);

    // Debug: show extent of render target
    // fragColor = vec4(mask_texCoords, 0.0, 1.0);
    // fragColor = texture(mask_texture, mask_texCoords);

    if (!mask) discard;
  }
`
  )
};
var getMaskUniforms = (opts) => {
  if (opts && "maskMap" in opts) {
    return {
      mask_texture: opts.maskMap
    };
  }
  return opts || {};
};
var shader_module_default3 = {
  name: "mask",
  dependencies: [project_default],
  vs: vs6,
  fs: fs5,
  inject: inject5,
  getUniforms: getMaskUniforms,
  uniformTypes: {
    bounds: "vec4<f32>",
    channel: "i32",
    enabled: "i32",
    inverted: "i32",
    maskByInstance: "i32"
  }
};

// node_modules/@deck.gl/extensions/dist/mask/mask-pass.js
var MASK_BLENDING = {
  blendColorOperation: "subtract",
  blendColorSrcFactor: "zero",
  blendColorDstFactor: "one",
  blendAlphaOperation: "subtract",
  blendAlphaSrcFactor: "zero",
  blendAlphaDstFactor: "one"
};
var MaskPass = class extends LayersPass {
  constructor(device, props) {
    super(device, props);
    const { mapSize = 2048 } = props;
    this.maskMap = device.createTexture({
      format: "rgba8unorm",
      width: mapSize,
      height: mapSize,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      }
    });
    this.fbo = device.createFramebuffer({
      id: "maskmap",
      width: mapSize,
      height: mapSize,
      colorAttachments: [this.maskMap]
    });
  }
  render(options) {
    const colorMask = 2 ** options.channel;
    const clearColor = [255, 255, 255, 255];
    super.render({ ...options, clearColor, colorMask, target: this.fbo, pass: "mask" });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: true,
      depthCompare: "always",
      ...MASK_BLENDING
    };
  }
  shouldDrawLayer(layer) {
    return layer.props.operation.includes("mask");
  }
  delete() {
    this.fbo.delete();
    this.maskMap.delete();
  }
};

// node_modules/@deck.gl/extensions/dist/utils/projection-utils.js
function joinLayerBounds(layers, viewport) {
  const bounds = [Infinity, Infinity, -Infinity, -Infinity];
  for (const layer of layers) {
    const layerBounds = layer.getBounds();
    if (layerBounds) {
      const bottomLeftCommon = layer.projectPosition(layerBounds[0], { viewport, autoOffset: false });
      const topRightCommon = layer.projectPosition(layerBounds[1], { viewport, autoOffset: false });
      bounds[0] = Math.min(bounds[0], bottomLeftCommon[0]);
      bounds[1] = Math.min(bounds[1], bottomLeftCommon[1]);
      bounds[2] = Math.max(bounds[2], topRightCommon[0]);
      bounds[3] = Math.max(bounds[3], topRightCommon[1]);
    }
  }
  if (Number.isFinite(bounds[0])) {
    return bounds;
  }
  return null;
}
var MAX_VIEWPORT_SIZE = 2048;
function makeViewport(opts) {
  const { bounds, viewport, border = 0 } = opts;
  const { isGeospatial } = viewport;
  if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
    return null;
  }
  const centerWorld = viewport.unprojectPosition([
    (bounds[0] + bounds[2]) / 2,
    (bounds[1] + bounds[3]) / 2,
    0
  ]);
  let { width, height, zoom } = opts;
  if (zoom === void 0) {
    width = width - border * 2;
    height = height - border * 2;
    const scale7 = Math.min(width / (bounds[2] - bounds[0]), height / (bounds[3] - bounds[1]));
    zoom = Math.min(Math.log2(scale7), 20);
  } else if (!width || !height) {
    const scale7 = 2 ** zoom;
    width = Math.round(Math.abs(bounds[2] - bounds[0]) * scale7);
    height = Math.round(Math.abs(bounds[3] - bounds[1]) * scale7);
    const maxSize = MAX_VIEWPORT_SIZE - border * 2;
    if (width > maxSize || height > maxSize) {
      const r = maxSize / Math.max(width, height);
      width = Math.round(width * r);
      height = Math.round(height * r);
      zoom += Math.log2(r);
    }
  }
  return isGeospatial ? new web_mercator_viewport_default({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    longitude: centerWorld[0],
    latitude: centerWorld[1],
    zoom,
    orthographic: true
  }) : new orthographic_viewport_default({
    id: viewport.id,
    x: border,
    y: border,
    width,
    height,
    target: centerWorld,
    zoom,
    flipY: false
  });
}
function getViewportBounds(viewport, zRange) {
  let viewportBoundsWorld;
  if (zRange && zRange.length === 2) {
    const [minZ, maxZ] = zRange;
    const bounds0 = viewport.getBounds({ z: minZ });
    const bounds1 = viewport.getBounds({ z: maxZ });
    viewportBoundsWorld = [
      Math.min(bounds0[0], bounds1[0]),
      Math.min(bounds0[1], bounds1[1]),
      Math.max(bounds0[2], bounds1[2]),
      Math.max(bounds0[3], bounds1[3])
    ];
  } else {
    viewportBoundsWorld = viewport.getBounds();
  }
  const viewportBottomLeftCommon = viewport.projectPosition(viewportBoundsWorld.slice(0, 2));
  const viewportTopRightCommon = viewport.projectPosition(viewportBoundsWorld.slice(2, 4));
  return [
    viewportBottomLeftCommon[0],
    viewportBottomLeftCommon[1],
    viewportTopRightCommon[0],
    viewportTopRightCommon[1]
  ];
}
function getRenderBounds(layerBounds, viewport, zRange) {
  if (!layerBounds) {
    return [0, 0, 1, 1];
  }
  const viewportBounds = getViewportBounds(viewport, zRange);
  const paddedBounds = doubleBounds(viewportBounds);
  if (layerBounds[2] - layerBounds[0] <= paddedBounds[2] - paddedBounds[0] && layerBounds[3] - layerBounds[1] <= paddedBounds[3] - paddedBounds[1]) {
    return layerBounds;
  }
  return [
    Math.max(layerBounds[0], paddedBounds[0]),
    Math.max(layerBounds[1], paddedBounds[1]),
    Math.min(layerBounds[2], paddedBounds[2]),
    Math.min(layerBounds[3], paddedBounds[3])
  ];
}
function doubleBounds(bounds) {
  const dx = bounds[2] - bounds[0];
  const dy = bounds[3] - bounds[1];
  const centerX = (bounds[0] + bounds[2]) / 2;
  const centerY = (bounds[1] + bounds[3]) / 2;
  return [centerX - dx, centerY - dy, centerX + dx, centerY + dy];
}

// node_modules/@deck.gl/extensions/dist/mask/mask-effect.js
var MaskEffect = class {
  constructor() {
    this.id = "mask-effect";
    this.props = null;
    this.useInPicking = true;
    this.order = 0;
    this.channels = [];
    this.masks = null;
  }
  setup({ device }) {
    this.dummyMaskMap = device.createTexture({
      width: 1,
      height: 1
    });
    this.maskPass = new MaskPass(device, { id: "default-mask" });
    this.maskMap = this.maskPass.maskMap;
  }
  preRender({ layers, layerFilter, viewports, onViewportActive, views, isPicking }) {
    let didRender = false;
    if (isPicking) {
      return { didRender };
    }
    const maskLayers = layers.filter((l) => l.props.visible && l.props.operation.includes("mask"));
    if (maskLayers.length === 0) {
      this.masks = null;
      this.channels.length = 0;
      return { didRender };
    }
    this.masks = {};
    const channelMap = this._sortMaskChannels(maskLayers);
    const viewport = viewports[0];
    const viewportChanged = !this.lastViewport || !this.lastViewport.equals(viewport);
    if (viewport.resolution !== void 0) {
      log_default.warn("MaskExtension is not supported in GlobeView")();
      return { didRender };
    }
    for (const maskId in channelMap) {
      const result = this._renderChannel(channelMap[maskId], {
        layerFilter,
        onViewportActive,
        views,
        viewport,
        viewportChanged
      });
      didRender || (didRender = result);
    }
    return { didRender };
  }
  /* eslint-disable-next-line complexity */
  _renderChannel(channelInfo, { layerFilter, onViewportActive, views, viewport, viewportChanged }) {
    let didRender = false;
    const oldChannelInfo = this.channels[channelInfo.index];
    if (!oldChannelInfo) {
      return didRender;
    }
    const maskChanged = (
      // If a channel is new
      channelInfo === oldChannelInfo || // If sublayers have changed
      channelInfo.layers.length !== oldChannelInfo.layers.length || channelInfo.layers.some((layer, i) => (
        // Layer instance is updated
        // Layer props might have changed
        // Undetermined props could have an effect on the output geometry of a mask layer,
        // for example getRadius+updateTriggers, radiusScale, modelMatrix
        layer !== oldChannelInfo.layers[i] || // Some prop is in transition
        layer.props.transitions
      )) || // If a sublayer's positions have been updated, the cached bounds will change shallowly
      channelInfo.layerBounds.some((b3, i) => b3 !== oldChannelInfo.layerBounds[i])
    );
    channelInfo.bounds = oldChannelInfo.bounds;
    channelInfo.maskBounds = oldChannelInfo.maskBounds;
    this.channels[channelInfo.index] = channelInfo;
    if (maskChanged || viewportChanged) {
      this.lastViewport = viewport;
      const layerBounds = joinLayerBounds(channelInfo.layers, viewport);
      channelInfo.bounds = layerBounds && getRenderBounds(layerBounds, viewport);
      if (maskChanged || !equals(channelInfo.bounds, oldChannelInfo.bounds)) {
        const { maskPass, maskMap } = this;
        const maskViewport = layerBounds && makeViewport({
          bounds: channelInfo.bounds,
          viewport,
          width: maskMap.width,
          height: maskMap.height,
          border: 1
        });
        channelInfo.maskBounds = maskViewport ? maskViewport.getBounds() : [0, 0, 1, 1];
        maskPass.render({
          pass: "mask",
          channel: channelInfo.index,
          layers: channelInfo.layers,
          layerFilter,
          viewports: maskViewport ? [maskViewport] : [],
          onViewportActive,
          views,
          shaderModuleProps: {
            project: {
              devicePixelRatio: 1
            }
          }
        });
        didRender = true;
      }
    }
    this.masks[channelInfo.id] = {
      index: channelInfo.index,
      bounds: channelInfo.maskBounds,
      coordinateOrigin: channelInfo.coordinateOrigin,
      coordinateSystem: channelInfo.coordinateSystem
    };
    return didRender;
  }
  /**
   * Find a channel to render each mask into
   * If a maskId already exists, diff and update the existing channel
   * Otherwise replace a removed mask
   * Otherwise create a new channel
   * Returns a map from mask layer id to channel info
   */
  _sortMaskChannels(maskLayers) {
    const channelMap = {};
    let channelCount = 0;
    for (const layer of maskLayers) {
      const { id } = layer.root;
      let channelInfo = channelMap[id];
      if (!channelInfo) {
        if (++channelCount > 4) {
          log_default.warn("Too many mask layers. The max supported is 4")();
          continue;
        }
        channelInfo = {
          id,
          index: this.channels.findIndex((c2) => (c2 == null ? void 0 : c2.id) === id),
          layers: [],
          layerBounds: [],
          coordinateOrigin: layer.root.props.coordinateOrigin,
          coordinateSystem: layer.root.props.coordinateSystem
        };
        channelMap[id] = channelInfo;
      }
      channelInfo.layers.push(layer);
      channelInfo.layerBounds.push(layer.getBounds());
    }
    for (let i = 0; i < 4; i++) {
      const channelInfo = this.channels[i];
      if (!channelInfo || !(channelInfo.id in channelMap)) {
        this.channels[i] = null;
      }
    }
    for (const maskId in channelMap) {
      const channelInfo = channelMap[maskId];
      if (channelInfo.index < 0) {
        channelInfo.index = this.channels.findIndex((c2) => !c2);
        this.channels[channelInfo.index] = channelInfo;
      }
    }
    return channelMap;
  }
  getShaderModuleProps() {
    return {
      mask: {
        maskMap: this.masks ? this.maskMap : this.dummyMaskMap,
        maskChannels: this.masks
      }
    };
  }
  cleanup() {
    if (this.dummyMaskMap) {
      this.dummyMaskMap.delete();
      this.dummyMaskMap = void 0;
    }
    if (this.maskPass) {
      this.maskPass.delete();
      this.maskPass = void 0;
      this.maskMap = void 0;
    }
    this.lastViewport = void 0;
    this.masks = null;
    this.channels.length = 0;
  }
};

// node_modules/@deck.gl/extensions/dist/mask/mask-extension.js
var defaultProps22 = {
  maskId: "",
  maskByInstance: void 0,
  maskInverted: false
};
var MaskExtension = class extends layer_extension_default {
  initializeState() {
    var _a;
    (_a = this.context.deck) == null ? void 0 : _a._addDefaultEffect(new MaskEffect());
  }
  getShaders() {
    let maskByInstance = "instancePositions" in this.getAttributeManager().attributes;
    if (this.props.maskByInstance !== void 0) {
      maskByInstance = Boolean(this.props.maskByInstance);
    }
    this.state.maskByInstance = maskByInstance;
    return {
      modules: [shader_module_default3]
    };
  }
  /* eslint-disable camelcase */
  draw({ context, shaderModuleProps }) {
    const maskProps = {};
    maskProps.maskByInstance = Boolean(this.state.maskByInstance);
    const { maskId, maskInverted } = this.props;
    const { maskChannels } = shaderModuleProps.mask || {};
    const { viewport } = context;
    if (maskChannels && maskChannels[maskId]) {
      const { index, bounds, coordinateOrigin: fromCoordinateOrigin } = maskChannels[maskId];
      let { coordinateSystem: fromCoordinateSystem } = maskChannels[maskId];
      maskProps.enabled = true;
      maskProps.channel = index;
      maskProps.inverted = maskInverted;
      if (fromCoordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
        fromCoordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
      }
      const opts = { modelMatrix: null, fromCoordinateOrigin, fromCoordinateSystem };
      const bl = this.projectPosition([bounds[0], bounds[1], 0], opts);
      const tr = this.projectPosition([bounds[2], bounds[3], 0], opts);
      maskProps.bounds = [bl[0], bl[1], tr[0], tr[1]];
    } else {
      if (maskId) {
        log_default.warn(`Could not find a mask layer with id: ${maskId}`)();
      }
      maskProps.enabled = false;
    }
    this.setShaderModuleProps({ mask: maskProps });
  }
};
MaskExtension.defaultProps = defaultProps22;
MaskExtension.extensionName = "MaskExtension";

// node_modules/@deck.gl/extensions/dist/terrain/shader-module.js
var TERRAIN_MODE = {
  NONE: 0,
  /** A terrain layer rendering encoded ground elevation into the height map */
  WRITE_HEIGHT_MAP: 1,
  /** An offset layer reading encoded ground elevation from the height map */
  USE_HEIGHT_MAP: 2,
  /** A terrain layer rendering to screen, using the cover fbo overlaid with its own texture */
  USE_COVER: 3,
  /** A terrain layer rendering to screen, using the cover fbo as texture */
  USE_COVER_ONLY: 4,
  /** Draped layer is rendered into a texture, and never to screen */
  SKIP: 5
};
var TERRAIN_MODE_CONSTANTS = Object.keys(TERRAIN_MODE).map((key) => `const float TERRAIN_MODE_${key} = ${TERRAIN_MODE[key]}.0;`).join("\n");
var uniformBlock9 = (
  // eslint-disable-next-line prefer-template
  TERRAIN_MODE_CONSTANTS + /* glsl */
  `
uniform terrainUniforms {
  float mode;
  vec4 bounds;
} terrain;

uniform sampler2D terrain_map;
`
);
var terrainModule = {
  name: "terrain",
  dependencies: [project_default],
  // eslint-disable-next-line prefer-template
  vs: uniformBlock9 + /* glsl */
  "out vec3 commonPos;",
  // eslint-disable-next-line prefer-template
  fs: uniformBlock9 + /* glsl */
  "in vec3 commonPos;",
  inject: {
    "vs:#main-start": (
      /* glsl */
      `
if (terrain.mode == TERRAIN_MODE_SKIP) {
  gl_Position = vec4(0.0);
  return;
}
`
    ),
    "vs:DECKGL_FILTER_GL_POSITION": (
      /* glsl */
      `
commonPos = geometry.position.xyz;
if (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;
  position = vec4(texCoords * 2.0 - 1.0, 0.0, 1.0);
  commonPos.z += project.commonOrigin.z;
}
if (terrain.mode == TERRAIN_MODE_USE_HEIGHT_MAP) {
  vec3 anchor = geometry.worldPosition;
  anchor.z = 0.0;
  vec3 anchorCommon = project_position(anchor);
  vec2 texCoords = (anchorCommon.xy - terrain.bounds.xy) / terrain.bounds.zw;
  if (texCoords.x >= 0.0 && texCoords.y >= 0.0 && texCoords.x <= 1.0 && texCoords.y <= 1.0) {
    float terrainZ = texture(terrain_map, texCoords).r;
    geometry.position.z += terrainZ;
    position = project_common_position_to_clipspace(geometry.position);
  }
}
    `
    ),
    "fs:#main-start": (
      /* glsl */
      `
if (terrain.mode == TERRAIN_MODE_WRITE_HEIGHT_MAP) {
  fragColor = vec4(commonPos.z, 0.0, 0.0, 1.0);
  return;
}
    `
    ),
    "fs:DECKGL_FILTER_COLOR": (
      /* glsl */
      `
if ((terrain.mode == TERRAIN_MODE_USE_COVER) || (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY)) {
  vec2 texCoords = (commonPos.xy - terrain.bounds.xy) / terrain.bounds.zw;
  vec4 pixel = texture(terrain_map, texCoords);
  if (terrain.mode == TERRAIN_MODE_USE_COVER_ONLY) {
    color = pixel;
  } else {
    // pixel is premultiplied
    color = pixel + color * (1.0 - pixel.a);
  }
  return;
}
    `
    )
  },
  // eslint-disable-next-line complexity
  getUniforms: (opts = {}) => {
    if ("dummyHeightMap" in opts) {
      const { drawToTerrainHeightMap, heightMap, heightMapBounds, dummyHeightMap, terrainCover, useTerrainHeightMap, terrainSkipRender } = opts;
      const projectUniforms = project_default.getUniforms(opts.project);
      const { commonOrigin } = projectUniforms;
      let mode = terrainSkipRender ? TERRAIN_MODE.SKIP : TERRAIN_MODE.NONE;
      let sampler = dummyHeightMap;
      let bounds = null;
      if (drawToTerrainHeightMap) {
        mode = TERRAIN_MODE.WRITE_HEIGHT_MAP;
        bounds = heightMapBounds;
      } else if (useTerrainHeightMap && heightMap) {
        mode = TERRAIN_MODE.USE_HEIGHT_MAP;
        sampler = heightMap;
        bounds = heightMapBounds;
      } else if (terrainCover) {
        const fbo = opts.isPicking ? terrainCover.getPickingFramebuffer() : terrainCover.getRenderFramebuffer();
        sampler = fbo == null ? void 0 : fbo.colorAttachments[0].texture;
        if (opts.isPicking) {
          mode = TERRAIN_MODE.SKIP;
        }
        if (sampler) {
          mode = mode === TERRAIN_MODE.SKIP ? TERRAIN_MODE.USE_COVER_ONLY : TERRAIN_MODE.USE_COVER;
          bounds = terrainCover.bounds;
        } else {
          sampler = dummyHeightMap;
        }
      }
      return {
        mode,
        terrain_map: sampler,
        // Convert bounds to the common space, as [minX, minY, width, height]
        bounds: bounds ? [
          bounds[0] - commonOrigin[0],
          bounds[1] - commonOrigin[1],
          bounds[2] - bounds[0],
          bounds[3] - bounds[1]
        ] : [0, 0, 0, 0]
      };
    }
    return {};
  },
  uniformTypes: {
    mode: "f32",
    bounds: "vec4<f32>"
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/utils.js
function createRenderTarget(device, opts) {
  return device.createFramebuffer({
    id: opts.id,
    colorAttachments: [
      device.createTexture({
        id: opts.id,
        ...opts.float && {
          format: "rgba32float",
          type: 5126
        },
        dimension: "2d",
        width: 1,
        height: 1,
        sampler: opts.interpolate === false ? {
          minFilter: "nearest",
          magFilter: "nearest"
        } : {
          minFilter: "linear",
          magFilter: "linear"
        }
      })
    ]
  });
}

// node_modules/@deck.gl/extensions/dist/terrain/terrain-cover.js
var TerrainCover = class {
  constructor(targetLayer) {
    this.isDirty = true;
    this.renderViewport = null;
    this.bounds = null;
    this.layers = [];
    this.targetBounds = null;
    this.targetBoundsCommon = null;
    this.targetLayer = targetLayer;
    this.tile = getTile(targetLayer);
  }
  get id() {
    return this.targetLayer.id;
  }
  /** returns true if the target layer is still in use (i.e. not finalized) */
  get isActive() {
    return Boolean(this.targetLayer.getCurrentLayer());
  }
  shouldUpdate({ targetLayer, viewport, layers, layerNeedsRedraw }) {
    if (targetLayer) {
      this.targetLayer = targetLayer;
    }
    const sizeChanged = viewport ? this._updateViewport(viewport) : false;
    let layersChanged = layers ? this._updateLayers(layers) : false;
    if (layerNeedsRedraw) {
      for (const id of this.layers) {
        if (layerNeedsRedraw[id]) {
          layersChanged = true;
          break;
        }
      }
    }
    return layersChanged || sizeChanged;
  }
  /** Compare layers with the last version. Only rerender if necessary. */
  _updateLayers(layers) {
    let needsRedraw = false;
    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;
    if (layers.length !== this.layers.length) {
      needsRedraw = true;
    } else {
      for (let i = 0; i < layers.length; i++) {
        const id = layers[i].id;
        if (id !== this.layers[i]) {
          needsRedraw = true;
          break;
        }
      }
    }
    if (needsRedraw) {
      this.layers = layers.map((layer) => layer.id);
    }
    return needsRedraw;
  }
  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */
  // eslint-disable-next-line max-statements
  _updateViewport(viewport) {
    var _a;
    const targetLayer = this.targetLayer;
    let shouldRedraw = false;
    if (this.tile && "boundingBox" in this.tile) {
      if (!this.targetBounds) {
        shouldRedraw = true;
        this.targetBounds = this.tile.boundingBox;
        const bottomLeftCommon = viewport.projectPosition(this.targetBounds[0]);
        const topRightCommon = viewport.projectPosition(this.targetBounds[1]);
        this.targetBoundsCommon = [
          bottomLeftCommon[0],
          bottomLeftCommon[1],
          topRightCommon[0],
          topRightCommon[1]
        ];
      }
    } else if (this.targetBounds !== targetLayer.getBounds()) {
      shouldRedraw = true;
      this.targetBounds = targetLayer.getBounds();
      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);
    }
    if (!this.targetBoundsCommon) {
      return false;
    }
    const newZoom = Math.ceil(viewport.zoom + 0.5);
    if (this.tile) {
      this.bounds = this.targetBoundsCommon;
    } else {
      const oldZoom = (_a = this.renderViewport) == null ? void 0 : _a.zoom;
      shouldRedraw = shouldRedraw || newZoom !== oldZoom;
      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);
      const oldBounds = this.bounds;
      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);
      this.bounds = newBounds;
    }
    if (shouldRedraw) {
      this.renderViewport = makeViewport({
        bounds: this.bounds,
        zoom: newZoom,
        viewport
      });
    }
    return shouldRedraw;
  }
  getRenderFramebuffer() {
    if (!this.renderViewport || this.layers.length === 0) {
      return null;
    }
    if (!this.fbo) {
      this.fbo = createRenderTarget(this.targetLayer.context.device, { id: this.id });
    }
    return this.fbo;
  }
  getPickingFramebuffer() {
    if (!this.renderViewport || this.layers.length === 0 && !this.targetLayer.props.pickable) {
      return null;
    }
    if (!this.pickingFbo) {
      this.pickingFbo = createRenderTarget(this.targetLayer.context.device, {
        id: `${this.id}-picking`,
        interpolate: false
      });
    }
    return this.pickingFbo;
  }
  filterLayers(layers) {
    return layers.filter(({ id }) => this.layers.includes(id));
  }
  delete() {
    const { fbo, pickingFbo } = this;
    if (fbo) {
      fbo.colorAttachments[0].destroy();
      fbo.destroy();
    }
    if (pickingFbo) {
      pickingFbo.colorAttachments[0].destroy();
      pickingFbo.destroy();
    }
  }
};
function getIntersectingLayers(sourceTile, layers) {
  return layers.filter((layer) => {
    const tile = getTile(layer);
    if (tile) {
      return intersect(sourceTile.boundingBox, tile.boundingBox);
    }
    return true;
  });
}
function getTile(layer) {
  while (layer) {
    const { tile } = layer.props;
    if (tile) {
      return tile;
    }
    layer = layer.parent;
  }
  return null;
}
function intersect(b1, b22) {
  if (b1 && b22) {
    return b1[0][0] < b22[1][0] && b22[0][0] < b1[1][0] && b1[0][1] < b22[1][1] && b22[0][1] < b1[1][1];
  }
  return false;
}

// node_modules/@deck.gl/extensions/dist/terrain/terrain-pass.js
var TERRAIN_BLENDING = {
  blendColorOperation: "max",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "one",
  blendAlphaOperation: "max",
  blendAlphaSrcFactor: "one",
  blendAlphaDstFactor: "one"
};
var TerrainPass = class extends LayersPass {
  getRenderableLayers(viewport, opts) {
    const { layers } = opts;
    const result = [];
    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts, true);
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {
        result.push(layer);
      }
    }
    return result;
  }
  renderHeightMap(heightMap, opts) {
    const target = heightMap.getRenderFramebuffer();
    const viewport = heightMap.renderViewport;
    if (!target || !viewport) {
      return;
    }
    target.resize(viewport);
    this.render({
      ...opts,
      target,
      pass: "terrain-height-map",
      layers: opts.layers,
      viewports: [viewport],
      effects: [],
      clearColor: [0, 0, 0, 0]
    });
  }
  renderTerrainCover(terrainCover, opts) {
    const target = terrainCover.getRenderFramebuffer();
    const viewport = terrainCover.renderViewport;
    if (!target || !viewport) {
      return;
    }
    const layers = terrainCover.filterLayers(opts.layers);
    target.resize(viewport);
    this.render({
      ...opts,
      target,
      pass: `terrain-cover-${terrainCover.id}`,
      layers,
      effects: [],
      viewports: [viewport],
      clearColor: [0, 0, 0, 0]
    });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    return {
      ...layer.props.parameters,
      blend: true,
      depthCompare: "always",
      ...layer.props.operation.includes("terrain") && TERRAIN_BLENDING
    };
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    return {
      terrain: {
        project: otherShaderModuleProps.project
      }
    };
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/terrain-picking-pass.js
var TerrainPickingPass = class extends PickLayersPass {
  constructor() {
    super(...arguments);
    this.drawParameters = {};
  }
  getRenderableLayers(viewport, opts) {
    const { layers } = opts;
    const result = [];
    this.drawParameters = {};
    this._resetColorEncoder(opts.pickZ);
    const drawParamsByIndex = this._getDrawLayerParams(viewport, opts);
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      if (!layer.isComposite && drawParamsByIndex[i].shouldDrawLayer) {
        result.push(layer);
        this.drawParameters[layer.id] = drawParamsByIndex[i].layerParameters;
      }
    }
    return result;
  }
  renderTerrainCover(terrainCover, opts) {
    const target = terrainCover.getPickingFramebuffer();
    const viewport = terrainCover.renderViewport;
    if (!target || !viewport) {
      return;
    }
    const layers = terrainCover.filterLayers(opts.layers);
    const terrainLayer = terrainCover.targetLayer;
    if (terrainLayer.props.pickable) {
      layers.unshift(terrainLayer);
    }
    target.resize(viewport);
    this.render({
      ...opts,
      pickingFBO: target,
      pass: `terrain-cover-picking-${terrainCover.id}`,
      layers,
      effects: [],
      viewports: [viewport],
      // Disable the default culling because TileLayer would cull sublayers based on the screen viewport,
      // not the viewport of the terrain cover. Culling is already done by `terrainCover.filterLayers`
      cullRect: void 0,
      deviceRect: viewport,
      pickZ: false
    });
  }
  getLayerParameters(layer, layerIndex, viewport) {
    let parameters2;
    if (this.drawParameters[layer.id]) {
      parameters2 = this.drawParameters[layer.id];
    } else {
      parameters2 = super.getLayerParameters(layer, layerIndex, viewport);
      parameters2.blend = true;
    }
    return { ...parameters2, depthCompare: "always" };
  }
  getShaderModuleProps(layer, effects, otherShaderModuleProps) {
    const base = super.getShaderModuleProps(layer, effects, otherShaderModuleProps);
    return {
      ...base,
      terrain: {
        project: otherShaderModuleProps.project
      }
    };
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/height-map-builder.js
var MAP_MAX_SIZE = 2048;
var HeightMapBuilder = class {
  static isSupported(device) {
    return device.isTextureFormatRenderable("rgba32float");
  }
  constructor(device) {
    this.renderViewport = null;
    this.bounds = null;
    this.layers = [];
    this.layersBounds = [];
    this.layersBoundsCommon = null;
    this.lastViewport = null;
    this.device = device;
  }
  /** Returns the height map framebuffer for read/write access.
   * Returns null when the texture is invalid.
   */
  getRenderFramebuffer() {
    if (!this.renderViewport) {
      return null;
    }
    if (!this.fbo) {
      this.fbo = createRenderTarget(this.device, { id: "height-map", float: true });
    }
    return this.fbo;
  }
  /** Called every render cycle to check if the framebuffer needs update */
  shouldUpdate({ layers, viewport }) {
    const layersChanged = layers.length !== this.layers.length || layers.some((layer, i) => (
      // Layer instance is updated
      // Layer props might have changed
      // Undetermined props could have an effect on the output geometry of a terrain source,
      // for example getElevation+updateTriggers, elevationScale, modelMatrix
      layer !== this.layers[i] || // Some prop is in transition
      layer.props.transitions || // Layer's geometry bounds have changed
      layer.getBounds() !== this.layersBounds[i]
    ));
    if (layersChanged) {
      this.layers = layers;
      this.layersBounds = layers.map((layer) => layer.getBounds());
      this.layersBoundsCommon = joinLayerBounds(layers, viewport);
    }
    const viewportChanged = !this.lastViewport || !viewport.equals(this.lastViewport);
    if (!this.layersBoundsCommon) {
      this.renderViewport = null;
    } else if (layersChanged || viewportChanged) {
      const bounds = getRenderBounds(this.layersBoundsCommon, viewport);
      if (bounds[2] <= bounds[0] || bounds[3] <= bounds[1]) {
        this.renderViewport = null;
        return false;
      }
      this.bounds = bounds;
      this.lastViewport = viewport;
      const scale7 = viewport.scale;
      const pixelWidth = (bounds[2] - bounds[0]) * scale7;
      const pixelHeight = (bounds[3] - bounds[1]) * scale7;
      this.renderViewport = pixelWidth > 0 || pixelHeight > 0 ? makeViewport({
        // It's not important whether the geometry is visible in this viewport, because
        // vertices will not use the standard project_to_clipspace in the DRAW_TO_HEIGHT_MAP shader
        // However the viewport must have the same center and zoom as the screen viewport
        // So that projection uniforms used for calculating z are the same
        bounds: [
          viewport.center[0] - 1,
          viewport.center[1] - 1,
          viewport.center[0] + 1,
          viewport.center[1] + 1
        ],
        zoom: viewport.zoom,
        width: Math.min(pixelWidth, MAP_MAX_SIZE),
        height: Math.min(pixelHeight, MAP_MAX_SIZE),
        viewport
      }) : null;
      return true;
    }
    return false;
  }
  delete() {
    if (this.fbo) {
      this.fbo.colorAttachments[0].delete();
      this.fbo.delete();
    }
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/terrain-effect.js
var TerrainEffect = class {
  constructor() {
    this.id = "terrain-effect";
    this.props = null;
    this.useInPicking = true;
    this.isPicking = false;
    this.isDrapingEnabled = false;
    this.terrainCovers = /* @__PURE__ */ new Map();
  }
  setup({ device, deck }) {
    this.dummyHeightMap = device.createTexture({
      width: 1,
      height: 1,
      data: new Uint8Array([0, 0, 0, 0])
    });
    this.terrainPass = new TerrainPass(device, { id: "terrain" });
    this.terrainPickingPass = new TerrainPickingPass(device, { id: "terrain-picking" });
    if (HeightMapBuilder.isSupported(device)) {
      this.heightMap = new HeightMapBuilder(device);
    } else {
      log_default.warn("Terrain offset mode is not supported by this browser")();
    }
    deck._addDefaultShaderModule(terrainModule);
  }
  preRender(opts) {
    if (opts.pickZ) {
      this.isDrapingEnabled = false;
      return;
    }
    const { viewports } = opts;
    const isPicking = opts.pass.startsWith("picking");
    this.isPicking = isPicking;
    this.isDrapingEnabled = true;
    const viewport = viewports[0];
    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);
    const terrainLayers = layers.filter((l) => l.props.operation.includes("terrain"));
    if (terrainLayers.length === 0) {
      return;
    }
    if (!isPicking) {
      const offsetLayers = layers.filter((l) => l.state.terrainDrawMode === "offset");
      if (offsetLayers.length > 0) {
        this._updateHeightMap(terrainLayers, viewport, opts);
      }
    }
    const drapeLayers = layers.filter((l) => l.state.terrainDrawMode === "drape");
    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);
  }
  getShaderModuleProps(layer, otherShaderModuleProps) {
    var _a, _b, _c;
    const { terrainDrawMode } = layer.state;
    return {
      terrain: {
        project: otherShaderModuleProps.project,
        isPicking: this.isPicking,
        heightMap: ((_b = (_a = this.heightMap) == null ? void 0 : _a.getRenderFramebuffer()) == null ? void 0 : _b.colorAttachments[0].texture) || null,
        heightMapBounds: (_c = this.heightMap) == null ? void 0 : _c.bounds,
        dummyHeightMap: this.dummyHeightMap,
        terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,
        useTerrainHeightMap: terrainDrawMode === "offset",
        terrainSkipRender: terrainDrawMode === "drape" || !layer.props.operation.includes("draw")
      }
    };
  }
  cleanup({ deck }) {
    if (this.dummyHeightMap) {
      this.dummyHeightMap.delete();
      this.dummyHeightMap = void 0;
    }
    if (this.heightMap) {
      this.heightMap.delete();
      this.heightMap = void 0;
    }
    for (const terrainCover of this.terrainCovers.values()) {
      terrainCover.delete();
    }
    this.terrainCovers.clear();
    deck._removeDefaultShaderModule(terrainModule);
  }
  _updateHeightMap(terrainLayers, viewport, opts) {
    if (!this.heightMap) {
      return;
    }
    const shouldUpdate = this.heightMap.shouldUpdate({ layers: terrainLayers, viewport });
    if (!shouldUpdate) {
      return;
    }
    this.terrainPass.renderHeightMap(this.heightMap, {
      ...opts,
      layers: terrainLayers,
      shaderModuleProps: {
        terrain: {
          heightMapBounds: this.heightMap.bounds,
          dummyHeightMap: this.dummyHeightMap,
          drawToTerrainHeightMap: true
        },
        project: {
          devicePixelRatio: 1
        }
      }
    });
  }
  _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {
    const layerNeedsRedraw = {};
    for (const layer of drapeLayers) {
      if (layer.state.terrainCoverNeedsRedraw) {
        layerNeedsRedraw[layer.id] = true;
        layer.state.terrainCoverNeedsRedraw = false;
      }
    }
    for (const terrainCover of this.terrainCovers.values()) {
      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({ layerNeedsRedraw });
    }
    for (const layer of terrainLayers) {
      this._updateTerrainCover(layer, drapeLayers, viewport, opts);
    }
    if (!this.isPicking) {
      this._pruneTerrainCovers();
    }
  }
  _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {
    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;
    let terrainCover = this.terrainCovers.get(terrainLayer.id);
    if (!terrainCover) {
      terrainCover = new TerrainCover(terrainLayer);
      this.terrainCovers.set(terrainLayer.id, terrainCover);
    }
    try {
      const isDirty = terrainCover.shouldUpdate({
        targetLayer: terrainLayer,
        viewport,
        layers: drapeLayers
      });
      if (this.isPicking || terrainCover.isDirty || isDirty) {
        renderPass.renderTerrainCover(terrainCover, {
          ...opts,
          layers: drapeLayers,
          shaderModuleProps: {
            terrain: {
              dummyHeightMap: this.dummyHeightMap,
              terrainSkipRender: false
            },
            project: {
              devicePixelRatio: 1
            }
          }
        });
        if (!this.isPicking) {
          terrainCover.isDirty = false;
        }
      }
    } catch (err) {
      terrainLayer.raiseError(err, `Error rendering terrain cover ${terrainCover.id}`);
    }
  }
  _pruneTerrainCovers() {
    const idsToRemove = [];
    for (const [id, terrainCover] of this.terrainCovers) {
      if (!terrainCover.isActive) {
        idsToRemove.push(id);
      }
    }
    for (const id of idsToRemove) {
      this.terrainCovers.delete(id);
    }
  }
};

// node_modules/@deck.gl/extensions/dist/terrain/terrain-extension.js
var defaultProps23 = {
  terrainDrawMode: void 0
};
var TerrainExtension = class extends layer_extension_default {
  getShaders() {
    return {
      modules: [terrainModule]
    };
  }
  initializeState() {
    var _a;
    (_a = this.context.deck) == null ? void 0 : _a._addDefaultEffect(new TerrainEffect());
  }
  updateState(params) {
    var _a;
    const { props, oldProps } = params;
    if (this.state.terrainDrawMode && props.terrainDrawMode === oldProps.terrainDrawMode && // @ts-ignore `extruded` may not exist in props
    props.extruded === oldProps.extruded) {
      return;
    }
    let { terrainDrawMode } = props;
    if (!terrainDrawMode) {
      const is3d = this.props.extruded;
      const attributes = (_a = this.getAttributeManager()) == null ? void 0 : _a.attributes;
      const hasAnchor = attributes && "instancePositions" in attributes;
      terrainDrawMode = is3d || hasAnchor ? "offset" : "drape";
    }
    this.setState({ terrainDrawMode });
  }
  onNeedsRedraw() {
    const state = this.state;
    if (state.terrainDrawMode === "drape") {
      state.terrainCoverNeedsRedraw = true;
    }
  }
};
TerrainExtension.defaultProps = defaultProps23;
TerrainExtension.extensionName = "TerrainExtension";

// node_modules/@loaders.gl/gis/dist/lib/binary-features/flat-geojson-to-binary.js
function flatGeojsonToBinary(features2, geometryInfo, options) {
  const propArrayTypes = extractNumericPropTypes(features2);
  const numericPropKeys = Object.keys(propArrayTypes).filter((k) => propArrayTypes[k] !== Array);
  return fillArrays(features2, {
    propArrayTypes,
    ...geometryInfo
  }, {
    numericPropKeys: options && options.numericPropKeys || numericPropKeys,
    PositionDataType: options ? options.PositionDataType : Float32Array,
    triangulate: options ? options.triangulate : true
  });
}
function extractNumericPropTypes(features2) {
  const propArrayTypes = {};
  for (const feature2 of features2) {
    if (feature2.properties) {
      for (const key in feature2.properties) {
        const val = feature2.properties[key];
        propArrayTypes[key] = deduceArrayType(val, propArrayTypes[key]);
      }
    }
  }
  return propArrayTypes;
}
function fillArrays(features2, geometryInfo, options) {
  const { pointPositionsCount, pointFeaturesCount, linePositionsCount, linePathsCount, lineFeaturesCount, polygonPositionsCount, polygonObjectsCount, polygonRingsCount, polygonFeaturesCount, propArrayTypes, coordLength } = geometryInfo;
  const { numericPropKeys = [], PositionDataType = Float32Array, triangulate = true } = options;
  const hasGlobalId = features2[0] && "id" in features2[0];
  const GlobalFeatureIdsDataType = features2.length > 65535 ? Uint32Array : Uint16Array;
  const points = {
    type: "Point",
    positions: new PositionDataType(pointPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(pointPositionsCount),
    featureIds: pointFeaturesCount > 65535 ? new Uint32Array(pointPositionsCount) : new Uint16Array(pointPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const lines = {
    type: "LineString",
    pathIndices: linePositionsCount > 65535 ? new Uint32Array(linePathsCount + 1) : new Uint16Array(linePathsCount + 1),
    positions: new PositionDataType(linePositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(linePositionsCount),
    featureIds: lineFeaturesCount > 65535 ? new Uint32Array(linePositionsCount) : new Uint16Array(linePositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  const polygons = {
    type: "Polygon",
    polygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonObjectsCount + 1) : new Uint16Array(polygonObjectsCount + 1),
    primitivePolygonIndices: polygonPositionsCount > 65535 ? new Uint32Array(polygonRingsCount + 1) : new Uint16Array(polygonRingsCount + 1),
    positions: new PositionDataType(polygonPositionsCount * coordLength),
    globalFeatureIds: new GlobalFeatureIdsDataType(polygonPositionsCount),
    featureIds: polygonFeaturesCount > 65535 ? new Uint32Array(polygonPositionsCount) : new Uint16Array(polygonPositionsCount),
    numericProps: {},
    properties: [],
    fields: []
  };
  if (triangulate) {
    polygons.triangles = [];
  }
  for (const object of [points, lines, polygons]) {
    for (const propName of numericPropKeys) {
      const T = propArrayTypes[propName];
      object.numericProps[propName] = new T(object.positions.length / coordLength);
    }
  }
  lines.pathIndices[linePathsCount] = linePositionsCount;
  polygons.polygonIndices[polygonObjectsCount] = polygonPositionsCount;
  polygons.primitivePolygonIndices[polygonRingsCount] = polygonPositionsCount;
  const indexMap = {
    pointPosition: 0,
    pointFeature: 0,
    linePosition: 0,
    linePath: 0,
    lineFeature: 0,
    polygonPosition: 0,
    polygonObject: 0,
    polygonRing: 0,
    polygonFeature: 0,
    feature: 0
  };
  for (const feature2 of features2) {
    const geometry = feature2.geometry;
    const properties = feature2.properties || {};
    switch (geometry.type) {
      case "Point":
        handlePoint(geometry, points, indexMap, coordLength, properties);
        points.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          points.fields.push({ id: feature2.id });
        }
        indexMap.pointFeature++;
        break;
      case "LineString":
        handleLineString(geometry, lines, indexMap, coordLength, properties);
        lines.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          lines.fields.push({ id: feature2.id });
        }
        indexMap.lineFeature++;
        break;
      case "Polygon":
        handlePolygon(geometry, polygons, indexMap, coordLength, properties);
        polygons.properties.push(keepStringProperties(properties, numericPropKeys));
        if (hasGlobalId) {
          polygons.fields.push({ id: feature2.id });
        }
        indexMap.polygonFeature++;
        break;
      default:
        throw new Error("Invalid geometry type");
    }
    indexMap.feature++;
  }
  return makeAccessorObjects(points, lines, polygons, coordLength);
}
function handlePoint(geometry, points, indexMap, coordLength, properties) {
  points.positions.set(geometry.data, indexMap.pointPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(points, properties, indexMap.pointPosition, nPositions);
  points.globalFeatureIds.fill(indexMap.feature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  points.featureIds.fill(indexMap.pointFeature, indexMap.pointPosition, indexMap.pointPosition + nPositions);
  indexMap.pointPosition += nPositions;
}
function handleLineString(geometry, lines, indexMap, coordLength, properties) {
  lines.positions.set(geometry.data, indexMap.linePosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(lines, properties, indexMap.linePosition, nPositions);
  lines.globalFeatureIds.fill(indexMap.feature, indexMap.linePosition, indexMap.linePosition + nPositions);
  lines.featureIds.fill(indexMap.lineFeature, indexMap.linePosition, indexMap.linePosition + nPositions);
  for (let i = 0, il = geometry.indices.length; i < il; ++i) {
    const start = geometry.indices[i];
    const end = i === il - 1 ? geometry.data.length : geometry.indices[i + 1];
    lines.pathIndices[indexMap.linePath++] = indexMap.linePosition;
    indexMap.linePosition += (end - start) / coordLength;
  }
}
function handlePolygon(geometry, polygons, indexMap, coordLength, properties) {
  polygons.positions.set(geometry.data, indexMap.polygonPosition * coordLength);
  const nPositions = geometry.data.length / coordLength;
  fillNumericProperties(polygons, properties, indexMap.polygonPosition, nPositions);
  polygons.globalFeatureIds.fill(indexMap.feature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  polygons.featureIds.fill(indexMap.polygonFeature, indexMap.polygonPosition, indexMap.polygonPosition + nPositions);
  for (let l = 0, ll = geometry.indices.length; l < ll; ++l) {
    const startPosition = indexMap.polygonPosition;
    polygons.polygonIndices[indexMap.polygonObject++] = startPosition;
    const areas = geometry.areas[l];
    const indices = geometry.indices[l];
    const nextIndices = geometry.indices[l + 1];
    for (let i = 0, il = indices.length; i < il; ++i) {
      const start = indices[i];
      const end = i === il - 1 ? (
        // last line, so either read to:
        nextIndices === void 0 ? geometry.data.length : nextIndices[0]
      ) : indices[i + 1];
      polygons.primitivePolygonIndices[indexMap.polygonRing++] = indexMap.polygonPosition;
      indexMap.polygonPosition += (end - start) / coordLength;
    }
    const endPosition = indexMap.polygonPosition;
    triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength });
  }
}
function triangulatePolygon(polygons, areas, indices, { startPosition, endPosition, coordLength }) {
  if (!polygons.triangles) {
    return;
  }
  const start = startPosition * coordLength;
  const end = endPosition * coordLength;
  const polygonPositions = polygons.positions.subarray(start, end);
  const offset = indices[0];
  const holes = indices.slice(1).map((n) => (n - offset) / coordLength);
  const triangles = earcut(polygonPositions, holes, coordLength, areas);
  for (let t = 0, tl = triangles.length; t < tl; ++t) {
    polygons.triangles.push(startPosition + triangles[t]);
  }
}
function wrapProps(obj, size) {
  const returnObj = {};
  for (const key in obj) {
    returnObj[key] = { value: obj[key], size };
  }
  return returnObj;
}
function makeAccessorObjects(points, lines, polygons, coordLength) {
  const binaryFeatures = {
    shape: "binary-feature-collection",
    points: {
      ...points,
      positions: { value: points.positions, size: coordLength },
      globalFeatureIds: { value: points.globalFeatureIds, size: 1 },
      featureIds: { value: points.featureIds, size: 1 },
      numericProps: wrapProps(points.numericProps, 1)
    },
    lines: {
      ...lines,
      positions: { value: lines.positions, size: coordLength },
      pathIndices: { value: lines.pathIndices, size: 1 },
      globalFeatureIds: { value: lines.globalFeatureIds, size: 1 },
      featureIds: { value: lines.featureIds, size: 1 },
      numericProps: wrapProps(lines.numericProps, 1)
    },
    polygons: {
      ...polygons,
      positions: { value: polygons.positions, size: coordLength },
      polygonIndices: { value: polygons.polygonIndices, size: 1 },
      primitivePolygonIndices: { value: polygons.primitivePolygonIndices, size: 1 },
      globalFeatureIds: { value: polygons.globalFeatureIds, size: 1 },
      featureIds: { value: polygons.featureIds, size: 1 },
      numericProps: wrapProps(polygons.numericProps, 1)
    }
    // triangles not expected
  };
  if (binaryFeatures.polygons && polygons.triangles) {
    binaryFeatures.polygons.triangles = { value: new Uint32Array(polygons.triangles), size: 1 };
  }
  return binaryFeatures;
}
function fillNumericProperties(object, properties, index, length5) {
  for (const numericPropName in object.numericProps) {
    if (numericPropName in properties) {
      const value = properties[numericPropName];
      object.numericProps[numericPropName].fill(value, index, index + length5);
    }
  }
}
function keepStringProperties(properties, numericKeys) {
  const props = {};
  for (const key in properties) {
    if (!numericKeys.includes(key)) {
      props[key] = properties[key];
    }
  }
  return props;
}
function deduceArrayType(x, constructor) {
  if (constructor === Array || !Number.isFinite(x)) {
    return Array;
  }
  return constructor === Float64Array || Math.fround(x) !== x ? Float64Array : Float32Array;
}

// node_modules/@loaders.gl/gis/dist/lib/binary-features/binary-to-geojson.js
function binaryToGeojson(data, options) {
  const globalFeatureId = options == null ? void 0 : options.globalFeatureId;
  if (globalFeatureId !== void 0) {
    return getSingleFeature(data, globalFeatureId);
  }
  return parseFeatures(data, options == null ? void 0 : options.type);
}
function getSingleFeature(data, globalFeatureId) {
  const dataArray = normalizeInput(data);
  for (const data2 of dataArray) {
    let lastIndex = 0;
    let lastValue = data2.featureIds.value[0];
    for (let i = 0; i < data2.featureIds.value.length; i++) {
      const currValue = data2.featureIds.value[i];
      if (currValue === lastValue) {
        continue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, i);
      }
      lastIndex = i;
      lastValue = currValue;
    }
    if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
      return parseFeature(data2, lastIndex, data2.featureIds.value.length);
    }
  }
  throw new Error(`featureId:${globalFeatureId} not found`);
}
function parseFeatures(data, type) {
  const dataArray = normalizeInput(data, type);
  return parseFeatureCollection(dataArray);
}
function binaryToGeometry(data, startIndex, endIndex) {
  switch (data.type) {
    case "Point":
      return pointToGeoJson(data, startIndex, endIndex);
    case "LineString":
      return lineStringToGeoJson(data, startIndex, endIndex);
    case "Polygon":
      return polygonToGeoJson(data, startIndex, endIndex);
    default:
      const unexpectedInput = data;
      throw new Error(`Unsupported geometry type: ${unexpectedInput == null ? void 0 : unexpectedInput.type}`);
  }
}
function normalizeInput(data, type) {
  const features2 = [];
  if (data.points) {
    data.points.type = "Point";
    features2.push(data.points);
  }
  if (data.lines) {
    data.lines.type = "LineString";
    features2.push(data.lines);
  }
  if (data.polygons) {
    data.polygons.type = "Polygon";
    features2.push(data.polygons);
  }
  return features2;
}
function parseFeatureCollection(dataArray) {
  const features2 = [];
  for (const data of dataArray) {
    if (data.featureIds.value.length === 0) {
      continue;
    }
    let lastIndex = 0;
    let lastValue = data.featureIds.value[0];
    for (let i = 0; i < data.featureIds.value.length; i++) {
      const currValue = data.featureIds.value[i];
      if (currValue === lastValue) {
        continue;
      }
      features2.push(parseFeature(data, lastIndex, i));
      lastIndex = i;
      lastValue = currValue;
    }
    features2.push(parseFeature(data, lastIndex, data.featureIds.value.length));
  }
  return features2;
}
function parseFeature(data, startIndex, endIndex) {
  const geometry = binaryToGeometry(data, startIndex, endIndex);
  const properties = parseProperties(data, startIndex, endIndex);
  const fields = parseFields(data, startIndex, endIndex);
  return { type: "Feature", geometry, properties, ...fields };
}
function parseFields(data, startIndex = 0, endIndex) {
  return data.fields && data.fields[data.featureIds.value[startIndex]];
}
function parseProperties(data, startIndex = 0, endIndex) {
  const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
  for (const key in data.numericProps) {
    properties[key] = data.numericProps[key].value[startIndex];
  }
  return properties;
}
function polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
  const { positions } = data;
  const polygonIndices = data.polygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);
  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);
  const multi = polygonIndices.length > 2;
  if (!multi) {
    const coordinates2 = [];
    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {
      const startRingIndex = primitivePolygonIndices[i];
      const endRingIndex = primitivePolygonIndices[i + 1];
      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
      coordinates2.push(ringCoordinates);
    }
    return { type: "Polygon", coordinates: coordinates2 };
  }
  const coordinates = [];
  for (let i = 0; i < polygonIndices.length - 1; i++) {
    const startPolygonIndex = polygonIndices[i];
    const endPolygonIndex = polygonIndices[i + 1];
    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
    coordinates.push(polygonCoordinates);
  }
  return { type: "MultiPolygon", coordinates };
}
function lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
  const { positions } = data;
  const pathIndices = data.pathIndices.value.filter((x) => x >= startIndex && x <= endIndex);
  const multi = pathIndices.length > 2;
  if (!multi) {
    const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
    return { type: "LineString", coordinates: coordinates2 };
  }
  const coordinates = [];
  for (let i = 0; i < pathIndices.length - 1; i++) {
    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);
    coordinates.push(ringCoordinates);
  }
  return { type: "MultiLineString", coordinates };
}
function pointToGeoJson(data, startIndex, endIndex) {
  const { positions } = data;
  const coordinates = ringToGeoJson(positions, startIndex, endIndex);
  const multi = coordinates.length > 1;
  if (multi) {
    return { type: "MultiPoint", coordinates };
  }
  return { type: "Point", coordinates: coordinates[0] };
}
function ringToGeoJson(positions, startIndex, endIndex) {
  startIndex = startIndex || 0;
  endIndex = endIndex || positions.value.length / positions.size;
  const ringCoordinates = [];
  for (let j = startIndex; j < endIndex; j++) {
    const coord = Array();
    for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {
      coord.push(Number(positions.value[k]));
    }
    ringCoordinates.push(coord);
  }
  return ringCoordinates;
}

// node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
var import_pbf = __toESM(require_pbf(), 1);

// node_modules/@loaders.gl/mvt/dist/lib/utils/geometry-utils.js
function signedArea(ring) {
  let sum = 0;
  for (let i = 0, j = ring.length - 1, p1, p2; i < ring.length; j = i++) {
    p1 = ring[i];
    p2 = ring[j];
    sum += (p2[0] - p1[0]) * (p1[1] + p2[1]);
  }
  return sum;
}
function convertToLocalCoordinates(coordinates, extent) {
  if (Array.isArray(coordinates[0])) {
    for (const subcoords of coordinates) {
      convertToLocalCoordinates(subcoords, extent);
    }
    return;
  }
  const p = coordinates;
  p[0] /= extent;
  p[1] /= extent;
}
function convertToLocalCoordinatesFlat(data, extent) {
  for (let i = 0; i < data.length; ++i) {
    data[i] /= extent;
  }
}
function projectToLngLat(line, tileIndex, extent) {
  if (typeof line[0][0] !== "number") {
    for (const point2 of line) {
      projectToLngLat(point2, tileIndex, extent);
    }
    return;
  }
  const size = extent * Math.pow(2, tileIndex.z);
  const x0 = extent * tileIndex.x;
  const y0 = extent * tileIndex.y;
  for (let j = 0; j < line.length; j++) {
    const p = line[j];
    p[0] = (p[0] + x0) * 360 / size - 180;
    const y2 = 180 - (p[1] + y0) * 360 / size;
    p[1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
  }
}
function projectToLngLatFlat(data, tileIndex, extent) {
  const { x, y, z } = tileIndex;
  const size = extent * Math.pow(2, z);
  const x0 = extent * x;
  const y0 = extent * y;
  for (let j = 0, jl = data.length; j < jl; j += 2) {
    data[j] = (data[j] + x0) * 360 / size - 180;
    const y2 = 180 - (data[j + 1] + y0) * 360 / size;
    data[j + 1] = 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
  }
}
function classifyRings(rings) {
  const len4 = rings.length;
  if (len4 <= 1)
    return [rings];
  const polygons = [];
  let polygon;
  let ccw;
  for (let i = 0; i < len4; i++) {
    const area = signedArea(rings[i]);
    if (area === 0)
      continue;
    if (ccw === void 0)
      ccw = area < 0;
    if (ccw === area < 0) {
      if (polygon)
        polygons.push(polygon);
      polygon = [rings[i]];
    } else if (polygon)
      polygon.push(rings[i]);
  }
  if (polygon)
    polygons.push(polygon);
  return polygons;
}
function classifyRingsFlat(geom) {
  const len4 = geom.indices.length;
  const type = "Polygon";
  if (len4 <= 1) {
    return {
      type,
      data: geom.data,
      areas: [[getPolygonSignedArea(geom.data)]],
      indices: [geom.indices]
    };
  }
  const areas = [];
  const polygons = [];
  let ringAreas = [];
  let polygon = [];
  let ccw;
  let offset = 0;
  for (let endIndex, i = 0, startIndex; i < len4; i++) {
    startIndex = geom.indices[i] - offset;
    endIndex = geom.indices[i + 1] - offset || geom.data.length;
    const shape = geom.data.slice(startIndex, endIndex);
    const area = getPolygonSignedArea(shape);
    if (area === 0) {
      const before = geom.data.slice(0, startIndex);
      const after = geom.data.slice(endIndex);
      geom.data = before.concat(after);
      offset += endIndex - startIndex;
      continue;
    }
    if (ccw === void 0)
      ccw = area < 0;
    if (ccw === area < 0) {
      if (polygon.length) {
        areas.push(ringAreas);
        polygons.push(polygon);
      }
      polygon = [startIndex];
      ringAreas = [area];
    } else {
      ringAreas.push(area);
      polygon.push(startIndex);
    }
  }
  if (ringAreas)
    areas.push(ringAreas);
  if (polygon.length)
    polygons.push(polygon);
  return { type, areas, indices: polygons, data: geom.data };
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile-feature.js
var VectorTileFeature = class {
  // eslint-disable-next-line max-params
  constructor(pbf, end, extent, keys, values, geometryInfo) {
    __publicField(this, "properties");
    __publicField(this, "extent");
    __publicField(this, "type");
    __publicField(this, "id");
    __publicField(this, "_pbf");
    __publicField(this, "_geometry");
    __publicField(this, "_keys");
    __publicField(this, "_values");
    __publicField(this, "_geometryInfo");
    this.properties = {};
    this.extent = extent;
    this.type = 0;
    this.id = null;
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;
    this._geometryInfo = geometryInfo;
    pbf.readFields(readFeature, this, end);
  }
  toGeoJSONFeature(coordinates, tileIndex) {
    const coords = this.loadGeometry();
    switch (coordinates) {
      case "wgs84":
        return _toGeoJSONFeature(this, coords, (line) => projectToLngLat(line, tileIndex, this.extent));
      default:
        return _toGeoJSONFeature(this, coords, convertToLocalCoordinates);
    }
  }
  /**
   *
   * @param options
   * @returns
   */
  toBinaryFeature(coordinates, tileIndex) {
    const geom = this.loadFlatGeometry();
    switch (coordinates) {
      case "wgs84":
        return this._toBinaryCoordinates(geom, (coords) => projectToLngLatFlat(coords, tileIndex, this.extent));
      default:
        return this._toBinaryCoordinates(geom, convertToLocalCoordinatesFlat);
    }
  }
  /** Read a bounding box from the feature */
  // eslint-disable-next-line max-statements
  bbox() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd = 1;
    let length5 = 0;
    let x = 0;
    let y = 0;
    let x1 = Infinity;
    let x2 = -Infinity;
    let y1 = Infinity;
    let y2 = -Infinity;
    while (pbf.pos < end) {
      if (length5 <= 0) {
        const cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length5 = cmdLen >> 3;
      }
      length5--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (x < x1)
          x1 = x;
        if (x > x2)
          x2 = x;
        if (y < y1)
          y1 = y;
        if (y > y2)
          y2 = y;
      } else if (cmd !== 7) {
        throw new Error(`unknown command ${cmd}`);
      }
    }
    return [x1, y1, x2, y2];
  }
  // BINARY HELPERS
  /**
   *
   * @param transform
   * @returns result
   */
  _toBinaryCoordinates(geom, transform2) {
    let geometry;
    transform2(geom.data, this.extent);
    const coordLength = 2;
    switch (this.type) {
      case 1:
        this._geometryInfo.pointFeaturesCount++;
        this._geometryInfo.pointPositionsCount += geom.indices.length;
        geometry = { type: "Point", ...geom };
        break;
      case 2:
        this._geometryInfo.lineFeaturesCount++;
        this._geometryInfo.linePathsCount += geom.indices.length;
        this._geometryInfo.linePositionsCount += geom.data.length / coordLength;
        geometry = { type: "LineString", ...geom };
        break;
      case 3:
        geometry = classifyRingsFlat(geom);
        this._geometryInfo.polygonFeaturesCount++;
        this._geometryInfo.polygonObjectsCount += geometry.indices.length;
        for (const indices of geometry.indices) {
          this._geometryInfo.polygonRingsCount += indices.length;
        }
        this._geometryInfo.polygonPositionsCount += geometry.data.length / coordLength;
        break;
      default:
        throw new Error(`Invalid geometry type: ${this.type}`);
    }
    const result = { type: "Feature", geometry, properties: this.properties };
    if (this.id !== null) {
      result.id = this.id;
    }
    return result;
  }
  // GEOJSON HELPER
  // eslint-disable-next-line complexity, max-statements
  loadGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const end = pbf.readVarint() + pbf.pos;
    let cmd = 1;
    let length5 = 0;
    let x = 0;
    let y = 0;
    const lines = [];
    let line;
    while (pbf.pos < end) {
      if (length5 <= 0) {
        const cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length5 = cmdLen >> 3;
      }
      length5--;
      switch (cmd) {
        case 1:
        case 2:
          x += pbf.readSVarint();
          y += pbf.readSVarint();
          if (cmd === 1) {
            if (line)
              lines.push(line);
            line = [];
          }
          if (line)
            line.push([x, y]);
          break;
        case 7:
          if (line) {
            line.push(line[0].slice());
          }
          break;
        default:
          throw new Error(`unknown command ${cmd}`);
      }
    }
    if (line)
      lines.push(line);
    return lines;
  }
  /**
   * Expands the protobuf data to an intermediate Flat GeoJSON
   * data format, which maps closely to the binary data buffers.
   * It is similar to GeoJSON, but rather than storing the coordinates
   * in multidimensional arrays, we have a 1D `data` with all the
   * coordinates, and then index into this using the `indices`
   * parameter, e.g.
   *
   * geometry: {
   *   type: 'Point', data: [1,2], indices: [0]
   * }
   * geometry: {
   *   type: 'LineString', data: [1,2,3,4,...], indices: [0]
   * }
   * geometry: {
   *   type: 'Polygon', data: [1,2,3,4,...], indices: [[0, 2]]
   * }
   * Thus the indices member lets us look up the relevant range
   * from the data array.
   * The Multi* versions of the above types share the same data
   * structure, just with multiple elements in the indices array
   */
  // eslint-disable-next-line complexity, max-statements
  loadFlatGeometry() {
    const pbf = this._pbf;
    pbf.pos = this._geometry;
    const endPos = pbf.readVarint() + pbf.pos;
    let cmd = 1;
    let cmdLen;
    let length5 = 0;
    let x = 0;
    let y = 0;
    let i = 0;
    const indices = [];
    const data = [];
    while (pbf.pos < endPos) {
      if (length5 <= 0) {
        cmdLen = pbf.readVarint();
        cmd = cmdLen & 7;
        length5 = cmdLen >> 3;
      }
      length5--;
      if (cmd === 1 || cmd === 2) {
        x += pbf.readSVarint();
        y += pbf.readSVarint();
        if (cmd === 1) {
          indices.push(i);
        }
        data.push(x, y);
        i += 2;
      } else if (cmd === 7) {
        if (i > 0) {
          const start = indices[indices.length - 1];
          data.push(data[start], data[start + 1]);
          i += 2;
        }
      } else {
        throw new Error(`unknown command ${cmd}`);
      }
    }
    return { data, indices };
  }
};
__publicField(VectorTileFeature, "types", ["Unknown", "Point", "LineString", "Polygon"]);
function _toGeoJSONFeature(vtFeature, coords, transform2) {
  let type = VectorTileFeature.types[vtFeature.type];
  let i;
  let j;
  let coordinates;
  switch (vtFeature.type) {
    case 1:
      const points = [];
      for (i = 0; i < coords.length; i++) {
        points[i] = coords[i][0];
      }
      coordinates = points;
      transform2(coordinates, vtFeature.extent);
      break;
    case 2:
      coordinates = coords;
      for (i = 0; i < coordinates.length; i++) {
        transform2(coordinates[i], vtFeature.extent);
      }
      break;
    case 3:
      coordinates = classifyRings(coords);
      for (i = 0; i < coordinates.length; i++) {
        for (j = 0; j < coordinates[i].length; j++) {
          transform2(coordinates[i][j], vtFeature.extent);
        }
      }
      break;
    default:
      throw new Error("illegal vector tile type");
  }
  if (coordinates.length === 1) {
    coordinates = coordinates[0];
  } else {
    type = `Multi${type}`;
  }
  const result = {
    type: "Feature",
    geometry: {
      type,
      coordinates
    },
    properties: vtFeature.properties
  };
  if (vtFeature.id !== null) {
    result.properties || (result.properties = {});
    result.properties.id = vtFeature.id;
  }
  return result;
}
function readFeature(tag, feature2, pbf) {
  if (feature2 && pbf) {
    if (tag === 1)
      feature2.id = pbf.readVarint();
    else if (tag === 2)
      readTag(pbf, feature2);
    else if (tag === 3)
      feature2.type = pbf.readVarint();
    else if (tag === 4)
      feature2._geometry = pbf.pos;
  }
}
function readTag(pbf, feature2) {
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const key = feature2._keys[pbf.readVarint()];
    const value = feature2._values[pbf.readVarint()];
    feature2.properties[key] = value;
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile-layer.js
var VectorTileLayer = class {
  constructor(pbf, end) {
    __publicField(this, "version");
    __publicField(this, "name");
    __publicField(this, "extent");
    __publicField(this, "length");
    __publicField(this, "_pbf");
    __publicField(this, "_keys");
    __publicField(this, "_values");
    __publicField(this, "_features");
    this.version = 1;
    this.name = "";
    this.extent = 4096;
    this.length = 0;
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];
    pbf.readFields(readLayer, this, end);
    this.length = this._features.length;
  }
  /**
   * return feature `i` from this layer as a `VectorTileFeature`
   * @param index
   * @returns feature
   */
  getGeoJSONFeature(i) {
    if (i < 0 || i >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
  }
  /**
   * return binary feature `i` from this layer as a `VectorTileFeature`
   *
   * @param index
   * @param geometryInfo
   * @returns binary feature
   */
  getBinaryFeature(i, geometryInfo) {
    if (i < 0 || i >= this._features.length) {
      throw new Error("feature index out of bounds");
    }
    this._pbf.pos = this._features[i];
    const end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values, geometryInfo);
  }
};
function readLayer(tag, layer, pbf) {
  if (layer && pbf) {
    if (tag === 15)
      layer.version = pbf.readVarint();
    else if (tag === 1)
      layer.name = pbf.readString();
    else if (tag === 5)
      layer.extent = pbf.readVarint();
    else if (tag === 2)
      layer._features.push(pbf.pos);
    else if (tag === 3)
      layer._keys.push(pbf.readString());
    else if (tag === 4)
      layer._values.push(readValueMessage(pbf));
  }
}
function readValueMessage(pbf) {
  let value = null;
  const end = pbf.readVarint() + pbf.pos;
  while (pbf.pos < end) {
    const tag = pbf.readVarint() >> 3;
    value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
  }
  return value;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tile/vector-tile.js
var VectorTile = class {
  constructor(pbf, end) {
    __publicField(this, "layers");
    this.layers = pbf.readFields(readTile, {}, end);
  }
};
function readTile(tag, layers, pbf) {
  if (tag === 3) {
    if (pbf) {
      const layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
      if (layer.length && layers) {
        layers[layer.name] = layer;
      }
    }
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/parse-mvt.js
function parseMVT(arrayBuffer, options) {
  var _a, _b;
  const mvtOptions = checkOptions(options);
  const shape = ((_a = options == null ? void 0 : options.gis) == null ? void 0 : _a.format) || ((_b = options == null ? void 0 : options.mvt) == null ? void 0 : _b.shape) || (options == null ? void 0 : options.shape);
  switch (shape) {
    case "columnar-table":
      return { shape: "columnar-table", data: parseToBinary(arrayBuffer, mvtOptions) };
    case "geojson-table": {
      const table = {
        shape: "geojson-table",
        type: "FeatureCollection",
        features: parseToGeojsonFeatures(arrayBuffer, mvtOptions)
      };
      return table;
    }
    case "geojson":
      return parseToGeojsonFeatures(arrayBuffer, mvtOptions);
    case "binary-geometry":
      return parseToBinary(arrayBuffer, mvtOptions);
    case "binary":
      return parseToBinary(arrayBuffer, mvtOptions);
    default:
      throw new Error(shape || "undefined shape");
  }
}
function parseToBinary(arrayBuffer, options) {
  const [flatGeoJsonFeatures, geometryInfo] = parseToFlatGeoJson(arrayBuffer, options);
  const binaryData = flatGeojsonToBinary(flatGeoJsonFeatures, geometryInfo);
  binaryData.byteLength = arrayBuffer.byteLength;
  return binaryData;
}
function parseToFlatGeoJson(arrayBuffer, options) {
  const features2 = [];
  const geometryInfo = {
    coordLength: 2,
    pointPositionsCount: 0,
    pointFeaturesCount: 0,
    linePositionsCount: 0,
    linePathsCount: 0,
    lineFeaturesCount: 0,
    polygonPositionsCount: 0,
    polygonObjectsCount: 0,
    polygonRingsCount: 0,
    polygonFeaturesCount: 0
  };
  if (arrayBuffer.byteLength <= 0) {
    return [features2, geometryInfo];
  }
  const tile = new VectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = options && Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i = 0; i < vectorTileLayer.length; i++) {
      const vectorTileFeature = vectorTileLayer.getBinaryFeature(i, geometryInfo);
      const decodedFeature = getDecodedFeatureBinary(vectorTileFeature, options, layerName);
      features2.push(decodedFeature);
    }
  });
  return [features2, geometryInfo];
}
function parseToGeojsonFeatures(arrayBuffer, options) {
  if (arrayBuffer.byteLength <= 0) {
    return [];
  }
  const features2 = [];
  const tile = new VectorTile(new import_pbf.default(arrayBuffer));
  const selectedLayers = Array.isArray(options.layers) ? options.layers : Object.keys(tile.layers);
  selectedLayers.forEach((layerName) => {
    const vectorTileLayer = tile.layers[layerName];
    if (!vectorTileLayer) {
      return;
    }
    for (let i = 0; i < vectorTileLayer.length; i++) {
      const vectorTileFeature = vectorTileLayer.getGeoJSONFeature(i);
      const decodedFeature = getDecodedFeature(vectorTileFeature, options, layerName);
      features2.push(decodedFeature);
    }
  });
  return features2;
}
function checkOptions(options) {
  var _a;
  if (!(options == null ? void 0 : options.mvt)) {
    throw new Error("mvt options required");
  }
  if (((_a = options.mvt) == null ? void 0 : _a.coordinates) === "wgs84" && !options.mvt.tileIndex) {
    throw new Error("MVT Loader: WGS84 coordinates need tileIndex property");
  }
  if (options.gis) {
    log.warn('MVTLoader: "options.gis" is deprecated, use "options.mvt.shape" instead')();
  }
  return options.mvt;
}
function getDecodedFeature(feature2, options, layerName) {
  const decodedFeature = feature2.toGeoJSONFeature(options.coordinates || "local", options.tileIndex);
  if (options.layerProperty) {
    decodedFeature.properties || (decodedFeature.properties = {});
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}
function getDecodedFeatureBinary(feature2, options, layerName) {
  const decodedFeature = feature2.toBinaryFeature(options.coordinates || "local", options.tileIndex);
  if (options.layerProperty && decodedFeature.properties) {
    decodedFeature.properties[options.layerProperty] = layerName;
  }
  return decodedFeature;
}

// node_modules/@loaders.gl/mvt/dist/mvt-loader.js
var VERSION9 = true ? "4.3.3" : "latest";
var MVTWorkerLoader = {
  dataType: null,
  batchType: null,
  name: "Mapbox Vector Tile",
  id: "mvt",
  module: "mvt",
  version: VERSION9,
  // Note: ArcGIS uses '.pbf' extension and 'application/octet-stream'
  extensions: ["mvt", "pbf"],
  mimeTypes: [
    // https://www.iana.org/assignments/media-types/application/vnd.mapbox-vector-tile
    "application/vnd.mapbox-vector-tile",
    "application/x-protobuf"
    // 'application/octet-stream'
  ],
  worker: true,
  category: "geometry",
  options: {
    mvt: {
      shape: "geojson",
      coordinates: "local",
      layerProperty: "layerName",
      layers: void 0,
      tileIndex: void 0
    }
  }
};
var MVTLoader = {
  ...MVTWorkerLoader,
  parse: async (arrayBuffer, options) => parseMVT(arrayBuffer, options),
  parseSync: parseMVT,
  binary: true
};

// node_modules/@loaders.gl/mvt/dist/mvt-source.js
var xRegex = new RegExp("{x}", "g");
var yRegex = new RegExp("{y}", "g");
var zRegex = new RegExp("{z}", "g");

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/proto-tile.js
function createProtoTile(features2, z, tx, ty, options) {
  const tolerance = z === options.maxZoom ? 0 : options.tolerance / ((1 << z) * options.extent);
  const tile = {
    protoFeatures: [],
    sourceFeatures: null,
    numPoints: 0,
    numSimplified: 0,
    numFeatures: features2.length,
    x: tx,
    y: ty,
    z,
    transformed: false,
    minX: 2,
    minY: 1,
    maxX: -1,
    maxY: 0
  };
  for (const feature2 of features2) {
    addProtoFeature(tile, feature2, tolerance, options);
  }
  return tile;
}
function addProtoFeature(tile, feature2, tolerance, options) {
  const geometry = feature2.geometry;
  const type = feature2.type;
  const simplifiedGeometry = [];
  tile.minX = Math.min(tile.minX, feature2.minX);
  tile.minY = Math.min(tile.minY, feature2.minY);
  tile.maxX = Math.max(tile.maxX, feature2.maxX);
  tile.maxY = Math.max(tile.maxY, feature2.maxY);
  let simplifiedType;
  switch (type) {
    case "Point":
    case "MultiPoint":
      simplifiedType = 1;
      for (let i = 0; i < geometry.length; i += 3) {
        simplifiedGeometry.push(geometry[i], geometry[i + 1]);
        tile.numPoints++;
        tile.numSimplified++;
      }
      break;
    case "LineString":
      simplifiedType = 2;
      addProtoLine(simplifiedGeometry, geometry, tile, tolerance, false, false);
      break;
    case "MultiLineString":
      simplifiedType = 2;
      for (let i = 0; i < geometry.length; i++) {
        addProtoLine(simplifiedGeometry, geometry[i], tile, tolerance, false, i === 0);
      }
      break;
    case "Polygon":
      simplifiedType = 3;
      for (let i = 0; i < geometry.length; i++) {
        addProtoLine(simplifiedGeometry, geometry[i], tile, tolerance, true, i === 0);
      }
      break;
    case "MultiPolygon":
      simplifiedType = 3;
      for (let k = 0; k < geometry.length; k++) {
        const polygon = geometry[k];
        for (let i = 0; i < polygon.length; i++) {
          addProtoLine(simplifiedGeometry, polygon[i], tile, tolerance, true, i === 0);
        }
      }
      break;
    default:
      throw new Error(`Unknown geometry type: ${type}`);
  }
  if (simplifiedGeometry.length) {
    let tags = feature2.tags || null;
    if (type === "LineString" && options.lineMetrics) {
      tags = {};
      for (const key in feature2.tags) {
        tags[key] = feature2.tags[key];
      }
      tags.mapbox_clip_start = geometry.start / geometry.size;
      tags.mapbox_clip_end = geometry.end / geometry.size;
    }
    const tileFeature = {
      geometry: simplifiedGeometry,
      simplifiedType,
      // @ts-expect-error
      tags
    };
    if (feature2.id !== null) {
      tileFeature.id = feature2.id;
    }
    tile.protoFeatures.push(tileFeature);
  }
}
function addProtoLine(result, geometry, tile, tolerance, isPolygon, isOuter) {
  const sqTolerance = tolerance * tolerance;
  if (tolerance > 0 && geometry.size < (isPolygon ? sqTolerance : tolerance)) {
    tile.numPoints += geometry.length / 3;
    return;
  }
  const ring = [];
  for (let i = 0; i < geometry.length; i += 3) {
    if (tolerance === 0 || geometry[i + 2] > sqTolerance) {
      tile.numSimplified++;
      ring.push(geometry[i], geometry[i + 1]);
    }
    tile.numPoints++;
  }
  if (isPolygon)
    rewind(ring, isOuter);
  result.push(ring);
}
function rewind(ring, clockwise) {
  let area = 0;
  for (let i = 0, j = ring.length - 2; i < ring.length; j = i, i += 2) {
    area += (ring[i] - ring[j]) * (ring[i + 1] + ring[j + 1]);
  }
  if (area > 0 === clockwise) {
    for (let i = 0, len4 = ring.length; i < len4 / 2; i += 2) {
      const x = ring[i];
      const y = ring[i + 1];
      ring[i] = ring[len4 - 2 - i];
      ring[i + 1] = ring[len4 - 1 - i];
      ring[len4 - 2 - i] = x;
      ring[len4 - 1 - i] = y;
    }
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/transform-tile.js
function transformTile(protoTile, extent) {
  if (protoTile.transformed) {
    return protoTile;
  }
  const z2 = 1 << protoTile.z;
  const tx = protoTile.x;
  const ty = protoTile.y;
  for (const protoFeature of protoTile.protoFeatures) {
    const geom = protoFeature.geometry;
    const simplifiedType = protoFeature.simplifiedType;
    protoFeature.geometry = [];
    if (simplifiedType === 1) {
      for (let j = 0; j < geom.length; j += 2) {
        protoFeature.geometry.push(transformPoint(geom[j], geom[j + 1], extent, z2, tx, ty));
      }
    } else {
      for (let j = 0; j < geom.length; j++) {
        const ring = [];
        for (let k = 0; k < geom[j].length; k += 2) {
          ring.push(transformPoint(geom[j][k], geom[j][k + 1], extent, z2, tx, ty));
        }
        protoFeature.geometry.push(ring);
      }
    }
  }
  protoTile.transformed = true;
  return protoTile;
}
function transformPoint(x, y, extent, z2, tx, ty) {
  return [Math.round(extent * (x * z2 - tx)), Math.round(extent * (y * z2 - ty))];
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/tile-to-geojson.js
function convertTileToGeoJSON(protoTile, props) {
  const features2 = [];
  for (const rawFeature of protoTile.protoFeatures) {
    if (!rawFeature || !rawFeature.geometry) {
      continue;
    }
    let type;
    let coordinates;
    switch (rawFeature.simplifiedType) {
      case 1:
        if (rawFeature.geometry.length === 1) {
          type = "Point";
          coordinates = rawFeature.geometry[0];
        } else {
          type = "MultiPoint";
          coordinates = rawFeature.geometry;
        }
        break;
      case 2:
        if (rawFeature.geometry.length === 1) {
          type = "LineString";
          coordinates = rawFeature.geometry[0];
        } else {
          type = "MultiLineString";
          coordinates = rawFeature.geometry;
        }
        break;
      case 3:
        if (rawFeature.geometry.length > 1) {
          type = "MultiPolygon";
          coordinates = [rawFeature.geometry];
        } else {
          type = "Polygon";
          coordinates = rawFeature.geometry;
        }
        break;
      default:
        throw new Error(`${rawFeature.simplifiedType}is not a valid simplified type`);
    }
    switch (props.coordinates) {
      case "EPSG:4326":
      case "wgs84":
        projectToLngLat(coordinates, props.tileIndex, props.extent);
        break;
      default:
        convertToLocalCoordinates(coordinates, props.extent);
        break;
    }
    const feature2 = {
      type: "Feature",
      geometry: {
        type,
        coordinates
      },
      properties: rawFeature.tags || {},
      id: rawFeature.id
    };
    features2.push(feature2);
  }
  if (features2.length === 0) {
    return null;
  }
  const table = {
    shape: "geojson-table",
    type: "FeatureCollection",
    features: features2
  };
  return table;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/proto-feature.js
function createProtoFeature(id, type, geometry, tags) {
  const feature2 = {
    // eslint-disable-next-line
    id: id == null ? null : id,
    type,
    simplifiedType: void 0,
    // TODO
    geometry,
    tags,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
  switch (type) {
    case "Point":
    case "MultiPoint":
    case "LineString":
      calcLineBBox(feature2, geometry);
      break;
    case "MultiLineString":
      for (const line of geometry) {
        calcLineBBox(feature2, line);
      }
      break;
    case "Polygon":
      calcLineBBox(feature2, geometry[0]);
      break;
    case "MultiPolygon":
      for (const polygon of geometry) {
        calcLineBBox(feature2, polygon[0]);
      }
      break;
    default:
      throw new Error(String(type));
  }
  return feature2;
}
function calcLineBBox(feature2, geometry) {
  for (let i = 0; i < geometry.length; i += 3) {
    feature2.minX = Math.min(feature2.minX, geometry[i]);
    feature2.minY = Math.min(feature2.minY, geometry[i + 1]);
    feature2.maxX = Math.max(feature2.maxX, geometry[i]);
    feature2.maxY = Math.max(feature2.maxY, geometry[i + 1]);
  }
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/simplify-path.js
function simplifyPath(coords, first, last, sqTolerance) {
  let maxSqDist = sqTolerance;
  const mid = last - first >> 1;
  let minPosToMid = last - first;
  let index;
  const ax = coords[first];
  const ay = coords[first + 1];
  const bx = coords[last];
  const by = coords[last + 1];
  for (let i = first + 3; i < last; i += 3) {
    const d2 = getSqSegDist(coords[i], coords[i + 1], ax, ay, bx, by);
    if (d2 > maxSqDist) {
      index = i;
      maxSqDist = d2;
    } else if (d2 === maxSqDist) {
      const posToMid = Math.abs(i - mid);
      if (posToMid < minPosToMid) {
        index = i;
        minPosToMid = posToMid;
      }
    }
  }
  if (maxSqDist > sqTolerance) {
    if (index - first > 3)
      simplifyPath(coords, first, index, sqTolerance);
    coords[index + 2] = maxSqDist;
    if (last - index > 3)
      simplifyPath(coords, index, last, sqTolerance);
  }
}
function getSqSegDist(px, py, x, y, bx, by) {
  let dx = bx - x;
  let dy = by - y;
  if (dx !== 0 || dy !== 0) {
    const t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x = bx;
      y = by;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = px - x;
  dy = py - y;
  return dx * dx + dy * dy;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/convert-feature.js
function convertFeaturesToProtoFeature(data, options) {
  const protoFeatures = [];
  switch (data.type) {
    case "FeatureCollection":
      let i = 0;
      for (const feature2 of data.features) {
        protoFeatures.push(convertFeature(feature2, options, i++));
      }
      break;
    case "Feature":
      protoFeatures.push(convertFeature(data, options));
      break;
    default:
      protoFeatures.push(convertFeature({ geometry: data }, options));
  }
  return protoFeatures;
}
function convertFeature(geojson, options, index) {
  if (!geojson.geometry) {
    return;
  }
  const coords = geojson.geometry.coordinates;
  const type = geojson.geometry.type;
  const tolerance = Math.pow(options.tolerance / ((1 << options.maxZoom) * options.extent), 2);
  let geometry = [];
  let id = geojson.id;
  if (options.promoteId) {
    id = geojson.properties[options.promoteId];
  } else if (options.generateId) {
    id = index || 0;
  }
  switch (type) {
    case "Point":
      convertPoint(coords, geometry);
      break;
    case "MultiPoint":
      for (const p of coords) {
        convertPoint(p, geometry);
      }
      break;
    case "LineString":
      convertLine(coords, geometry, tolerance, false);
      break;
    case "MultiLineString":
      if (options.lineMetrics) {
        for (const line of coords) {
          geometry = [];
          convertLine(line, geometry, tolerance, false);
          features.push(createProtoFeature(id, "LineString", geometry, geojson.properties));
        }
        return;
        convertLines(coords, geometry, tolerance, false);
      }
      break;
    case "Polygon":
      convertLines(coords, geometry, tolerance, true);
      break;
    case "MultiPolygon":
      for (const polygon of coords) {
        const newPolygon = [];
        convertLines(polygon, newPolygon, tolerance, true);
        geometry.push(newPolygon);
      }
      break;
    case "GeometryCollection":
      for (const singleGeometry of geojson.geometry.geometries) {
        convertFeature(features, {
          id,
          geometry: singleGeometry,
          properties: geojson.properties
        }, options, index);
      }
      break;
    default:
      throw new Error("Input data is not a valid GeoJSON object.");
  }
  return createProtoFeature(id, type, geometry, geojson.properties);
}
function convertPoint(coords, out) {
  out.push(projectX(coords[0]), projectY(coords[1]), 0);
}
function convertLine(ring, out, tolerance, isPolygon) {
  let x0, y0;
  let size = 0;
  for (let j = 0; j < ring.length; j++) {
    const x = projectX(ring[j][0]);
    const y = projectY(ring[j][1]);
    out.push(x, y, 0);
    if (j > 0) {
      if (isPolygon) {
        size += (x0 * y - x * y0) / 2;
      } else {
        size += Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2));
      }
    }
    x0 = x;
    y0 = y;
  }
  const last = out.length - 3;
  out[2] = 1;
  simplifyPath(out, 0, last, tolerance);
  out[last + 2] = 1;
  out.size = Math.abs(size);
  out.start = 0;
  out.end = out.size;
}
function convertLines(rings, out, tolerance, isPolygon) {
  for (let i = 0; i < rings.length; i++) {
    const geom = [];
    convertLine(rings[i], geom, tolerance, isPolygon);
    out.push(geom);
  }
}
function projectX(x) {
  return x / 360 + 0.5;
}
function projectY(y) {
  const sin = Math.sin(y * Math.PI / 180);
  const y2 = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
  return y2 < 0 ? 0 : y2 > 1 ? 1 : y2;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/clip-features.js
function clipFeatures(features2, scale7, k1, k2, axis, minAll, maxAll, options) {
  k1 /= scale7;
  k2 /= scale7;
  if (minAll >= k1 && maxAll < k2) {
    return features2;
  } else if (maxAll < k1 || minAll >= k2) {
    return null;
  }
  const clipped = [];
  for (const feature2 of features2) {
    const geometry = feature2.geometry;
    let type = feature2.type;
    const min3 = axis === 0 ? feature2.minX : feature2.minY;
    const max3 = axis === 0 ? feature2.maxX : feature2.maxY;
    if (min3 >= k1 && max3 < k2) {
      clipped.push(feature2);
      continue;
    } else if (max3 < k1 || min3 >= k2) {
      continue;
    }
    let newGeometry = [];
    if (type === "Point" || type === "MultiPoint") {
      clipPoints(geometry, newGeometry, k1, k2, axis);
    } else if (type === "LineString") {
      clipLine(geometry, newGeometry, k1, k2, axis, false, options.lineMetrics);
    } else if (type === "MultiLineString") {
      clipLines(geometry, newGeometry, k1, k2, axis, false);
    } else if (type === "Polygon") {
      clipLines(geometry, newGeometry, k1, k2, axis, true);
    } else if (type === "MultiPolygon") {
      for (const polygon of geometry) {
        const newPolygon = [];
        clipLines(polygon, newPolygon, k1, k2, axis, true);
        if (newPolygon.length) {
          newGeometry.push(newPolygon);
        }
      }
    }
    if (newGeometry.length) {
      if (options.lineMetrics && type === "LineString") {
        for (const line of newGeometry) {
          clipped.push(createProtoFeature(feature2.id, type, line, feature2.tags));
        }
        continue;
      }
      if (type === "LineString" || type === "MultiLineString") {
        if (newGeometry.length === 1) {
          type = "LineString";
          newGeometry = newGeometry[0];
        } else {
          type = "MultiLineString";
        }
      }
      if (type === "Point" || type === "MultiPoint") {
        type = newGeometry.length === 3 ? "Point" : "MultiPoint";
      }
      clipped.push(createProtoFeature(feature2.id, type, newGeometry, feature2.tags));
    }
  }
  return clipped.length ? clipped : null;
}
function clipPoints(geom, newGeom, k1, k2, axis) {
  for (let i = 0; i < geom.length; i += 3) {
    const a3 = geom[i + axis];
    if (a3 >= k1 && a3 <= k2) {
      addPoint(newGeom, geom[i], geom[i + 1], geom[i + 2]);
    }
  }
}
function clipLine(geom, newGeom, k1, k2, axis, isPolygon, trackMetrics) {
  let slice = newSlice(geom);
  const intersect2 = axis === 0 ? intersectX : intersectY;
  let len4 = geom.start;
  let segLen;
  let t;
  for (let i = 0; i < geom.length - 3; i += 3) {
    const ax2 = geom[i];
    const ay2 = geom[i + 1];
    const az2 = geom[i + 2];
    const bx = geom[i + 3];
    const by = geom[i + 4];
    const a4 = axis === 0 ? ax2 : ay2;
    const b3 = axis === 0 ? bx : by;
    let exited = false;
    if (trackMetrics) {
      segLen = Math.sqrt(Math.pow(ax2 - bx, 2) + Math.pow(ay2 - by, 2));
    }
    if (a4 < k1) {
      if (b3 > k1) {
        t = intersect2(slice, ax2, ay2, bx, by, k1);
        if (trackMetrics) {
          slice.start = len4 + segLen * t;
        }
      }
    } else if (a4 > k2) {
      if (b3 < k2) {
        t = intersect2(slice, ax2, ay2, bx, by, k2);
        if (trackMetrics) {
          slice.start = len4 + segLen * t;
        }
      }
    } else {
      addPoint(slice, ax2, ay2, az2);
    }
    if (b3 < k1 && a4 >= k1) {
      t = intersect2(slice, ax2, ay2, bx, by, k1);
      exited = true;
    }
    if (b3 > k2 && a4 <= k2) {
      t = intersect2(slice, ax2, ay2, bx, by, k2);
      exited = true;
    }
    if (!isPolygon && exited) {
      if (trackMetrics) {
        slice.end = len4 + segLen * t;
      }
      newGeom.push(slice);
      slice = newSlice(geom);
    }
    if (trackMetrics) {
      len4 += segLen;
    }
  }
  let last = geom.length - 3;
  const ax = geom[last];
  const ay = geom[last + 1];
  const az = geom[last + 2];
  const a3 = axis === 0 ? ax : ay;
  if (a3 >= k1 && a3 <= k2)
    addPoint(slice, ax, ay, az);
  last = slice.length - 3;
  if (isPolygon && last >= 3 && (slice[last] !== slice[0] || slice[last + 1] !== slice[1])) {
    addPoint(slice, slice[0], slice[1], slice[2]);
  }
  if (slice.length) {
    newGeom.push(slice);
  }
}
function newSlice(line) {
  const slice = [];
  slice.size = line.size;
  slice.start = line.start;
  slice.end = line.end;
  return slice;
}
function clipLines(geom, newGeom, k1, k2, axis, isPolygon) {
  for (const line of geom) {
    clipLine(line, newGeom, k1, k2, axis, isPolygon, false);
  }
}
function addPoint(out, x, y, z) {
  out.push(x, y, z);
}
function intersectX(out, ax, ay, bx, by, x) {
  const t = (x - ax) / (bx - ax);
  addPoint(out, x, ay + (by - ay) * t, 1);
  return t;
}
function intersectY(out, ax, ay, bx, by, y) {
  const t = (y - ay) / (by - ay);
  addPoint(out, ax + (bx - ax) * t, y, 1);
  return t;
}

// node_modules/@loaders.gl/mvt/dist/lib/vector-tiler/features/wrap-features.js
function wrapFeatures(features2, options) {
  const buffer = options.buffer / options.extent;
  let merged = features2;
  const left = clipFeatures(features2, 1, -1 - buffer, buffer, 0, -1, 2, options);
  const right = clipFeatures(features2, 1, 1 - buffer, 2 + buffer, 0, -1, 2, options);
  if (left || right) {
    merged = clipFeatures(features2, 1, -buffer, 1 + buffer, 0, -1, 2, options) || [];
    if (left) {
      merged = shiftFeatureCoords(left, 1).concat(merged);
    }
    if (right) {
      merged = merged.concat(shiftFeatureCoords(right, -1));
    }
  }
  return merged;
}
function shiftFeatureCoords(features2, offset) {
  const newFeatures = [];
  for (let i = 0; i < features2.length; i++) {
    const feature2 = features2[i];
    const type = feature2.type;
    let newGeometry;
    switch (type) {
      case "Point":
      case "MultiPoint":
      case "LineString":
        newGeometry = shiftCoords(feature2.geometry, offset);
        break;
      case "MultiLineString":
      case "Polygon":
        newGeometry = [];
        for (const line of feature2.geometry) {
          newGeometry.push(shiftCoords(line, offset));
        }
        break;
      case "MultiPolygon":
        newGeometry = [];
        for (const polygon of feature2.geometry) {
          const newPolygon = [];
          for (const line of polygon) {
            newPolygon.push(shiftCoords(line, offset));
          }
          newGeometry.push(newPolygon);
        }
        break;
      default:
        throw new Error(String(type));
    }
    newFeatures.push(createProtoFeature(feature2.id, type, newGeometry, feature2.tags));
  }
  return newFeatures;
}
function shiftCoords(points, offset) {
  const newPoints = [];
  newPoints.size = points.size;
  if (points.start !== void 0) {
    newPoints.start = points.start;
    newPoints.end = points.end;
  }
  for (let i = 0; i < points.length; i += 3) {
    newPoints.push(points[i] + offset, points[i + 1], points[i + 2]);
  }
  return newPoints;
}

// node_modules/@loaders.gl/mvt/dist/table-tile-source.js
var TableTileSource = {
  name: "TableTiler",
  id: "table-tiler",
  version: "0.0.0",
  extensions: ["mvt"],
  mimeTypes: ["application/octet-stream"],
  options: {
    table: {
      coordinates: "local",
      promoteId: void 0,
      maxZoom: 14,
      indexMaxZoom: 5,
      maxPointsPerTile: 1e4,
      tolerance: 3,
      extent: 4096,
      buffer: 64,
      generateId: void 0
    }
  },
  type: "table",
  testURL: (url) => url.endsWith(".geojson"),
  createDataSource(url, options) {
    var _a, _b;
    const needsLoading = typeof url === "string" || url instanceof Blob;
    const loader = (_b = (_a = options == null ? void 0 : options.table) == null ? void 0 : _a.loaders) == null ? void 0 : _b[0];
    const tablePromise = needsLoading ? loadTable(url, loader) : url;
    return new DynamicVectorTileSource(tablePromise, options);
  }
  // @ts-expect-error
};
async function loadTable(url, loader) {
  if (typeof url === "string") {
    const response = await fetch(url);
    const data2 = await response.arrayBuffer();
    return await loader.parse(data2);
  }
  const data = await url.arrayBuffer();
  return await loader.parse(data);
}
var _DynamicVectorTileSource = class _DynamicVectorTileSource {
  constructor(table, props) {
    /** Stats for this DynamicVectorTileSource */
    __publicField(this, "stats", new Stats({
      id: "table-tile-source",
      stats: [new Stat("tiles", "count"), new Stat("features", "count")]
    }));
    /** MIME type of the tiles emitted by this tile source */
    __publicField(this, "mimeType", "application/vnd.mapbox-vector-tile");
    __publicField(this, "localCoordinates", true);
    /** The props that this tile source was created with */
    // @ts-expect-error
    __publicField(this, "props");
    /* Schema of the data */
    __publicField(this, "schema", null);
    /** Map of generated tiles, indexed by stringified tile coordinates */
    __publicField(this, "tiles", {});
    /** Array of tile coordinates */
    __publicField(this, "tileCoords", []);
    /** Input data has loaded, initial top-level tiling is done, sync methods can now be called */
    __publicField(this, "ready");
    /** Metadata for the tile source (generated TileJSON/tilestats */
    __publicField(this, "metadata");
    this.props = { ...TableTileSource.options.table, ...props == null ? void 0 : props.table };
    this.getTileData = this.getTileData.bind(this);
    this.ready = this.initializeTilesAsync(table);
    this.metadata = this.getMetadata();
  }
  async initializeTilesAsync(tablePromise) {
    const table = await tablePromise;
    this.schema = deduceTableSchema(table);
    this.createRootTiles(table);
  }
  async getMetadata() {
    await this.ready;
    return { schema: this.schema, minZoom: 0, maxZoom: this.props.maxZoom };
  }
  async getSchema() {
    await this.ready;
    return this.schema;
  }
  /**
   * Get a tile at the specified index
   * @param tileIndex z, x, y of tile
   * @returns
   */
  async getVectorTile(tileIndex) {
    await this.ready;
    const table = this.getTileSync(tileIndex);
    log.info(2, "getVectorTile", tileIndex, table)();
    return table;
  }
  async getTile(tileIndex) {
    await this.ready;
    return this.getTileSync(tileIndex);
  }
  async getTileData(tileParams) {
    const { x, y, z } = tileParams.index;
    const tile = await this.getVectorTile({ x, y, z });
    return (tile == null ? void 0 : tile.features) || [];
  }
  // Implementation
  /**
   * Synchronously request a tile
   * @note Application must await `source.ready` before calling sync methods.
   */
  getTileSync(tileIndex) {
    const protoTile = this.getProtoTile(tileIndex);
    if (!protoTile) {
      return null;
    }
    return convertTileToGeoJSON(protoTile, {
      coordinates: this.props.coordinates,
      tileIndex,
      extent: this.props.extent
    });
  }
  /**
   * Create the initial tiles
   * @note the tiles stores all the features together with additional data
   */
  createRootTiles(table) {
    if (this.props.maxZoom < 0 || this.props.maxZoom > 24) {
      throw new Error("maxZoom should be in the 0-24 range");
    }
    if (this.props.promoteId && this.props.generateId) {
      throw new Error("promoteId and generateId cannot be used together.");
    }
    log.log(1, "DynamicVectorTileSource creating root tiles", this.props)();
    log.time(1, "preprocess table")();
    let features2 = convertFeaturesToProtoFeature(table, this.props);
    log.timeEnd(1, "preprocess table")();
    log.time(1, "generate tiles")();
    features2 = wrapFeatures(features2, this.props);
    if (features2.length === 0) {
      log.log(1, "DynamicVectorTileSource: no features generated")();
      return;
    }
    this.splitTile(features2, 0, 0, 0);
    const rootTile = this.tiles[0];
    log.log(1, `root tile features: ${rootTile.numFeatures}, points: ${rootTile.numPoints}`)();
    log.timeEnd(1, "generate tiles")();
    log.log(1, `DynamicVectorTileSource: tiles generated: ${this.stats.get("total").count}`, this.stats)();
  }
  /**
   * Return geojsonvt-style "half formed" vector tile
   * @note Application must await `source.ready` before calling sync methods.
   */
  // eslint-disable-next-line complexity, max-statements
  getProtoTile(tileIndex) {
    const { z, y } = tileIndex;
    let { x } = tileIndex;
    const { extent } = this.props;
    if (z < 0 || z > 24) {
      return null;
    }
    const z2 = 1 << z;
    x = x + z2 & z2 - 1;
    const id = toID(z, x, y);
    if (this.tiles[id]) {
      return transformTile(this.tiles[id], extent);
    }
    log.log(log, "drilling down to z%d-%d-%d", z, x, y)();
    let z0 = z;
    let x0 = x;
    let y0 = y;
    let parent;
    while (!parent && z0 > 0) {
      z0--;
      x0 = x0 >> 1;
      y0 = y0 >> 1;
      parent = this.tiles[toID(z0, x0, y0)];
    }
    if (!parent || !parent.sourceFeatures) {
      return null;
    }
    log.log(1, "found parent tile z%d-%d-%d", z0, x0, y0)();
    log.time(1, "drilling down")();
    this.splitTile(parent.sourceFeatures, z0, x0, y0, z, x, y);
    log.timeEnd(1, "drilling down")();
    return this.tiles[id] ? transformTile(this.tiles[id], extent) : null;
  }
  /**
   * splits features from a parent tile to sub-tiles.
   * @param z, x, and y are the coordinates of the parent tile
   * @param cz, cx, and cy are the coordinates of the target tile
   *
   * If no target tile is specified, splitting stops when we reach the maximum
   * zoom or the number of points is low as specified in the props.
   */
  // eslint-disable-next-line max-params, max-statements, complexity
  splitTile(features2, z, x, y, cz, cx, cy) {
    const stack2 = [features2, z, x, y];
    while (stack2.length) {
      y = stack2.pop();
      x = stack2.pop();
      z = stack2.pop();
      features2 = stack2.pop();
      const z2 = 1 << z;
      const id = toID(z, x, y);
      let tile = this.tiles[id];
      if (!tile) {
        log.time(2, "tile creation")();
        tile = this.tiles[id] = createProtoTile(features2, z, x, y, this.props);
        this.tileCoords.push({ z, x, y });
        const key = `z${z}`;
        let stat = this.stats.get(key, "count");
        stat.incrementCount();
        stat = this.stats.get("total");
        stat.incrementCount();
        stat = _DynamicVectorTileSource.stats.get(key, "count");
        stat.incrementCount();
        stat = _DynamicVectorTileSource.stats.get("total");
        stat.incrementCount();
        log.log(2, "tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", z, x, y, tile.numFeatures, tile.numPoints, tile.numSimplified)();
        log.timeEnd(2, "tile creation")();
      }
      tile.sourceFeatures = features2;
      if (cz === void 0) {
        if (z === this.props.indexMaxZoom || tile.numPoints <= this.props.maxPointsPerTile) {
          continue;
        }
      } else if (z === this.props.maxZoom || z === cz) {
        continue;
      } else if (cz !== void 0) {
        const zoomSteps = cz - z;
        if (x !== cx >> zoomSteps || y !== cy >> zoomSteps) {
          continue;
        }
      }
      tile.sourceFeatures = null;
      if (features2.length === 0)
        continue;
      log.time(2, "clipping tile")();
      const k1 = 0.5 * this.props.buffer / this.props.extent;
      const k2 = 0.5 - k1;
      const k3 = 0.5 + k1;
      const k4 = 1 + k1;
      let tl = null;
      let bl = null;
      let tr = null;
      let br = null;
      let left = clipFeatures(features2, z2, x - k1, x + k3, 0, tile.minX, tile.maxX, this.props);
      let right = clipFeatures(features2, z2, x + k2, x + k4, 0, tile.minX, tile.maxX, this.props);
      features2 = null;
      if (left) {
        tl = clipFeatures(left, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);
        bl = clipFeatures(left, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);
        left = null;
      }
      if (right) {
        tr = clipFeatures(right, z2, y - k1, y + k3, 1, tile.minY, tile.maxY, this.props);
        br = clipFeatures(right, z2, y + k2, y + k4, 1, tile.minY, tile.maxY, this.props);
        right = null;
      }
      log.timeEnd(2, "clipping tile")();
      stack2.push(tl || [], z + 1, x * 2, y * 2);
      stack2.push(bl || [], z + 1, x * 2, y * 2 + 1);
      stack2.push(tr || [], z + 1, x * 2 + 1, y * 2);
      stack2.push(br || [], z + 1, x * 2 + 1, y * 2 + 1);
    }
  }
};
/** Global stats for all DynamicVectorTileSources */
__publicField(_DynamicVectorTileSource, "stats", new Stats({
  id: "table-tile-source-all",
  stats: [new Stat("count", "tiles"), new Stat("count", "features")]
}));
var DynamicVectorTileSource = _DynamicVectorTileSource;
function toID(z, x, y) {
  return ((1 << z) * y + x) * 32 + z;
}

// node_modules/@deck.gl/geo-layers/dist/mvt-layer/coordinate-transform.js
var availableTransformations = {
  Point,
  MultiPoint,
  LineString,
  MultiLineString,
  Polygon,
  MultiPolygon
};
function Point([pointX, pointY], [nw, se], viewport) {
  const x = lerp(nw[0], se[0], pointX);
  const y = lerp(nw[1], se[1], pointY);
  return viewport.unprojectFlat([x, y]);
}
function getPoints(geometry, bbox, viewport) {
  return geometry.map((g) => Point(g, bbox, viewport));
}
function MultiPoint(multiPoint, bbox, viewport) {
  return getPoints(multiPoint, bbox, viewport);
}
function LineString(line, bbox, viewport) {
  return getPoints(line, bbox, viewport);
}
function MultiLineString(multiLineString, bbox, viewport) {
  return multiLineString.map((lineString2) => LineString(lineString2, bbox, viewport));
}
function Polygon(polygon, bbox, viewport) {
  return polygon.map((polygonRing) => getPoints(polygonRing, bbox, viewport));
}
function MultiPolygon(multiPolygon, bbox, viewport) {
  return multiPolygon.map((polygon) => Polygon(polygon, bbox, viewport));
}
function transform(geometry, bbox, viewport) {
  const nw = viewport.projectFlat([bbox.west, bbox.north]);
  const se = viewport.projectFlat([bbox.east, bbox.south]);
  const projectedBbox = [nw, se];
  return {
    ...geometry,
    coordinates: availableTransformations[geometry.type](geometry.coordinates, projectedBbox, viewport)
  };
}

// node_modules/@deck.gl/geo-layers/dist/mvt-layer/find-index-binary.js
var GEOM_TYPES = ["points", "lines", "polygons"];
function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {
  for (const gt of GEOM_TYPES) {
    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);
    if (index >= 0) {
      return index;
    }
  }
  return -1;
}
function findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {
  const featureIds = geomData.featureIds.value;
  if (!featureIds.length) {
    return -1;
  }
  let startFeatureIndex = 0;
  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;
  if (layerName) {
    const layerRange = getLayerRange(geomData, layerName);
    if (layerRange) {
      startFeatureIndex = layerRange[0];
      endFeatureIndex = layerRange[1] + 1;
    } else {
      return -1;
    }
  }
  let featureIndex = -1;
  if (uniqueIdProperty in geomData.numericProps) {
    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x, i) => x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex);
    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;
  } else if (uniqueIdProperty) {
    featureIndex = findIndex(geomData.properties, (elem) => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);
  } else if (geomData.fields) {
    featureIndex = findIndex(geomData.fields, (elem) => elem.id === featureId, startFeatureIndex, endFeatureIndex);
  }
  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;
}
function getLayerRange(geomData, layerName) {
  if (!geomData.__layers) {
    const layerNames = {};
    const { properties } = geomData;
    for (let i = 0; i < properties.length; i++) {
      const { layerName: key } = properties[i];
      if (!key) {
      } else if (layerNames[key]) {
        layerNames[key][1] = i;
      } else {
        layerNames[key] = [i, i];
      }
    }
    geomData.__layers = layerNames;
  }
  return geomData.__layers[layerName];
}
function getGlobalFeatureId(geomData, featureIndex) {
  if (!geomData.__ids) {
    const result = [];
    const featureIds = geomData.featureIds.value;
    const globalFeatureIds = geomData.globalFeatureIds.value;
    for (let i = 0; i < featureIds.length; i++) {
      result[featureIds[i]] = globalFeatureIds[i];
    }
    geomData.__ids = result;
  }
  return geomData.__ids[featureIndex];
}
function findIndex(array, predicate, startIndex, endIndex) {
  for (let i = startIndex; i < endIndex; i++) {
    if (predicate(array[i], i)) {
      return i;
    }
  }
  return -1;
}

// node_modules/@deck.gl/geo-layers/dist/mvt-layer/mvt-layer.js
var WORLD_SIZE = 512;
var defaultProps24 = {
  ...geojson_layer_default.defaultProps,
  data: urlType,
  onDataLoad: { type: "function", value: null, optional: true, compare: false },
  uniqueIdProperty: "",
  highlightedFeatureId: null,
  loaders: [MVTWorkerLoader],
  binary: true
};
var MVTLayer = class extends tile_layer_default {
  initializeState() {
    super.initializeState();
    const binary = this.context.viewport.resolution !== void 0 ? false : this.props.binary;
    this.setState({
      binary,
      data: null,
      tileJSON: null,
      hoveredFeatureId: null,
      hoveredFeatureLayerName: null
    });
  }
  get isLoaded() {
    var _a;
    return Boolean(((_a = this.state) == null ? void 0 : _a.data) && super.isLoaded);
  }
  updateState({ props, oldProps, context, changeFlags }) {
    var _a;
    if (changeFlags.dataChanged) {
      this._updateTileData();
    }
    if ((_a = this.state) == null ? void 0 : _a.data) {
      super.updateState({ props, oldProps, context, changeFlags });
      this._setWGS84PropertyForTiles();
    }
    const { highlightColor } = props;
    if (highlightColor !== oldProps.highlightColor && Array.isArray(highlightColor)) {
      this.setState({ highlightColor });
    }
  }
  /* eslint-disable complexity */
  async _updateTileData() {
    let data = this.props.data;
    let tileJSON = null;
    if (typeof data === "string" && !isURLTemplate(data)) {
      const { onDataLoad, fetch: fetch2 } = this.props;
      this.setState({ data: null, tileJSON: null });
      try {
        tileJSON = await fetch2(data, { propName: "data", layer: this, loaders: [] });
      } catch (error) {
        this.raiseError(error, "loading TileJSON");
        data = null;
      }
      if (onDataLoad) {
        onDataLoad(tileJSON, { propName: "data", layer: this });
      }
    } else if (data && typeof data === "object" && "tilejson" in data) {
      tileJSON = data;
    }
    if (tileJSON) {
      data = tileJSON.tiles;
    }
    this.setState({ data, tileJSON });
  }
  _getTilesetOptions() {
    const opts = super._getTilesetOptions();
    const tileJSON = this.state.tileJSON;
    const { minZoom, maxZoom } = this.props;
    if (tileJSON) {
      if (Number.isFinite(tileJSON.minzoom) && tileJSON.minzoom > minZoom) {
        opts.minZoom = tileJSON.minzoom;
      }
      if (Number.isFinite(tileJSON.maxzoom) && (!Number.isFinite(maxZoom) || tileJSON.maxzoom < maxZoom)) {
        opts.maxZoom = tileJSON.maxzoom;
      }
    }
    return opts;
  }
  /* eslint-disable complexity */
  renderLayers() {
    var _a;
    if (!((_a = this.state) == null ? void 0 : _a.data))
      return null;
    return super.renderLayers();
  }
  getTileData(loadProps) {
    const { data, binary } = this.state;
    const { index, signal } = loadProps;
    const url = getURLFromTemplate(data, loadProps);
    if (!url) {
      return Promise.reject("Invalid URL");
    }
    let loadOptions = this.getLoadOptions();
    const { fetch: fetch2 } = this.props;
    loadOptions = {
      ...loadOptions,
      mimeType: "application/x-protobuf",
      mvt: {
        ...loadOptions == null ? void 0 : loadOptions.mvt,
        coordinates: this.context.viewport.resolution ? "wgs84" : "local",
        tileIndex: index
        // Local worker debug
        // workerUrl: `modules/mvt/dist/mvt-loader.worker.js`
        // Set worker to null to skip web workers
        // workerUrl: null
      },
      gis: binary ? { format: "binary" } : {}
    };
    return fetch2(url, { propName: "data", layer: this, loadOptions, signal });
  }
  renderSubLayers(props) {
    const { x, y, z } = props.tile.index;
    const worldScale = Math.pow(2, z);
    const xScale = WORLD_SIZE / worldScale;
    const yScale = -xScale;
    const xOffset = WORLD_SIZE * x / worldScale;
    const yOffset = WORLD_SIZE * (1 - y / worldScale);
    const modelMatrix2 = new Matrix4().scale([xScale, yScale, 1]);
    props.autoHighlight = false;
    if (!this.context.viewport.resolution) {
      props.modelMatrix = modelMatrix2;
      props.coordinateOrigin = [xOffset, yOffset, 0];
      props.coordinateSystem = COORDINATE_SYSTEM.CARTESIAN;
      props.extensions = [...props.extensions || [], new clip_extension_default()];
    }
    const subLayers = super.renderSubLayers(props);
    if (this.state.binary && !(subLayers instanceof geojson_layer_default)) {
      log_default.warn("renderSubLayers() must return GeoJsonLayer when using binary:true")();
    }
    return subLayers;
  }
  _updateAutoHighlight(info) {
    const { uniqueIdProperty } = this.props;
    const { hoveredFeatureId, hoveredFeatureLayerName } = this.state;
    const hoveredFeature = info.object;
    let newHoveredFeatureId = null;
    let newHoveredFeatureLayerName = null;
    if (hoveredFeature) {
      newHoveredFeatureId = getFeatureUniqueId(hoveredFeature, uniqueIdProperty);
      newHoveredFeatureLayerName = getFeatureLayerName(hoveredFeature);
    }
    let { highlightColor } = this.props;
    if (typeof highlightColor === "function") {
      highlightColor = highlightColor(info);
    }
    if (hoveredFeatureId !== newHoveredFeatureId || hoveredFeatureLayerName !== newHoveredFeatureLayerName) {
      this.setState({
        highlightColor,
        hoveredFeatureId: newHoveredFeatureId,
        hoveredFeatureLayerName: newHoveredFeatureLayerName
      });
    }
  }
  _isWGS84() {
    return Boolean(this.context.viewport.resolution);
  }
  getPickingInfo(params) {
    const info = super.getPickingInfo(params);
    if (this.state.binary && info.index !== -1) {
      const { data } = params.sourceLayer.props;
      info.object = binaryToGeojson(data, {
        globalFeatureId: info.index
      });
    }
    if (info.object && !this._isWGS84()) {
      info.object = transformTileCoordsToWGS84(
        info.object,
        info.tile.bbox,
        // eslint-disable-line
        this.context.viewport
      );
    }
    return info;
  }
  getSubLayerPropsByTile(tile) {
    return {
      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
      highlightColor: this.state.highlightColor
    };
  }
  getHighlightedObjectIndex(tile) {
    const { hoveredFeatureId, hoveredFeatureLayerName, binary } = this.state;
    const { uniqueIdProperty, highlightedFeatureId } = this.props;
    const data = tile.content;
    const isHighlighted = isFeatureIdDefined(highlightedFeatureId);
    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId) || isHighlighted;
    if (!isFeatureIdPresent) {
      return -1;
    }
    const featureIdToHighlight = isHighlighted ? highlightedFeatureId : hoveredFeatureId;
    if (Array.isArray(data)) {
      return data.findIndex((feature2) => {
        const isMatchingId = getFeatureUniqueId(feature2, uniqueIdProperty) === featureIdToHighlight;
        const isMatchingLayer = isHighlighted || getFeatureLayerName(feature2) === hoveredFeatureLayerName;
        return isMatchingId && isMatchingLayer;
      });
    } else if (data && binary) {
      return findIndexBinary(data, uniqueIdProperty, featureIdToHighlight, isHighlighted ? "" : hoveredFeatureLayerName);
    }
    return -1;
  }
  _pickObjects(maxObjects) {
    const { deck, viewport } = this.context;
    const width = viewport.width;
    const height = viewport.height;
    const x = viewport.x;
    const y = viewport.y;
    const layerIds = [this.id];
    return deck.pickObjects({ x, y, width, height, layerIds, maxObjects });
  }
  /** Get the rendered features in the current viewport. */
  getRenderedFeatures(maxFeatures = null) {
    const features2 = this._pickObjects(maxFeatures);
    const featureCache = /* @__PURE__ */ new Set();
    const renderedFeatures = [];
    for (const f of features2) {
      const featureId = getFeatureUniqueId(f.object, this.props.uniqueIdProperty);
      if (featureId === void 0) {
        renderedFeatures.push(f.object);
      } else if (!featureCache.has(featureId)) {
        featureCache.add(featureId);
        renderedFeatures.push(f.object);
      }
    }
    return renderedFeatures;
  }
  _setWGS84PropertyForTiles() {
    const propName = "dataInWGS84";
    const tileset = this.state.tileset;
    tileset.selectedTiles.forEach((tile) => {
      if (!tile.hasOwnProperty(propName)) {
        Object.defineProperty(tile, propName, {
          get: () => {
            if (!tile.content) {
              return null;
            }
            if (this.state.binary && Array.isArray(tile.content) && !tile.content.length) {
              return [];
            }
            const { bbox } = tile;
            if (tile._contentWGS84 === void 0 && isGeoBoundingBox(bbox)) {
              const content = this.state.binary ? binaryToGeojson(tile.content) : tile.content;
              tile._contentWGS84 = content.map((feature2) => transformTileCoordsToWGS84(feature2, bbox, this.context.viewport));
            }
            return tile._contentWGS84;
          }
        });
      }
    });
  }
};
MVTLayer.layerName = "MVTLayer";
MVTLayer.defaultProps = defaultProps24;
var mvt_layer_default = MVTLayer;
function getFeatureUniqueId(feature2, uniqueIdProperty) {
  if (feature2.properties && uniqueIdProperty) {
    return feature2.properties[uniqueIdProperty];
  }
  if ("id" in feature2) {
    return feature2.id;
  }
  return void 0;
}
function getFeatureLayerName(feature2) {
  var _a;
  return ((_a = feature2.properties) == null ? void 0 : _a.layerName) || null;
}
function isFeatureIdDefined(value) {
  return value !== void 0 && value !== null && value !== "";
}
function transformTileCoordsToWGS84(object, bbox, viewport) {
  const feature2 = {
    ...object,
    geometry: {
      type: object.geometry.type
    }
  };
  Object.defineProperty(feature2.geometry, "coordinates", {
    get: () => {
      const wgs84Geom = transform(object.geometry, bbox, viewport);
      return wgs84Geom.coordinates;
    }
  });
  return feature2;
}

// node_modules/@deck.gl/geo-layers/dist/geohash-layer/geohash-utils.js
var BASE32_CODES = "0123456789bcdefghjkmnpqrstuvwxyz";
var BASE32_CODES_DICT = {};
for (let i = 0; i < BASE32_CODES.length; i++) {
  BASE32_CODES_DICT[BASE32_CODES.charAt(i)] = i;
}
var MIN_LAT = -90;
var MAX_LAT = 90;
var MIN_LON = -180;
var MAX_LON = 180;
function getGeohashBounds(geohash) {
  let isLon = true;
  let maxLat = MAX_LAT;
  let minLat = MIN_LAT;
  let maxLon = MAX_LON;
  let minLon = MIN_LON;
  let mid;
  let hashValue = 0;
  for (let i = 0, l = geohash.length; i < l; i++) {
    const code = geohash[i].toLowerCase();
    hashValue = BASE32_CODES_DICT[code];
    for (let bits = 4; bits >= 0; bits--) {
      const bit = hashValue >> bits & 1;
      if (isLon) {
        mid = (maxLon + minLon) / 2;
        if (bit === 1) {
          minLon = mid;
        } else {
          maxLon = mid;
        }
      } else {
        mid = (maxLat + minLat) / 2;
        if (bit === 1) {
          minLat = mid;
        } else {
          maxLat = mid;
        }
      }
      isLon = !isLon;
    }
  }
  return [minLat, minLon, maxLat, maxLon];
}
function getGeohashPolygon(geohash) {
  const [s, w2, n, e2] = getGeohashBounds(geohash);
  return [e2, n, e2, s, w2, s, w2, n, e2, n];
}

// node_modules/@deck.gl/geo-layers/dist/geohash-layer/geohash-layer.js
var defaultProps25 = {
  getGeohash: { type: "accessor", value: (d2) => d2.geohash }
};
var GeohashLayer = class extends GeoCellLayer_default {
  indexToBounds() {
    const { data, getGeohash } = this.props;
    return {
      data,
      _normalize: false,
      positionFormat: "XY",
      getPolygon: (x, objectInfo) => getGeohashPolygon(getGeohash(x, objectInfo))
    };
  }
};
GeohashLayer.layerName = "GeohashLayer";
GeohashLayer.defaultProps = defaultProps25;
var geohash_layer_default = GeohashLayer;
export {
  a5_layer_default as A5Layer,
  geohash_layer_default as GeohashLayer,
  great_circle_layer_default as GreatCircleLayer,
  h3_cluster_layer_default as H3ClusterLayer,
  h3_hexagon_layer_default as H3HexagonLayer,
  mvt_layer_default as MVTLayer,
  quadkey_layer_default as QuadkeyLayer,
  s2_layer_default as S2Layer,
  terrain_layer_default as TerrainLayer,
  tile_3d_layer_default as Tile3DLayer,
  tile_layer_default as TileLayer,
  trips_layer_default as TripsLayer,
  GeoCellLayer_default as _GeoCellLayer,
  Tile2DHeader as _Tile2DHeader,
  Tileset2D as _Tileset2D,
  WMSLayer as _WMSLayer,
  getURLFromTemplate as _getURLFromTemplate
};
/*! Bundled license information:

long/dist/long.js:
  (**
   * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/long.js for details
   *)

jszip/dist/jszip.min.js:
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

long/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
//# sourceMappingURL=@deck__gl_geo-layers.js.map
